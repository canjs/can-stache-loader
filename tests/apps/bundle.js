/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./tests/apps/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@feathersjs/errors/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@feathersjs/errors/lib/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('@feathersjs/errors');\n\nfunction FeathersError (msg, name, code, className, data) {\n  msg = msg || 'Error';\n\n  let errors;\n  let message;\n  let newData;\n\n  if (msg instanceof Error) {\n    message = msg.message || 'Error';\n\n    // NOTE (EK): This is typically to handle validation errors\n    if (msg.errors) {\n      errors = msg.errors;\n    }\n  } else if (typeof msg === 'object') { // Support plain old objects\n    message = msg.message || 'Error';\n    data = msg;\n  } else { // message is just a string\n    message = msg;\n  }\n\n  if (data) {\n    // NOTE(EK): To make sure that we are not messing\n    // with immutable data, just make a copy.\n    // https://github.com/feathersjs/errors/issues/19\n    newData = JSON.parse(JSON.stringify(data));\n\n    if (newData.errors) {\n      errors = newData.errors;\n      delete newData.errors;\n    } else if (data.errors) {\n      // The errors property from data could be\n      // stripped away while cloning resulting newData not to have it\n      // For example: when cloning arrays this property\n      errors = JSON.parse(JSON.stringify(data.errors));\n    }\n  }\n\n  // NOTE (EK): Babel doesn't support this so\n  // we have to pass in the class name manually.\n  // this.name = this.constructor.name;\n  this.type = 'FeathersError';\n  this.name = name;\n  this.message = message;\n  this.code = code;\n  this.className = className;\n  this.data = newData;\n  this.errors = errors || {};\n\n  debug(`${this.name}(${this.code}): ${this.message}`);\n  debug(this.errors);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, FeathersError);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n}\n\nfunction inheritsFrom (Child, Parent) {\n  Child.prototype = Object.create(Parent.prototype);\n  Child.prototype.constructor = Child;\n}\n\ninheritsFrom(FeathersError, Error);\n\n// NOTE (EK): A little hack to get around `message` not\n// being included in the default toJSON call.\nObject.defineProperty(FeathersError.prototype, 'toJSON', {\n  value: function () {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      className: this.className,\n      data: this.data,\n      errors: this.errors\n    };\n  }\n});\n\n// 400 - Bad Request\nfunction BadRequest (message, data) {\n  FeathersError.call(this, message, 'BadRequest', 400, 'bad-request', data);\n}\n\ninheritsFrom(BadRequest, FeathersError);\n\n// 401 - Not Authenticated\nfunction NotAuthenticated (message, data) {\n  FeathersError.call(this, message, 'NotAuthenticated', 401, 'not-authenticated', data);\n}\n\ninheritsFrom(NotAuthenticated, FeathersError);\n\n// 402 - Payment Error\nfunction PaymentError (message, data) {\n  FeathersError.call(this, message, 'PaymentError', 402, 'payment-error', data);\n}\n\ninheritsFrom(PaymentError, FeathersError);\n\n// 403 - Forbidden\nfunction Forbidden (message, data) {\n  FeathersError.call(this, message, 'Forbidden', 403, 'forbidden', data);\n}\n\ninheritsFrom(Forbidden, FeathersError);\n\n// 404 - Not Found\nfunction NotFound (message, data) {\n  FeathersError.call(this, message, 'NotFound', 404, 'not-found', data);\n}\n\ninheritsFrom(NotFound, FeathersError);\n\n// 405 - Method Not Allowed\nfunction MethodNotAllowed (message, data) {\n  FeathersError.call(this, message, 'MethodNotAllowed', 405, 'method-not-allowed', data);\n}\n\ninheritsFrom(MethodNotAllowed, FeathersError);\n\n// 406 - Not Acceptable\nfunction NotAcceptable (message, data) {\n  FeathersError.call(this, message, 'NotAcceptable', 406, 'not-acceptable', data);\n}\n\ninheritsFrom(NotAcceptable, FeathersError);\n\n// 408 - Timeout\nfunction Timeout (message, data) {\n  FeathersError.call(this, message, 'Timeout', 408, 'timeout', data);\n}\n\ninheritsFrom(Timeout, FeathersError);\n\n// 409 - Conflict\nfunction Conflict (message, data) {\n  FeathersError.call(this, message, 'Conflict', 409, 'conflict', data);\n}\n\ninheritsFrom(Conflict, FeathersError);\n\n// 410 - Gone\nfunction Gone (message, data) {\n  FeathersError(this, message, 'Gone', 410, 'gone', data);\n}\n\ninheritsFrom(Gone, FeathersError);\n\n// 411 - Length Required\nfunction LengthRequired (message, data) {\n  FeathersError.call(this, message, 'LengthRequired', 411, 'length-required', data);\n}\n\ninheritsFrom(LengthRequired, FeathersError);\n\n// 422 Unprocessable\nfunction Unprocessable (message, data) {\n  FeathersError.call(this, message, 'Unprocessable', 422, 'unprocessable', data);\n}\n\ninheritsFrom(Unprocessable, FeathersError);\n\n// 429 Too Many Requests\nfunction TooManyRequests (message, data) {\n  FeathersError.call(this, message, 'TooManyRequests', 429, 'too-many-requests', data);\n}\n\ninheritsFrom(TooManyRequests, FeathersError);\n\n// 500 - General Error\nfunction GeneralError (message, data) {\n  FeathersError.call(this, message, 'GeneralError', 500, 'general-error', data);\n}\n\ninheritsFrom(GeneralError, FeathersError);\n\n// 501 - Not Implemented\nfunction NotImplemented (message, data) {\n  FeathersError.call(this, message, 'NotImplemented', 501, 'not-implemented', data);\n}\n\ninheritsFrom(NotImplemented, FeathersError);\n\n// 502 - Bad Gateway\nfunction BadGateway (message, data) {\n  FeathersError.call(this, message, 'BadGateway', 502, 'bad-gateway', data);\n}\n\ninheritsFrom(BadGateway, FeathersError);\n\n// 503 - Unavailable\nfunction Unavailable (message, data) {\n  FeathersError.call(this, message, 'Unavailable', 503, 'unavailable', data);\n}\n\ninheritsFrom(Unavailable, FeathersError);\n\nconst errors = {\n  FeathersError,\n  BadRequest,\n  NotAuthenticated,\n  PaymentError,\n  Forbidden,\n  NotFound,\n  MethodNotAllowed,\n  NotAcceptable,\n  Timeout,\n  Conflict,\n  Gone,\n  LengthRequired,\n  Unprocessable,\n  TooManyRequests,\n  GeneralError,\n  NotImplemented,\n  BadGateway,\n  Unavailable,\n  400: BadRequest,\n  401: NotAuthenticated,\n  402: PaymentError,\n  403: Forbidden,\n  404: NotFound,\n  405: MethodNotAllowed,\n  406: NotAcceptable,\n  408: Timeout,\n  409: Conflict,\n  410: Gone,\n  411: LengthRequired,\n  422: Unprocessable,\n  429: TooManyRequests,\n  500: GeneralError,\n  501: NotImplemented,\n  502: BadGateway,\n  503: Unavailable\n};\n\nfunction convert (error) {\n  if (!error) {\n    return error;\n  }\n\n  const FeathersError = errors[error.name];\n  const result = FeathersError\n    ? new FeathersError(error.message, error.data)\n    : new Error(error.message || error);\n\n  if (typeof error === 'object') {\n    Object.assign(result, error);\n  }\n\n  return result;\n}\n\nmodule.exports = Object.assign({ convert }, errors);\n\n\n//# sourceURL=webpack:///./node_modules/@feathersjs/errors/lib/index.js?");

/***/ }),

/***/ "./node_modules/can-ajax/dist/cjs/can-ajax.js":
/*!****************************************************!*\
  !*** ./node_modules/can-ajax/dist/cjs/can-ajax.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*can-ajax@2.4.4#can-ajax*/\n\nvar Global = __webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar parseURI = __webpack_require__(/*! can-parse-uri */ \"./node_modules/can-parse-uri/can-parse-uri.js\");\nvar param = __webpack_require__(/*! can-param */ \"./node_modules/can-param/can-param.js\");\nvar xhrs = [\n        function () {\n            return new XMLHttpRequest();\n        },\n        function () {\n            return new ActiveXObject('Microsoft.XMLHTTP');\n        },\n        function () {\n            return new ActiveXObject('MSXML2.XMLHTTP.3.0');\n        },\n        function () {\n            return new ActiveXObject('MSXML2.XMLHTTP');\n        }\n    ], _xhrf = null;\nvar originUrl = parseURI(Global().location.href);\nvar globalSettings = {};\nvar makeXhr = function () {\n    if (_xhrf != null) {\n        return _xhrf();\n    }\n    for (var i = 0, l = xhrs.length; i < l; i++) {\n        try {\n            var f = xhrs[i], req = f();\n            if (req != null) {\n                _xhrf = f;\n                return req;\n            }\n        } catch (e) {\n            continue;\n        }\n    }\n    return function () {\n    };\n};\nvar contentTypes = {\n    json: 'application/json',\n    form: 'application/x-www-form-urlencoded'\n};\nvar _xhrResp = function (xhr, options) {\n    try {\n        var type = options.dataType || xhr.getResponseHeader('Content-Type').split(';')[0];\n        if (type && (xhr.responseText || xhr.responseXML)) {\n            switch (type) {\n            case 'text/xml':\n            case 'xml':\n                return xhr.responseXML;\n            case 'text/json':\n            case 'application/json':\n            case 'text/javascript':\n            case 'application/javascript':\n            case 'application/x-javascript':\n            case 'json':\n                return xhr.responseText && JSON.parse(xhr.responseText);\n            default:\n                return xhr.responseText;\n            }\n        } else {\n            return xhr;\n        }\n    } catch (e) {\n        return xhr;\n    }\n};\nfunction ajax(o) {\n    var xhr = makeXhr(), timer, n = 0;\n    var deferred = {}, isFormData;\n    var promise = new Promise(function (resolve, reject) {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n    });\n    var requestUrl;\n    var isAborted = false;\n    promise.abort = function () {\n        isAborted = true;\n        xhr.abort();\n    };\n    o = [\n        {\n            userAgent: 'XMLHttpRequest',\n            lang: 'en',\n            type: 'GET',\n            data: null,\n            dataType: 'json'\n        },\n        globalSettings,\n        o\n    ].reduce(function (a, b, i) {\n        return canReflect.assignDeep(a, b);\n    });\n    var async = o.async !== false;\n    if (!o.contentType) {\n        o.contentType = o.type.toUpperCase() === 'GET' ? contentTypes.form : contentTypes.json;\n    }\n    if (o.crossDomain == null) {\n        try {\n            requestUrl = parseURI(o.url);\n            o.crossDomain = !!(requestUrl.protocol && requestUrl.protocol !== originUrl.protocol || requestUrl.host && requestUrl.host !== originUrl.host);\n        } catch (e) {\n            o.crossDomain = true;\n        }\n    }\n    if (o.timeout) {\n        timer = setTimeout(function () {\n            xhr.abort();\n            if (o.timeoutFn) {\n                o.timeoutFn(o.url);\n            }\n        }, o.timeout);\n    }\n    xhr.onreadystatechange = function () {\n        try {\n            if (xhr.readyState === 4) {\n                if (timer) {\n                    clearTimeout(timer);\n                }\n                if (xhr.status < 300) {\n                    if (o.success) {\n                        o.success(_xhrResp(xhr, o));\n                    }\n                } else if (o.error) {\n                    o.error(xhr, xhr.status, xhr.statusText);\n                }\n                if (o.complete) {\n                    o.complete(xhr, xhr.statusText);\n                }\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    deferred.resolve(_xhrResp(xhr, o));\n                } else {\n                    deferred.reject(_xhrResp(xhr, o));\n                }\n            } else if (o.progress) {\n                o.progress(++n);\n            }\n        } catch (e) {\n            deferred.reject(e);\n        }\n    };\n    var url = o.url, data = null, type = o.type.toUpperCase();\n    var isJsonContentType = o.contentType === contentTypes.json;\n    var isPost = type === 'POST' || type === 'PUT';\n    if (!isPost && o.data) {\n        url += '?' + (isJsonContentType ? JSON.stringify(o.data) : param(o.data));\n    }\n    xhr.open(type, url, async);\n    var isSimpleCors = o.crossDomain && [\n        'GET',\n        'POST',\n        'HEAD'\n    ].indexOf(type) !== -1;\n    isFormData = typeof FormData !== 'undefined' && o.data instanceof FormData;\n    if (isPost) {\n        if (isFormData) {\n            data = o.data;\n        } else {\n            if (isJsonContentType && !isSimpleCors) {\n                data = typeof o.data === 'object' ? JSON.stringify(o.data) : o.data;\n                xhr.setRequestHeader('Content-Type', 'application/json');\n            } else {\n                data = param(o.data);\n                xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n            }\n        }\n    } else {\n        xhr.setRequestHeader('Content-Type', o.contentType);\n    }\n    if (!isSimpleCors) {\n        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    }\n    if (o.xhrFields) {\n        for (var f in o.xhrFields) {\n            xhr[f] = o.xhrFields[f];\n        }\n    }\n    function send() {\n        if (!isAborted) {\n            xhr.send(data);\n        }\n    }\n    if (o.beforeSend) {\n        var result = o.beforeSend.call(o, xhr, o);\n        if (canReflect.isPromise(result)) {\n            result.then(send).catch(deferred.reject);\n            return promise;\n        }\n    }\n    send();\n    return promise;\n}\nmodule.exports = namespace.ajax = ajax;\nmodule.exports.ajaxSetup = function (o) {\n    globalSettings = o || {};\n};\n\n//# sourceURL=webpack:///./node_modules/can-ajax/dist/cjs/can-ajax.js?");

/***/ }),

/***/ "./node_modules/can-assign/can-assign.js":
/*!***********************************************!*\
  !*** ./node_modules/can-assign/can-assign.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\n/**\n * @module {function} can-assign can-assign\n * @parent can-js-utilities\n * @collection can-infrastructure\n * @signature `assign(target, source)`\n * @package ./package.json\n *\n * A simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.\n *\n * ```js\n * var assign = require(\"can-assign\");\n *\n * var obj = {};\n *\n * assign(obj, {\n *   foo: \"bar\"\n * });\n *\n * console.log(obj.foo); // -> \"bar\"\n * ```\n *\n * @param {Object} target The destination object. This object's properties will be mutated based on the object provided as `source`.\n * @param {Object} source The source object whose own properties will be applied to `target`.\n *\n * @return {Object} Returns the `target` argument.\n */\n\nmodule.exports = namespace.assign = function (d, s) {\n\tfor (var prop in s) {\n\t\tvar desc = Object.getOwnPropertyDescriptor(d,prop);\n\t\tif(!desc || desc.writable !== false){\n\t\t\td[prop] = s[prop];\n\t\t}\n\t}\n\treturn d;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-assign/can-assign.js?");

/***/ }),

/***/ "./node_modules/can-attribute-encoder/can-attribute-encoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-attribute-encoder/can-attribute-encoder.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\n/**\n * @module {{}} can-attribute-encoder can-attribute-encoder\n * @parent can-dom-utilities\n * @collection can-infrastructure\n * @package ./package.json\n *\n * Encode and decode attribute names.\n *\n * @option {Object} An object with the methods:\n * [can-attribute-encoder.encode] and [can-attribute-encoder.decode].\n *\n */\n\n\nfunction each(items, callback){\n\tfor ( var i = 0; i < items.length; i++ ) {\n\t\tcallback(items[i], i);\n\t}\n}\n\nfunction makeMap(str){\n\tvar obj = {}, items = str.split(\",\");\n\teach(items, function(name){\n\t\tobj[name] = true;\n\t});\n\treturn obj;\n}\n\n// Attributes for which the case matters - shouldnâ€™t be lowercased.\nvar caseMattersAttributes = makeMap(\"allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector,controlsList\");\n\nfunction camelCaseToSpinalCase(match, lowerCaseChar, upperCaseChar) {\n\treturn lowerCaseChar + \"-\" + upperCaseChar.toLowerCase();\n}\n\nfunction startsWith(allOfIt, startsWith) {\n\treturn allOfIt.indexOf(startsWith) === 0;\n}\n\nfunction endsWith(allOfIt, endsWith) {\n\treturn (allOfIt.length - allOfIt.lastIndexOf(endsWith)) === endsWith.length;\n}\n\nvar regexes = {\n\tleftParens: /\\(/g,\n\trightParens: /\\)/g,\n\tleftBrace: /\\{/g,\n\trightBrace: /\\}/g,\n\tcamelCase: /([a-z]|[0-9]|^)([A-Z])/g,\n\tforwardSlash: /\\//g,\n\tspace: /\\s/g,\n\tuppercase: /[A-Z]/g,\n\tuppercaseDelimiterThenChar: /:u:([a-z])/g,\n\tcaret: /\\^/g,\n\tdollar: /\\$/g,\n\tat: /@/g\n};\n\nvar delimiters = {\n\tprependUppercase: ':u:',\n\treplaceSpace: ':s:',\n\treplaceForwardSlash: ':f:',\n\treplaceLeftParens: ':lp:',\n\treplaceRightParens: ':rp:',\n\treplaceLeftBrace: ':lb:',\n\treplaceRightBrace: ':rb:',\n\treplaceCaret: ':c:',\n\treplaceDollar: ':d:',\n\treplaceAt: ':at:'\n};\n\nvar encoder = {};\n\n/**\n * @function can-attribute-encoder.encode encode\n * @parent can-attribute-encoder\n * @description Encode an attribute name\n *\n * @signature `encoder.encode(attributeName)`\n *\n * Note: specific encoding may change, but encoded attributes\n * can always be decoded using [can-attribute-encoder.decode].\n *\n * @body\n *\n * ```js\n * var encodedAttributeName = encoder.encode(\"{(^$foo/bar baz)}\");\n * div.setAttribute(encodedAttributeName, \"attribute value\");\n * ```\n *\n * @param {String} attributeName The attribute name.\n * @return {String} The encoded attribute name.\n *\n */\nencoder.encode = function(name) {\n\tvar encoded = name;\n\n\t// encode or convert camelCase attributes unless in list of attributes\n\t// where case matters\n\tif (!caseMattersAttributes[encoded] && encoded.match(regexes.camelCase)) {\n\t\t// encode uppercase characters in new bindings\n\t\t// - on:fooBar, fooBar:to, fooBar:from, fooBar:bind\n\t\tif (\n\t\t\tstartsWith(encoded, 'on:') ||\n\t\t\tendsWith(encoded, ':to') ||\n\t\t\tendsWith(encoded, ':from') ||\n\t\t\tendsWith(encoded, ':bind') ||\n\t\t\tendsWith(encoded, ':raw')\n\t\t) {\n\t\t\tencoded = encoded\n\t\t\t\t.replace(regexes.uppercase, function(char) {\n\t\t\t\t\treturn delimiters.prependUppercase + char.toLowerCase();\n\t\t\t\t});\n\t\t} else if(startsWith(encoded, '(') || startsWith(encoded, '{')) {\n\t\t\t// convert uppercase characters in older bindings to kebab-case\n\t\t\t// - {fooBar}, (fooBar), {(fooBar)}\n\t\t\tencoded = encoded.replace(regexes.camelCase, camelCaseToSpinalCase);\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tdev.warn(\"can-attribute-encoder: Found attribute with name: \" + name + \". Converting to: \" + encoded + '.');\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\t}\n\n\t//encode spaces\n\tencoded = encoded.replace(regexes.space, delimiters.replaceSpace)\n\t\t//encode forward slashes\n\t\t.replace(regexes.forwardSlash, delimiters.replaceForwardSlash)\n\t\t// encode left parentheses\n\t\t.replace(regexes.leftParens, delimiters.replaceLeftParens)\n\t\t// encode right parentheses\n\t\t.replace(regexes.rightParens, delimiters.replaceRightParens)\n\t\t// encode left braces\n\t\t.replace(regexes.leftBrace, delimiters.replaceLeftBrace)\n\t\t// encode left braces\n\t\t.replace(regexes.rightBrace, delimiters.replaceRightBrace)\n\t\t// encode ^\n\t\t.replace(regexes.caret, delimiters.replaceCaret)\n\t\t// encode $\n\t\t.replace(regexes.dollar, delimiters.replaceDollar)\n\t\t// encode @\n\t\t.replace(regexes.at, delimiters.replaceAt);\n\n\treturn encoded;\n};\n\n/**\n * @function can-attribute-encoder.decode decode\n * @parent can-attribute-encoder\n * @description Decode an attribute name encoded by [can-attribute-encoder.encode]\n * @signature `encoder.decode(attributeName)`\n *\n * @body\n *\n * ```js\n * encoder.decode(attributeName); // -> \"{(^$foo/bar baz)}\"\n *\n * ```\n *\n * @param {String} attributeName The encoded attribute name.\n * @return {String} The decoded attribute name.\n *\n */\nencoder.decode = function(name) {\n\tvar decoded = name;\n\n\t// decode uppercase characters in new bindings\n\tif (!caseMattersAttributes[decoded] && regexes.uppercaseDelimiterThenChar.test(decoded)) {\n\t\tif (\n\t\t\tstartsWith(decoded, 'on:') ||\n\t\t\tendsWith(decoded, ':to') ||\n\t\t\tendsWith(decoded, ':from') ||\n\t\t\tendsWith(decoded, ':bind') ||\n\t\t\tendsWith(decoded, ':raw')\n\t\t) {\n\t\t\tdecoded = decoded\n\t\t\t\t.replace(regexes.uppercaseDelimiterThenChar, function(match, char) {\n\t\t\t\t\treturn char.toUpperCase();\n\t\t\t\t});\n\t\t}\n\t}\n\n\t// decode left parentheses\n\tdecoded = decoded.replace(delimiters.replaceLeftParens, '(')\n\t\t// decode right parentheses\n\t\t.replace(delimiters.replaceRightParens, ')')\n\t\t// decode left braces\n\t\t.replace(delimiters.replaceLeftBrace, '{')\n\t\t// decode left braces\n\t\t.replace(delimiters.replaceRightBrace, '}')\n\t\t// decode forward slashes\n\t\t.replace(delimiters.replaceForwardSlash, '/')\n\t\t// decode spaces\n\t\t.replace(delimiters.replaceSpace, ' ')\n\t\t// decode ^\n\t\t.replace(delimiters.replaceCaret, '^')\n\t\t//decode $\n\t\t.replace(delimiters.replaceDollar, '$')\n\t\t//decode @\n\t\t.replace(delimiters.replaceAt, '@');\n\n\treturn decoded;\n};\n\nif (namespace.encoder) {\n\tthrow new Error(\"You can't have two versions of can-attribute-encoder, check your dependencies\");\n} else {\n\tmodule.exports = namespace.encoder = encoder;\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-attribute-encoder/can-attribute-encoder.js?");

/***/ }),

/***/ "./node_modules/can-attribute-observable/behaviors.js":
/*!************************************************************!*\
  !*** ./node_modules/can-attribute-observable/behaviors.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\nvar global = __webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\")();\nvar setData = __webpack_require__(/*! can-dom-data */ \"./node_modules/can-dom-data/can-dom-data.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"./node_modules/can-dom-events/can-dom-events.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\nvar getMutationObserver = __webpack_require__(/*! can-globals/mutation-observer/mutation-observer */ \"./node_modules/can-globals/mutation-observer/mutation-observer.js\");\nvar diff = __webpack_require__(/*! can-diff/list/list */ \"./node_modules/can-diff/list/list.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\n\nvar xmlnsAttrNamespaceURI = \"http://www.w3.org/2000/xmlns/\";\nvar xlinkHrefAttrNamespaceURI =  \"http://www.w3.org/1999/xlink\";\nvar attrsNamespacesURI = {\n\t'xmlns': xmlnsAttrNamespaceURI,\n\t'xlink:href': xlinkHrefAttrNamespaceURI\n};\n\n\nvar formElements = {\"INPUT\": true, \"TEXTAREA\": true, \"SELECT\": true, \"BUTTON\": true},\n\t// Used to convert values to strings.\n\ttoString = function(value){\n\t\tif(value == null) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn \"\"+value;\n\t\t}\n\t},\n\tisSVG = function(el){\n\t\treturn el.namespaceURI === \"http://www.w3.org/2000/svg\";\n\t},\n\ttruthy = function() { return true; },\n\tgetSpecialTest = function(special){\n\t\treturn (special && special.test) || truthy;\n\t},\n\tpropProp = function(prop, obj){\n\t\tobj = obj || {};\n\t\tobj.get = function(){\n\t\t\treturn this[prop];\n\t\t};\n\t\tobj.set = function(value){\n\t\t\tif(this[prop] !== value) {\n\t\t\t\tthis[prop] = value;\n\t\t\t}\n\t\t};\n\t\treturn obj;\n\t},\n\tbooleanProp = function(prop){\n\t\treturn {\n\t\t\tisBoolean: true,\n\t\t\tset: function(value){\n\t\t\t\tif(prop in this) {\n\t\t\t\t\tthis[prop] = value;\n\t\t\t\t} else {\n\t\t\t\t\tdomMutateNode.setAttribute.call(this, prop, \"\");\n\t\t\t\t}\n\t\t\t},\n\t\t\tremove: function(){\n\t\t\t\tthis[prop] = false;\n\t\t\t}\n\t\t};\n\t},\n\tsetupMO = function(el, callback){\n\t\tvar attrMO = setData.get(el, \"attrMO\");\n\t\tif(!attrMO) {\n\t\t\tvar onMutation = function(){\n\t\t\t\tcallback.call(el);\n\t\t\t};\n\t\t\tvar MO = getMutationObserver();\n\t\t\tif(MO) {\n\t\t\t\tvar observer = new MO(onMutation);\n\t\t\t\tobserver.observe(el, {\n\t\t\t\t\tchildList: true,\n\t\t\t\t\tsubtree: true\n\t\t\t\t});\n\t\t\t\tsetData.set(el, \"attrMO\", observer);\n\t\t\t} else {\n\t\t\t\tsetData.set(el, \"attrMO\", true);\n\t\t\t\tsetData.set(el, \"canBindingCallback\", {onMutation: onMutation});\n\t\t\t}\n\t\t}\n\t},\n\t_findOptionToSelect = function (parent, value) {\n\t\tvar child = parent.firstChild;\n\t\twhile (child) {\n\t\t\tif (child.nodeName === \"OPTION\" && value === child.value) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t\tif (child.nodeName === \"OPTGROUP\") {\n\t\t\t\tvar groupChild = _findOptionToSelect(child, value);\n\t\t\t\tif (groupChild) {\n\t\t\t\t\treturn groupChild;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t},\n\tsetChildOptions = function(el, value){\n\t\tvar option;\n\t\tif (value != null) {\n\t\t\toption = _findOptionToSelect(el, value);\n\t\t}\n\t\tif (option) {\n\t\t\toption.selected = true;\n\t\t} else {\n\t\t\tel.selectedIndex = -1;\n\t\t}\n\t},\n\tforEachOption = function (parent, fn) {\n\t\tvar child = parent.firstChild;\n\t\twhile (child) {\n\t\t\tif (child.nodeName === \"OPTION\") {\n\t\t\t\tfn(child);\n\t\t\t}\n\t\t\tif (child.nodeName === \"OPTGROUP\") {\n\t\t\t\tforEachOption(child, fn);\n\t\t\t}\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t},\n\tcollectSelectedOptions = function (parent) {\n\t\tvar selectedValues = [];\n\t\tforEachOption(parent, function (option) {\n\t\t\tif (option.selected) {\n\t\t\t\tselectedValues.push(option.value);\n\t\t\t}\n\t\t});\n\t\treturn selectedValues;\n\t},\n\tmarkSelectedOptions = function (parent, values) {\n\t\tforEachOption(parent, function (option) {\n\t\t\toption.selected = values.indexOf(option.value) !== -1;\n\t\t});\n\t},\n\t// Create a handler, only once, that will set the child options any time\n\t// the select's value changes.\n\tsetChildOptionsOnChange = function(select, aEL){\n\t\tvar handler = setData.get(select, \"attrSetChildOptions\");\n\t\tif(handler) {\n\t\t\treturn Function.prototype;\n\t\t}\n\t\thandler = function(){\n\t\t\tsetChildOptions(select, select.value);\n\t\t};\n\t\tsetData.set(select, \"attrSetChildOptions\", handler);\n\t\taEL.call(select, \"change\", handler);\n\t\treturn function(rEL){\n\t\t\tsetData.clean(select, \"attrSetChildOptions\");\n\t\t\trEL.call(select, \"change\", handler);\n\t\t};\n\t},\n\t// cache of rules already calculated by `attr.getRule`\n\tbehaviorRules = new Map(),\n\t// # isPropWritable\n\t// check if a property is writable on an element by finding its property descriptor\n\t// on the element or its prototype chain\n\tisPropWritable = function(el, prop) {\n\t\t   var desc = Object.getOwnPropertyDescriptor(el, prop);\n\n\t\t   if (desc) {\n\t\t\t\t   return desc.writable || desc.set;\n\t\t   } else {\n\t\t\t\t   var proto = Object.getPrototypeOf(el);\n\t\t\t\t   if (proto) {\n\t\t\t\t\t\t   return isPropWritable(proto, prop);\n\t\t\t\t   }\n\t\t   }\n\n\t\t   return false;\n\t},\n\t// # cacheRule\n\t// add a rule to the rules Map so it does not need to be calculated more than once\n\tcacheRule = function(el, attrOrPropName, rule) {\n\t\t   var rulesForElementType;\n\n\t\t   rulesForElementType = behaviorRules.get(el.prototype);\n\n\t\t   if (!rulesForElementType) {\n\t\t\t\t   rulesForElementType = {};\n\t\t\t\t   behaviorRules.set(el.constructor, rulesForElementType);\n\t\t   }\n\n\t\t   rulesForElementType[attrOrPropName] = rule;\n\n\t\t   return rule;\n\t};\n\nvar specialAttributes = {\n\tchecked: {\n\t\tget: function(){\n\t\t\treturn this.checked;\n\t\t},\n\t\tset: function(val){\n\t\t\t// - `set( truthy )` => TRUE\n\t\t\t// - `set( \"\" )`     => TRUE\n\t\t\t// - `set()`         => TRUE\n\t\t\t// - `set(undefined)` => false.\n\t\t\tvar notFalse = !!val || val === \"\" || arguments.length === 0;\n\t\t\tthis.checked = notFalse;\n\t\t\tif(notFalse && this.type === \"radio\") {\n\t\t\t\tthis.defaultChecked = true;\n\t\t\t}\n\t\t},\n\t\tremove: function(){\n\t\t\tthis.checked = false;\n\t\t},\n\t\ttest: function(){\n\t\t\treturn this.nodeName === \"INPUT\";\n\t\t}\n\t},\n\t\"class\": {\n\t\tget: function(){\n\t\t\tif(isSVG(this)) {\n\t\t\t\treturn this.getAttribute(\"class\");\n\t\t\t}\n\t\t\treturn this.className;\n\t\t},\n\t\tset: function(val){\n\t\t\tval = val || \"\";\n\n\t\t\tif(isSVG(this)) {\n\t\t\t\tdomMutateNode.setAttribute.call(this, \"class\", \"\" + val);\n\t\t\t} else {\n\t\t\t\tthis.className = val;\n\t\t\t}\n\t\t}\n\t},\n\tdisabled: booleanProp(\"disabled\"),\n\tfocused: {\n\t\tget: function(){\n\t\t\treturn this === document.activeElement;\n\t\t},\n\t\tset: function(val){\n\t\t\tvar cur = attr.get(this, \"focused\");\n\t\t\tvar docEl = this.ownerDocument.documentElement;\n\t\t\tvar element = this;\n\t\t\tfunction focusTask() {\n\t\t\t\tif (val) {\n\t\t\t\t\telement.focus();\n\t\t\t\t} else {\n\t\t\t\t\telement.blur();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cur !== val) {\n\t\t\t\tif (!docEl.contains(element)) {\n\t\t\t\t\tvar connectionDisposal = domMutate.onNodeConnected(element, function () {\n\t\t\t\t\t\tconnectionDisposal();\n\t\t\t\t\t\tfocusTask();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// THIS MIGHT NEED TO BE PUT IN THE MUTATE QUEUE\n\t\t\t\t\tqueues.enqueueByQueue({\n\t\t\t\t\t\tmutate: [focusTask]\n\t\t\t\t\t}, null, []);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\taEL.call(this, \"focus\", handler);\n\t\t\taEL.call(this, \"blur\", handler);\n\t\t\treturn function(rEL){\n\t\t\t\trEL.call(this, \"focus\", handler);\n\t\t\t\trEL.call(this, \"blur\", handler);\n\t\t\t};\n\t\t},\n\t\ttest: function(){\n\t\t\treturn this.nodeName === \"INPUT\";\n\t\t}\n\t},\n\t\"for\": propProp(\"htmlFor\"),\n\tinnertext: propProp(\"innerText\"),\n\tinnerhtml: propProp(\"innerHTML\"),\n\tinnerHTML: propProp(\"innerHTML\", {\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\tvar handlers = [];\n\t\t\tvar el = this;\n\t\t\t[\"change\", \"blur\"].forEach(function(eventName){\n\t\t\t\tvar localHandler = function(){\n\t\t\t\t\thandler.apply(this, arguments);\n\t\t\t\t};\n\t\t\t\tdomEvents.addEventListener(el, eventName, localHandler);\n\t\t\t\thandlers.push([eventName, localHandler]);\n\t\t\t});\n\n\t\t\treturn function(rEL){\n\t\t\t\thandlers.forEach( function(info){\n\t\t\t\t\trEL.call(el, info[0], info[1]);\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t}),\n\trequired: booleanProp(\"required\"),\n\treadonly: booleanProp(\"readOnly\"),\n\tselected: {\n\t\tget: function(){\n\t\t\treturn this.selected;\n\t\t},\n\t\tset: function(val){\n\t\t\tval = !!val;\n\t\t\tsetData.set(this, \"lastSetValue\", val);\n\t\t\tthis.selected = val;\n\t\t},\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\tvar option = this;\n\t\t\tvar select = this.parentNode;\n\t\t\tvar lastVal = option.selected;\n\t\t\tvar localHandler = function(changeEvent){\n\t\t\t\tvar curVal = option.selected;\n\t\t\t\tlastVal = setData.get(option, \"lastSetValue\") || lastVal;\n\t\t\t\tif(curVal !== lastVal) {\n\t\t\t\t\tlastVal = curVal;\n\n\t\t\t\t\tdomEvents.dispatch(option, eventName);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar removeChangeHandler = setChildOptionsOnChange(select, aEL);\n\t\t\tdomEvents.addEventListener(select, \"change\", localHandler);\n\t\t\taEL.call(option, eventName, handler);\n\n\t\t\treturn function(rEL){\n\t\t\t\tremoveChangeHandler(rEL);\n\t\t\t\tdomEvents.removeEventListener(select, \"change\", localHandler);\n\t\t\t\trEL.call(option, eventName, handler);\n\t\t\t};\n\t\t},\n\t\ttest: function(){\n\t\t\treturn this.nodeName === \"OPTION\" && this.parentNode &&\n\t\t\t\tthis.parentNode.nodeName === \"SELECT\";\n\t\t}\n\t},\n\tstyle: {\n\t\tset: (function () {\n\t\t\tvar el = global.document && getDocument().createElement(\"div\");\n\t\t\tif ( el && el.style && (\"cssText\" in el.style) ) {\n\t\t\t\treturn function (val) {\n\t\t\t\t\tthis.style.cssText = (val || \"\");\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn function (val) {\n\t\t\t\t\tdomMutateNode.setAttribute.call(this, \"style\", val);\n\t\t\t\t};\n\t\t\t}\n\t\t})()\n\t},\n\ttextcontent: propProp(\"textContent\"),\n\tvalue: {\n\t\tget: function(){\n\t\t\tvar value = this.value;\n\t\t\tif(this.nodeName === \"SELECT\") {\n\t\t\t\tif((\"selectedIndex\" in this) && this.selectedIndex === -1) {\n\t\t\t\t\tvalue = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tset: function(value){\n\t\t\tvar providedValue = value;\n\t\t\tvar nodeName = this.nodeName.toLowerCase();\n\t\t\tif(nodeName === \"input\" || nodeName === \"textarea\") {\n\t\t\t\t// Do some input types support non string values?\n\t\t\t\tvalue = toString(value);\n\t\t\t}\n\t\t\tif(this.value !== value || nodeName === \"option\") {\n\t\t\t\tthis.value = value;\n\t\t\t}\n\t\t\tif (nodeName === \"input\" || nodeName === \"textarea\") {\n\t\t\t\tthis.defaultValue = value;\n\t\t\t}\n\t\t\tif(nodeName === \"select\") {\n\t\t\t\tsetData.set(this, \"attrValueLastVal\", value);\n\t\t\t\t//If it's null then special case\n\t\t\t\tsetChildOptions(this, value === null ? value : this.value);\n\n\t\t\t\t// If not in the document reset the value when inserted.\n\t\t\t\tvar docEl = this.ownerDocument.documentElement;\n\t\t\t\tif(!docEl.contains(this)) {\n\t\t\t\t\tvar select = this;\n\t\t\t\t\tvar connectionDisposal = domMutate.onNodeConnected(select, function () {\n\t\t\t\t\t\tconnectionDisposal();\n\t\t\t\t\t\tsetChildOptions(select, value === null ? value : select.value);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// MO handler is only set up **ONCE**\n\t\t\t\tsetupMO(this, function(){\n\t\t\t\t\tvar value = setData.get(this, \"attrValueLastVal\");\n\t\t\t\t\tattr.set(this, \"value\", value);\n\t\t\t\t\tdomEvents.dispatch(this, \"change\");\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Warnings area\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tvar settingADateInputToADate = nodeName === \"input\" && this.type === \"date\" && (providedValue instanceof Date);\n\t\t\t\tif(settingADateInputToADate) {\n\t\t\t\t\tdev.warn(\"Binding a Date to the \\\"value\\\" property on an <input type=\\\"date\\\"> will not work as expected. Use valueAsDate:bind instead. See https://canjs.com/doc/guides/forms.html#Dateinput for more information.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t},\n\t\ttest: function(){\n\t\t\treturn formElements[this.nodeName];\n\t\t}\n\t},\n\tvalues: {\n\t\tget: function(){\n\t\t\treturn collectSelectedOptions(this);\n\t\t},\n\t\tset: function(values){\n\t\t\tvalues = values || [];\n\n\t\t\t// set new DOM state\n\t\t\tmarkSelectedOptions(this, values);\n\n\t\t\t// store new DOM state\n\t\t\tsetData.set(this, \"stickyValues\", attr.get(this,\"values\") );\n\n\t\t\t// MO handler is only set up **ONCE**\n\t\t\t// TODO: should this be moved into addEventListener?\n\t\t\tsetupMO(this, function(){\n\n\t\t\t\t// Get the previous sticky state\n\t\t\t\tvar previousValues = setData.get(this,\n\t\t\t\t\t\"stickyValues\");\n\n\t\t\t\t// Set DOM to previous sticky state\n\t\t\t\tattr.set(this, \"values\", previousValues);\n\n\t\t\t\t// Get the new result after trying to maintain the sticky state\n\t\t\t\tvar currentValues = setData.get(this,\n\t\t\t\t\t\"stickyValues\");\n\n\t\t\t\t// If there are changes, trigger a `values` event.\n\t\t\t\tvar changes = diff(previousValues.slice().sort(),\n\t\t\t\t\tcurrentValues.slice().sort());\n\n\t\t\t\tif (changes.length) {\n\t\t\t\t\tdomEvents.dispatch(this, \"values\");\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\tvar localHandler = function(){\n\t\t\t\tdomEvents.dispatch(this, \"values\");\n\t\t\t};\n\n\t\t\tdomEvents.addEventListener(this, \"change\", localHandler);\n\t\t\taEL.call(this, eventName, handler);\n\n\t\t\treturn function(rEL){\n\t\t\t\tdomEvents.removeEventListener(this, \"change\", localHandler);\n\t\t\t\trEL.call(this, eventName, handler);\n\t\t\t};\n\t\t}\n\t}\n};\n\nvar attr = {\n\t// cached rules (stored on `attr` for testing purposes)\n\trules: behaviorRules,\n\n\t// special attribute behaviors (stored on `attr` for testing purposes)\n\tspecialAttributes: specialAttributes,\n\n\t// # attr.getRule\n\t//\n\t// get the behavior rule for an attribute or property on an element\n\t//\n\t// Rule precendence:\n\t//   1. \"special\" behaviors - use the special behavior getter/setter\n\t//   2. writable properties - read and write as a property\n\t//   3. all others - read and write as an attribute\n\t//\n\t// Once rule is determined it will be cached for all elements of the same type\n\t// so that it does not need to be calculated again\n\tgetRule: function(el, attrOrPropName) {\n\t\tvar special = specialAttributes[attrOrPropName];\n\t\t// always use \"special\" if available\n\t\t// these are not cached since they would have to be cached separately\n\t\t// for each element type and it is faster to just look up in the\n\t\t// specialAttributes object\n\t\tif (special) {\n\t\t\treturn special;\n\t\t}\n\n\t\t// next use rules cached in a previous call to getRule\n\t\tvar rulesForElementType = behaviorRules.get(el.constructor);\n\t\tvar cached = rulesForElementType && rulesForElementType[attrOrPropName];\n\n\t\tif (cached) {\n\t\t\treturn cached;\n\t\t}\n\n\t\t// if the element doesn't have a property of this name, it must be an attribute\n\t\tif (!(attrOrPropName in el)) {\n\t\t\treturn this.attribute(attrOrPropName);\n\t\t}\n\n\t\t// if there is a property, check if it is writable\n\t\tvar newRule = isPropWritable(el, attrOrPropName) ?\n\t\t\tthis.property(attrOrPropName) :\n\t\t\tthis.attribute(attrOrPropName);\n\n\t\t// cache the new rule and return it\n\t\treturn cacheRule(el, attrOrPropName, newRule);\n\t},\n\n\tattribute: function(attrName) {\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\treturn this.getAttribute(attrName);\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\tif (attrsNamespacesURI[attrName]) {\n\t\t\t\t\tdomMutateNode.setAttributeNS.call(this, attrsNamespacesURI[attrName], attrName, val);\n\t\t\t\t} else {\n\t\t\t\t\tdomMutateNode.setAttribute.call(this, attrName, val);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t},\n\n\tproperty: function(propName) {\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\treturn this[propName];\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\tthis[propName] = val;\n\t\t\t}\n\t\t};\n\t},\n\n\tfindSpecialListener: function(attributeName) {\n\t\treturn specialAttributes[attributeName] && specialAttributes[attributeName].addEventListener;\n\t},\n\n\tsetAttrOrProp: function(el, attrName, val){\n\t\treturn this.set(el, attrName, val);\n\t},\n\t// ## attr.set\n\t// Set the value an attribute on an element.\n\tset: function (el, attrName, val) {\n\t\tvar rule = this.getRule(el, attrName);\n\t\tvar setter = rule && rule.set;\n\n\t\tif (setter) {\n\t\t\treturn setter.call(el, val);\n\t\t}\n\t},\n\t// ## attr.get\n\t// Gets the value of an attribute or property.\n\t// First checks if the property is an `specialAttributes` and if so calls the special getter.\n\t// Then checks if the attribute or property is a property on the element.\n\t// Otherwise uses `getAttribute` to retrieve the value.\n\tget: function (el, attrName) {\n\t\tvar rule = this.getRule(el, attrName);\n\t\tvar getter = rule && rule.get;\n\n\t\tif (getter) {\n\t\t\treturn rule.test ?\n\t\t\t\trule.test.call(el) && getter.call(el) :\n\t\t\t\tgetter.call(el);\n\t\t}\n\t},\n\t// ## attr.remove\n\t// Removes an attribute from an element. First checks specialAttributes to see if the attribute is special and has a setter. If so calls the setter with `undefined`. Otherwise `removeAttribute` is used.\n\t// If the attribute previously had a value and the browser doesn't support MutationObservers we then trigger an \"attributes\" event.\n\tremove: function (el, attrName) {\n\t\tattrName = attrName.toLowerCase();\n\t\tvar special = specialAttributes[attrName];\n\t\tvar setter = special && special.set;\n\t\tvar remover = special && special.remove;\n\t\tvar test = getSpecialTest(special);\n\n\t\tif(typeof remover === \"function\" && test.call(el)) {\n\t\t\tremover.call(el);\n\t\t} else if(typeof setter === \"function\" && test.call(el)) {\n\t\t\tsetter.call(el, undefined);\n\t\t} else {\n\t\t\tdomMutateNode.removeAttribute.call(el, attrName);\n\t\t}\n\t}\n};\n\nmodule.exports = attr;\n\n\n//# sourceURL=webpack:///./node_modules/can-attribute-observable/behaviors.js?");

/***/ }),

/***/ "./node_modules/can-attribute-observable/can-attribute-observable.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-attribute-observable/can-attribute-observable.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar canEvent = __webpack_require__(/*! ./event */ \"./node_modules/can-attribute-observable/event.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar attr = __webpack_require__(/*! ./behaviors */ \"./node_modules/can-attribute-observable/behaviors.js\");\nvar getEventName = __webpack_require__(/*! ./get-event-name */ \"./node_modules/can-attribute-observable/get-event-name.js\");\nvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"./node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ \"./node_modules/can-simple-observable/settable/settable.js\");\nvar canAssign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar onValueSymbol = canSymbol.for('can.onValue');\nvar offValueSymbol = canSymbol.for('can.offValue');\nvar onEmitSymbol = canSymbol.for('can.onEmit');\nvar offEmitSymbol = canSymbol.for('can.offEmit');\n\n// We register a namespaced radiochange event with the global\n// event registry so it does not interfere with user-defined events.\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"./node_modules/can-dom-events/can-dom-events.js\");\nvar radioChangeEvent = __webpack_require__(/*! can-event-dom-radiochange */ \"./node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js\");\nvar internalRadioChangeEventType = \"can-attribute-observable-radiochange\";\ndomEvents.addEvent(radioChangeEvent, internalRadioChangeEventType);\n\nvar isSelect = function isSelect(el) {\n\treturn el.nodeName.toLowerCase() === \"select\";\n};\n\nvar isMultipleSelect = function isMultipleSelect(el, prop) {\n\treturn isSelect(el) && prop === \"value\" && el.multiple;\n};\n\nvar slice = Array.prototype.slice;\n\nfunction canUtilAEL () {\n\tvar args = slice.call(arguments, 0);\n\targs.unshift(this);\n\treturn domEvents.addEventListener.apply(null, args);\n}\n\nfunction canUtilREL () {\n\tvar args = slice.call(arguments, 0);\n\targs.unshift(this);\n\treturn domEvents.removeEventListener.apply(null, args);\n}\n\nfunction AttributeObservable(el, prop, bindingData, event) {\n\tif(typeof bindingData === \"string\") {\n\t\tevent = bindingData;\n\t\tbindingData = undefined;\n\t}\n\n\tthis.el = el;\n\tthis.bound = false;\n\tthis.prop = isMultipleSelect(el, prop) ? \"values\" : prop;\n\tthis.event = event || getEventName(el, prop);\n\tthis.handler = this.handler.bind(this);\n\n\t// If we have an event\n\t// remove onValue/offValue and add onEvent\n\tif (event !== undefined) {\n\t\tthis[onValueSymbol] = null;\n\t\tthis[offValueSymbol] = null;\n\t\tthis[onEmitSymbol] = AttributeObservable.prototype.on;\n\t\tthis[offEmitSymbol] = AttributeObservable.prototype.off;\n\t}\n\n\n\t//!steal-remove-start\n\tif(true) {\n\t\t// register what changes the element's attribute\n\t\tcanReflectDeps.addMutatedBy(this.el, this.prop, this);\n\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function getName() {\n\t\t\t\treturn (\n\t\t\t\t\t\"AttributeObservable<\" +\n\t\t\t\t\tel.nodeName.toLowerCase() +\n\t\t\t\t\t\".\" +\n\t\t\t\t\tthis.prop +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\t//!steal-remove-end\n}\n\nAttributeObservable.prototype = Object.create(SettableObservable.prototype);\n\ncanAssign(AttributeObservable.prototype, {\n\tconstructor: AttributeObservable,\n\n\tget: function get() {\n\t\tif (ObservationRecorder.isRecording()) {\n\t\t\tObservationRecorder.add(this);\n\t\t\tif (!this.bound) {\n\t\t\t\tObservation.temporarilyBind(this);\n\t\t\t}\n\t\t}\n\t\tvar value = attr.get(this.el, this.prop);\n\t\tif (typeof value === 'function') {\n\t\t\tvalue = value.bind(this.el);\n\t\t}\n\t\treturn value;\n\t},\n\n\tset: function set(newVal) {\n\t\tvar setterDispatchedEvents = attr.setAttrOrProp(this.el, this.prop, newVal);\n\t\t// update the observation internal value\n\t\tif(!setterDispatchedEvents) {\n\t\t\tthis._value = newVal;\n\t\t}\n\n\n\t\treturn newVal;\n\t},\n\n\thandler: function handler(newVal, event) {\n\t\tvar old = this._value;\n\t\tvar queuesArgs = [];\n\t\tthis._value = attr.get(this.el, this.prop);\n\n\t\t// If we have an event then we want to enqueue on all changes\n\t\t// otherwise only enquue when there are changes to the value\n\t\tif (event !== undefined || this._value !== old) {\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\t\tthis._log(old, newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.handlers.getNode([]),\n  \t\t\tthis,\n  \t\t\t[newVal, old]\n  \t\t];\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tqueuesArgs = [\n\t\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\t\tthis,\n\t\t\t\t\t[newVal, old]\n\t\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t\t,null\n\t\t\t\t\t,[this.el,this.prop,\"changed to\", newVal, \"from\", old, \"by\", event]\n\t\t\t\t\t/* jshint laxcomma: false */\n\t\t\t\t];\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t// adds callback handlers to be called w/i their respective queue.\n\t\t\tqueues.enqueueByQueue.apply(queues, queuesArgs);\n\t\t}\n\t},\n\n\tonBound: function onBound() {\n\t\tvar observable = this;\n\n\t\tobservable.bound = true;\n\n\t\t// make sure `this.handler` gets the new value instead of\n\t\t// the event object passed to the event handler\n\t\tobservable._handler = function(event) {\n\t\t\tobservable.handler(attr.get(observable.el, observable.prop), event);\n\t\t};\n\n\t\tif (observable.event === internalRadioChangeEventType) {\n\t\t\tcanEvent.on.call(observable.el, \"change\", observable._handler);\n\t\t}\n\n\t\tvar specialBinding = attr.findSpecialListener(observable.prop);\n\t\tif (specialBinding) {\n\t\t\tobservable._specialDisposal = specialBinding.call(observable.el, observable.prop, observable._handler, canUtilAEL);\n\t\t}\n\n\t\tcanEvent.on.call(observable.el, observable.event, observable._handler);\n\n\t\t// initial value\n\t\tthis._value = attr.get(this.el, this.prop);\n\t},\n\n\tonUnbound: function onUnbound() {\n\t\tvar observable = this;\n\n\t\tobservable.bound = false;\n\n\t\tif (observable.event === internalRadioChangeEventType) {\n\t\t\tcanEvent.off.call(observable.el, \"change\", observable._handler);\n\t\t}\n\n\t\tif (observable._specialDisposal) {\n\t\t\tobservable._specialDisposal.call(observable.el, canUtilREL);\n\t\t\tobservable._specialDisposal = null;\n\t\t}\n\n\t\tcanEvent.off.call(observable.el, observable.event, observable._handler);\n\t},\n\n\tvalueHasDependencies: function valueHasDependencies() {\n\t\treturn true;\n\t},\n\n\tgetValueDependencies: function getValueDependencies() {\n\t\tvar m = new Map();\n\t\tvar s = new Set();\n\t\ts.add(this.prop);\n\t\tm.set(this.el, s);\n\t\treturn {\n\t\t\tkeyDependencies: m\n\t\t};\n\t}\n});\n\ncanReflect.assignSymbols(AttributeObservable.prototype, {\n\t\"can.isMapLike\": false,\n\t\"can.getValue\": AttributeObservable.prototype.get,\n\t\"can.setValue\": AttributeObservable.prototype.set,\n\t\"can.onValue\": AttributeObservable.prototype.on,\n\t\"can.offValue\": AttributeObservable.prototype.off,\n\t\"can.valueHasDependencies\": AttributeObservable.prototype.hasDependencies,\n\t\"can.getValueDependencies\": AttributeObservable.prototype.getValueDependencies\n});\n\nmodule.exports = AttributeObservable;\n\n\n//# sourceURL=webpack:///./node_modules/can-attribute-observable/can-attribute-observable.js?");

/***/ }),

/***/ "./node_modules/can-attribute-observable/event.js":
/*!********************************************************!*\
  !*** ./node_modules/can-attribute-observable/event.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"./node_modules/can-dom-events/can-dom-events.js\");\nvar isDomEventTarget = __webpack_require__(/*! can-dom-events/helpers/util */ \"./node_modules/can-dom-events/helpers/util.js\").isDomEventTarget;\n\nvar canEvent = {\n\ton: function on(eventName, handler, queue) {\n\t\tif (isDomEventTarget(this)) {\n\t\t\tdomEvents.addEventListener(this, eventName, handler, queue);\n\t\t} else {\n\t\t\tcanReflect.onKeyValue(this, eventName, handler, queue);\n\t\t}\n\t},\n\toff: function off(eventName, handler, queue) {\n\t\tif (isDomEventTarget(this)) {\n\t\t\tdomEvents.removeEventListener(this, eventName, handler, queue);\n\t\t} else {\n\t\t\tcanReflect.offKeyValue(this, eventName, handler, queue);\n\t\t}\n\t},\n\tone: function one(event, handler, queue) {\n\t\t// Unbind the listener after it has been executed\n\t\tvar one = function() {\n\t\t\tcanEvent.off.call(this, event, one, queue);\n\t\t\treturn handler.apply(this, arguments);\n\t\t};\n\n\t\t// Bind the altered listener\n\t\tcanEvent.on.call(this, event, one, queue);\n\t\treturn this;\n\t}\n};\n\nmodule.exports = canEvent;\n\n\n//# sourceURL=webpack:///./node_modules/can-attribute-observable/event.js?");

/***/ }),

/***/ "./node_modules/can-attribute-observable/get-event-name.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-attribute-observable/get-event-name.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar attr = __webpack_require__(/*! ./behaviors */ \"./node_modules/can-attribute-observable/behaviors.js\");\n\nvar isRadioInput = function isRadioInput(el) {\n\treturn el.nodeName.toLowerCase() === \"input\" && el.type === \"radio\";\n};\n\n// Determine the event or events we need to listen to when this value changes.\nmodule.exports = function getEventName(el, prop) {\n\tvar event = \"change\";\n\n\tif (isRadioInput(el) && prop === \"checked\" ) {\n\t\tevent = \"can-attribute-observable-radiochange\";\n\t}\n\n\tif (attr.findSpecialListener(prop)) {\n\t\tevent = prop;\n\t}\n\n\treturn event;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-attribute-observable/get-event-name.js?");

/***/ }),

/***/ "./node_modules/can-bind/can-bind.js":
/*!*******************************************!*\
  !*** ./node_modules/can-bind/can-bind.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar canAssign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\n//!steal-remove-start\nif(true) {\n\tvar canLog = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\tvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"./node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\n}\n//!steal-remove-end\n\n// Symbols\nvar getChangesSymbol = canSymbol.for(\"can.getChangesDependencyRecord\");\nvar getValueSymbol = canSymbol.for(\"can.getValue\");\nvar onValueSymbol = canSymbol.for(\"can.onValue\");\nvar onEmitSymbol = canSymbol.for(\"can.onEmit\");\nvar offEmitSymbol = canSymbol.for(\"can.offEmit\");\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\nvar canElementSymbol = canSymbol.for(\"can.element\");\n\n// Default implementations for setting the child and parent values\nfunction defaultSetValue(newValue, observable) {\n\tcanReflect.setValue(observable, newValue);\n}\n\n// onEmit function\nfunction onEmit (listenToObservable, updateFunction, queue) {\n\treturn listenToObservable[onEmitSymbol](updateFunction, queue);\n}\n\n// offEmit function\nfunction offEmit (listenToObservable, updateFunction, queue) {\n\treturn listenToObservable[offEmitSymbol](updateFunction, queue);\n}\n\n// Given an observable, stop listening to it and tear down the mutation dependencies\nfunction turnOffListeningAndUpdate(listenToObservable, updateObservable, updateFunction, queue) {\n\tvar offValueOrOffEmitFn;\n\n\t// Use either offValue or offEmit depending on which Symbols are on the `observable`\n\tif (listenToObservable[onValueSymbol]) {\n\t\toffValueOrOffEmitFn = canReflect.offValue;\n\t} else if (listenToObservable[onEmitSymbol]) {\n\t\toffValueOrOffEmitFn = offEmit;\n\t}\n\n\tif (offValueOrOffEmitFn) {\n\t\toffValueOrOffEmitFn(listenToObservable, updateFunction, queue);\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\n\t\t\t// The updateObservable is no longer mutated by listenToObservable\n\t\t\tcanReflectDeps.deleteMutatedBy(updateObservable, listenToObservable);\n\n\t\t\t// The updateFunction no longer mutates anything\n\t\t\tupdateFunction[getChangesSymbol] = function getChangesDependencyRecord() {\n\t\t\t};\n\n\t\t}\n\t\t//!steal-remove-end\n\t}\n}\n\n// Given an observable, start listening to it and set up the mutation dependencies\nfunction turnOnListeningAndUpdate(listenToObservable, updateObservable, updateFunction, queue) {\n\tvar onValueOrOnEmitFn;\n\n\t// Use either onValue or onEmit depending on which Symbols are on the `observable`\n\tif (listenToObservable[onValueSymbol]) {\n\t\tonValueOrOnEmitFn = canReflect.onValue;\n\t} else if (listenToObservable[onEmitSymbol]) {\n\t\tonValueOrOnEmitFn = onEmit;\n\t}\n\n\tif (onValueOrOnEmitFn) {\n\t\tonValueOrOnEmitFn(listenToObservable, updateFunction, queue);\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\n\t\t\t// The updateObservable is mutated by listenToObservable\n\t\t\tcanReflectDeps.addMutatedBy(updateObservable, listenToObservable);\n\n\t\t\t// The updateFunction mutates updateObservable\n\t\t\tupdateFunction[getChangesSymbol] = function getChangesDependencyRecord() {\n\t\t\t\tvar s = new Set();\n\t\t\t\ts.add(updateObservable);\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: s\n\t\t\t\t};\n\t\t\t};\n\n\t\t}\n\n\t\t//!steal-remove-end\n\t}\n}\n\n// Semaphores are used to keep track of updates to the child & parent\n// For debugging purposes, Semaphore and Bind are highly coupled.\nfunction Semaphore(binding, type) {\n\tthis.value = 0;\n\tthis._binding = binding;\n\tthis._type = type;\n}\ncanAssign(Semaphore.prototype, {\n\tdecrement: function() {\n\t\tthis.value -= 1;\n\t},\n\tincrement: function(args) {\n\t\tthis._incremented = true;\n\t\tthis.value += 1;\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif(this.value === 1) {\n\t\t\t\tthis._binding._debugSemaphores = [];\n\t\t\t}\n\t\t\tvar semaphoreData = {\n\t\t\t\ttype: this._type,\n\t\t\t\taction: \"increment\",\n\t\t\t\tobservable: args.observable,\n\t\t\t\tnewValue: args.newValue,\n\t\t\t\tvalue: this.value,\n\t\t\t\tlastTask: queues.lastTask()\n\t\t\t};\n\t\t\tthis._binding._debugSemaphores.push(semaphoreData);\n\t\t}\n\t\t//!steal-remove-end\n\t}\n});\n\nfunction Bind(options) {\n\tthis._options = options;\n\n\t// These parameters must be supplied\n\t//!steal-remove-start\n\tif(true) {\n\t\tif (options.child === undefined) {\n\t\t\tthrow new TypeError(\"You must supply a child\");\n\t\t}\n\t\tif (options.parent === undefined) {\n\t\t\tthrow new TypeError(\"You must supply a parent\");\n\t\t}\n\t\tif (options.queue && [\"notify\", \"derive\", \"domUI\",\"dom\"].indexOf(options.queue) === -1) {\n\t\t\tthrow new RangeError(\"Invalid queue; must be one of notify, derive, dom, or domUI\");\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// queue; by default, domUI\n\tif (options.queue === undefined) {\n\t\tif(options.element) {\n\t\t\toptions.queue = \"dom\";\n\t\t} else {\n\t\t\toptions.queue = \"domUI\";\n\t\t}\n\n\t}\n\n\t// cycles: when an observable is set in a two-way binding, it can update the\n\t// other bound observable, which can then update the original observable the\n\t// â€œcyclesâ€ number of times. For example, a child is set and updates the parent;\n\t// with cycles: 0, the parent could not update the child;\n\t// with cycles: 1, the parent could update the child, which can update the parent\n\t// with cycles: 2, the parent can update the child again, and so on and so forthâ€¦\n\tif (options.cycles > 0 === false) {\n\t\toptions.cycles = 0;\n\t}\n\n\t// onInitDoNotUpdateChild is false by default\n\toptions.onInitDoNotUpdateChild =\n\t\ttypeof options.onInitDoNotUpdateChild === \"boolean\" ?\n\t\t\toptions.onInitDoNotUpdateChild\n\t\t\t: false;\n\n\t// onInitDoNotUpdateParent is false by default\n\toptions.onInitDoNotUpdateParent =\n\t\ttypeof options.onInitDoNotUpdateParent === \"boolean\" ?\n\t\t\toptions.onInitDoNotUpdateParent\n\t\t\t: false;\n\n\t// onInitSetUndefinedParentIfChildIsDefined is true by default\n\toptions.onInitSetUndefinedParentIfChildIsDefined =\n\t\ttypeof options.onInitSetUndefinedParentIfChildIsDefined === \"boolean\" ?\n\t\t\toptions.onInitSetUndefinedParentIfChildIsDefined\n\t\t\t: true;\n\n\t// The way the cycles are tracked is through semaphores; currently, when\n\t// either the child or parent is updated, we increase their respective\n\t// semaphore so that if itâ€™s two-way binding, then the â€œotherâ€Â observable\n\t// will only update if the total count for both semaphores is less than or\n\t// equal to twice the number of cycles (because a cycle means two updates).\n\tvar childSemaphore = new Semaphore(this,\"child\");\n\tvar parentSemaphore = new Semaphore(this,\"parent\");\n\n\t// Determine if this is a one-way or two-way binding; by default, accept\n\t// whatever options are passed in, but if theyâ€™re not defined, then check for\n\t// the getValue and setValue symbols on the child and parent values.\n\tvar childToParent = true;\n\tif (typeof options.childToParent === \"boolean\") {\n\t\t// Always let the option override any checks\n\t\tchildToParent = options.childToParent;\n\t} else if (options.child[getValueSymbol] == null) {\n\t\t// Child to parent wonâ€™t work if we canâ€™t get the childâ€™s value\n\t\tchildToParent = false;\n\t} else if (options.setParent === undefined && options.parent[setValueSymbol] == null) {\n\t\t// Child to parent wonâ€™t work if we canâ€™t set the parentâ€™s value\n\t\tchildToParent = false;\n\t}\n\tvar parentToChild = true;\n\tif (typeof options.parentToChild === \"boolean\") {\n\t\t// Always let the option override any checks\n\t\tparentToChild = options.parentToChild;\n\t} else if (options.parent[getValueSymbol] == null) {\n\t\t// Parent to child wonâ€™t work if we canâ€™t get the parentâ€™s value\n\t\tparentToChild = false;\n\t} else if (options.setChild === undefined && options.child[setValueSymbol] == null) {\n\t\t// Parent to child wonâ€™t work if we canâ€™t set the childâ€™s value\n\t\tparentToChild = false;\n\t}\n\tif (childToParent === false && parentToChild === false) {\n\t\tthrow new Error(\"Neither the child nor parent will be updated; this is a no-way binding\");\n\t}\n\tthis._childToParent = childToParent;\n\tthis._parentToChild = parentToChild;\n\n\t// Custom child & parent setters can be supplied; if they arenâ€™t provided,\n\t// then create our own.\n\tif (options.setChild === undefined) {\n\t\toptions.setChild = defaultSetValue;\n\t}\n\tif (options.setParent === undefined) {\n\t\toptions.setParent = defaultSetValue;\n\t}\n\n\t// Set the observablesâ€™ priority\n\tif (options.priority !== undefined) {\n\t\tcanReflect.setPriority(options.child, options.priority);\n\t\tcanReflect.setPriority(options.parent, options.priority);\n\t}\n\n\t// These variables keep track of how many updates are allowed in a cycle.\n\t// cycles is multipled by two because one update is allowed for each side of\n\t// the binding, child and parent. One more update is allowed depending on the\n\t// sticky option; if itâ€™s sticky, then one more update needs to be allowed.\n\tvar allowedUpdates = options.cycles * 2;\n\tvar allowedChildUpdates = allowedUpdates + (options.sticky === \"childSticksToParent\" ? 1 : 0);\n\tvar allowedParentUpdates = allowedUpdates + (options.sticky === \"parentSticksToChild\" ? 1 : 0);\n\n\t// This keeps track of whether weâ€™re bound to the child and/or parent; this\n\t// allows startParent() to be called first and on() can be called later to\n\t// finish setting up the child binding. This is also checked when updating\n\t// values; if stop() has been called but updateValue() is called, then we\n\t// ignore the update.\n\tthis._bindingState = {\n\t\tchild: false,\n\t\tparent: false\n\t};\n\n\t// This is the listener thatâ€™s called when the parent changes\n\tthis._updateChild = function(newValue) {\n\t\tupdateValue.call(this, {\n\t\t\tbindingState: this._bindingState,\n\t\t\tnewValue: newValue,\n\n\t\t\t// Some options used for debugging\n\t\t\tdebugObservableName: \"child\",\n\t\t\tdebugPartnerName: \"parent\",\n\n\t\t\t// Main observable values\n\t\t\tobservable: options.child,\n\t\t\tsetValue: options.setChild,\n\t\t\tsemaphore: childSemaphore,\n\n\t\t\t// If the sum of the semaphores is less than or equal to this number, then\n\t\t\t// itâ€™s ok to update the child with the new value.\n\t\t\tallowedUpdates: allowedChildUpdates,\n\n\t\t\t// If options.sticky === \"parentSticksToChild\", then after the parent sets\n\t\t\t// the child, check to see if the child matches the parent; if not, then\n\t\t\t// set the parent to the childâ€™s value. This is used in cases where the\n\t\t\t// child modifies its own value and the parent should be kept in sync with\n\t\t\t// the child.\n\t\t\tsticky: options.sticky === \"parentSticksToChild\",\n\n\t\t\t// Partner observable values\n\t\t\tpartner: options.parent,\n\t\t\tsetPartner: options.setParent,\n\t\t\tpartnerSemaphore: parentSemaphore\n\t\t});\n\t}.bind(this);\n\n\t// This is the listener thatâ€™s called when the child changes\n\tthis._updateParent = function(newValue) {\n\t\tupdateValue.call(this, {\n\t\t\tbindingState: this._bindingState,\n\t\t\tnewValue: newValue,\n\n\t\t\t// Some options used for debugging\n\t\t\tdebugObservableName: \"parent\",\n\t\t\tdebugPartnerName: \"child\",\n\n\t\t\t// Main observable values\n\t\t\tobservable: options.parent,\n\t\t\tsetValue: options.setParent,\n\t\t\tsemaphore: parentSemaphore,\n\n\t\t\t// If the sum of the semaphores is less than or equal to this number, then\n\t\t\t// itâ€™s ok to update the parent with the new value.\n\t\t\tallowedUpdates: allowedParentUpdates,\n\n\t\t\t// If options.sticky === \"childSticksToParent\", then after the child sets\n\t\t\t// the parent, check to see if the parent matches the child; if not, then\n\t\t\t// set the child to the parentâ€™s value. This is used in cases where the\n\t\t\t// parent modifies its own value and the child should be kept in sync with\n\t\t\t// the parent.\n\t\t\tsticky: options.sticky === \"childSticksToParent\",\n\n\t\t\t// Partner observable values\n\t\t\tpartner: options.child,\n\t\t\tsetPartner: options.setChild,\n\t\t\tpartnerSemaphore: childSemaphore\n\t\t});\n\t}.bind(this);\n\n\tif(options.element) {\n\t\tthis._updateChild[canElementSymbol] = this._updateParent[canElementSymbol] = options.element;\n\t}\n\n\t//!steal-remove-start\n\tif(true) {\n\n\t\tObject.defineProperty(this._updateChild, \"name\", {\n\t\t\tvalue: options.updateChildName ? options.updateChildName : \"update \"+canReflect.getName(options.child),\n\t\t\tconfigurable: true\n\t\t});\n\n\t\tObject.defineProperty(this._updateParent, \"name\", {\n\t\t\tvalue: options.updateParentName ? options.updateParentName : \"update \"+canReflect.getName(options.parent),\n\t\t\tconfigurable: true\n\t\t});\n\t}\n\t//!steal-remove-end\n\n}\n\nObject.defineProperty(Bind.prototype, \"parentValue\", {\n\tget: function() {\n\t\treturn canReflect.getValue(this._options.parent);\n\t}\n});\n\ncanAssign(Bind.prototype, {\n\n\t// Turn on any bindings that havenâ€™t already been enabled;\n\t// also update the child or parent if need be.\n\tstart: function() {\n\t\tvar childValue;\n\t\tvar options = this._options;\n\t\tvar parentValue;\n\n\t\t// The tests donâ€™t show that it matters which is bound first, but weâ€™ll\n\t\t// bind to the parent first to stay consistent with how\n\t\t// can-stache-bindings did things.\n\t\tthis.startParent();\n\t\tthis.startChild();\n\n\t\t// Initialize the child & parent values\n\t\tif (this._childToParent === true && this._parentToChild === true) {\n\t\t\t// Two-way binding\n\t\t\tparentValue = canReflect.getValue(options.parent);\n\t\t\tif (parentValue === undefined) {\n\t\t\t\tchildValue = canReflect.getValue(options.child);\n\t\t\t\tif (childValue === undefined) {\n\t\t\t\t\t// Check if updating the child is allowed\n\t\t\t\t\tif (options.onInitDoNotUpdateChild === false) {\n\t\t\t\t\t\tthis._updateChild(parentValue);\n\t\t\t\t\t}\n\t\t\t\t} else if (options.onInitDoNotUpdateParent === false && options.onInitSetUndefinedParentIfChildIsDefined === true) {\n\t\t\t\t\tthis._updateParent(childValue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Check if updating the child is allowed\n\t\t\t\tif (options.onInitDoNotUpdateChild === false) {\n\t\t\t\t\tthis._updateChild(parentValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true){\n\t\t\t\t// Here we want to do a dev-mode check to see whether the child does type conversions on\n\t\t\t\t//  any two-way bindings.  This will be ignored and the child and parent will be desynched.\n\t\t\t\tvar parentContext = options.parent.observation && options.parent.observation.func || options.parent;\n\t\t\t\tvar childContext = options.child.observation && options.child.observation.func || options.child;\n\t\t\t\tparentValue = canReflect.getValue(options.parent);\n\t\t\t\tchildValue = canReflect.getValue(options.child);\n\t\t\t\tif (options.sticky && childValue !== parentValue) {\n\t\t\t\t\tcanLog.warn(\n\t\t\t\t\t\t\"can-bind: The \" +\n\t\t\t\t\t\t(options.sticky === \"parentSticksToChild\" ? \"parent\" : \"child\") +\n\t\t\t\t\t\t\" of the sticky two-way binding \" +\n\t\t\t\t\t\t(options.debugName || (canReflect.getName(parentContext) + \"<->\" + canReflect.getName(childContext))) +\n\t\t\t\t\t\t\" is changing or converting its value when set. Conversions should only be done on the binding \" +\n\t\t\t\t\t\t(options.sticky === \"parentSticksToChild\" ? \"child\" : \"parent\") +\n\t\t\t\t\t\t\" to preserve synchronization. \" +\n\t\t\t\t\t\t\"See https://canjs.com/doc/can-stache-bindings.html#StickyBindings for more about sticky bindings\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t} else if (this._childToParent === true) {\n\t\t\t// One-way child -> parent, so update the parent\n\t\t\t// Check if we are to initialize the parent\n\t\t\tif (options.onInitDoNotUpdateParent === false) {\n\t\t\t\tchildValue = canReflect.getValue(options.child);\n\t\t\t\tthis._updateParent(childValue);\n\t\t\t}\n\n\t\t} else if (this._parentToChild === true) {\n\t\t\t// One-way parent -> child, so update the child\n\t\t\t// Check if updating the child is allowed\n\t\t\tif (options.onInitDoNotUpdateChild === false) {\n\t\t\t\tparentValue = canReflect.getValue(options.parent);\n\t\t\t\tthis._updateChild(parentValue);\n\t\t\t}\n\t\t}\n\t},\n\n\t// Listen for changes to the child observable and update the parent\n\tstartChild: function() {\n\t\tif (this._bindingState.child === false && this._childToParent === true) {\n\t\t\tvar options = this._options;\n\t\t\tthis._bindingState.child = true;\n\t\t\tturnOnListeningAndUpdate(options.child, options.parent, this._updateParent, options.queue);\n\t\t}\n\t},\n\n\t// Listen for changes to the parent observable and update the child\n\tstartParent: function() {\n\t\tif (this._bindingState.parent === false && this._parentToChild === true) {\n\t\t\tvar options = this._options;\n\t\t\tthis._bindingState.parent = true;\n\t\t\tturnOnListeningAndUpdate(options.parent, options.child, this._updateChild, options.queue);\n\t\t}\n\t},\n\n\t// Turn off all the bindings\n\tstop: function() {\n\t\tvar bindingState = this._bindingState;\n\t\tvar options = this._options;\n\n\t\t// Turn off the parent listener\n\t\tif (bindingState.parent === true && this._parentToChild === true) {\n\t\t\tbindingState.parent = false;\n\t\t\tturnOffListeningAndUpdate(options.parent, options.child, this._updateChild, options.queue);\n\t\t}\n\n\t\t// Turn off the child listener\n\t\tif (bindingState.child === true && this._childToParent === true) {\n\t\t\tbindingState.child = false;\n\t\t\tturnOffListeningAndUpdate(options.child, options.parent, this._updateParent, options.queue);\n\t\t}\n\t}\n\n});\n\n[\"parent\", \"child\"].forEach(function(property){\n\tObject.defineProperty(Bind.prototype, property, {\n\t\tget: function(){\n\t\t\treturn this._options[property];\n\t\t}\n\t});\n});\n\n\n\n// updateValue is a helper function thatâ€™s used by updateChild and updateParent\nfunction updateValue(args) {\n\t/* jshint validthis: true */\n\t// Check to see whether the binding is active; ignore updates if it isnâ€™t active\n\tvar bindingState = args.bindingState;\n\tif (bindingState.child === false && bindingState.parent === false) {\n\t\t// We donâ€™t warn the user about this because itâ€™s a common occurrence in\n\t\t// can-stache-bindings, e.g. {{#if value}}<input value:bind=\"value\"/>{{/if}}\n\t\treturn;\n\t}\n\n\t// Now check the semaphore; if this change is happening because the partner\n\t// observable was just updated, we only want to update this observable again\n\t// if the total count for both semaphores is less than or equal to the number\n\t// of allowed updates.\n\tvar semaphore = args.semaphore;\n\tif ((semaphore.value + args.partnerSemaphore.value) <= args.allowedUpdates) {\n\t\tqueues.batch.start();\n\n\t\t// Increase the semaphore so that when the batch ends, if an update to the\n\t\t// partner observableâ€™s value is made, then it wonâ€™t update this observable\n\t\t// again unless cycles are allowed.\n\t\tsemaphore.increment(args);\n\n\t\t// Update the observableâ€™s value; this uses either a custom function passed\n\t\t// in when the binding was initialized or canReflect.setValue.\n\t\targs.setValue(args.newValue, args.observable);\n\n\n\n\t\t// Decrease the semaphore after all other updates have occurred\n\t\tqueues.mutateQueue.enqueue(semaphore.decrement, semaphore, []);\n\n\t\tqueues.batch.stop();\n\n\t\t// Stickiness is used in cases where the call to args.setValue above might\n\t\t// have resulted in the observable being set to a different value than what\n\t\t// was passed into this function (args.newValue). If sticky:true, then set\n\t\t// the partner observableâ€™s value so theyâ€™re kept in sync.\n\t\tif (args.sticky) {\n\t\t\tvar observableValue = canReflect.getValue(args.observable);\n\t\t\tif (observableValue !== canReflect.getValue(args.partner)) {\n\t\t\t\targs.setPartner(observableValue, args.partner);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t// Itâ€™s natural for this â€œelseâ€ block to be hit in two-way bindings; as an\n\t\t// example, if a parent gets set and the child gets updated, the childâ€™s\n\t\t// listener to update the parent will be called, but itâ€™ll be ignored if we\n\t\t// donâ€™t want cycles. HOWEVER, if this gets called and the parent is not the\n\t\t// same value as the child, then their values are going to be out of sync,\n\t\t// probably unintentionally. This is worth pointing out to developers\n\t\t// because it can cause unexpected behaviorâ€¦ some people call those bugs. :)\n\n\t\t//!steal-remove-start\n\t\tif(true){\n\t\t\tvar currentValue = canReflect.getValue(args.observable);\n\t\t\tif (currentValue !== args.newValue) {\n\t\t\t\tvar warningParts = [\n\t\t\t\t\t\"can-bind: attempting to update \" + args.debugObservableName + \" \" + canReflect.getName(args.observable) + \" to new value: %o\",\n\t\t\t\t\t\"â€¦but the \" + args.debugObservableName + \" semaphore is at \" + semaphore.value + \" and the \" + args.debugPartnerName + \" semaphore is at \" + args.partnerSemaphore.value + \". The number of allowed updates is \" + args.allowedUpdates + \".\",\n\t\t\t\t\t\"The \" + args.debugObservableName + \" value will remain unchanged; itâ€™s currently: %o. \",\n\t\t\t\t\t\"Read https://canjs.com/doc/can-bind.html#Warnings for more information. Printing mutation history:\"\n\t\t\t\t];\n\t\t\t\tcanLog.warn(warningParts.join(\"\\n\"), args.newValue, currentValue);\n\t\t\t\tif(console.groupCollapsed) {\n\t\t\t\t\t// stores the last stack we've seen so we only need to show what's happened since the\n\t\t\t\t\t// last increment.\n\t\t\t\t\tvar lastStack = [];\n\t\t\t\t\tvar getFromLastStack = function(stack){\n\t\t\t\t\t\tif(lastStack.length) {\n\t\t\t\t\t\t\t// walk backwards\n\t\t\t\t\t\t\tfor(var i = lastStack.length - 1; i >= 0 ; i--) {\n\t\t\t\t\t\t\t\tvar index = stack.indexOf(lastStack[i]);\n\t\t\t\t\t\t\t\tif(index !== - 1) {\n\t\t\t\t\t\t\t\t\treturn stack.slice(i+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn stack;\n\t\t\t\t\t};\n\t\t\t\t\t// Loop through all the debug information\n\t\t\t\t\t// And print out what caused increments.\n\t\t\t\t\tthis._debugSemaphores.forEach(function(semaphoreMutation){\n\t\t\t\t\t\tif(semaphoreMutation.action === \"increment\") {\n\t\t\t\t\t\t\tconsole.groupCollapsed(semaphoreMutation.type+\" \"+canReflect.getName(semaphoreMutation.observable)+\" set.\");\n\t\t\t\t\t\t\tvar stack = queues.stack(semaphoreMutation.lastTask);\n\t\t\t\t\t\t\tvar printStack = getFromLastStack(stack);\n\t\t\t\t\t\t\tlastStack = stack;\n\t\t\t\t\t\t\t// This steals how `logStack` logs information.\n\t\t\t\t\t\t\tqueues.logStack.call({\n\t\t\t\t\t\t\t\tstack: function(){\n\t\t\t\t\t\t\t\t\treturn printStack;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconsole.log(semaphoreMutation.type+ \" semaphore incremented to \"+semaphoreMutation.value+\".\");\n\t\t\t\t\t\t\tconsole.log(canReflect.getName(semaphoreMutation.observable),semaphoreMutation.observable,\"set to \", semaphoreMutation.newValue);\n\t\t\t\t\t\t\tconsole.groupEnd();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tconsole.groupCollapsed(args.debugObservableName+\" \"+canReflect.getName(args.observable)+\" NOT set.\");\n\t\t\t\t\tvar stack = getFromLastStack(queues.stack());\n\t\t\t\t\tqueues.logStack.call({\n\t\t\t\t\t\tstack: function(){\n\t\t\t\t\t\t\treturn stack;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tconsole.log(args.debugObservableName+\" semaphore (\"+semaphore.value+\n\t\t\t\t\t \") + \"+args.debugPartnerName+\" semaphore (\"+args.partnerSemaphore.value+ \") IS NOT <= allowed updates (\"+\n\t\t\t\t\t args.allowedUpdates+\")\");\n\t\t\t\t\tconsole.log(\"Prevented from setting \"+canReflect.getName(args.observable), args.observable, \"to\", args.newValue);\n\t\t\t\t\tconsole.groupEnd();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t}\n}\n\nmodule.exports = namespace.Bind = Bind;\n\n\n//# sourceURL=webpack:///./node_modules/can-bind/can-bind.js?");

/***/ }),

/***/ "./node_modules/can-child-nodes/can-child-nodes.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-child-nodes/can-child-nodes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\n/**\n * @module {function} can-child-nodes\n * @parent can-dom-utilities\n * @collection can-infrastructure\n * @package ./package.json\n * \n * @signature `childNodes(node)`\n *\n * Get all of the childNodes of a given node.\n *\n * ```js\n * var stache = require(\"can-stache\");\n * var childNodes = require(\"can-util/child-nodes/child-nodes\");\n *\n * var html = \"<div><h1><span></span></h1></div>\";\n * var frag = stache(html)();\n *\n * console.log(childNodes(frag)[0].nodeName); // -> DIV\n * ```\n *\n * @param {Object} node The Node that you want child nodes for.\n */\n\nfunction childNodes(node) {\n\tvar childNodes = node.childNodes;\n\tif (\"length\" in childNodes) {\n\t\treturn childNodes;\n\t} else {\n\t\tvar cur = node.firstChild;\n\t\tvar nodes = [];\n\t\twhile (cur) {\n\t\t\tnodes.push(cur);\n\t\t\tcur = cur.nextSibling;\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\nmodule.exports = namespace.childNodes = childNodes;\n\n\n//# sourceURL=webpack:///./node_modules/can-child-nodes/can-child-nodes.js?");

/***/ }),

/***/ "./node_modules/can-cid/can-cid.js":
/*!*****************************************!*\
  !*** ./node_modules/can-cid/can-cid.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n/**\n * @module {function} can-cid\n * @parent can-typed-data\n * @collection can-infrastructure\n * @package ./package.json\n * @description Utility for getting a unique identifier for an object.\n * @signature `cid(object, optionalObjectType)`\n *\n * Get a unique identifier for the object, optionally prefixed by a type name.\n *\n * Once set, the unique identifier does not change, even if the type name\n * changes on subsequent calls.\n *\n * ```js\n * var cid = require(\"can-cid\");\n * var x = {};\n * var y = {};\n *\n * console.log(cid(x, \"demo\")); // -> \"demo1\"\n * console.log(cid(x, \"prod\")); // -> \"demo1\"\n * console.log(cid(y));         // -> \"2\"\n * ```\n *\n * @param {Object} object The object to uniquely identify.\n * @param {String} name   An optional type name with which to prefix the identifier\n *\n * @return {String} Returns the unique identifier\n */\nvar _cid = 0;\n// DOM nodes shouldn't all use the same property\nvar domExpando = \"can\" + new Date();\nvar cid = function (object, name) {\n\tvar propertyName = object.nodeName ? domExpando : \"_cid\";\n\n\tif (!object[propertyName]) {\n\t\t_cid++;\n\t\tobject[propertyName] = (name || '') + _cid;\n\t}\n\treturn object[propertyName];\n};\ncid.domExpando = domExpando;\ncid.get = function(object){\n\tvar type = typeof object;\n\tvar isObject = type !== null && (type === \"object\" || type === \"function\");\n\treturn isObject ? cid(object) : (type + \":\" + object);\n};\n\nif (namespace.cid) {\n\tthrow new Error(\"You can't have two versions of can-cid, check your dependencies\");\n} else {\n\tmodule.exports = namespace.cid = cid;\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-cid/can-cid.js?");

/***/ }),

/***/ "./node_modules/can-cid/helpers.js":
/*!*****************************************!*\
  !*** ./node_modules/can-cid/helpers.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = {\n    each: function(obj, cb, context) {\n        for(var prop in obj) {\n            cb.call(context, obj[prop], prop);\n        }\n        return obj;\n    }\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-cid/helpers.js?");

/***/ }),

/***/ "./node_modules/can-cid/map/map.js":
/*!*****************************************!*\
  !*** ./node_modules/can-cid/map/map.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getCID = __webpack_require__(/*! ../can-cid */ \"./node_modules/can-cid/can-cid.js\").get;\nvar helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/can-cid/helpers.js\");\n\nvar CIDMap;\n\nif(typeof Map !== \"undefined\") {\n\tCIDMap = Map;\n} else {\n\tvar CIDMap = function(){\n\t\tthis.values = {};\n\t};\n\tCIDMap.prototype.set = function(key, value){\n\t\tthis.values[getCID(key)] = {key: key, value: value};\n\t};\n\tCIDMap.prototype[\"delete\"] = function(key){\n\t\tvar has = getCID(key) in this.values;\n\t\tif(has) {\n\t\t\tdelete this.values[getCID(key)];\n\t\t}\n\t\treturn has;\n\t};\n\tCIDMap.prototype.forEach = function(cb, thisArg) {\n\t\thelpers.each(this.values, function(pair){\n\t\t\treturn cb.call(thisArg || this, pair.value, pair.key, this);\n\t\t}, this);\n\t};\n\tCIDMap.prototype.has = function(key) {\n\t\treturn getCID(key) in this.values;\n\t};\n\tCIDMap.prototype.get = function(key) {\n\t\tvar obj = this.values[getCID(key)];\n\t\treturn obj && obj.value;\n\t};\n\tCIDMap.prototype.clear = function() {\n\t\treturn this.values = {};\n\t};\n\tObject.defineProperty(CIDMap.prototype,\"size\",{\n\t\tget: function(){\n\t\t\tvar size = 0;\n\t\t\thelpers.each(this.values, function(){\n\t\t\t\tsize++;\n\t\t\t});\n\t\t\treturn size;\n\t\t}\n\t});\n}\n\nmodule.exports = CIDMap;\n\n\n//# sourceURL=webpack:///./node_modules/can-cid/map/map.js?");

/***/ }),

/***/ "./node_modules/can-cid/set/set.js":
/*!*****************************************!*\
  !*** ./node_modules/can-cid/set/set.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar getCID = __webpack_require__(/*! ../can-cid */ \"./node_modules/can-cid/can-cid.js\").get;\nvar helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/can-cid/helpers.js\");\n\nvar CIDSet;\n\nif(typeof Set !== \"undefined\") {\n\tCIDSet = Set;\n} else {\n\tvar CIDSet = function(){\n\t\tthis.values = {};\n\t};\n\tCIDSet.prototype.add = function(value){\n\t\tthis.values[getCID(value)] = value;\n\t};\n\tCIDSet.prototype[\"delete\"] = function(key){\n\t\tvar has = getCID(key) in this.values;\n\t\tif(has) {\n\t\t\tdelete this.values[getCID(key)];\n\t\t}\n\t\treturn has;\n\t};\n\tCIDSet.prototype.forEach = function(cb, thisArg) {\n\t\thelpers.each(this.values, cb, thisArg);\n\t};\n\tCIDSet.prototype.has = function(value) {\n\t\treturn getCID(value) in this.values;\n\t};\n\tCIDSet.prototype.clear = function() {\n\t\treturn this.values = {};\n\t};\n\tObject.defineProperty(CIDSet.prototype,\"size\",{\n\t\tget: function(){\n\t\t\tvar size = 0;\n\t\t\thelpers.each(this.values, function(){\n\t\t\t\tsize++;\n\t\t\t});\n\t\t\treturn size;\n\t\t}\n\t});\n}\n\nmodule.exports = CIDSet;\n\n\n//# sourceURL=webpack:///./node_modules/can-cid/set/set.js?");

/***/ }),

/***/ "./node_modules/can-component/can-component.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-component/can-component.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// # can-component.js\n// This implements the `Component` which allows you to create widgets\n// that use a view, a view-model, and custom tags.\n//\n// `Component` implements most of it's functionality in the `Component.setup`\n// and the `Component.prototype.setup` functions.\n//\n// `Component.setup` prepares everything needed by the `Component.prototype.setup`\n// to hookup the component.\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar Bind = __webpack_require__(/*! can-bind */ \"./node_modules/can-bind/can-bind.js\");\nvar Construct = __webpack_require__(/*! can-construct */ \"./node_modules/can-construct/can-construct.js\");\nvar stache = __webpack_require__(/*! can-stache */ \"./node_modules/can-stache/can-stache.js\");\nvar stacheBindings = __webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\nvar Scope = __webpack_require__(/*! can-view-scope */ \"./node_modules/can-view-scope/can-view-scope.js\");\nvar viewCallbacks = __webpack_require__(/*! can-view-callbacks */ \"./node_modules/can-view-callbacks/can-view-callbacks.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\nvar SimpleMap = __webpack_require__(/*! can-simple-map */ \"./node_modules/can-simple-map/can-simple-map.js\");\nvar DefineMap = __webpack_require__(/*! can-define/map/map */ \"./node_modules/can-define/map/map.js\");\nvar canLog = __webpack_require__(/*! can-log */ \"./node_modules/can-log/can-log.js\");\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar domData = __webpack_require__(/*! can-dom-data */ \"./node_modules/can-dom-data/can-dom-data.js\");\nvar string = __webpack_require__(/*! can-string */ \"./node_modules/can-string/can-string.js\");\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"./node_modules/can-dom-events/can-dom-events.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar DOCUMENT = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\n\nvar ComponentControl = __webpack_require__(/*! ./control/control */ \"./node_modules/can-component/control/control.js\");\n\n// #### Side effects\n\n__webpack_require__(/*! can-view-model */ \"./node_modules/can-view-model/can-view-model.js\");\n// DefineList must be imported so Arrays on the ViewModel\n// will be converted to DefineLists automatically\n__webpack_require__(/*! can-define/list/list */ \"./node_modules/can-define/list/list.js\");\n\n// Makes sure bindings are added simply by importing component.\nstache.addBindings(stacheBindings);\n\n// #### Symbols\nvar createdByCanComponentSymbol = canSymbol(\"can.createdByCanComponent\");\nvar getValueSymbol = canSymbol.for(\"can.getValue\");\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\nvar viewInsertSymbol = canSymbol.for(\"can.viewInsert\");\nvar viewModelSymbol = canSymbol.for('can.viewModel');\n\n\n// ## Helpers\n\n// ### addContext\n// For replacement elements like `<can-slot>` and `<context>`, this is used to\n// figure out what data they should render with.  Slots can have bindings like\n// `this:from=\"value\"` or `x:from=\"y\"`.\n//\n// If `this` is set, a compute is created for the context.\n// If variables are set, a variable scope is created.\n//\n// Arguments:\n//\n// - el - the insertion element\n// - tagData - the tagData the insertion element will be rendered with\n// - insertionElementTagData - the tagData found at the insertion element.\n//\n// Returns: the tagData the template should be rendered with.\nfunction addContext(el, tagData, insertionElementTagData) {\n\tvar vm,\n\t\tnewScope;\n\n\t// Prevent setting up bindings manually.\n\tdomData.set(el, \"preventDataBindings\", true);\n\n\tvar teardown = stacheBindings.behaviors.viewModel(el, insertionElementTagData,\n\t\t// `createViewModel` is used to create the ViewModel that the\n\t\t// bindings will operate on.\n\t\tfunction createViewModel(initialData, hasDataBinding, bindingState) {\n\n\t\t\tif(bindingState && bindingState.isSettingOnViewModel === true) {\n\t\t\t\t// If we are setting a value like `x:from=\"y\"`,\n\t\t\t\t// we need to make a variable scope.\n\t\t\t\tnewScope = tagData.scope.addLetContext(initialData);\n\t\t\t\treturn newScope._context;\n\n\t\t\t} else {\n\t\t\t\t// If we are setting the ViewModel itself, we\n\t\t\t\t// stick the value in an observable: `this:from=\"value\"`.\n\t\t\t\treturn vm = new SimpleObservable(initialData);\n\t\t\t}\n\t\t}, undefined, true);\n\n\tif(!teardown) {\n\t\t// If no teardown, there's no bindings, no need to change the scope.\n\t\treturn tagData;\n\t} else {\n\t\t// Copy `tagData` and overwrite the scope.\n\t\treturn assign( assign({}, tagData), {\n\t\t\tteardown: teardown,\n\t\t\tscope: newScope || tagData.scope.add(vm)\n\t\t});\n\t}\n}\n\n// ### makeReplacementTagCallback\n// Returns a `viewCallbacks.tag` function for `<can-slot>` or `<content>`.\n// The `replacementTag` function:\n// - gets the proper tagData\n// - renders it the template\n// - adds the rendered result to the page using nodeLists\n//\n// Arguments:\n// - `tagName` - the tagName being created (`\"can-slot\"`).\n// - `componentTagData` - the component's tagData, including its scope.\n// - `shadowTagData` - the tagData where the element was found.\n// - `leakScope` - how scope is being leaked.\n// - `getPrimaryTemplate(el)` - a function to call to get the template to be rendered.\nfunction makeReplacementTagCallback(tagName, componentTagData, shadowTagData, leakScope, getPrimaryTemplate) {\n\n\tvar options = shadowTagData.options;\n\n\t// `replacementTag` is called when `<can-slot>` is found.\n\t// Arguments:\n\t// - `el` - the element\n\t// - `insertionElementTagData` - the tagData where the element was found.\n\treturn function replacementTag(el, insertionElementTagData) {\n\t\t// If there's no template to be rendered, we'll render what's inside the\n\t\t// element. This is usually default content.\n\t\tvar template = getPrimaryTemplate(el) || insertionElementTagData.subtemplate,\n\t\t\t// `true` if we are rendering something the user \"passed\" to this component.\n\t\t\trenderingLightContent = template !== insertionElementTagData.subtemplate;\n\n\t\t// If there's no template and no default content, we will do nothing. If\n\t\t// there is a template to render, lets render it!\n\t\tif (template) {\n\n\t\t\t// It's possible that rendering the contents of a `<can-slot>` will end up\n\t\t\t// rendering another `<can-slot>`.  We should make sure we can't render ourselves.\n\t\t\tdelete options.tags[tagName];\n\n\t\t\t// First, lets figure out what we should be rendering\n\t\t\t// the template with.\n\t\t\tvar tagData;\n\n\t\t\t// If we are rendering something the user passed.\n\t\t\tif( renderingLightContent ) {\n\n\t\t\t\tif(leakScope.toLightContent) {\n\t\t\t\t\t// We want to render with the same scope as the\n\t\t\t\t\t// `insertionElementTagData.scope`, but we don't want the\n\t\t\t\t\t// TemplateContext of the component's view included.\n\t\t\t\t\ttagData = addContext(el, {\n\t\t\t\t\t\tscope: insertionElementTagData.scope.cloneFromRef(),\n\t\t\t\t\t\toptions: insertionElementTagData.options\n\t\t\t\t\t}, insertionElementTagData);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// render with the same scope the component was found within.\n\t\t\t\t\ttagData = addContext(el, componentTagData, insertionElementTagData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We are rendering default content so this content should\n\t\t\t\t// use the same scope as the <content> tag was found within.\n\t\t\t\ttagData = addContext(el, insertionElementTagData, insertionElementTagData);\n\t\t\t}\n\n\n\t\t\t// Now we need to render the right template and insert its result in the page.\n\t\t\t// We need to teardown any bindings created too so we create a nodeList\n\t\t\t// to do this.\n\t\t\tvar fragment = template(tagData.scope, tagData.options);\n\t\t\tif(tagData.teardown) {\n\n\t\t\t\tvar placeholder = el.ownerDocument.createComment(tagName);\n\t\t\t\tfragment.insertBefore(placeholder, fragment.firstChild);\n\t\t\t\tdomMutate.onNodeRemoved(placeholder, tagData.teardown);\n\t\t\t}\n\n\t\t\tel.parentNode.replaceChild(\n\t\t\t\tfragment,\n\t\t\t\tel\n\t\t\t);\n\t\t\t/*\n\t\t\tvar nodeList = nodeLists.register([el], tagData.teardown || noop,\n\t\t\t\tinsertionElementTagData.parentNodeList || true,\n\t\t\t\tinsertionElementTagData.directlyNested);\n\n\t\t\tnodeList.expression = \"<can-slot name='\"+el.getAttribute('name')+\"'/>\";\n\n\t\t\tvar frag = template(tagData.scope, tagData.options);\n\n\n\t\t\tvar newNodes = canReflect.toArray( getChildNodes(frag) );\n\t\t\tvar oldNodes = nodeLists.update(nodeList, newNodes);\n\t\t\tnodeLists.replace(oldNodes, frag);*/\n\n\t\t\t// Restore the proper tag function so it could potentially be used again (as in lists)\n\t\t\toptions.tags[tagName] = replacementTag;\n\t\t}\n\t};\n}\n// ### getSetupFunctionForComponentVM\n// This helper function is used to setup a Component when `new Component({viewModel})`\n// is called.\n// Arguments:\n// - `componentInitVM` - The `viewModel` object used to initialize the actual viewModel.\n// Returns: A component viewModel setup function.\nfunction getSetupFunctionForComponentVM(componentInitVM) {\n\n\n\treturn ObservationRecorder.ignore(function(el, componentTagData, makeViewModel, initialVMData) {\n\n\t\tvar bindingContext = {\n\t\t\telement: el,\n\t\t\tscope: componentTagData.scope,\n\t\t\tparentNodeList: componentTagData.parentNodeList,\n\t\t\tviewModel: undefined\n\t\t};\n\n\t\tvar bindingSettings = {};\n\n\t\tvar bindings = [];\n\n\t\t// Loop through all viewModel props and create dataBindings.\n\t\tcanReflect.eachKey(componentInitVM, function(parent, propName) {\n\n\t\t\tvar canGetParentValue = parent != null && !!parent[getValueSymbol];\n\t\t\tvar canSetParentValue = parent != null && !!parent[setValueSymbol];\n\n\t\t\t// If we can get or set the value, then weâ€™ll create a binding\n\t\t\tif (canGetParentValue === true || canSetParentValue) {\n\n\t\t\t\t// Create an observable for reading/writing the viewModel\n\t\t\t\t// even though it doesn't exist yet.\n\t\t\t\tvar child = stacheBindings.getObservableFrom.viewModel({\n\t\t\t\t\tname: propName,\n\t\t\t\t}, bindingContext, bindingSettings);\n\n\t\t\t\t// Create the binding similar to whatâ€™s in can-stache-bindings\n\t\t\t\tvar canBinding = new Bind({\n\t\t\t\t\tchild: child,\n\t\t\t\t\tparent: parent,\n\t\t\t\t\tqueue: \"dom\",\n\t\t\t\t\telement: el,\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t// For debugging: the names that will be assigned to the updateChild\n\t\t\t\t\t// and updateParent functions within can-bind\n\t\t\t\t\tupdateChildName: \"update viewModel.\" + propName + \" of <\" + el.nodeName.toLowerCase() + \">\",\n\t\t\t\t\tupdateParentName: \"update \" + canReflect.getName(parent) + \" of <\" + el.nodeName.toLowerCase() + \">\"\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t});\n\n\t\t\t\tbindings.push({\n\t\t\t\t\tbinding: canBinding,\n\t\t\t\t\tsiblingBindingData: {\n\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\tsource: \"scope\",\n\t\t\t\t\t\t\texports: canGetParentValue\n\t\t\t\t\t\t},\n\t\t\t\t\t\tchild: {\n\t\t\t\t\t\t\tsource: \"viewModel\",\n\t\t\t\t\t\t\texports: canSetParentValue,\n\t\t\t\t\t\t\tname: propName\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\t// Canâ€™t get or set the value, so assume itâ€™s not an observable\n\t\t\t\tinitialVMData[propName] = parent;\n\t\t\t}\n\t\t});\n\n\t\t// Initialize the viewModel.  Make sure you\n\t\t// save it so the observables can access it.\n\t\tvar initializeData = stacheBindings.behaviors.initializeViewModel(bindings, initialVMData, function(properties){\n\t\t\treturn bindingContext.viewModel = makeViewModel(properties);\n\t\t}, bindingContext);\n\n\t\t// Return a teardown function\n\t\treturn function() {\n\t\t\tfor (var attrName in initializeData.onTeardowns) {\n\t\t\t\tinitializeData.onTeardowns[attrName]();\n\t\t\t}\n\t\t};\n\t});\n}\n\nvar Component = Construct.extend(\n\n\t// ## Static\n\t{\n\t\t// ### setup\n\t\t//\n\t\t// When a component is extended, this sets up the component's internal constructor\n\t\t// functions and views for later fast initialization.\n\t\t// jshint maxdepth:6\n\t\tsetup: function() {\n\t\t\tConstruct.setup.apply(this, arguments);\n\n\t\t\t// When `Component.setup` function is ran for the first time, `Component` doesn't exist yet\n\t\t\t// which ensures that the following code is ran only in constructors that extend `Component`.\n\t\t\tif (Component) {\n\t\t\t\tvar self = this;\n\n\t\t\t\t// Define a control using the `events` prototype property.\n\t\t\t\tif(this.prototype.events !== undefined && canReflect.size(this.prototype.events) !== 0) {\n\t\t\t\t\tthis.Control = ComponentControl.extend(this.prototype.events);\n\t\t\t\t}\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\t// If a constructor is assigned to the viewModel, give a warning\n\t\t\t\t\tif (this.prototype.viewModel && canReflect.isConstructorLike(this.prototype.viewModel)) {\n\t\t\t\t\t\tcanDev.warn(\"can-component: Assigning a DefineMap or constructor type to the viewModel property may not be what you intended. Did you mean ViewModel instead? More info: https://canjs.com/doc/can-component.prototype.ViewModel.html\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\t// Look at viewModel, scope, and ViewModel properties and set one of:\n\t\t\t\t//  - this.viewModelHandler\n\t\t\t\t//  - this.ViewModel\n\t\t\t\t//  - this.viewModelInstance\n\t\t\t\tvar protoViewModel = this.prototype.viewModel || this.prototype.scope;\n\n\t\t\t\tif(protoViewModel && this.prototype.ViewModel) {\n\t\t\t\t\tthrow new Error(\"Cannot provide both a ViewModel and a viewModel property\");\n\t\t\t\t}\n\t\t\t\tvar vmName = string.capitalize( string.camelize(this.prototype.tag) )+\"VM\";\n\t\t\t\tif(this.prototype.ViewModel) {\n\t\t\t\t\tif(typeof this.prototype.ViewModel === \"function\") {\n\t\t\t\t\t\tthis.ViewModel = this.prototype.ViewModel;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.ViewModel = DefineMap.extend(vmName, {}, this.prototype.ViewModel);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif(protoViewModel) {\n\t\t\t\t\t\tif(typeof protoViewModel === \"function\") {\n\t\t\t\t\t\t\tif(canReflect.isObservableLike(protoViewModel.prototype) && canReflect.isMapLike(protoViewModel.prototype)) {\n\t\t\t\t\t\t\t\tthis.ViewModel = protoViewModel;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.viewModelHandler = protoViewModel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(canReflect.isObservableLike(protoViewModel) && canReflect.isMapLike(protoViewModel)) {\n\t\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\t\t\tcanLog.warn(\"can-component: \"+this.prototype.tag+\" is sharing a single map across all component instances\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\t\tthis.viewModelInstance = protoViewModel;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcanLog.warn(\"can-component: \"+this.prototype.tag+\" is extending the viewModel into a can-simple-map\");\n\t\t\t\t\t\t\t\tthis.ViewModel = SimpleMap.extend(vmName,{},protoViewModel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.ViewModel = SimpleMap.extend(vmName,{},{});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Convert the template into a renderer function.\n\t\t\t\tif (this.prototype.template) {\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tcanLog.warn('can-component.prototype.template: is deprecated and will be removed in a future release. Use can-component.prototype.view');\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tthis.view = this.prototype.template;\n\t\t\t\t}\n\t\t\t\tif (this.prototype.view) {\n\t\t\t\t\tthis.view = this.prototype.view;\n\t\t\t\t}\n\n\t\t\t\t// default to stache if renderer is a string\n\t\t\t\tif (typeof this.view === \"string\") {\n\t\t\t\t\tvar viewName = string.capitalize( string.camelize(this.prototype.tag) )+\"View\";\n\t\t\t\t\tthis.view = stache(viewName, this.view);\n\t\t\t\t}\n\n\t\t\t\t// TODO: Remove in next release.\n\t\t\t\tthis.renderer = this.view;\n\n\t\t\t\tvar renderComponent = function(el, tagData) {\n\t\t\t\t\t// Check if a symbol already exists on the element; if it does, then\n\t\t\t\t\t// a new instance of the component has already been created\n\t\t\t\t\tif (el[createdByCanComponentSymbol] === undefined) {\n\t\t\t\t\t\tnew self(el, tagData);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tObject.defineProperty(renderComponent, \"name\",{\n\t\t\t\t\t\tvalue: \"render <\"+this.prototype.tag+\">\",\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\t\t\t\t\trenderComponent = queues.runAsTask(renderComponent, function(el, tagData) {\n\t\t\t\t\t\treturn [\"Rendering\", el, \"with\",tagData.scope];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\t// Register this component to be created when its `tag` is found.\n\t\t\t\tviewCallbacks.tag(this.prototype.tag, renderComponent);\n\t\t\t}\n\t\t}\n\t}, {\n\t\t// ## Prototype\n\t\t// ### setup\n\t\t// When a new component instance is created, setup bindings, render the view, etc.\n\t\tsetup: function(el, componentTagData) {\n\t\t\t// Save arguments so if this component gets re-inserted,\n\t\t\t// we can setup again.\n\t\t\tthis._initialArgs = [el,componentTagData];\n\n\t\t\tvar component = this;\n\n\t\t\tvar options = {\n\t\t\t\thelpers: {},\n\t\t\t\ttags: {}\n\t\t\t};\n\n\t\t\t// #### Clean up arguments\n\n\t\t\t// If componentTagData isnâ€™t defined, check for el and use it if itâ€™s defined;\n\t\t\t// otherwise, an empty object is needed for componentTagData.\n\t\t\tif (componentTagData === undefined) {\n\t\t\t\tif (el === undefined) {\n\t\t\t\t\tcomponentTagData = {};\n\t\t\t\t} else {\n\t\t\t\t\tcomponentTagData = el;\n\t\t\t\t\tel = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create an element if it doesnâ€™t exist and make it available outside of this\n\t\t\tif (el === undefined) {\n\t\t\t\tel = DOCUMENT().createElement(this.tag);\n\t\t\t\tel[createdByCanComponentSymbol] = true;\n\t\t\t}\n\t\t\tthis.element = el;\n\n\t\t\tif(componentTagData.initializeBindings === false && !this._skippedSetup) {\n\t\t\t\t// Temporary, will be overridden.\n\t\t\t\tthis._skippedSetup = this._torndown = true;\n\t\t\t\tthis.viewModel = Object.create(null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar componentContent = componentTagData.content;\n\t\t\tif (componentContent !== undefined) {\n\t\t\t\t// Check if itâ€™s already a renderer function or\n\t\t\t\t// a string that needs to be parsed by stache\n\t\t\t\tif (typeof componentContent === \"function\") {\n\t\t\t\t\tcomponentTagData.subtemplate = componentContent;\n\t\t\t\t} else if (typeof componentContent === \"string\") {\n\t\t\t\t\tcomponentTagData.subtemplate = stache(componentContent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar componentScope = componentTagData.scope;\n\t\t\tif (componentScope !== undefined && componentScope instanceof Scope === false) {\n\t\t\t\tcomponentTagData.scope = new Scope(componentScope);\n\t\t\t}\n\n\t\t\t// Hook up any templates with which the component was instantiated\n\t\t\tvar componentTemplates = componentTagData.templates;\n\t\t\tif (componentTemplates !== undefined) {\n\t\t\t\tcanReflect.eachKey(componentTemplates, function(template, name) {\n\t\t\t\t\t// Check if itâ€™s a string that needs to be parsed by stache\n\t\t\t\t\tif (typeof template === \"string\") {\n\t\t\t\t\t\tvar debugName = name + \" template\";\n\t\t\t\t\t\tcomponentTemplates[name] = stache(debugName, template);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// #### Setup ViewModel\n\t\t\tvar viewModel;\n\t\t\tvar initialViewModelData = {};\n\n\t\t\tvar preventDataBindings = domData.get(el, \"preventDataBindings\");\n\n\t\t\tvar teardownBindings;\n\t\t\tif (preventDataBindings) {\n\t\t\t\tviewModel = el[viewModelSymbol];\n\t\t\t} else {\n\t\t\t\t// Set up the bindings\n\t\t\t\tvar setupFn;\n\t\t\t\tif (componentTagData.setupBindings) {\n\t\t\t\t\tsetupFn = function(el, componentTagData, callback, initialViewModelData){\n\t\t\t\t\t\treturn componentTagData.setupBindings(el, callback, initialViewModelData);\n\t\t\t\t\t};\n\t\t\t\t} else if (componentTagData.viewModel) {\n\t\t\t\t\t// Component is being instantiated with a viewModel\n\t\t\t\t\tsetupFn = getSetupFunctionForComponentVM(componentTagData.viewModel);\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tsetupFn = queues.runAsTask(setupFn, function(el, componentTagData) {\n\t\t\t\t\t\t\treturn [\"Constructing\", el, \"with viewModel\",componentTagData.viewModel];\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t} else {\n\t\t\t\t\tsetupFn = stacheBindings.behaviors.viewModel;\n\t\t\t\t}\n\n\n\t\t\t\tteardownBindings = setupFn(el, componentTagData, function(initialViewModelData) {\n\n\t\t\t\t\tvar ViewModel = component.constructor.ViewModel,\n\t\t\t\t\t\tviewModelHandler = component.constructor.viewModelHandler,\n\t\t\t\t\t\tviewModelInstance = component.constructor.viewModelInstance;\n\n\t\t\t\t\tif(viewModelHandler) {\n\t\t\t\t\t\tvar scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);\n\t\t\t\t\t\tif (canReflect.isObservableLike(scopeResult) && canReflect.isMapLike(scopeResult) ) {\n\t\t\t\t\t\t\t// If the function returns a can.Map, use that as the viewModel\n\t\t\t\t\t\t\tviewModelInstance = scopeResult;\n\t\t\t\t\t\t} else if (canReflect.isObservableLike(scopeResult.prototype) && canReflect.isMapLike(scopeResult.prototype)) {\n\t\t\t\t\t\t\t// If `scopeResult` is of a `can.Map` type, use it to wrap the `initialViewModelData`\n\t\t\t\t\t\t\tViewModel = scopeResult;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise extend `SimpleMap` with the `scopeResult` and initialize it with the `initialViewModelData`\n\t\t\t\t\t\t\tViewModel = SimpleMap.extend(scopeResult);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(ViewModel) {\n\t\t\t\t\t\tviewModelInstance = new ViewModel(initialViewModelData);\n\t\t\t\t\t}\n\t\t\t\t\tviewModel = viewModelInstance;\n\t\t\t\t\treturn viewModelInstance;\n\t\t\t\t}, initialViewModelData);\n\t\t\t}\n\n\t\t\t// Set `viewModel` to `this.viewModel` and set it to the element's `data` object as a `viewModel` property\n\t\t\tthis.viewModel = viewModel;\n\t\t\tel[viewModelSymbol] = viewModel;\n\t\t\tel.viewModel = viewModel;\n\t\t\tdomData.set(el, \"preventDataBindings\", true);\n\n\t\t\t// TEARDOWN SETUP\n\t\t\tvar removedDisposal,\n\t\t\t\tconnectedDisposal,\n\t\t\t\tviewModelDisconnectedCallback;\n\t\t\tfunction teardownComponent(){\n\t\t\t\tif(removedDisposal) {\n\t\t\t\t\tremovedDisposal();\n\t\t\t\t\tremovedDisposal = null;\n\t\t\t\t}\n\t\t\t\tcomponent._torndown = true;\n\t\t\t\tdomEvents.dispatch(el, \"beforeremove\", false);\n\t\t\t\tif(teardownBindings) {\n\t\t\t\t\tteardownBindings();\n\t\t\t\t}\n\t\t\t\tif(viewModelDisconnectedCallback) {\n\t\t\t\t\tviewModelDisconnectedCallback(el);\n\t\t\t\t} else if(typeof viewModel.stopListening === \"function\"){\n\t\t\t\t\tviewModel.stopListening();\n\t\t\t\t}\n\t\t\t\tif(connectedDisposal) {\n\t\t\t\t\tconnectedDisposal();\n\t\t\t\t\tconnectedDisposal = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// #### Helpers\n\t\t\t// TODO: remove in next release\n\t\t\t// Setup helpers to callback with `this` as the component\n\t\t\tif(this.helpers !== undefined) {\n\t\t\t\tcanReflect.eachKey(this.helpers, function(val, prop) {\n\t\t\t\t\tif (typeof val === \"function\") {\n\t\t\t\t\t\toptions.helpers[prop] = val.bind(viewModel);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// #### `events` control\n\t\t\t// TODO: remove in next release\n\t\t\t// Create a control to listen to events\n\t\t\tif(this.constructor.Control) {\n\t\t\t\tthis._control = new this.constructor.Control(el, {\n\t\t\t\t\t// Pass the viewModel to the control so we can listen to it's changes from the controller.\n\t\t\t\t\tscope: this.viewModel,\n\t\t\t\t\tviewModel: this.viewModel\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tremovedDisposal = domMutate.onNodeRemoved(el, function () {\n\t\t\t\tvar doc = el.ownerDocument;\n\t\t\t\tvar rootNode = doc.contains ? doc : doc.documentElement;\n\t\t\t\tif (!rootNode || !rootNode.contains(el)) {\n\t\t\t\t\tteardownComponent();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// #### Rendering\n\n\t\t\tvar leakScope = {\n\t\t\t\ttoLightContent: this.leakScope === true,\n\t\t\t\tintoShadowContent: this.leakScope === true\n\t\t\t};\n\n\t\t\tvar hasShadowView = !!(this.constructor.view);\n\t\t\tvar shadowFragment;\n\n\t\t\t// Get what we should render between the component tags\n\t\t\t// and the data for it.\n\t\t\tvar betweenTagsView;\n\t\t\tvar betweenTagsTagData;\n\t\t\tif( hasShadowView ) {\n\t\t\t\tvar shadowTagData;\n\t\t\t\tif (leakScope.intoShadowContent) {\n\t\t\t\t\t// Give access to the component's data and the VM\n\t\t\t\t\tshadowTagData = {\n\t\t\t\t\t\tscope: componentTagData.scope.add(this.viewModel, { viewModel: true }),\n\t\t\t\t\t\toptions: options\n\t\t\t\t\t};\n\n\t\t\t\t} else { // lexical\n\t\t\t\t\t// only give access to the VM\n\t\t\t\t\tshadowTagData = {\n\t\t\t\t\t\tscope: new Scope(this.viewModel, null, { viewModel: true }),\n\t\t\t\t\t\toptions: options\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Add a hookup for each <can-slot>\n\t\t\t\toptions.tags['can-slot'] = makeReplacementTagCallback('can-slot', componentTagData, shadowTagData, leakScope, function(el) {\n\t\t\t\t\tvar templates = componentTagData.templates;\n\t\t\t\t\tif (templates) {// This is undefined if the component is <self-closing/>\n\t\t\t\t\t\treturn templates[el.getAttribute(\"name\")];\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Add a hookup for <content>\n\t\t\t\toptions.tags.content = makeReplacementTagCallback('content',  componentTagData, shadowTagData, leakScope, function() {\n\t\t\t\t\treturn componentTagData.subtemplate;\n\t\t\t\t});\n\n\t\t\t\tbetweenTagsView = this.constructor.view;\n\t\t\t\tbetweenTagsTagData = shadowTagData;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No shadow template.\n\t\t\t\t// Render light template with viewModel on top\n\t\t\t\tvar lightTemplateTagData = {\n\t\t\t\t\tscope: componentTagData.scope.add(this.viewModel, {\n\t\t\t\t\t\tviewModel: true\n\t\t\t\t\t}),\n\t\t\t\t\toptions: options\n\t\t\t\t};\n\t\t\t\tbetweenTagsTagData = lightTemplateTagData;\n\t\t\t\tbetweenTagsView = componentTagData.subtemplate || el.ownerDocument.createDocumentFragment.bind(el.ownerDocument);\n\t\t\t}\n\n\n\n\n\t\t\t// Keep a nodeList so we can kill any directly nested nodeLists within this component\n\n\n\n\t\t\tshadowFragment = betweenTagsView(betweenTagsTagData.scope, betweenTagsTagData.options);\n\n\t\t\t// TODO: afterRender\n\n\t\t\t// Append the resulting document fragment to the element\n\t\t\tdomMutateNode.appendChild.call(el, shadowFragment);\n\n\t\t\t// Call connectedCallback\n\t\t\tif(viewModel && viewModel.connectedCallback) {\n\t\t\t\tvar body = DOCUMENT().body;\n\t\t\t\tvar componentInPage = body && body.contains(el);\n\n\t\t\t\tif(componentInPage) {\n\t\t\t\t\tviewModelDisconnectedCallback = viewModel.connectedCallback(el);\n\t\t\t\t} else {\n\t\t\t\t\tconnectedDisposal = domMutate.onNodeConnected(el, function () {\n\t\t\t\t\t\tconnectedDisposal();\n\t\t\t\t\t\tconnectedDisposal = null;\n\t\t\t\t\t\tviewModelDisconnectedCallback = viewModel.connectedCallback(el);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tcomponent._torndown = false;\n\t\t}\n\t});\n\n// This adds support for components being rendered as values in stache templates\nComponent.prototype[viewInsertSymbol] = function(viewData) {\n\tif(this._torndown) {\n\t\tthis.setup.apply(this,this._initialArgs);\n\t}\n\treturn this.element;\n};\n\nmodule.exports = namespace.Component = Component;\n\n\n//# sourceURL=webpack:///./node_modules/can-component/can-component.js?");

/***/ }),

/***/ "./node_modules/can-component/control/control.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-component/control/control.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Control = __webpack_require__(/*! can-control */ \"./node_modules/can-control/can-control.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\n// ## Helpers\n// Attribute names to ignore for setting viewModel values.\nvar paramReplacer = /\\{([^\\}]+)\\}/g;\n\nvar ComponentControl = Control.extend({\n\t\t// the lookup path - where templated keys will be looked up\n\t\t// change lookup to first look in the viewModel\n\t\t_lookup: function(options) {\n\t\t\treturn [options.scope, options, window];\n\t\t},\n\t\t// strip strings that represent delegates from the key\n\t\t// viewModel.foo -> foo\n\t\t_removeDelegateFromKey: function (key) {\n\t\t\treturn key.replace(/^(scope|^viewModel)\\./, \"\");\n\t\t},\n\t\t// return whether the key is a delegate\n\t\t_isDelegate: function(options, key) {\n\t\t\treturn key === 'scope' || key === 'viewModel';\n\t\t},\n\t\t// return the delegate object for a given key\n\t\t_getDelegate: function(options, key) {\n\t\t\treturn options[key];\n\t\t},\n\t\t_action: function(methodName, options, controlInstance) {\n\t\t\tvar hasObjectLookup;\n\n\t\t\tparamReplacer.lastIndex = 0;\n\n\t\t\thasObjectLookup = paramReplacer.test(methodName);\n\n\t\t\t// If we don't have options (a `control` instance), we'll run this later.\n\t\t\tif (!controlInstance && hasObjectLookup) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\treturn Control._action.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t},\n\t// Extend `events` with a setup method that listens to changes in `viewModel` and\n\t// rebinds all templated event handlers.\n\t{\n\t\tsetup: function(el, options) {\n\t\t\tthis.scope = options.scope;\n\t\t\tthis.viewModel = options.viewModel;\n\t\t\treturn Control.prototype.setup.call(this, el, options);\n\t\t},\n\t\toff: function() {\n\t\t\t// If `this._bindings` exists we need to go through it's `readyComputes` and manually\n\t\t\t// unbind `change` event listeners set by the controller.\n\t\t\tif (this._bindings) {\n\t\t\t\tcanReflect.eachKey(this._bindings.readyComputes || {}, function(value) {\n\t\t\t\t\tcanReflect.offValue(value.compute, value.handler);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Call `Control.prototype.off` function on this instance to cleanup the bindings.\n\t\t\tControl.prototype.off.apply(this, arguments);\n\t\t\tthis._bindings.readyComputes = {};\n\t\t},\n\t\tdestroy: function() {\n\t\t\tif (typeof this.options.destroy === 'function') {\n\t\t\t\tthis.options.destroy.apply(this, arguments);\n\t\t\t}\n\t\t\tControl.prototype.destroy.apply(this, arguments);\n\n\t\t}\n\t});\n\nmodule.exports = ComponentControl;\n\n\n//# sourceURL=webpack:///./node_modules/can-component/control/control.js?");

/***/ }),

/***/ "./node_modules/can-compute/can-compute.js":
/*!*************************************************!*\
  !*** ./node_modules/can-compute/can-compute.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint maxdepth:7*/\n\n// # can.compute\n//\n// `can.compute` allows the creation of observable values in different forms.\n// This module is now just a facade around [proto_compute.js](proto_compute.html).\n// `proto_compute.js` provides `can.Compute` as a constructor function where this file,\n// `compute.js` wraps an instance of a `can.Compute` with a function.\n//\n// Other files:\n// - [get_value_and_bind.js](get_value_and_bind.js) provides the low-level utility for observing functions.\n// - [read.js](read.html) provides a helper that read properties and values in an observable way.\n\n\n\nvar Compute = __webpack_require__(/*! ./proto-compute */ \"./node_modules/can-compute/proto-compute.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar singleReference = __webpack_require__(/*! can-single-reference */ \"./node_modules/can-single-reference/can-single-reference.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect/reflections/get-set/get-set */ \"./node_modules/can-reflect/reflections/get-set/get-set.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canOnValueSymbol = canSymbol.for(\"can.onValue\"),\n\tcanOffValueSymbol = canSymbol.for(\"can.offValue\"),\n\tcanGetValue = canSymbol.for(\"can.getValue\"),\n\tcanSetValue = canSymbol.for(\"can.setValue\"),\n\tisValueLike = canSymbol.for(\"can.isValueLike\"),\n\tisMapLike = canSymbol.for(\"can.isMapLike\"),\n\tisListLike = canSymbol.for(\"can.isListLike\"),\n\tisFunctionLike = canSymbol.for(\"can.isFunctionLike\"),\n\tcanValueHasDependencies = canSymbol.for(\"can.valueHasDependencies\"),\n\tcanGetValueDependencies = canSymbol.for(\"can.getValueDependencies\");\n\n// The `can.compute` generator function.\nvar addEventListener = function(ev, handler){\n\tvar compute = this;\n\tvar translationHandler;\n\tif(handler){\n\t\ttranslationHandler = function() {\n\t\t   handler.apply(compute, arguments);\n\t   };\n\t   singleReference.set(handler, this, translationHandler);\n\t}\n\treturn compute.computeInstance.addEventListener(ev, translationHandler);\n};\n\nvar removeEventListener = function(ev, handler){\n\t\tvar args = [];\n\t\tif (typeof ev !== 'undefined') {\n\t\t\targs.push(ev);\n\t\t\tif (typeof handler !== 'undefined') {\n\t\t\t\targs.push(singleReference.getAndDelete(handler, this));\n\t\t\t}\n\t\t}\n\t\treturn this.computeInstance.removeEventListener.apply(this.computeInstance, args);\n};\nvar onValue = function(handler, queue){\n\t\treturn this.computeInstance[canOnValueSymbol](handler, queue);\n\t},\n\toffValue = function(handler, queue){\n\t\treturn this.computeInstance[canOffValueSymbol](handler, queue);\n\t},\n\tgetValue = function(){\n\t\treturn this.computeInstance.get();\n\t},\n\tsetValue = function(value){\n\t\treturn this.computeInstance.set(value);\n\t},\n\thasDependencies = function(){\n\t\treturn this.computeInstance.hasDependencies;\n\t},\n\tgetDependencies = function() {\n\t\treturn this.computeInstance[canGetValueDependencies]();\n\t};\n\n\nvar COMPUTE = function (getterSetter, context, eventName, bindOnce) {\n\n\tfunction compute(val) {\n\t\tif(arguments.length) {\n\t\t\treturn compute.computeInstance.set(val);\n\t\t}\n\n\t\treturn compute.computeInstance.get();\n\t}\n\n\t// Create an internal `can.Compute`.\n\tcompute.computeInstance = new Compute(getterSetter, context, eventName, bindOnce);\n\n\tcompute.on = compute.bind = compute.addEventListener = addEventListener;\n\tcompute.off = compute.unbind = compute.removeEventListener = removeEventListener;\n\tcompute.isComputed = compute.computeInstance.isComputed;\n\n\tcompute.clone = function(ctx) {\n\t\tif(typeof getterSetter === 'function') {\n\t\t\tcontext = ctx;\n\t\t}\n\t\treturn COMPUTE(getterSetter, context, ctx, bindOnce);\n\t};\n\n\t// forward on and off to the computeInstance as this doesn't matter\n\tcanReflect.set(compute, canOnValueSymbol, onValue);\n\tcanReflect.set(compute, canOffValueSymbol, offValue);\n\tcanReflect.set(compute, canGetValue, getValue);\n\tcanReflect.set(compute, canSetValue, setValue);\n\tcanReflect.set(compute, isValueLike, true);\n\tcanReflect.set(compute, isMapLike, false);\n\tcanReflect.set(compute, isListLike, false);\n\tcanReflect.set(compute, isFunctionLike, false);\n\tcanReflect.set(compute, canValueHasDependencies, hasDependencies);\n\tcanReflect.set(compute, canGetValueDependencies, getDependencies);\n\treturn compute;\n};\n\n// ## Helpers\n\n// ### truthy\n// Wraps a compute with another compute that only changes when\n// the wrapped compute's `truthiness` changes.\nCOMPUTE.truthy = function (compute) {\n\treturn COMPUTE(function () {\n\t\tvar res = compute();\n\t\treturn !!res;\n\t});\n};\n\n// ### async\n// A simple helper that makes an async compute a bit easier.\nCOMPUTE.async = function(initialValue, asyncComputer, context){\n\treturn COMPUTE(initialValue, {\n\t\tfn: asyncComputer,\n\t\tcontext: context\n\t});\n};\n\n// ### compatability\n// Setting methods that should not be around in 3.0.\nCOMPUTE.temporarilyBind = Compute.temporarilyBind;\n\nmodule.exports = namespace.compute = COMPUTE;\n\n\n//# sourceURL=webpack:///./node_modules/can-compute/can-compute.js?");

/***/ }),

/***/ "./node_modules/can-compute/proto-compute.js":
/*!***************************************************!*\
  !*** ./node_modules/can-compute/proto-compute.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # can/compute/proto_compute (aka can.Compute)\n//\n// Allows the creation of observablue values. This\n// is a prototype based version of [can.compute](compute.html).\n//\n// can.Computes come in different flavors:\n//\n// - [Getter / Setter functional computes](#setup-getter-setter-functional-computes).\n// - [Property computes](#setup-property-computes).\n// - [Setter computes](#setup-setter-computes).\n// - [Async computes](#setup-async-computes).\n// - [Settings computes](#setup-settings-computes).\n// - [Simple value computes](#setup-simple-value-computes).\n//\n//\n// can.Computes have public `.get`, `.set`, `.on`, and `.off` methods that call\n// internal methods that are configured differently depending on what flavor of\n// compute is being created.  Those methods are:\n//\n// - `_on(updater)` - Called the first time the compute is bound. This should bind to\n//    any source observables.  When any of the source observables have changed, it should call\n//    `updater(newVal, oldVal, batchNum)`.\n//\n// - `_off(updater)` - Called when the compute has no more event handlers.  This should unbind to any source observables.\n// - `_get` - Called to get the current value of the compute.\n// - `_set` - Called to set the value of the compute.\n//\n//\n//\n// Other internal flags and values:\n// - `value` - the cached value\n// - `_setUpdates` - if calling `_set` will have updated the cached value itself so `_get` does not need to be called.\n// - `_canObserve` - if this compute can be observed.\n// - `hasDependencies` - if this compute has source observable values.\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar eventQueue = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar observeReader = __webpack_require__(/*! can-stache-key */ \"./node_modules/can-stache-key/can-stache-key.js\");\nvar getObject = __webpack_require__(/*! can-key/get/get */ \"./node_modules/can-key/get/get.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar singleReference = __webpack_require__(/*! can-single-reference */ \"./node_modules/can-single-reference/can-single-reference.js\");\n\n// ## can.Compute\n// Checks the arguments and calls different setup methods.\nvar Compute = function(getterSetter, context, eventName, bindOnce) {\n\tvar args = [];\n\n\tfor(var i = 0, arglen = arguments.length; i < arglen; i++) {\n\t\targs[i] = arguments[i];\n\t}\n\n\tvar contextType = typeof args[1];\n\n\tif (typeof args[0] === 'function') {\n\t\t// Getter/Setter functional computes.\n\t\t// `new can.Compute(function(){ ... })`\n\t\tthis._setupGetterSetterFn(args[0], args[1], args[2], args[3]);\n\t} else if (args[1] !== undefined) {\n\t\tif (contextType === 'string' || contextType === 'number') {\n\t\t\t// Property computes.\n\t\t\t// `new can.Compute(object, propertyName[, eventName])`\n\t\t\tvar isListLike = canReflect.isObservableLike(args[0]) && canReflect.isListLike(args[0]);\n\t\t\tvar isMapLike = canReflect.isObservableLike(args[0]) && canReflect.isMapLike(args[0]);\n\t\t\tif(isMapLike || isListLike) {\n\t\t\t\tvar map = args[0];\n\t\t\t\tvar propertyName = args[1];\n\t\t\t\tvar mapGetterSetter = function(newValue){\n\t\t\t\t\tif(arguments.length) {\n\t\t\t\t\t\tobserveReader.set(map,propertyName, newValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// forces length to be read\n\t\t\t\t\t\tif(isListLike) {\n\t\t\t\t\t\t\tobserveReader.get(map,\"length\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn observeReader.get(map,\"\"+propertyName);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis._setupGetterSetterFn(mapGetterSetter, args[1], args[2], args[3]);\n\t\t\t} else {\n\t\t\t\tthis._setupProperty(args[0], args[1], args[2]);\n\t\t\t}\n\n\t\t} else if(contextType === 'function') {\n\t\t\t// Setter computes.\n\t\t\t// `new can.Compute(initialValue, function(newValue){ ... })`\n\t\t\tthis._setupSetter(args[0], args[1], args[2]);\n\t\t} else {\n\n\t\t\tif(args[1] && args[1].fn) {\n\t\t\t\t// Async computes.\n\t\t\t\tthis._setupAsyncCompute(args[0], args[1]);\n\t\t\t} else {\n\t\t\t\t// Settings computes.\n\t\t\t\t//`new can.Compute(initialValue, {on, off, get, set})`\n\t\t\t\tthis._setupSettings(args[0], args[1]);\n\t\t\t}\n\n\t\t}\n\t} else {\n\t\t// Simple value computes.\n\t\t// `new can.Compute(initialValue)`\n\t\tthis._setupSimpleValue(args[0]);\n\t}\n\n\tthis._args = args;\n\tthis._primaryDepth = 0;\n\n\tthis.isComputed = true;\n\n};\n\n// ## Helpers\n\n// ## updateOnChange\n// A helper to trigger an event when a value changes\nvar updateOnChange = function(compute, newValue, oldValue, batchNum){\n\n\tvar valueChanged = newValue !== oldValue && !(newValue !== newValue && oldValue !== oldValue);\n\t// Only trigger event when value has changed\n\tif (valueChanged) {\n\t\tcompute.dispatch({type: \"change\", batchNum: batchNum}, [\n\t\t\tnewValue,\n\t\t\toldValue\n\t\t]);\n\t}\n};\n\n// ### setupComputeHandlers\n// A helper that creates an `_on` and `_off` function that\n// will bind on source observables and update the value of the compute.\nvar setupComputeHandlers = function(compute, func, context) {\n\tvar observation = new Observation(func, context, compute);\n\tvar updater = compute.updater.bind(compute);\n\t//!steal-remove-start\n\tif(true) {\n\t\tObject.defineProperty(updater,\"name\",{\n\t\t\tvalue: canReflect.getName(compute) + \".updater\",\n\t\t});\n\t}\n\t//!steal-remove-end\n\tcompute.observation = observation;\n\treturn {\n\t\t// Call `onchanged` when any source observables change.\n\t\t_on: function() {\n\t\t\tcanReflect.onValue( observation, updater,\"notify\");\n\t\t\tif (observation.hasOwnProperty(\"_value\")) {// can-observation 4.1+\n\t\t\t\tcompute.value = observation._value;\n\t\t\t} else {// can-observation < 4.1\n\t\t\t\tcompute.value = observation.value;\n\t\t\t}\n\t\t},\n\t\t// Unbind `onchanged` from all source observables.\n\t\t_off: function() {\n\t\t\tcanReflect.offValue( observation, updater,\"notify\");\n\t\t},\n\t\tgetDepth: function() {\n\t\t\treturn observation.getDepth();\n\t\t}\n\t};\n};\neventQueue(Compute.prototype);\nassign(Compute.prototype, {\n\tsetPrimaryDepth: function(depth) {\n\t\tthis._primaryDepth = depth;\n\t},\n\n\t// ## Setup getter / setter functional computes\n\t// Uses the function as both a getter and setter.\n\t_setupGetterSetterFn: function(getterSetter, context, eventName) {\n\t\tthis._set = context ? getterSetter.bind(context) : getterSetter;\n\t\tthis._get = context ? getterSetter.bind(context) : getterSetter;\n\t\tthis._canObserve = eventName === false ? false : true;\n\t\t// The helper provides the on and off methods that use `getValueAndBind`.\n\t\tvar handlers = setupComputeHandlers(this, getterSetter, context || this);\n\n\t\tassign(this, handlers);\n\t},\n\t// ## Setup property computes\n\t// Listen to a property changing on an object.\n\t_setupProperty: function(target, propertyName, eventName) {\n\t\tvar self = this,\n\t\t\thandler;\n\n\n\t\t// This is objects that can be bound to with can.bind.\n\t\thandler = function () {\n\t\t\tself.updater(self._get(), self.value);\n\t\t};\n\t\tthis._get = function() {\n\t\t\treturn getObject(target, propertyName);\n\t\t};\n\t\tthis._set = function(value) {\n\t\t\t// allow setting properties n levels deep, if separated with dot syntax\n\t\t\tvar properties = propertyName.split(\".\"),\n\t\t\t\tleafPropertyName = properties.pop();\n\n\t\t\tif(properties.length) {\n\t\t\t\tvar targetProperty = getObject(target, properties.join('.'));\n\t\t\t\ttargetProperty[leafPropertyName] = value;\n\t\t\t} else {\n\t\t\t\ttarget[propertyName] = value;\n\t\t\t}\n\t\t};\n\n\t\tthis._on = function(update) {\n\t\t\teventQueue.on.call(target, eventName || propertyName, handler);\n\t\t\t// Set the cached value\n\t\t\tthis.value = this._get();\n\t\t};\n\t\tthis._off = function() {\n\t\t\treturn eventQueue.off.call( target, eventName || propertyName, handler);\n\t\t};\n\t},\n\t// ## Setup Setter Computes\n\t// Only a setter function is specified.\n\t_setupSetter: function(initialValue, setter, eventName) {\n\t\tthis.value = initialValue;\n\t\tthis._set = setter;\n\t\tassign(this, eventName);\n\t},\n\t// ## Setup settings computes\n\t// Use whatever `on`, `off`, `get`, `set` the users provided\n\t// as the internal methods.\n\t_setupSettings: function(initialValue, settings) {\n\n\t\tthis.value = initialValue;\n\n\t\tthis._set = settings.set || this._set;\n\t\tthis._get = settings.get || this._get;\n\n\t\t// This allows updater to be called without any arguments.\n\t\t// selfUpdater flag can be set by things that want to call updater themselves.\n\t\tif(!settings.__selfUpdater) {\n\t\t\tvar self = this,\n\t\t\t\toldUpdater = this.updater;\n\t\t\tthis.updater = function() {\n\t\t\t\toldUpdater.call(self, self._get(), self.value);\n\t\t\t};\n\t\t}\n\n\n\t\tthis._on = settings.on ? settings.on : this._on;\n\t\tthis._off = settings.off ? settings.off : this._off;\n\t},\n\t// ## Setup async computes\n\t// This is a special, non-documented form of a compute\n\t// rhat can asynchronously update its value.\n\t_setupAsyncCompute: function(initialValue, settings){\n\t\tvar self = this;\n\t\t// This is the async getter function.  Depending on how many arguments the function takes,\n\t\t// we setup bindings differently.\n\t\tvar getter = settings.fn;\n\t\tvar bindings;\n\n\t\tthis.value = initialValue;\n\n\t\t// This compute will call update with the new value itself.\n\t\tthis._setUpdates = true;\n\n\t\t// An \"async\" compute has a `lastSetValue` that represents\n\t\t// the last value `compute.set` was called with.\n\t\t// The following creates `lastSetValue` as a can.Compute so when\n\t\t//  `lastSetValue` is changed, the `getter` can see that change\n\t\t// and automatically update itself.\n\t\tthis.lastSetValue = new Compute(initialValue);\n\n\t\t// Wires up setting this compute to set `lastSetValue`.\n\t\t// If the new value matches the last setValue, do nothing.\n\t\tthis._set = function(newVal){\n\t\t\tif(newVal === self.lastSetValue.get()) {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\treturn self.lastSetValue.set(newVal);\n\t\t};\n\n\t\t// Wire up the get to pass the lastNewValue\n\t\tthis._get = function() {\n\t\t\treturn getter.call(settings.context, self.lastSetValue.get() );\n\t\t};\n\n\t\tif(getter.length === 0) {\n\t\t\t// If it takes no arguments, it should behave just like a Getter compute.\n\t\t\tbindings = setupComputeHandlers(this, getter, settings.context);\n\t\t} else if(getter.length === 1) {\n\t\t\t// If it has a single argument, pass it the last setValue.\n\t\t\tbindings = setupComputeHandlers(this, function() {\n\t\t\t\treturn getter.call(settings.context, self.lastSetValue.get() );\n\t\t\t}, settings);\n\n\t\t} else {\n\t\t\t// If the function takes 2 arguments, the second argument is a function\n\t\t\t// that should update the value of the compute (`setValue`). To make this we need\n\t\t\t// the \"normal\" updater function because we are about to overwrite it.\n\t\t\tvar oldUpdater = this.updater,\n\t\t\t\tresolve = ObservationRecorder.ignore(function(newVal) {\n\t\t\t\t\toldUpdater.call(self, newVal, self.value);\n\t\t\t\t});\n\n\t\t\t// Because `setupComputeHandlers` calls `updater` internally with its\n\t\t\t// observation._value as `oldValue` and that might not be up to date,\n\t\t\t// we overwrite updater to always use self.value.\n\t\t\tthis.updater = function(newVal) {\n\t\t\t\toldUpdater.call(self, newVal, self.value);\n\t\t\t};\n\n\n\t\t\tbindings = setupComputeHandlers(this, function() {\n\t\t\t\t// Call getter, and get new value\n\t\t\t\tvar res = getter.call(settings.context, self.lastSetValue.get(), resolve);\n\t\t\t\t// If undefined is returned, don't update the value.\n\t\t\t\treturn res !== undefined ? res : this.value;\n\t\t\t}, this);\n\t\t}\n\n\t\tassign(this, bindings);\n\t},\n\t// ## Setup simple value computes\n\t// Uses the default `_get`, `_set` behaviors.\n\t_setupSimpleValue: function(initialValue) {\n\t\tthis.value = initialValue;\n\t},\n\t// ## _bindsetup\n\t// When a compute is first bound, call the internal `this._on` method.\n\t// `can.__notObserve` makes sure if `_on` is listening to any observables,\n\t// they will not be observed by any outer compute.\n\t_eventSetup: ObservationRecorder.ignore(function () {\n\t\tthis.bound = true;\n\t\tthis._on(this.updater);\n\t}),\n\t// ## _bindteardown\n\t// When a compute has no other bindings, call the internal `this._off` method.\n\t_eventTeardown: function () {\n\t\tthis._off(this.updater);\n\t\tthis.bound = false;\n\t},\n\n\t// ## clone\n\t// Copies this compute, but for a different context.\n\t// This is mostly used for computes on a map's prototype.\n\tclone: function(context) {\n\t\tif(context && typeof this._args[0] === 'function') {\n\t\t\tthis._args[1] = context;\n\t\t} else if(context) {\n\t\t\tthis._args[2] = context;\n\t\t}\n\n\t\treturn new Compute(this._args[0], this._args[1], this._args[2], this._args[3]);\n\t},\n\t// ## _on and _off\n\t// Default _on and _off do nothing.\n\t_on: function(){},\n\t_off: function(){},\n\t// ## get\n\t// Returns the cached value if `bound`, otherwise, returns\n\t// the _get value.\n\tget: function() {\n\t\t// If an external compute is tracking observables and\n\t\t// this compute can be listened to by \"function\" based computes ....\n\t\tvar recordingObservation = ObservationRecorder.isRecording();\n\t\tif(recordingObservation && this._canObserve !== false) {\n\n\t\t\t// ... tell the tracking compute to listen to change on this computed.\n\t\t\tObservationRecorder.add(this, 'change');\n\t\t\t// ... if we are not bound, we should bind so that\n\t\t\t// we don't have to re-read to get the value of this compute.\n\t\t\tif (!this.bound) {\n\t\t\t\tCompute.temporarilyBind(this);\n\t\t\t}\n\t\t}\n\t\t// If computed is bound, use the cached value.\n\t\tif (this.bound) {\n\t\t\t// if it has dependencies ... it should do some stuff ...\n\t\t\tif(this.observation) {\n\t\t\t\treturn this.observation.get();\n\t\t\t} else {\n\t\t\t\treturn this.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._get();\n\t\t}\n\t},\n\t// ## _get\n\t// Returns the cached value.\n\t_get: function() {\n\t\treturn this.value;\n\t},\n\t// ## set\n\t// Sets the value of the compute.\n\t// Depending on the type of the compute and what `_set` returns, it might need to call `_get` after\n\t// `_set` to get the final value.\n\tset: function(newVal) {\n\n\t\tvar old = this.value;\n\n\t\t// Setter may return the value if setter\n\t\t// is for a value maintained exclusively by this compute.\n\t\tvar setVal = this._set(newVal, old);\n\n\t\t// If the setter updated this.value, just return that.\n\t\tif(this._setUpdates) {\n\t\t\treturn this.value;\n\t\t}\n\n\t\t// If the computed function has dependencies,\n\t\t// we should call the getter.\n\t\tif (this.hasDependencies) {\n\t\t\treturn this._get();\n\t\t}\n\n\t\t// Setting may not fire a change event, in which case\n\t\t// the value must be read\n\t\tthis.updater(setVal === undefined ? this._get() : setVal, old);\n\n\t\treturn this.value;\n\t},\n\t// ## _set\n\t// Updates the cached value.\n\t_set: function(newVal) {\n\t\treturn this.value = newVal;\n\t},\n\t// ## updater\n\t// Updates the cached value and fires an event if the value has changed.\n\tupdater: function(newVal, oldVal, batchNum) {\n\t\tthis.value = newVal;\n\t\tvar observation = this.observation;\n\t\tif (observation) {\n\t\t\t// it's possible the observation doesn't actually\n\t\t\t// have any dependencies\n\t\t\tif (observation.hasOwnProperty(\"_value\")) {// can-observation 4.1+\n\t\t\t\tobservation._value = newVal;\n\t\t\t} else {// can-observation < 4.1\n\t\t\t\tobservation.value = newVal;\n\t\t\t}\n\t\t}\n\t\tupdateOnChange(this, newVal, oldVal, batchNum);\n\t},\n\t// ## toFunction\n\t// Returns a proxy form of this compute.\n\ttoFunction: function() {\n\t\treturn this._computeFn.bind( this);\n\t},\n\t_computeFn: function(newVal) {\n\t\tif(arguments.length) {\n\t\t\treturn this.set(newVal);\n\t\t}\n\n\t\treturn this.get();\n\t}\n});\n\nCompute.prototype.on = Compute.prototype.bind = Compute.prototype.addEventListener;\nCompute.prototype.off = Compute.prototype.unbind = Compute.prototype.removeEventListener;\n\nvar hasDependencies = function hasDependencies() {\n\treturn this.observation && this.observation.hasDependencies();\n};\nObject.defineProperty(Compute.prototype, \"hasDependencies\", {\n\tget: hasDependencies\n});\n\n// ### temporarilyBind\n// Binds computes for a moment to cache their value and prevent re-calculating it.\nCompute.temporarilyBind = Observation.temporarilyBind;\n\n// ### async\n// A simple helper that makes an async compute a bit easier.\nCompute.async = function(initialValue, asyncComputer, context){\n\treturn new Compute(initialValue, {\n\t\tfn: asyncComputer,\n\t\tcontext: context\n\t});\n};\n\n// ### truthy\n// Wraps a compute with another compute that only changes when\n// the wrapped compute's `truthiness` changes.\nCompute.truthy = function(compute) {\n\treturn new Compute(function() {\n\t\tvar res = compute.get();\n\t\tif(typeof res === 'function') {\n\t\t\tres = res.get();\n\t\t}\n\t\treturn !!res;\n\t});\n};\n\ncanReflect.assignSymbols(Compute.prototype, {\n\t\"can.isValueLike\": true,\n\t\"can.isMapLike\": false,\n\t\"can.isListLike\": false,\n\t\"can.setValue\": Compute.prototype.set,\n\t\"can.getValue\": Compute.prototype.get,\n\t\"can.valueHasDependencies\": hasDependencies,\n\t\"can.onValue\": function onValue(handler, queue) {\n\t\tfunction translationHandler(ev, newValue, oldValue) {\n\t\t\thandler(newValue, oldValue);\n\t\t}\n\t\tsingleReference.set(handler, this, translationHandler);\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tObject.defineProperty(translationHandler, \"name\", {\n\t\t\t\tvalue: canReflect.getName(handler) + \"::onValue\"\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\t\tthis.addEventListener(\"change\", translationHandler, queue);\n\t},\n\t\"can.offValue\": function offValue(handler, queue) {\n\t\tthis.removeEventListener(\n\t\t\t\"change\",\n\t\t\tsingleReference.getAndDelete(handler, this),\n\t\t\tqueue\n\t\t);\n\t},\n\t\"can.getValueDependencies\": function getValueDependencies() {\n\t\tvar ret;\n\n\t\tif (this.observation) {\n\t\t\tret = {\n\t\t\t\tvalueDependencies: new Set([this.observation])\n\t\t\t};\n\t\t}\n\n\t\treturn ret;\n\t}\n});\n\nmodule.exports = exports = Compute;\n\n\n//# sourceURL=webpack:///./node_modules/can-compute/proto-compute.js?");

/***/ }),

/***/ "./node_modules/can-connect-feathers/can-connect-feathers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/can-connect-feathers/can-connect-feathers.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = {\n\tservice: __webpack_require__(/*! ./service/service */ \"./node_modules/can-connect-feathers/service/service.js\"),\n\tsession: __webpack_require__(/*! ./session/session */ \"./node_modules/can-connect-feathers/session/session.js\")\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-connect-feathers/can-connect-feathers.js?");

/***/ }),

/***/ "./node_modules/can-connect-feathers/service/service.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-connect-feathers/service/service.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar connect = __webpack_require__(/*! can-connect */ \"./node_modules/can-connect/can-connect.js\");\n\nfunction getIdProp (Model) {\n\tvar algebraIdProp;\n\tvar algebraClause = Model.algebra && Model.algebra.clauses && Model.algebra.clauses.id;\n\tif (algebraClause) {\n\t\talgebraIdProp = Object.keys(algebraClause)[0];\n\t}\n\tif (!algebraIdProp && !Model.idProp) {\n\t\tthrow new Error('An idProp was not set in the Model for ' + Model + '. Things may not work as expected.');\n\t}\n\treturn algebraIdProp || Model.idProp;\n}\n\nmodule.exports = connect.behavior('data/feathers-service', function (base) {\n\tvar helpURL = 'https://canjs.com/doc/can-connect-feathers.html';\n\tif (!this.feathersService) {\n\t\tthrow new Error('You must provide a feathersService to the feathers-service behavior: ' + helpURL);\n\t}\n\n\tvar service = this.feathersService;\n\n\treturn {\n\t\tinit: function () {\n\t\t\tbase.init.apply(this, arguments);\n\t\t\tvar self = this;\n\t\t\t// Connect to real-time events.\n\t\t\tservice.on('created', function (message) { self.createInstance(message); });\n\t\t\tservice.on('updated', function (message) { self.updateInstance(message); });\n\t\t\tservice.on('patched', function (message) { self.updateInstance(message); });\n\t\t\tservice.on('removed', function (message) { self.destroyInstance(message); });\n\t\t},\n\n\t\tgetListData: function (params) {\n\t\t\treturn service.find({query: params});\n\t\t},\n\n\t\tgetData: function (params) {\n\t\t\tvar id = null;\n\t\t\tvar idProp = getIdProp(this);\n\t\t\tif (typeof params === 'string' || typeof params === 'number') {\n\t\t\t\tid = params;\n\t\t\t\tparams = {};\n\t\t\t} else if (params && typeof params[idProp] !== 'undefined') {\n\t\t\t\tid = params[idProp];\n\t\t\t\tdelete params[idProp];\n\t\t\t}\n\t\t\treturn service.get(id, {query: params});\n\t\t},\n\n\t\tcreateData: function (data) {\n\t\t\treturn service.create(data);\n\t\t},\n\n\t\tupdateData: function (instance) {\n\t\t\tvar idProp = getIdProp(this);\n\t\t\treturn service.update(instance[idProp], instance);\n\t\t},\n\n\t\tdestroyData: function (instance) {\n\t\t\tvar idProp = getIdProp(this);\n\t\t\treturn service.remove(instance[idProp]);\n\t\t}\n\t};\n});\n\n\n//# sourceURL=webpack:///./node_modules/can-connect-feathers/service/service.js?");

/***/ }),

/***/ "./node_modules/can-connect-feathers/session/session.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-connect-feathers/session/session.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar connect = __webpack_require__(/*! can-connect */ \"./node_modules/can-connect/can-connect.js\");\nvar errors = __webpack_require__(/*! @feathersjs/errors */ \"./node_modules/@feathersjs/errors/lib/index.js\");\nvar authAgent = __webpack_require__(/*! feathers-authentication-popups */ \"./node_modules/feathers-authentication-popups/lib/feathers-authentication-popups.js\").authAgent;\nvar decode = __webpack_require__(/*! jwt-decode */ \"./node_modules/jwt-decode/lib/index.js\");\nvar payloadIsValid = __webpack_require__(/*! ../utils/utils */ \"./node_modules/can-connect-feathers/utils/utils.js\").payloadIsValid;\nvar hasValidToken = __webpack_require__(/*! ../utils/utils */ \"./node_modules/can-connect-feathers/utils/utils.js\").hasValidToken;\nvar convertLocalAuthData = __webpack_require__(/*! ../utils/utils */ \"./node_modules/can-connect-feathers/utils/utils.js\").convertLocalAuthData;\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar zoneStorage = __webpack_require__(/*! ./storage */ \"./node_modules/can-connect-feathers/session/storage.js\");\n\nmodule.exports = connect.behavior('data/feathers-session', function (base) {\n\tvar helpURL = 'https://canjs.com/doc/can-connect-feathers.html';\n\tvar feathersClient = this.feathersClient;\n\n\tif (!feathersClient) {\n\t\tthrow new Error('You must provide a feathersClient instance to the feathers-session behavior. See ' + helpURL);\n\t}\n\tif (!this.Map) {\n\t\tthrow new Error('You must provide a Map instance to the feathers-session behavior. See ' + helpURL);\n\t}\n\tif (!feathersClient.authentication) {\n\t\tthrow new Error('You must register the feathers-authentication-client plugin before using the feathers-session behavior. See ' + helpURL);\n\t}\n\n\tvar options = feathersClient.authentication.options;\n\tvar Session = this.Map;\n\n\tObject.defineProperty(Session, 'current', {\n\t\tget: function () {\n\t\t\tObservationRecorder.add(Session, 'current');\n\t\t\tif (zoneStorage.getItem('can-connect-feathers-session') === undefined) {\n\n\t\t\t\t// set session to `undefined` when we start authentication:\n\t\t\t\tzoneStorage.removeItem('can-connect-feathers-session');\n\n\t\t\t\tSession.get().then(function (session) {\n\t\t\t\t\tzoneStorage.setItem('can-connect-feathers-session', session);\n\t\t\t\t\tSession.dispatch('current', [session]);\n\t\t\t\t})\n\t\t\t\t.catch(function (error) {\n\n\t\t\t\t\t// set session to `null` since we know that user is non-authenticated:\n\t\t\t\t\tzoneStorage.setItem('can-connect-feathers-session', null);\n\t\t\t\t\tSession.dispatch('current', [null]);\n\n\t\t\t\t\tif (!error.className || error.className.indexOf('not-authenticated') < 0) {\n\t\t\t\t\t\treturn Promise.reject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn zoneStorage.getItem('can-connect-feathers-session');\n\t\t}\n\t});\n\n\tSession.on('created', function (ev, session) {\n\t\tzoneStorage.setItem('can-connect-feathers-session', session);\n\t\tSession.dispatch('current', [session]);\n\t});\n\tSession.on('destroyed', function () {\n\t\tzoneStorage.removeItem('can-connect-feathers-session');\n\t\tSession.dispatch('current', [undefined, zoneStorage.getItem('can-connect-feathers-session')]);\n\t});\n\n\treturn {\n\t\tinit: function () {\n\t\t\tbase.init.apply(this, arguments);\n\t\t\tvar connection = this;\n\t\t\t// Listen to feathers-authentication-popups messages.\n\t\t\tauthAgent.on('login', function (token) {\n\t\t\t\ttry {\n\t\t\t\t\tvar payload = decode(token);\n\t\t\t\t\tif (!payloadIsValid(payload)) {\n\t\t\t\t\t\tthrow new Error('invalid token');\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new Error('An invalid token was received through the feathers-authentication-popups authAgent');\n\t\t\t\t}\n\t\t\t\tfeathersClient.authenticate({strategy: 'jwt', accessToken: token})\n\t\t\t\t\t.then(function (data) {\n\t\t\t\t\t\tvar payload = decode(data.accessToken);\n\t\t\t\t\t\tconnection.createInstance(payload);\n\t\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\tcreateData: function (data) {\n\t\t\t/*var tokenLocation = options.storageKey || options.cookie;\n\t\t\tif(!hasValidToken(tokenLocation)) {\n\t\t\t\treturn Promise.reject(new errors.NotAuthenticated('Not Authenticated'));\n\t\t\t}*/\n\n\t\t\tvar requestData = convertLocalAuthData(data);\n\t\t\treturn feathersClient.authenticate(requestData)\n\t\t\t\t.then(function (response) {\n\t\t\t\t\tif (response.accessToken) {\n\t\t\t\t\t\tObject.assign(response, decode(response.accessToken));\n\t\t\t\t\t}\n\t\t\t\t\treturn response;\n\t\t\t\t});\n\t\t},\n\t\tgetData: function () {\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tvar tokenLocation = options.storageKey || options.cookie;\n\t\t\t\tif (hasValidToken(tokenLocation) && !window.doneSsr) {\n\t\t\t\t\tfeathersClient.authenticate()\n\t\t\t\t\t\t.then(function (data) {\n\t\t\t\t\t\t\tvar payload = decode(data.accessToken);\n\t\t\t\t\t\t\treturn resolve(payload);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(reject);\n\t\t\t\t} else {\n\t\t\t\t\treject(new errors.NotAuthenticated('Not Authenticated'));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdestroyData: function (session) {\n\t\t\treturn feathersClient.logout().then(function () {\n\t\t\t\treturn session;\n\t\t\t});\n\t\t}\n\t};\n});\n\n\n//# sourceURL=webpack:///./node_modules/can-connect-feathers/session/session.js?");

/***/ }),

/***/ "./node_modules/can-connect-feathers/session/storage.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-connect-feathers/session/storage.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = {\n  data: {},\n\n  getStore: function () {\n    if (window.doneSsr) {\n      var CanZone = window.CanZone || undefined;\n      return typeof CanZone === 'undefined' ? this.data : CanZone.current.data;\n    }\n    return this.data;\n  },\n\n  setItem: function (prop, value) {\n    var store = this.getStore();\n    store[prop] = value;\n  },\n\n  getItem: function (prop) {\n    var store = this.getStore();\n    return store[prop];\n  },\n\n  removeItem: function (prop) {\n    var store = this.getStore();\n    delete store[prop];\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-connect-feathers/session/storage.js?");

/***/ }),

/***/ "./node_modules/can-connect-feathers/utils/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-connect-feathers/utils/utils.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar decode = __webpack_require__(/*! jwt-decode */ \"./node_modules/jwt-decode/lib/index.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\n// Reads and returns the contents of a cookie with the provided name.\nfunction readCookie (name) {\n\tvar nameEQ = name + '=';\n\tvar ca = document.cookie.split(';');\n\tfor (var i = 0; i < ca.length; i++) {\n\t\tvar c = ca[i];\n\t\twhile (c.charAt(0) === ' ') {\n\t\t\tc = c.substring(1, c.length);\n\t\t}\n\t\tif (c.indexOf(nameEQ) === 0) {\n\t\t\treturn c.substring(nameEQ.length, c.length);\n\t\t}\n\t}\n\treturn null;\n}\n\n// Reads the token from a cookie, sessionStorage, or localStorage, in that order.\nfunction getStoredToken (storageLocation) {\n\tvar token = readCookie(storageLocation);\n\tif (!token && (window && window.localStorage || window.sessionStorage)) {\n\t\ttoken = window.sessionStorage.getItem(storageLocation) || window.localStorage.getItem(storageLocation);\n\t}\n\treturn token;\n}\n\n// Pass a decoded payload and it will return a boolean based on if it hasn't expired.\nfunction payloadIsValid (payload) {\n\treturn payload && payload.exp * 1000 > new Date().getTime();\n}\n\n// Gets a stored token and returns a boolean of whether it was valid.\nfunction hasValidToken (storageLocation) {\n\tvar token = getStoredToken(storageLocation);\n\tif (token) {\n\t\ttry {\n\t\t\tvar payload = decode(token);\n\t\t\treturn payloadIsValid(payload);\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction convertLocalAuthData (originalData) {\n\tvar data = assign({}, originalData);\n\tif (data && data.strategy === 'local' && data.user) {\n\t\tObject.keys(data.user).forEach(function (key) {\n\t\t\tdata[key] = data.user[key];\n\t\t});\n\t\tdelete data.user;\n\t}\n\treturn data;\n}\n\nmodule.exports = {\n\treadCookie: readCookie,\n\tgetStoredToken: getStoredToken,\n\thasValidToken: hasValidToken,\n\tpayloadIsValid: payloadIsValid,\n\tconvertLocalAuthData: convertLocalAuthData\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-connect-feathers/utils/utils.js?");

/***/ }),

/***/ "./node_modules/can-connect-ndjson/can-connect-ndjson.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-connect-ndjson/can-connect-ndjson.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global ReadableStream */\n/* exported connectNdjson */\nvar connect = __webpack_require__(/*! can-connect */ \"./node_modules/can-connect/can-connect.js\");\nvar sortedSetJSON = __webpack_require__(/*! can-connect/helpers/sorted-set-json */ \"./node_modules/can-connect/helpers/sorted-set-json.js\");\nvar ndJSONStream = __webpack_require__(/*! can-ndjson-stream */ \"./node_modules/can-ndjson-stream/can-ndjson-stream.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar connectNdjson = connect.behavior(\"data-ndjson\", function(baseConnection) {\n  //Feature detection and fallback if ReadableStream and fetch are not supported\n  try {\n    new ReadableStream();\n\t\tif(typeof window.fetch !== \"function\") {\n\t\t\tthrow new Error(\"fetch not supported\");\n\t\t}\n  } catch (err) {\n    return {};\n  }\n  return {\n    hydrateList: function(listData, set) {\n      set = set || this.listSet(listData);\n      var id = sortedSetJSON(set);\n      var list = baseConnection.hydrateList.call(this, listData, set);//instance of list constructor\n\n      if (this._getHydrateListCallbacks[id]) {\n        this._getHydrateListCallbacks[id].shift()(list);\n        if (!this._getHydrateListCallbacks[id].length){\n          delete this._getHydrateListCallbacks[id];\n        }\n      }\n      return list;\n    },\n    _getHydrateListCallbacks: {},\n    _getHydrateList: function(set, callback) {\n      var id = sortedSetJSON(set);\n      if (!this._getHydrateListCallbacks[id]) {\n        this._getHydrateListCallbacks[id] = [];\n      }\n      this._getHydrateListCallbacks[id].push(callback);\n    },\n    getListData: function(set) {\n      var fetchPromise = fetch(this.ndjson || this.url);\n      this._getHydrateList(set, function(list) {\n        function streamerr(e) {\n          canReflect.setKeyValue(list,\"isStreaming\", false);\n          canReflect.setKeyValue(list,\"streamError\", e);\n        }\n\n        fetchPromise.then(function(response) {\n          canReflect.setKeyValue(list,\"isStreaming\", true);\n          return ndJSONStream(response.body);\n        }).then(function(itemStream) {\n          var reader = itemStream.getReader();\n          reader.read().then(function read(result) {\n            if (result.done) {\n              canReflect.setKeyValue(list,\"isStreaming\", false);\n              return;\n            }\n            list.push(result.value);\n            reader.read().then(read, streamerr);\n          }, streamerr);\n        });\n      });\n\n      return fetchPromise.then(function() {\n        return {\n          data: []\n        };\n      });\n    }\n  };\n});\n\nmodule.exports = namespace.connectNdjson = connectNdjson;\n\n\n//# sourceURL=webpack:///./node_modules/can-connect-ndjson/can-connect-ndjson.js?");

/***/ }),

/***/ "./node_modules/can-connect-tag/can-connect-tag.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-connect-tag/can-connect-tag.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n\n__webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\n\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar expression = __webpack_require__(/*! can-stache/src/expression */ \"./node_modules/can-stache/src/expression.js\");\nvar viewCallbacks = __webpack_require__(/*! can-view-callbacks */ \"./node_modules/can-view-callbacks/can-view-callbacks.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\nvar each = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\").each;\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\n\nvar convertToValue = function(arg){\n\tif(typeof arg === \"function\") {\n\t\treturn convertToValue( arg() );\n\t} else {\n\t\treturn arg;\n\t}\n};\n\nfunction connectTag(tagName, connection){\n\n\tvar removeBrackets = function(value, open, close){\n\t\topen = open || \"{\";\n\t\tclose = close || \"}\";\n\n\t\tif(value[0] === open && value[value.length-1] === close) {\n\t\t\treturn value.substr(1, value.length - 2);\n\t\t}\n\t\treturn value;\n\t};\n\n\n\tviewCallbacks.tag(tagName, function(el, tagData){\n\t\tvar getList = el.getAttribute(\"getList\") || el.getAttribute(\"get-list\");\n\t\tvar getInstance = el.getAttribute(\"get\");\n\n\t\tvar attrValue = getList || getInstance;\n\t\tvar method = getList ? \"getList\" : \"get\";\n\n\t\tvar attrInfo = expression.parse('tmp(' + removeBrackets(attrValue)+\")\", {baseMethodType: \"Call\"});\n\t\t// -> {hash: {foo: 'bar', zed: 5, abc: {get: 'myValue'}}}\n\n\n\t\tvar addedToPageData = false;\n\t\tvar addToPageData = ObservationRecorder.ignore(function(set, promise){\n\t\t\tif(!addedToPageData) {\n\t\t\t\tvar root = tagData.scope.peek(\"%root\") || tagData.scope.peek(\"@root\");\n\t\t\t\tif( root && root.pageData ) {\n\t\t\t\t\tif(method === \"get\"){\n\t\t\t\t\t\tset = connection.id(set);\n\t\t\t\t\t}\n\t\t\t\t\troot.pageData(connection.name, set, promise);\n\t\t\t\t}\n\t\t\t}\n\t\t\taddedToPageData = true;\n\t\t});\n\n\t\tvar request = new Observation(function(){\n\t\t\tvar hash = {};\n\t\t\tif(typeof attrInfo.hash === \"object\") {\n\t\t\t\t// old expression data\n\t\t\t\teach(attrInfo.hash, function(val, key) {\n\t\t\t\t\tif (val && val.hasOwnProperty(\"get\")) {\n\t\t\t\t\t\thash[key] = tagData.scope.read(val.get, {}).value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thash[key] = val;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if(typeof attrInfo.hash === \"function\"){\n\t\t\t\t// new expression data\n\t\t\t\tvar getHash = attrInfo.hash(tagData.scope, tagData.options, {});\n\t\t\t\teach(getHash(), function(val, key) {\n\t\t\t\t\thash[key] = convertToValue(val);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\thash = attrInfo.argExprs.length ? canReflect.getValue(attrInfo.argExprs[0].value(tagData.scope, tagData.options))\n\t\t\t\t\t: {};\n\t\t\t}\n\n\t\t\tvar promise = connection[method](hash);\n\t\t\taddToPageData(hash, promise);\n\t\t\treturn promise;\n\t\t});\n\n\t\tel[canSymbol.for('can.viewModel')] = request;\n\n\t\tvar frag = tagData.subtemplate ?\n\t\t\t\t\ttagData.subtemplate( tagData.scope.add(request), tagData.options ) :\n\t\t\t\t\tdocument.createDocumentFragment();\n\n\t\t// Append the resulting document fragment to the element\n\t\tdomMutateNode.appendChild.call(el, frag);\n\t});\n}\n\nmodule.exports = namespace.connectTag = connectTag;\n\n\n//# sourceURL=webpack:///./node_modules/can-connect-tag/can-connect-tag.js?");

/***/ }),

/***/ "./node_modules/can-connect/all.js":
/*!*****************************************!*\
  !*** ./node_modules/can-connect/all.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar connect = __webpack_require__(/*! ./can-connect */ \"./node_modules/can-connect/can-connect.js\");\n\nconnect.cacheRequests = __webpack_require__(/*! ./cache-requests/cache-requests */ \"./node_modules/can-connect/cache-requests/cache-requests.js\");\n\nconnect.constructor = __webpack_require__(/*! ./constructor/constructor */ \"./node_modules/can-connect/constructor/constructor.js\");\nconnect.constructorCallbacksOnce = __webpack_require__(/*! ./constructor/callbacks-once/callbacks-once */ \"./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js\");\nconnect.constructorStore = __webpack_require__(/*! ./constructor/store/store */ \"./node_modules/can-connect/constructor/store/store.js\");\nconnect.dataCallbacks = __webpack_require__(/*! ./data/callbacks/callbacks */ \"./node_modules/can-connect/data/callbacks/callbacks.js\");\nconnect.dataCallbacksCache = __webpack_require__(/*! ./data/callbacks-cache/callbacks-cache */ \"./node_modules/can-connect/data/callbacks-cache/callbacks-cache.js\");\nconnect.dataCombineRequests = __webpack_require__(/*! ./data/combine-requests/combine-requests */ \"./node_modules/can-connect/data/combine-requests/combine-requests.js\");\nconnect.dataLocalStorageCache = __webpack_require__(/*! ./data/localstorage-cache/localstorage-cache */ \"./node_modules/can-connect/data/localstorage-cache/localstorage-cache.js\");\nconnect.dataMemoryCache = __webpack_require__(/*! ./data/memory-cache/memory-cache */ \"./node_modules/can-connect/data/memory-cache/memory-cache.js\");\nconnect.dataParse = __webpack_require__(/*! ./data/parse/parse */ \"./node_modules/can-connect/data/parse/parse.js\");\nconnect.dataUrl = __webpack_require__(/*! ./data/url/url */ \"./node_modules/can-connect/data/url/url.js\");\nconnect.fallThroughCache = __webpack_require__(/*! ./fall-through-cache/fall-through-cache */ \"./node_modules/can-connect/fall-through-cache/fall-through-cache.js\");\nconnect.realTime = __webpack_require__(/*! ./real-time/real-time */ \"./node_modules/can-connect/real-time/real-time.js\");\n\nconnect.canMap = __webpack_require__(/*! ./can/map/map */ \"./node_modules/can-connect/can/map/map.js\");\n\nconnect.superMap = __webpack_require__(/*! ./can/super-map/super-map */ \"./node_modules/can-connect/can/super-map/super-map.js\");\nconnect.baseMap = __webpack_require__(/*! ./can/base-map/base-map */ \"./node_modules/can-connect/can/base-map/base-map.js\");\n\nmodule.exports = connect;\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/all.js?");

/***/ }),

/***/ "./node_modules/can-connect/base/base.js":
/*!***********************************************!*\
  !*** ./node_modules/can-connect/base/base.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar behavior = __webpack_require__(/*! ../behavior */ \"./node_modules/can-connect/behavior.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n/**\n * @module can-connect/base/base base\n * @group can-connect/base/base.options 0 behavior options\n * @group can-connect/base/base.identifiers 1 identifiers\n * @parent can-connect.behaviors\n *\n * The first behavior added to every `can-connect` connection. Provides methods to uniquely identify instances and\n * lists.\n *\n * @signature `base(connectionOptions)`\n *\n * Provides instance and list identifiers. Added automatically to every connection created by the `connect` helper.\n * So even if we do:\n *\n * ```js\n * var connection = connect([],{});\n * ```\n *\n * The connection still has the identification functionality provided by `base`:\n *\n * ```js\n * connection.id({id: 1, ...}) //-> 1\n * ```\n *\n * `can-connect` connections are typically created by the `connect` helper rather than by calling the behaviors directly.\n * This ensures the behaviors are called in the required order and is more elegant than requiring the user to chain\n * together the calls to all the behaviors.\n *\n * See the [can-connect/base/base.id id] and [can-connect/base/base.listQuery listQuery] methods for more specifics on\n * how ids are determined.\n *\n * @param {Object} connectionOptions Object containing the configuration for the behaviors of the connection. Added to the\n * prototype of the returned connection object. `base` is almost always configured with an [can-connect/base/base.queryLogic] option since it\n * [can-connect/base/base.id defines how to read the identity properties] and the majority of behaviors also require the queryLogic.\n *\n * @return {Object} A `can-connect` connection containing the methods provided by `base`.\n */\nmodule.exports = behavior(\"base\",function(baseConnection){\n\tvar setQueryLogic;\n\treturn {\n\t\t/**\n\t\t * @function can-connect/base/base.id id\n\t\t * @parent can-connect/base/base.identifiers\n\t\t *\n\t\t * Uniquely identify an instance or raw instance data.\n\t\t *\n\t\t * @signature `connection.id(instance)`\n\t\t *\n\t\t *   Returns the instance id as determined by [can-connect/base/base.queryLogic]'s id values.\n\t\t *\n\t\t *   @param {Instance|Object} instance An instance or raw properties for an instance.\n\t\t *\n\t\t *   @return {String|Number} A string or number uniquely representing `instance`.\n\t\t *\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * Many behaviors, such as the [can-connect/constructor/store/store], need to have a unique identifier for an\n\t\t * instance or instance data.  This `connection.id` method should return that.\n\t\t *\n\t\t * Typically, an item's id is a simply property value on the object. For example, \"Todo\" data might look like:\n\t\t *\n\t\t * ```js\n\t\t * {_id: 5, name: \"do the dishes\"}\n\t\t * ```\n\t\t *\n\t\t * In this case, [can-connect/base/base.queryLogic]'s `id` property should be set to \"_id\":\n\t\t *\n\t\t * ```js\n\t\t * import QueryLogic from \"can-query-logic\";\n\t\t *\n\t\t * var queryLogic = new QueryLogic({\n\t\t *   identity: [\"_id\"]\n\t \t * });\n\t\t *\n\t\t * connect([...],{queryLogic: queryLogic});\n\t\t * ```\n\t\t *\n\t\t */\n\t\tid: function(instance){\n\t\t\tif(this.queryLogic) {\n\t\t\t\treturn canReflect.getIdentity(instance, this.queryLogic.schema);\n\t\t\t} else if(this.idProp) {\n\t\t\t\treturn instance[this.idProp];\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"can-connect/base/base - Please add a queryLogic option.\");\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/base/base.listQuery listQuery\n\t\t * @parent can-connect/base/base.identifiers\n\t\t *\n\t\t * Uniquely identify the set of data a list contains.\n\t\t *\n\t\t * @signature `connection.listQuery(list)`\n\t\t *\n\t\t *   Returns the value of the property referenced by [can-connect/base/base.listQueryProp] if it exists.\n\t\t *   By default, this will return `list[Symbol.for(\"can.listQuery\")]`.\n\t\t *\n\t\t *   @param {can-connect.List} list A list instance.\n\t\t *\n\t\t *   @return {can-query-logic/query} An object that can be passed to `JSON.stringify` to represent the list.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * Many behaviors, such as the [can-connect/constructor/store/store], need to have a unique identifier for a list.\n\t\t * This `connection.listQuery` method should return that.\n\t\t *\n\t\t * Typically, a list's set identifier is a property on the list object.  As example, a list of Todos might look like\n\t\t * the following:\n\t\t *\n\t\t * ```js\n\t\t * var dueTodos = todoConnection.getList({filter: {due: \"today\"}});\n\t\t * dueTodos; // [{_id: 5, name: \"do dishes\", due:\"today\"}, {_id: 6, name: \"walk dog\", due:\"today\"}, ...]\n\t\t * dueTodos[Symbol.for(\"can.listQuery\")]; //-> {filter: {due: \"today\"}}\n\t\t * todoConnection.listQuery(dueTodos); //-> {filter: {due: \"today\"}}\n\t\t * ```\n\t\t *\n\t\t * In the above example the [can-connect/base/base.listQueryProp] would be the default `@can.listQuery`.\n\t\t */\n\t\tlistQuery: function(list){\n\t\t\treturn list[this.listQueryProp];\n\t\t},\n\n\t\t/**\n\t\t * @property {Symbol} can-connect/base/base.listQueryProp listQueryProp\n\t\t * @parent can-connect/base/base.identifiers\n\t\t *\n\t\t * Specifies the property that uniquely identifies a list.\n\t\t *\n\t\t * @option {Symbol} The property that uniquely identifies the list.\n\t\t * Defaults to `Symbol.for(\"can.listQuery\")`.\n\t\t *\n\t\t * ```js\n\t\t * var dataUrl = require(\"can-connect/data/url/\");\n\t\t * var connection = connect([dataUrl], {\n\t\t *   listQueryProp: \"set\"\n\t\t * });\n\t\t *\n\t\t * var list = [{id: 1, ...}, {id: 2, ...}]\n\t\t * list.set = {complete: true};\n\t\t *\n\t\t * connection.listQuery(list) //-> {complete: true}\n\t\t * ```\n\t\t *\n\t\t */\n\t\tlistQueryProp: canSymbol.for(\"can.listQuery\"),\n\n\t\tinit: function(){},\n\n\n\t\t/**\n\t\t * @property {can-query-logic} can-connect/base/base.queryLogic queryLogic\n\t\t * @parent can-connect/base/base.options\n\t\t *\n\t\t * Configuration for list comparison, instance identification and membership\n\t\t * calculations. A way for the `can-connect` behaviors to understand what the properties of a request mean and act\n\t\t * on them.\n\t\t *\n\t\t * @option {can-query-logic} A [can-query-logic queryLogic] that is used to perform calculations using set\n\t\t * definition objects passed to [can-connect/connection.getListData] and [can-connect/connection.getList].\n\t\t * Needed to enable [can-connect/fall-through-cache/fall-through-cache caching],\n\t\t * [can-connect/data/combine-requests/combine-requests request combining], [can-connect/real-time/real-time] and other\n\t\t * behaviors. By default no queryLogic is provided.\n\t\t *\n\t\t * An example of the types of calculations behaviors will make using the queryLogic:\n\t\t * ```js\n\t\t * var queryLogic = new QueryLogic({\n\t\t *   identity: ['_uid'],\n\t\t *   keys: {\n\t\t *     _uid: Number\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * var todoConnection = connect([...behaviors...],{\n\t\t *   queryLogic: queryLogic\n\t\t * });\n\t\t *\n\t\t * todoConnection.queryLogic.memberIdentity({_uid: 5, ...}); //-> 5\n\t\t * todoConnection.id({_uid: 5, ...}); //-> 5\n\t\t * todoConnection.queryLogic.intersection(\n\t\t *   {page: {first: 0, last: 10}},\n\t\t *   {page: {first:  d5, last: 20}}); //-> {first:5, last:10}\n\t\t * ```\n\t\t */\n\n\t\tget queryLogic(){\n\t\t\tif(setQueryLogic) {\n\t\t\t\treturn setQueryLogic;\n\t\t\t} else if(baseConnection.queryLogic) {\n\t\t\t\treturn baseConnection.queryLogic;\n\t\t\t} else if(baseConnection.algebra) {\n\t\t\t\treturn baseConnection.algebra;\n\t\t\t}\n\t\t},\n\t\tset queryLogic(newVal) {\n\t\t\tsetQueryLogic = newVal;\n\t\t}\n\n\t\t/**\n\t\t * @property {can-query-logic} can-connect/base/base.algebra algebra\n\t\t * @parent can-connect/base/base.options\n\t\t *\n\t\t * @description Legacy configuration for [can-set-legacy]. Use [can-connect/base/base.queryLogic] instead.\n\t\t */\n\n\t\t/**\n\t\t * @property {can-connect/DataInterface} can-connect/base/base.cacheConnection cacheConnection\n\t\t * @parent can-connect/base/base.options\n\t\t *\n\t\t * An underlying `can-connect` connection used when fetching data from a cache.\n\t\t *\n\t\t * @option {can-connect/DataInterface} A connection that provides access to a cache via [can-connect/DataInterface]\n\t\t * requests. Several behaviors including [can-connect/fall-through-cache/fall-through-cache] expect this property.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * ```js\n\t\t * import {memoryStore, connect, QueryLogic} from \"can\";\n\t\t *\n\t\t * var cacheConnection = memoryStore({\n\t\t *   queryLogic: new QueryLogic({identity: [\"id\"]})\n\t\t * });\n\t\t *\n\t\t * var todoConnection = connect([...behaviors...],{\n\t\t *   cacheConnection: cacheConnection\n\t\t * });\n\t\t * ```\n\t\t */\n\t};\n});\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/base/base.js?");

/***/ }),

/***/ "./node_modules/can-connect/behavior.js":
/*!**********************************************!*\
  !*** ./node_modules/can-connect/behavior.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar behaviorsMap = {};\n\nfunction behavior(name, behavior){\n\tif(typeof name !== \"string\") {\n\t\tbehavior = name;\n\t\tname = undefined;\n\t}\n\tvar behaviorMixin = function(base){\n\t\t// basically Object.create\n\t\tvar Behavior = function(){};\n\t\tObject.defineProperty(Behavior,\"name\",{\n\t\t\tvalue: name,\n\t\t\tconfigurable: true\n\t\t});\n\t\tBehavior.prototype = base;\n\t\tvar newBehavior = new Behavior();\n\t\t// allows behaviors to be a simple object, not always a function\n\t\tvar res = typeof behavior === \"function\" ? behavior.apply(newBehavior, arguments) : behavior;\n\t\tfor(var prop in res) {\n\t\t\tif(res.hasOwnProperty(prop)) {\n\t\t\t\tObject.defineProperty(newBehavior, prop, Object.getOwnPropertyDescriptor(res, prop));\n\t\t\t} else {\n\t\t\t\t// we only copy values from up the proto chain\n\t\t\t\tnewBehavior[prop] = res[prop];\n\t\t\t}\n\t\t}\n\t\tnewBehavior.__behaviorName = name;\n\t\treturn newBehavior;\n\t};\n\tif(name) {\n\t\tbehaviorMixin.behaviorName = name;\n\t\tbehaviorsMap[name] = behaviorMixin;\n\t}\n\tbehaviorMixin.isBehavior = true;\n\treturn behaviorMixin;\n}\nbehavior.map = behaviorsMap;\nmodule.exports = behavior;\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/behavior.js?");

/***/ }),

/***/ "./node_modules/can-connect/cache-requests/cache-requests.js":
/*!*******************************************************************!*\
  !*** ./node_modules/can-connect/cache-requests/cache-requests.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var connect = __webpack_require__(/*! ../can-connect */ \"./node_modules/can-connect/can-connect.js\");\nvar getItems = __webpack_require__(/*! ../helpers/get-items */ \"./node_modules/can-connect/helpers/get-items.js\");\nvar forEach = Array.prototype.forEach;\n\n\n/**\n * @module can-connect/cache-requests/cache-requests cache-requests\n * @parent can-connect.behaviors\n * @group can-connect/cache-requests/cache-requests.data data interface\n * @group can-connect/cache-requests/cache-requests.queryLogic queryLogic\n *\n * Cache response data and use it to prevent unnecessary future requests or make future requests smaller.\n *\n * @signature `cacheRequests( baseConnection )`\n *\n *   Provide an implementation of [can-connect/cache-requests/cache-requests.getListData] that uses [can-connect/base/base.queryLogic] to\n *   determine what data is already in the [can-connect/base/base.cacheConnection cache] and what data needs to be\n *   loaded from the base connection.\n *\n *   It then gets data from the cache and the base connection (if needed), merges it, and returns it. Any data returned\n *   from the base connection is added to the cache.\n *\n *   @param {{}} baseConnection `can-connect` connection object that is having the `cache-requests` behavior added\n *   on to it. Should already contain the behaviors that provide the [can-connect/DataInterface]\n *   (e.g [can-connect/data/url/url]). If the `connect` helper is used to build the connection, the behaviors will\n *   automatically be ordered as required.\n *\n *   @return {Object} A `can-connect` connection containing the methods provided by `cache-requests`.\n *\n *\n * @body\n *\n * ## Use\n *\n * Use `cache-requests` in combination with a cache like [can-connect/data/memory-cache/memory-cache] or\n * [can-connect/data/localstorage-cache/localstorage-cache].  For example, to make it so response data is cached\n * in memory:\n *\n * ```js\n * var memoryStore = require(\"can-memory-store\");\n * var dataUrl = require(\"can-connect/data/url/url\");\n * var cacheRequests = require(\"can-connect/cache-requests/cache-requests\");\n * var queryLogic = require(\"can-query-logic\");\n *\n * var todoQueryLogic = new QueryLogic({});\n *\n * var cacheConnection = memoryStore({queryLogic: todoQueryLogic});\n * var todoConnection = connect([dataUrl, cacheRequests],{\n *   cacheConnection: cacheConnection,\n *   url: \"/todos\",\n *   queryLogic: todoQueryLogic\n * });\n * ```\n *\n * Now if today's todos are loaded:\n *\n * ```js\n * todoConnection.getListData({filter: {due: \"today\"}});\n * ```\n *\n * And later, a subset of those todos are loaded:\n *\n * ```js\n * todoConnection.getListData({filter: {due: \"today\", status: \"critical\"}});\n * ```\n *\n * The second request will be created from the original request's data.\n *\n * ## QueryLogic Usage\n *\n * `cache-requests` will \"fill-in\" the `cacheConnection` using [can-query-logic queryLogic].\n *\n * For example, if you requested paginated data like:\n *\n * ```\n * todoConnection.getListData({filter: {status: \"critical\"}})\n * ```\n *\n * And then later requested:\n *\n * ```\n * todoConnection.getListData({})\n * ```\n *\n * `cache-requests` will only request `{filter: {status: [\"low\",\"medium\"]}}`, merging\n * that response with the data already present in the cache.\n *\n * That configuration looks like:\n *\n * ```js\n * var memoryStore = require(\"can-memory-store\");\n * var dataUrl = require(\"can-connect/data/url/url\");\n * var cacheRequests = require(\"can-connect/cache-requests/cache-requests\");\n * var queryLogic = require(\"can-query-logic\");\n *\n * var todoQueryLogic = new QueryLogic({\n *   keys: {\n *     status: QueryLogic.makeEnum([\"low\",\"medium\",\"critical\"])\n *   }\n * });\n *\n * var cacheConnection = memoryStore({queryLogic: todoQueryLogic});\n * var todoConnection = connect([dataUrl, cacheRequests], {\n *   cacheConnection: cacheConnection,\n *   url: \"/todos\",\n *   queryLogic: todoQueryLogic\n * })\n * ```\n *\n * **Note:** `cacheConnection` shares the same queryLogic configuration as the primary connection.\n */\nvar cacheRequestsBehaviour = connect.behavior(\"cache-requests\",function(baseConnection){\n\n\treturn {\n\n\t\t/**\n\t\t * @function can-connect/cache-requests/cache-requests.getDiff getDiff\n\t\t * @parent can-connect/cache-requests/cache-requests.queryLogic\n\t\t *\n\t\t * Compares the cached queries to the requested query and returns a description of what subset can be loaded from the\n\t\t * cache and what subset must be loaded from the base connection.\n\t\t *\n\t\t * @signature `connection.getDiff( query, availableQueries )`\n\t\t *\n\t\t *   This determines the minimal amount of data that must be loaded from the base connection by going through each\n\t\t *   cached query (`availableQueries`) and doing a [can-query-logic.prototype.isSubset isSubset] check and a\n\t\t *   [can-query-logic.prototype.difference query difference] with the requested query (`query`).\n\t\t *\n\t\t *   If `query` is a subset of an `availableSet`, `{cached: query}` will be returned.\n\t\t *\n\t\t *   If `query` is neither a subset of, nor intersects with any `availableQueries`, `{needed: query}` is returned.\n\t\t *\n\t\t *   If `query` has an intersection with one or more `availableQueries`, a description of the difference that has the fewest\n\t\t *   missing elements will be returned. An example diff description looks like:\n\t\t *\n\t\t *   ```\n\t\t *   {\n\t\t *     needed: {start: 50, end: 99}, // the difference, the query that is not cached\n\t\t *     cached: {start: 0, end: 49}, // the intersection, the query that is cached\n\t\t *     count: 49 // the size of the needed query\n\t\t *   }\n\t\t *   ```\n\t\t *\n\t\t *   @param {can-query-logic/query} query The query that is being requested.\n\t\t *   @param {Array<can-query-logic/query>} availableQueries An array of [can-connect/connection.getSets available queries] in the\n\t\t *     [can-connect/base/base.cacheConnection cache].\n\t\t *   @return {Promise<{needed: can-query-logic/query, cached: can-query-logic/query, count: Integer}>} a difference description object. Described above.\n\t\t *\n\t\t */\n\t\tgetDiff: function( params, availableQueries ){\n\n\t\t\tvar minSets,\n\t\t\t\tself = this;\n\n\t\t\tforEach.call(availableQueries, function(query){\n\t\t\t\tvar curSets;\n\t\t\t\tvar difference = self.queryLogic.difference(params, query );\n\t\t\t\tif( self.queryLogic.isDefinedAndHasMembers(difference) ) {\n\t\t\t\t\tvar intersection = self.queryLogic.intersection(params, query);\n\t\t\t\t\tcurSets = {\n\t\t\t\t\t\tneeded: difference,\n\t\t\t\t\t\tcached: self.queryLogic.isDefinedAndHasMembers(intersection) ? intersection : false,\n\t\t\t\t\t\tcount: self.queryLogic.count(difference)\n\t\t\t\t\t};\n\t\t\t\t} else if( self.queryLogic.isSubset(params, query) ){\n\t\t\t\t\tcurSets = {\n\t\t\t\t\t\tcached: params,\n\t\t\t\t\t\tcount: 0\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif(curSets) {\n\t\t\t\t\tif(!minSets || curSets.count < minSets.count) {\n\t\t\t\t\t\tminSets = curSets;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif(!minSets) {\n\t\t\t\treturn {\n\t\t\t\t\tneeded: params\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tneeded: minSets.needed,\n\t\t\t\t\tcached: minSets.cached\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/cache-requests/cache-requests.unionMembers unionMembers\n\t\t * @parent can-connect/cache-requests/cache-requests.queryLogic\n\t\t *\n\t\t * Create the requested data set, a union of the cached and un-cached data.\n\t\t *\n\t\t * @signature `connection.unionMembers(set, diff, neededData, cachedData)`\n\t\t *\n\t\t *   Uses [can-query-logic.prototype.unionMembers] to merge the two queries of data (`neededData` & `cachedData`).\n\t\t *\n\t\t * @param {can-query-logic/query} query The parameters of the data set requested.\n\t\t * @param {Object} diff The result of [can-connect/cache-requests/cache-requests.getDiff].\n\t\t * @param {can-connect.listData} neededData The data loaded from the base connection.\n\t\t * @param {can-connect.listData} cachedData The data loaded from the [can-connect/base/base.cacheConnection].\n\t\t *\n\t\t * @return {can-connect.listData} A merged [can-connect.listData] representation of the the cached and requested data.\n\t\t */\n\t\tunionMembers: function(params, diff, neededItems, cachedItems){\n\t\t\t// using the diff, re-construct everything\n\t\t\treturn {data: this.queryLogic.unionMembers(diff.needed, diff.cached, getItems(neededItems), getItems(cachedItems))};\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/cache-requests/cache-requests.getListData getListData\n\t\t * @parent can-connect/cache-requests/cache-requests.data\n\t\t *\n\t\t * Only request data that isn't already present in the [can-connect/base/base.cacheConnection cache].\n\t\t *\n\t\t * @signature `connection.getListData(set)`\n\t\t *\n\t\t *   Overwrites a base connection's `getListData` to use data in the [can-connect/base/base.cacheConnection cache]\n\t\t *   whenever possible.  This works by [can-connect/connection.getSets getting the stored queries]\n\t\t *   from the [can-connect/base/base.cacheConnection cache] and\n\t\t *   doing a [can-connect/cache-requests/cache-requests.getDiff diff] to see what needs to be loaded from the base\n\t\t *   connection and what can be loaded from the [can-connect/base/base.cacheConnection cache].\n\t\t *\n\t\t *   With that information, this `getListData` requests data from the cache or the base connection as needed.\n\t\t *   Data loaded from different sources is combined via [can-connect/cache-requests/cache-requests.unionMembers].\n\t\t *\n\t\t * @param {can-query-logic/query} query the parameters of the list that is being requested.\n\t\t * @return {Promise<can-connect.listData>} a promise that returns an object conforming to the [can-connect.listData] format.\n\t\t */\n\t\tgetListData: function(set){\n\t\t\tset = set || {};\n\t\t\tvar self = this;\n\n\t\t\treturn this.cacheConnection.getSets(set).then(function(queries){\n\n\t\t\t\tvar diff = self.getDiff(set, queries);\n\n\t\t\t\tif(!diff.needed) {\n\t\t\t\t\treturn self.cacheConnection.getListData(diff.cached);\n\t\t\t\t} else if(!diff.cached) {\n\t\t\t\t\treturn baseConnection.getListData(diff.needed).then(function(data){\n\n\t\t\t\t\t\treturn self.cacheConnection.updateListData(getItems(data), diff.needed ).then(function(){\n\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar cachedPromise = self.cacheConnection.getListData(diff.cached);\n\t\t\t\t\tvar needsPromise = baseConnection.getListData(diff.needed);\n\n\t\t\t\t\tvar savedPromise = needsPromise.then(function(data){\n\t\t\t\t\t\treturn self.cacheConnection.updateListData(  getItems(data), diff.needed ).then(function(){\n\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\t// start the combine while we might be saving param and adding to cache\n\t\t\t\t\tvar combinedPromise = Promise.all([\n\t\t\t\t\t\tcachedPromise,\n\t\t\t\t\t\tneedsPromise\n\t\t\t\t\t]).then(function(result){\n\t\t\t\t\t\tvar cached = result[0],\n\t\t\t\t\t\t\tneeded = result[1];\n\t\t\t\t\t\treturn self.unionMembers( set, diff, needed, cached);\n\t\t\t\t\t});\n\n\t\t\t\t\treturn Promise.all([combinedPromise, savedPromise]).then(function(data){\n\t\t\t\t\t\treturn data[0];\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t};\n\n});\n\nmodule.exports = cacheRequestsBehaviour;\n\n//!steal-remove-start\nif(true) {\n\tvar validate = __webpack_require__(/*! ../helpers/validate */ \"./node_modules/can-connect/helpers/validate.js\");\n\tmodule.exports = validate(cacheRequestsBehaviour, ['getListData', 'cacheConnection']);\n}\n//!steal-remove-end\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/cache-requests/cache-requests.js?");

/***/ }),

/***/ "./node_modules/can-connect/can-connect.js":
/*!*************************************************!*\
  !*** ./node_modules/can-connect/can-connect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar connect = __webpack_require__(/*! ./connect */ \"./node_modules/can-connect/connect.js\");\nvar base = __webpack_require__(/*! ./base/base */ \"./node_modules/can-connect/base/base.js\");\nvar ns = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nconnect.base = base;\n\nmodule.exports = ns.connect = connect;\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/can-connect.js?");

/***/ }),

/***/ "./node_modules/can-connect/can/base-map/base-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-connect/can/base-map/base-map.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var connect = __webpack_require__(/*! ../../can-connect */ \"./node_modules/can-connect/can-connect.js\");\n\nvar constructor = __webpack_require__(/*! ../../constructor/constructor */ \"./node_modules/can-connect/constructor/constructor.js\");\nvar canMap = __webpack_require__(/*! ../map/map */ \"./node_modules/can-connect/can/map/map.js\");\nvar canRef = __webpack_require__(/*! ../ref/ref */ \"./node_modules/can-connect/can/ref/ref.js\");\nvar constructorStore = __webpack_require__(/*! ../../constructor/store/store */ \"./node_modules/can-connect/constructor/store/store.js\");\nvar dataCallbacks = __webpack_require__(/*! ../../data/callbacks/callbacks */ \"./node_modules/can-connect/data/callbacks/callbacks.js\");\nvar dataParse = __webpack_require__(/*! ../../data/parse/parse */ \"./node_modules/can-connect/data/parse/parse.js\");\nvar dataUrl = __webpack_require__(/*! ../../data/url/url */ \"./node_modules/can-connect/data/url/url.js\");\nvar realTime = __webpack_require__(/*! ../../real-time/real-time */ \"./node_modules/can-connect/real-time/real-time.js\");\nvar callbacksOnce = __webpack_require__(/*! ../../constructor/callbacks-once/callbacks-once */ \"./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js\");\nvar GLOBAL = __webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\n\n\nvar $ = GLOBAL().$;\n\nconnect.baseMap = function(options){\n\n\tvar behaviors = [\n\t\tconstructor,\n\t\tcanMap,\n\t\tcanRef,\n\t\tconstructorStore,\n\t\tdataCallbacks,\n\t\tdataParse,\n\t\tdataUrl,\n\t\trealTime,\n\t\tcallbacksOnce\n\t];\n\n\t// Handles if jQuery isn't provided.\n\tif($ && $.ajax) {\n\t\toptions.ajax = $.ajax;\n\t}\n\n\treturn connect(behaviors,options);\n};\n\nmodule.exports = connect.baseMap;\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/can/base-map/base-map.js?");

/***/ }),

/***/ "./node_modules/can-connect/can/map/map.js":
/*!*************************************************!*\
  !*** ./node_modules/can-connect/can/map/map.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar each = canReflect.each;\nvar isPlainObject = canReflect.isPlainObject;\n\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar eventQueue = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar QueryLogic = __webpack_require__(/*! can-query-logic */ \"./node_modules/can-query-logic/can-query-logic.js\");\n\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\nvar behavior = __webpack_require__(/*! ../../behavior */ \"./node_modules/can-connect/behavior.js\");\nvar updateDeepExceptIdentity = __webpack_require__(/*! can-diff/update-deep-except-identity/update-deep-except-identity */ \"./node_modules/can-diff/update-deep-except-identity/update-deep-except-identity.js\");\nvar assignDeepExceptIdentity = __webpack_require__(/*! can-diff/assign-deep-except-identity/assign-deep-except-identity */ \"./node_modules/can-diff/assign-deep-except-identity/assign-deep-except-identity.js\");\nvar smartMerge = __webpack_require__(/*! can-diff/merge-deep/merge-deep */ \"./node_modules/can-diff/merge-deep/merge-deep.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar getNameSymbol = canSymbol.for(\"can.getName\");\n\nfunction smartMergeExceptIdentity(dest, source, schema) {\n\tif(!schema) {\n        schema = canReflect.getSchema(dest);\n    }\n    if(!schema) {\n        throw new Error(\"can-connect/can/map/ is unable to update without a schema.\");\n    }\n\tschema.identity.forEach(function(key){\n        var id = canReflect.getKeyValue(dest, key);\n        if(id!== undefined) {\n            canReflect.setKeyValue(source, key, id );\n        }\n    });\n\tsmartMerge(dest, source);\n}\n\nvar canMapBehavior = behavior(\"can/map\",function(baseConnection){\n\n\t// overwrite\n\tvar behavior = {\n\t\tinit: function(){\n\t\t\tif(!this.Map) {\n\t\t\t\tif (this.ObjectType) {\n\t\t\t\t\tthis.Map = this.ObjectType;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"can-connect/can/map/map must be configured with a Map or ObjectType type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!this[getNameSymbol]) {\n\t\t\t\tthis[getNameSymbol] = function(){\n\t\t\t\t\tif(this.name) {\n\t\t\t\t\t\treturn \"Connection{\"+this.name+\"}\";\n\t\t\t\t\t} else if(this.Map) {\n\t\t\t\t\t\treturn \"Connection{\"+canReflect.getName(this.Map)+\"}\";\n\t\t\t\t\t} else if(typeof this.url === \"string\") {\n\t\t\t\t\t\treturn \"Connection{\"+this.url+\"}\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn \"Connection{}\";\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.List = this.List || this.ArrayType || this.Map.List;\n\t\t\tvar hasList = Boolean(this.List);\n\n\t\t\tif (!hasList) {\n\t\t\t\tObject.defineProperty(this, 'List', {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\tthrow new Error(\"can-connect/can/map/map - \"+canReflect.getName(this)+\" should be configured with an ArrayType or List type.\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\toverwrite(this, this.Map, mapOverwrites);\n\t\t\tif (hasList) {\n\t\t\t\toverwrite(this, this.List, listOverwrites);\n\t\t\t}\n\n\t\t\tif(!this.queryLogic) {\n\t\t\t\tthis.queryLogic = new QueryLogic(this.Map);\n\t\t\t}\n\n\n\t\t\tvar connection = this;\n\n\t\t\t// ### Setup store updates\n\t\t\tif(this.Map[canSymbol.for(\"can.onInstanceBoundChange\")]) {\n\t\t\t\tvar canConnectMap_onMapBoundChange = function (instance, isBound){\n\t\t\t\t\tvar method = isBound ? \"addInstanceReference\" : \"deleteInstanceReference\";\n\t\t\t\t\tif(connection[method]) {\n\t\t\t\t\t\tconnection[method](instance);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t//!steal-remove-start\n\t\t\t\tObject.defineProperty(canConnectMap_onMapBoundChange, \"name\", {\n\t\t\t\t\tvalue: canReflect.getName(this.Map) + \" boundChange\",\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\t\t\t\t//!steal-remove-end\n\t\t\t\tthis.Map[canSymbol.for(\"can.onInstanceBoundChange\")](canConnectMap_onMapBoundChange);\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"can-connect/can/map is unable to listen to onInstanceBoundChange on the Map type\");\n\t\t\t}\n\n\t\t\tif (hasList) {\n\t\t\t\tif(this.List[canSymbol.for(\"can.onInstanceBoundChange\")]) {\n\t\t\t\t\tvar canConnectMap_onListBoundChange = function(list, isBound){\n\t\t\t\t\t\tvar method = isBound ? \"addListReference\" : \"deleteListReference\";\n\t\t\t\t\t\tif(connection[method]) {\n\t\t\t\t\t\t\tconnection[method](list);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tObject.defineProperty(canConnectMap_onListBoundChange, \"name\", {\n\t\t\t\t\t\tvalue: canReflect.getName(this.List) + \" boundChange\",\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tthis.List[canSymbol.for(\"can.onInstanceBoundChange\")](canConnectMap_onListBoundChange);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"can-connect/can/map is unable to listen to onInstanceBoundChange on the List type\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adds the instance when its `id` property is set\n\t\t\tif(this.Map[canSymbol.for(\"can.onInstancePatches\")]) {\n\t\t\t\tthis.Map[canSymbol.for(\"can.onInstancePatches\")](function canConnectMap_onInstancePatches(instance, patches){\n\t\t\t\t\tpatches.forEach(function(patch){\n\t\t\t\t\t\tif( (patch.type === \"add\" || patch.type === \"set\") &&\n\t\t\t\t\t\t\tpatch.key === connection.idProp &&\n\t\t\t\t\t\t\tinstance[canSymbol.for(\"can.isBound\")]()) {\n\t\t\t\t\t\t\tconnection.addInstanceReference(instance);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"can-connect/can/map is unable to listen to onInstancePatches on the Map type\");\n\t\t\t}\n\t\t\tbaseConnection.init.apply(this, arguments);\n\t\t},\n\t\t/**\n\t\t * @function can-connect/can/map/map.serializeInstance serializeInstance\n\t\t * @parent can-connect/can/map/map.serializers\n\t\t *\n\t\t * Returns the properties of an instance that should be sent to the data source when saving. Done by calling\n\t\t * [can-define/map/map.prototype.serialize `instance.serialize()`].\n\t\t *\n\t\t * @signature `connection.serializeInstance(instance)`\n\t\t * Simply calls [can-define/map/map.prototype.serialize] on the `instance` argument.\n\t\t *\n\t\t * @param {can-connect/can/map/map._Map} instance the instance to serialize\n\t\t * @return {Object} the result of calling [can-define/map/map.prototype.serialize `instance.serialize()`]\n\t\t */\n\t\tserializeInstance: function(instance){\n\t\t\treturn canReflect.serialize(instance);\n\t\t},\n\t\t/**\n\t\t * @function can-connect/can/map/map.serializeList serializeList\n\t\t * @parent can-connect/can/map/map.serializers\n\t\t *\n\t\t * Returns the properties of a list that should be sent to the data source when saving. Done by calling\n\t\t * [can-define/list/list.prototype.serialize `list.serialize()`].\n\t\t *\n\t\t * @signature `connection.serializeList(list)`\n\t\t * Simply calls [can-define/list/list.prototype.serialize] on the `list` argument.\n\t\t *\n\t\t * @param {can-connect/can/map/map._List} list the list to serialize\n\t\t * @return {Object} the result of calling [can-define/list/list.prototype.serialize `list.serialize()`]\n\t\t */\n\t\tserializeList: function(list){\n\t\t\treturn canReflect.serialize(list);\n\t\t},\n\t\t/**\n\t\t * @property {Boolean} can-connect/can/map/map.updateInstanceWithAssignDeep updateInstanceWithAssignDeep\n\t\t * @parent can-connect/can/map/map.options\n\t\t *\n\t\t * Use the response from `save()` and `destroy()` to assign properties, never delete them.\n\t\t *\n\t\t * @option {Boolean}\n\t\t *\n\t\t * Setting `updateInstanceWithAssignDeep` to `true` changes how instances get updated. Instead of using\n\t\t * [can-diff/merge-deep/merge-deep], records will be updated with [can-reflect.assignDeep].\n\t\t *\n\t\t * The following example shows that the response from `.save()` only includes the `id`\n\t\t * property. Normally, this would delete all other properties (`name`).  But setting `updateInstanceWithAssignDeep`\n\t\t * to `true` prevents this:\n\t\t *\n\t\t * **Usage:**\n\t\t *\n\t\t * ```js\n\t\t * import {DefineMap, restModel} from \"can\";\n\t\t *\n\t\t * var Todo = DefineMap.extend({\n\t\t *   id: {type: \"number\", identity: true},\n\t\t *   name: \"string\"\n\t\t * });\n\t\t *\n\t\t * // restModel uses `can-connect/can/map/map`\n\t\t * restModel({\n\t\t *   Map: Todo,\n\t\t *   url: \"/todos\",\n\t\t *   updateInstanceWithAssignDeep: true\n\t\t * });\n\t\t *\n\t\t *\n\t\t * var todo = new Todo({name: \"learn canjs\"})\n\t\t *\n\t\t * var savePromise = todo.save()\n\t\t * // SERVER SENDS\n\t\t * // -> POST /todos {name: \"learn canjs\"}\n\t\t *\n\t\t * // SERVER RESPONDS WITH:\n\t\t * // <- {id: 5}\n\t\t *\n\t\t * savePromise.then(function(){\n\t\t *   // Name still exists even though the server did not\n\t\t *   // respond with it.\n\t\t *   todo.name //-> \"learn canjs\"\n\t\t * })\n\t\t * ```\n\t\t *\n\t\t * __NOTE__: [can-diff/merge-deep/merge-deep] is able to work _MUCH_ better with nested\n\t\t * data than [can-reflect.assignDeep]. Specifically, it is able to better\n\t\t * prevent overwriting one instance's data with another. The _Use_ section of [can-diff/merge-deep/merge-deep]\n\t\t * goes over this ability. Make sure you understand its capabilities before turning it off.\n\t\t */\n\n\t\t/**\n\t\t * @property {connection.Map} can-connect/can/map/map._Map Map\n\t\t * @parent can-connect/can/map/map.options\n\t\t *\n\t\t * Specify the type of the `[can-define/map/map DefineMap]` that should be instantiated by the connection.\n\t\t *\n\t\t * @option {connection.Map}\n\t\t *\n\t\t * **Usage:**\n\t\t *\n\t\t * ```js\n\t\t * var DefineMap = require(\"can-define/map/map\");\n\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t *\n\t\t * var Todo = DefineMap.extend({\n\t\t *   completed: \"boolean\",\n\t\t *   complete: function(){\n\t\t *     this.completed = true\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * var todoConnection = connect([dataUrl, constructor, canMap], {\n\t\t *   Map: Todo,\n\t\t *   url: \"/todos\"\n\t\t * });\n\t\t *\n\t\t * todoConnect.get({id:1}).then(function(item) {\n\t\t *   item instanceof Todo // true\n\t\t * });\n\t\t * ```\n\t\t */\n\n\t\t/**\n\t\t * @property {connection.List} can-connect/can/map/map._List List\n\t\t * @parent can-connect/can/map/map.options\n\t\t *\n\t\t * Specify the type of the `[can-define/list/list DefineList]` that should be instantiated by the connection.\n\t\t *\n\t\t * @option {connection.List} If this option is not specified it defaults to the [can-connect/can/map/map._Map Map].List\n\t\t * property.\n\t\t *\n\t\t * **Usage:**\n\t\t * ```js\n\t\t * var DefineMap = require(\"can-define/map/map\");\n\t\t * var DefineList = require(\"can-define/list/list\");\n\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t *\n\t\t * var Todo = DefineMap.extend({\n\t\t *   completed: \"boolean\",\n\t\t *   complete: function(){\n\t\t *     this.completed = true\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * var Todo.List = DefineList.extend({\n\t\t *   \"#\": Todo,\n\t\t *   completed: function(){\n\t\t *     this.filter(function(todo){\n\t\t *       return todo.completed;\n\t\t *     });\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * var todoConnection = connect([dataUrl, constructor, canMap],{\n\t\t *   Map: Todo,\n\t\t *   List: Todo.List,\n\t\t *   url: \"/todos\"\n\t\t * });\n\t\t *\n\t\t * todoConnection.getList({}).then(function(list) {\n\t\t *   list instanceOf Todo.List // true\n\t\t * })\n\t\t * ```\n\t\t *\n\t\t */\n\n\t\t/**\n\t\t * @function can-connect/can/map/map.instance instance\n\t\t * @parent can-connect/can/map/map.hydrators\n\t\t *\n\t\t * Creates a [can-connect/can/map/map._Map] instance given raw data.\n\t\t *\n\t\t * @signature `connection.instance(props)`\n\t\t *\n\t\t *   Create an instance of [can-connect/can/map/map._Map].\n\t\t *\n\t\t *   @param {Object} props the raw instance data.\n\t\t *   @return [can-connect/can/map/map._Map] a [can-connect/can/map/map._Map] instance containing the `props`.\n\t\t */\n\t\tinstance: function(props){\n\t\t\tvar _Map = this.Map;\n\t\t\treturn new _Map(props);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/can/map/map.list list\n\t\t * @parent can-connect/can/map/map.hydrators\n\t\t *\n\t\t * Creates a [can-connect/can/map/map._List] instance given raw data.\n\t\t *\n\t\t * @signature `connection.list(listData, set)`\n\t\t *\n\t\t *   Creates an instance of [can-connect/can/map/map._List] if available, otherwise creates\n\t\t *   [can-connect/can/map/map._Map].List if available.\n\t\t *\n\t\t *   This will add properties on the raw `listData` array to the created list instance. e.g:\n\t\t *   ```js\n\t\t *   var listData = [{id: 1, name:\"do dishes\"}, ...];\n\t\t *   listData.loadedFrom; // \"shard 5\"\n\t\t *\n\t\t *   var todoList = todoConnection.list(listData, {});\n\t\t *   todoList.loadedFrom; // \"shard 5\"\n\t\t *   ```\n\t\t *\n\t\t *   @param {can-connect.listData} listData the raw list data.\n\t\t *   @param {can-query-logic/query} query the set the data belongs to.\n\t\t *   @return {can-connect.List} a [can-connect/can/map/map._List] instance containing instances of\n\t\t *   [can-connect/can/map/map._Map] built from the list items in `listData`.\n\t\t */\n\t\tlist: function(listData, set){\n\t\t\tvar _List = this.List || (this.Map && this.Map.List);\n\t\t\tvar list = canReflect.new(_List, listData.data);\n\t\t\tcanReflect.eachKey(listData, function (val, prop) {\n\t\t\t\tif (prop !== 'data') {\n\t\t\t\t\tcanReflect.setKeyValue(list, prop, val);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlist[this.listQueryProp] = set;\n\t\t\treturn list;\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/can/map/map.updatedList updatedList\n\t\t * @parent can-connect/can/map/map.instance-callbacks\n\t\t *\n\t\t * Implements the [can-connect/constructor/constructor.updatedList] callback so it updates the list and it's items\n\t\t * during a single [can-event/batch/batch batched event].\n\t\t *\n\t\t * @signature `connection.updatedList(list, listData, set)`\n\t\t *\n\t\t *   Updates the list and the items within it during a single [can-event/batch/batch batched event].\n\t\t *\n\t\t *   @param {can-connect.List} list the list to be updated.\n\t\t *   @param {can-connect.listData} listData raw list data.\n\t\t *   @param {can-query-logic/query} query the set of the list being updated.\n\t\t */\n\t\tupdatedList: function(list, listData, set){\n\t\t\tqueues.batch.start();\n\t\t\tvar enqueueOptions = {};\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tenqueueOptions = {\n    \t\t\t\treasonLog: [\"set\", set,\"list\", list,\"updated with\", listData]\n  \t\t\t\t};\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tqueues.mutateQueue.enqueue(baseConnection.updatedList, this, arguments, enqueueOptions);\n\t\t\tqueues.batch.stop();\n\n\t\t},\n\t\tsave: function(instance){\n\t\t\tcanReflect.setKeyValue(instance, \"_saving\", true);\n\t\t\t//canEvent.dispatch.call(instance, \"_saving\", [true, false]);\n\t\t\tvar done = function(){\n\t\t\t\tcanReflect.setKeyValue(instance, \"_saving\", false);\n\t\t\t\t//canEvent.dispatch.call(instance, \"_saving\", [false, true]);\n\t\t\t};\n\t\t\tvar base = baseConnection.save.apply(this, arguments);\n\t\t\tbase.then(done,done);\n\t\t\treturn base;\n\t\t},\n\t\tdestroy: function(instance){\n\t\t\tcanReflect.setKeyValue(instance, \"_destroying\", true);\n\t\t\t//canEvent.dispatch.call(instance, \"_destroying\", [true, false]);\n\t\t\tvar done = function(){\n\t\t\t\tcanReflect.setKeyValue(instance, \"_destroying\", false);\n\t\t\t\t//canEvent.dispatch.call(instance, \"_destroying\", [false, true]);\n\t\t\t};\n\t\t\tvar base = baseConnection.destroy.apply(this, arguments);\n\t\t\tbase.then(done,done);\n\t\t\treturn base;\n\t\t}\n\t};\n\n\teach([\n\t\t/**\n\t\t * @function can-connect/can/map/map.createdInstance createdInstance\n\t\t * @parent can-connect/can/map/map.instance-callbacks\n\t\t *\n\t\t * Implements the [can-connect/constructor/constructor.createdInstance] callback so it dispatches an event and\n\t\t * updates the instance.\n\t\t *\n\t\t * @signature `connection.createdInstance(instance, props)`\n\t\t *\n\t\t *   Updates the instance with `props` and dispatches a \"created\" event on the instance and the instances's\n\t\t *   constructor function ([can-connect/can/map/map._Map]).\n\t\t *\n\t\t *   Calls [can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore] to ensure new instances\n\t\t *   are moved into the [can-connect/constructor/store/store.instanceStore] after being saved.\n\t\t *\n\t\t *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance\n\t\t *   @param {Object} props the data in the response from [can-connect/connection.createData]\n\t\t */\n\t\t\"created\",\n\t\t/**\n\t\t * @function can-connect/can/map/map.updatedInstance updatedInstance\n\t\t * @parent can-connect/can/map/map.instance-callbacks\n\t\t *\n\t\t * Implements the [can-connect/constructor/constructor.updatedInstance] callback so it dispatches an event and\n\t\t * updates the instance.\n\t\t *\n\t\t * @signature `connection.updatedInstance(instance, props)`\n\t\t *\n\t\t *   Updates the instance with `props` and dispatches an \"updated\" event on the instance and the instances's\n\t\t *   constructor function ([can-connect/can/map/map._Map]).\n\t\t *\n\t\t *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance\n\t\t *   @param {Object} props the data in the response from [can-connect/connection.updateData]\n\t\t */\n\t\t\"updated\",\n\t\t/**\n\t\t * @function can-connect/can/map/map.destroyedInstance destroyedInstance\n\t\t * @parent can-connect/can/map/map.instance-callbacks\n\t\t *\n\t\t * Implements the [can-connect/constructor/constructor.destroyedInstance] callback so it dispatches an event and\n\t\t * updates the instance.\n\t\t *\n\t\t * @signature `connection.destroyedInstance(instance, props)`\n\t\t *\n\t\t *   Updates the instance with `props` and dispatches a \"destroyed\" event on the instance and the instances's\n\t\t *   constructor function ([can-connect/can/map/map._Map]).\n\t\t *\n\t\t *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance\n\t\t *   @param {Object} props the data in the response from [can-connect/connection.destroyData]\n\t\t */\n\t\t\"destroyed\"\n\t], function (funcName) {\n\t\t// Each of these is pretty much the same, except for the events they trigger.\n\t\tbehavior[funcName+\"Instance\"] = function (instance, props) {\n\n\t\t\t// Update attributes if attributes have been passed\n\t\t\tif(props && typeof props === 'object') {\n\n\t\t\t\tif(funcName === \"destroyed\" && canReflect.size(props) === 0) {\n\t\t\t\t\t// If destroy is passed an empty object, ignore update\n\t\t\t\t\t// This isn't tested except by can-rest-model.\n\t\t\t\t} else {\n\t\t\t\t\tif(this.constructor.removeAttr) {\n\t\t\t\t\t\tupdateDeepExceptIdentity(instance, props, this.queryLogic.schema);\n\t\t\t\t\t}\n\t\t\t\t\t// this is legacy\n\t\t\t\t\telse if(this.updateInstanceWithAssignDeep){\n\t\t\t\t\t\tassignDeepExceptIdentity(instance, props, this.queryLogic.schema);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsmartMergeExceptIdentity( instance, props, this.queryLogic.schema);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// This happens in constructor/store, but we don't call base, so we have to do it ourselves.\n\t\t\tif(funcName === \"created\" && this.moveCreatedInstanceToInstanceStore) {\n\t\t\t\tthis.moveCreatedInstanceToInstanceStore(instance);\n\t\t\t}\n\n\t\t\tcanMapBehavior.callbackInstanceEvents(funcName, instance);\n\t\t};\n\t});\n\n\n\treturn behavior;\n\n});\n\n/**\n * @function can-connect/can/map/map.callbackInstanceEvents callbackInstanceEvents\n * @parent can-connect/can/map/map.static\n *\n * Utility function to dispatch events for instance callbacks, e.g. [can-connect/can/map/map.updatedInstance].\n *\n * @signature `connection.callbackInstanceEvents(cbName, instance)`\n *\n *   Used to dispatch events as part of instance callbacks implementations. This method could be useful in other\n *   behaviors that implement instance callbacks. E.g. a behavior overriding the\n *   [can-connect/can/map/map.updatedInstance `updatedInstance`] callback:\n *\n *   ```\n *   connect([canMap, {\n *       updatedInstance: function(instance, props) {\n *           instance = smartMerge(instance, props);\n *           canMapBehavior.callbackInstanceEvents(\"updated\", instance);\n *       }\n *   }], {})\n *   ```\n *\n *   @param {String} eventName name of the the event to be triggered\n *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance.\n */\ncanMapBehavior.callbackInstanceEvents = function (funcName, instance) {\n\tvar constructor = instance.constructor;\n\n\t// triggers change event that bubble's like\n\t// handler( 'change','1.destroyed' ). This is used\n\t// to remove items on destroyed from Model Lists.\n\t// but there should be a better way.\n\tqueues.batch.start();\n\teventQueue.dispatch.call(instance, {type: funcName, target: instance});\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tif (this.id) {\n\t\t\tdev.log(\"can-connect/can/map/map.js - \" + (constructor.shortName || this.name) + \" \" + this.id(instance) + \" \" + funcName);\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// Call event on the instance's Class\n\teventQueue.dispatch.call(constructor, funcName, [instance]);\n\tqueues.batch.stop();\n};\n\n\nvar mapOverwrites = {\n\tstatic: {\n\t\t/**\n\t\t * @function can-connect/can/map/map.getList getList\n\t\t * @parent can-connect/can/map/map.map-static\n\t\t *\n\t\t * Retrieve a list of instance.\n\t\t *\n\t\t * @signature `Map.getList(query)`\n\t\t *\n\t\t * `.getList` is added to the configured [can-connect/can/map/map._Map] type. Retrieves a [can-connect/can/map/map._List] of\n\t\t * [can-connect/can/map/map._Map] instances via the connection.\n\t\t *\n\t\t * ```js\n\t\t * // import connection plugins\n\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t *\n\t\t * // define connection types\n\t\t * var Todo = DefineMap.extend({\n\t\t *   id: \"number\",\n\t\t *   complete: \"boolean\",\n\t\t *   name: \"string\"\n\t\t * });\n\t\t *\n\t\t * Todo.List = DefineList.extend({\n\t\t *   completed: function() {\n\t\t *     return this.filter(function(item) { return item.completed; });\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * // create connection\n\t\t * connect([canMap, constructor, dataUrl],{\n\t\t *   Map: Todo,\n\t\t *   url: \"/todos\"\n\t\t * })\n\t\t *\n\t\t * // retrieve instances\n\t\t * Todo.getList({filter: {due: \"today\"}}).then(function(todos){\n\t\t *   ...\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * @param {can-query-logic/query} query Definition of the list being retrieved.\n\t\t * @return {Promise<Map>} `Promise` returning the [can-connect/can/map/map._List] of instances being retrieved\n\t\t *\n\t\t *\n\t\t *\n\t\t *\n\t\t */\n\t\tgetList: function (base, connection) {\n\t\t\treturn function(set) {\n\t\t\t\treturn connection.getList(set);\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * @function can-connect/can/map/map.findAll findAll\n\t\t * @parent can-connect/can/map/map.map-static\n\t\t * @hide\n\t\t *\n\t\t * Alias of [can-connect/can/map/map.getList]. You should use `.getList()`.\n\t\t */\n\t\tfindAll: function (base, connection) {\n\t\t\treturn function(set) {\n\t\t\t\treturn connection.getList(set);\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * @function can-connect/can/map/map.get get\n\t\t * @parent can-connect/can/map/map.map-static\n\t\t *\n\t\t * Use it to get a single instance by id.\n\t\t *\n\t\t * @signature `Map.get(params)`\n\t\t *\n\t\t * `.get()` is added to the configured [can-connect/can/map/map._Map] type.\n\t\t * Use it to get a single instance by the identity keys of the Map type.\n\t\t *\n\t\t * ```js\n\t\t * // import connection plugins\n\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t *\n\t\t * // define connection type\n\t\t * var Todo = DefineMap.extend({\n\t\t *   id: \"number\",\n\t\t *   complete: \"boolean\",\n\t\t *   name: \"string\"\n\t\t * });\n\t\t *\n\t\t * // create connection\n\t\t * connect([canMap, constructor, dataUrl],{\n\t\t *   Map: Todo,\n\t\t *   url: \"/todos\"\n\t\t * })\n\t\t *\n\t\t * // retrieve instance\n\t\t * Todo.get({id: 5}).then(function(todo){\n\t\t *   ...\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * @param {Object} params Identifying parameters of the instance to retrieve. Typically, this is an object\n\t\t * with the identity property and its value like: `{_id: 5}`.\n\t\t * @return {Promise<Map>} `Promise` returning the [can-connect/can/map/map._Map] instance being retrieved\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Get a single record by filtering non-identity keys\n\t\t *\n\t\t * Sometimes, you want a single record, but by filtering non-identity keys.  Instead of using\n\t\t * `.get`, use `.getList` like:\n\t\t *\n\t\t * ```js\n\t\t * var firstCompleteTodo = Todo.getList({\n\t\t *   filter: {complete: false},\n\t\t *   page: {start: 0, end: 0}\n\t\t * }).then(function(list){\n\t\t *   return list.length ? list[0] : Promise.reject({message: \"reject message\"});\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t */\n\t\tget: function (base, connection) {\n\t\t\treturn function(params) {\n\t\t\t\t// adds .then for compat\n\t\t\t\treturn connection.get(params);\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * @function can-connect/can/map/map.findOne findOne\n\t\t * @parent can-connect/can/map/map.map-static\n\t\t * @hide\n\t\t *\n\t\t * Alias of [can-connect/can/map/map.get]. You should use `.get()`.\n\t\t */\n\t\tfindOne: function (base, connection) {\n\t\t\treturn function(params) {\n\t\t\t\t// adds .then for compat\n\t\t\t\treturn connection.get(params);\n\t\t\t};\n\t\t}\n\t},\n\tprototype: {\n\t\tisNew: function (base, connection) {\n\t\t\t/**\n\t\t\t * @function can-connect/can/map/map.prototype.isNew isNew\n\t\t\t * @parent can-connect/can/map/map.map\n\t\t\t *\n\t\t\t * If the data is not in the dat\n\t\t\t *\n\t\t\t * @signature `instance.isNew()`\n\t\t\t *\n\t\t\t * Returns if the instance has not been loaded from or saved to the data source.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * connect([...],{\n\t\t\t *   Map: Todo\n\t\t\t * });\n\t\t\t *\n\t\t\t * var todo = new Todo();\n\t\t\t * todo.isNew()   //-> true\n\t\t\t *\n\t\t\t * todo.save().then(function(){\n\t\t\t *   todo.isNew() //-> false\n\t\t\t * })\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @return {Boolean} Returns `true` if [can-connect/base/base.id] is `null` or `undefined`.\n\t\t\t */\n\t\t\treturn function () {\n\t\t\t\treturn connection.isNew(this);\n\t\t\t};\n\t\t},\n\n\t\tisSaving: function (base, connection) {\n\t\t\t/**\n\t\t\t * @function can-connect/can/map/map.prototype.isSaving isSaving\n\t\t\t * @parent can-connect/can/map/map.map\n\t\t\t *\n\t\t\t * Returns if the instance is currently being saved.\n\t\t\t *\n\t\t\t * @signature `instance.isSaving()`\n\t\t\t *\n\t\t\t * Observes if a promise returned by [can-connect/connection.save `connection.save`] is in progress for this\n\t\t\t * instance.  This is often used in a template like:\n\t\t\t *\n\t\t\t * ```html\n\t\t\t * <button on:click=\"todo.save()\"\n\t\t\t *    disabled:from=\"todo.isSaving()\">\n\t\t\t *   Save Changes\n\t\t\t * </button>\n\t\t\t * ```\n\t\t\t *\n\t\t\t *   @return {Boolean} Returns `true` if [can-connect/connection.save `connection.save`] has been called for this\n\t\t\t *   instance but the returned promise has not yet resolved.\n\t\t\t */\n\t\t\treturn function () {\n\t\t\t\treturn !!canReflect.getKeyValue(this,\"_saving\");\n\t\t\t};\n\t\t},\n\n\t\tisDestroying: function (base, connection) {\n\t\t\t/**\n\t\t\t * @function can-connect/can/map/map.prototype.isDestroying isDestroying\n\t\t\t * @parent can-connect/can/map/map.map\n\t\t\t *\n\t\t\t * Returns if the instance is currently being destroyed.\n\t\t\t *\n\t\t\t * @signature `instance.isDestroying()`\n\t\t\t *\n\t\t\t * Observes if a promise returned by [can-connect/connection.destroy `connection.destroy`] is in progress for this\n\t\t\t * instance.  This is often used in a template like:\n\t\t\t *\n\t\t\t * ```html\n\t\t\t * <button on:click=\"todo.destroy()\"\n\t\t\t *         disabled:from=\"todo.isDestroying()\">\n\t\t\t *   Delete\n\t\t\t * </button>\n\t\t\t * ```\n\t\t\t *\n\t\t\t *   @return {Boolean} `true` if [can-connect/connection.destroy `connection.destroy`] has been called for this\n\t\t\t *   instance but the returned promise has not resolved.\n\t\t\t */\n\t\t\treturn function () {\n\t\t\t\treturn !!canReflect.getKeyValue(this,\"_destroying\");\n\t\t\t};\n\t\t},\n\n\t\tsave: function (base, connection) {\n\t\t\t/**\n\t\t\t * @function can-connect/can/map/map.prototype.save save\n\t\t\t * @parent can-connect/can/map/map.map\n\t\t\t *\n\t\t\t * Save or update client data to the persisted data source.\n\t\t\t *\n\t\t\t * @signature `instance.save(success, error)`\n\t\t\t *\n\t\t\t * Calls [can-connect/connection.save].\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * // import connection plugins\n\t\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t\t *\n\t\t\t * // define connection types\n\t\t\t * var Todo = DefineMap.extend({\n\t\t\t *   id: \"number\",\n\t\t\t *   complete: \"boolean\",\n\t\t\t *   name: \"string\"\n\t\t\t * });\n\t\t\t *\n\t\t\t * // create connection\n\t\t\t * connect([canMap, constructor, dataUrl], {\n\t\t\t *   Map: Todo,\n\t\t\t *   url: \"/todos\"\n\t\t\t * })\n\t\t\t *\n\t\t\t * new Todo({name: \"dishes\"}).save();\n\t\t\t * ```\n\t\t\t *\n\t\t\t *   @param {function} success A function that is called if the save is successful.\n\t\t\t *   @param {function} error A function that is called if the save is rejected.\n\t\t\t *   @return {Promise<Instance>} A promise that resolves to the instance if successful.\n\t\t\t *\n\t\t\t *\n\t\t\t */\n\t\t\treturn function(success, error){\n\t\t\t\t// return only one item for compatability\n\t\t\t\tvar promise = connection.save(this);\n\t\t\t\tpromise.then(success,error);\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t},\n\t\tdestroy: function (base, connection) {\n\t\t\t/**\n\t\t\t * @function can-connect/can/map/map.prototype.destroy destroy\n\t\t\t * @parent can-connect/can/map/map.map\n\t\t\t *\n\t\t\t * Delete an instance from the service via the connection.\n\t\t\t *\n\t\t\t * @signature `instance.destroy(success, error)`\n\t\t\t *\n\t\t\t * Calls [can-connect/connection.destroy] for the `instance`.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * // import connection plugins\n\t\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t\t *\n\t\t\t * // define connection types\n\t\t\t * var Todo = DefineMap.extend({\n\t\t\t *   id: \"number\",\n\t\t\t *   complete: \"boolean\",\n\t\t\t *   name: \"string\"\n\t\t\t * });\n\t\t\t *\n\t\t\t * // create connection\n\t\t\t * connect([canMap, constructor, dataUrl],{\n\t\t\t *   Map: Todo,\n\t\t\t *   url: \"/todos\"\n\t\t\t * })\n\t\t\t *\n\t\t\t * // read instance\n\t\t\t * Todo.get({id: 5}).then(function(todo){\n\t\t\t *   if (todo.complete) {\n\t\t\t *     // delete instance\n\t\t\t *     todo.destroy();\n\t\t\t *   }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {function} success a function that is called if the [can-connect/connection.destroy] call is successful.\n\t\t\t * @param {function} error a function that is called if the [can-connect/connection.destroy] call is rejected.\n\t\t\t * @return {Promise<Instance>} a promise that resolves to the instance if successful\n\t\t\t *\n\t\t\t *\n\t\t\t */\n\t\t\treturn function(success, error){\n\t\t\t\tvar promise = connection.destroy(this);\n\t\t\t\tpromise.then(success,error);\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t}\n\t},\n\tproperties: {\n\t\t_saving: {enumerable: false, value: false, configurable: true, writable: true},\n\t\t_destroying: {enumerable: false, value: false, configurable: true, writable: true}\n\t}\n};\n\nvar listOverwrites = {\n\tstatic:  {\n\t\t_bubbleRule: function(base, connection) {\n\t\t\treturn function(eventName, list) {\n\t\t\t\tvar bubbleRules = base(eventName, list);\n\t\t\t\tbubbleRules.push('destroyed');\n\t\t\t\treturn bubbleRules;\n\t\t\t};\n\t\t}\n\t},\n\tprototype: {\n\t\tsetup: function(base, connection){\n\t\t\treturn function (params) {\n\t\t\t\t// If there was a plain object passed to the List constructor,\n\t\t\t\t// we use those as parameters for an initial getList.\n\t\t\t\tif (isPlainObject(params) && !Array.isArray(params)) {\n\t\t\t\t\tthis[connection.listQueryProp] = params;\n\t\t\t\t\tbase.apply(this);\n\t\t\t\t\tthis.replace(canReflect.isPromise(params) ? params : connection.getList(params));\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, set up the list like normal.\n\t\t\t\t\tbase.apply(this, arguments);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\tproperties: {}\n};\n\nvar overwrite = function( connection, Constructor, overwrites) {\n\tvar prop;\n\tfor(prop in overwrites.properties) {\n\t\tcanReflect.defineInstanceKey(Constructor, prop, overwrites.properties[prop]);\n\t}\n\tfor(prop in overwrites.prototype) {\n\t\tConstructor.prototype[prop] = overwrites.prototype[prop](Constructor.prototype[prop], connection);\n\t}\n\tif(overwrites.static) {\n\t\tfor(prop in overwrites.static) {\n\t\t\tConstructor[prop] = overwrites.static[prop](Constructor[prop], connection);\n\t\t}\n\t}\n};\n\nmodule.exports = canMapBehavior;\n\n//!steal-remove-start\nif(true) {\n\tvar validate = __webpack_require__(/*! ../../helpers/validate */ \"./node_modules/can-connect/helpers/validate.js\");\n\n\tmodule.exports = validate(\n\t\tcanMapBehavior,\n\t\t[\n\t\t\t'id', 'get', 'updatedList', 'destroy', 'save', 'getList'\n\t\t]\n\t);\n}\n//!steal-remove-end\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/can/map/map.js?");

/***/ }),

/***/ "./node_modules/can-connect/can/ref/ref.js":
/*!*************************************************!*\
  !*** ./node_modules/can-connect/can/ref/ref.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {connect.Behavior} can-connect/can/ref/ref can/ref\n * @parent can-connect.behaviors\n * @group can-connect/can/ref/ref.hydrators hydrators\n * @group can-connect/can/ref/ref.methods methods\n *\n * @description Handle references to instances in the data returned by the server. Allows several means of\n * loading referenced instances, determined on-the-fly.\n *\n * @signature `canRef( baseConnection )`\n *\n * Adds a reference type to [can-connect/can/map/map._Map `connection.Map`] that loads the related type or holds onto\n * an existing one. This handles circular references and loads relevant data as needed. The reference type can be loaded\n * by:\n * - it's data being included in the response for the referencing instance\n * - having an existing instance available in the [can-connect/constructor/store/store.instanceStore]\n * - lazy loading via the connection for the reference type\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `can/ref` behavior added on to it.\n * Expects the [can-connect/can/map/map] behavior to already be added to this base connection. If the `connect` helper\n * is used to build the connection, the behaviors will automatically be ordered as required.\n *\n * @return {{}} a connection with the [can-connect/can/map/map._Map `Map`] having the reference type property\n * (`Map.Ref.type`) created by `can/ref`.\n *\n * @body\n *\n * ## Use\n *\n * `can/ref` is useful when the server might return either a reference to\n * a value or the value itself.  For example, in a MongoDB setup,\n * a request like `GET /game/5` might return:\n *\n * ```\n * {\n *   id: 5,\n *   teamRef: 7,\n *   score: 21\n * }\n * ```\n *\n * But a request like `GET /game/5?$populate=teamRef` might return:\n *\n * ```\n * {\n *   id: 5,\n *   teamRef: {id: 7, name: \"Cubs\"},\n *   score: 21\n * }\n * ```\n *\n * `can/ref` can handle this ambiguity and even make lazy loading possible.\n *\n * To use `can/ref`, first create a Map and a connection for the referenced type:\n *\n * ```\n * var Team = DefineMap.extend({\n *   id: 'string'\n * });\n *\n * connect([\n *   require(\"can-connect/constructor/constructor\"),\n *   require(\"can-connect/constructor/store/store\"),\n *   require(\"can-connect/can/map/map\"),\n *   require(\"can-connect/can/ref/ref\")\n * ],{\n *     Map: Team,\n *     List: Team.List,\n *     ...\n * })\n * ```\n *\n * The connection is necessary because it creates an instance store which will\n * hold instances of `Team` that the `Team.Ref` type will be able to access.\n *\n * Now we can create a reference to the Team within a Game map and the Game's connection:\n *\n * ```\n * var Game = DefineMap.extend({\n *   id: 'string',\n *   teamRef: {type: Team.Ref.type},\n *   score: \"number\"\n * });\n *\n * superMap({\n *   Map: Game,\n *   List: Game.List\n * })\n * ```\n *\n * Now, `teamRef` is a [can-connect/can/ref/ref.Map.Ref] type, which will\n * house the id of the reference no matter how the server returns data, e.g.\n * `game.teamRef.id`.\n *\n * For example, without populating the team data:\n *\n * ```\n * Game.get({id: 5}).then(function(game){\n *   game.teamRef.id //-> 7\n * });\n * ```\n *\n * With populating the team data:\n *\n * ```\n * Game.get({id: 5, $populate: \"teamRef\"}).then(function(game){\n *   game.teamRef.id //-> 7\n * });\n * ```\n *\n * The values of other properties and methods on the [can-connect/can/ref/ref.Map.Ref] type\n * are determined by if the reference was populated or the referenced item already exists\n * in the [can-connect/constructor/store/store.instanceStore].\n *\n * For example, `value`, which points to the referenced instance, will be populated if the reference was populated:\n *\n * ```\n * Game.get({id: 5, $populate: \"teamRef\"}).then(function(game){\n *   game.teamRef.value.name //-> 5\n * });\n * ```\n *\n * Or, it will be populated if that instance had been loaded through another means and\n * itâ€™s in the instance store:\n *\n * ```\n * Team.get({id: 7}).then(function(team){\n *   // binding adds things to the store\n *   team.on(\"name\", function(){})\n * }).then(function(){\n *   Game.get({id: 5}).then(function(game){\n *     game.teamRef.value.name //-> 5\n *   });\n * })\n * ```\n *\n * `value` is an [can-define.types.get asynchronous getter], which means that even if\n * the referenced value isn't populated or loaded through the store, it can be lazy loaded. This\n * is generally most useful in a template.\n *\n * The following will make an initial request for game `5`, but when the template\n * tried to read and listen to `game.teamRef.value.name`, a request for team `7`\n * will be made.\n *\n * ```\n * var template = stache(\"{{game.teamRef.value.name}} scored {{game.score}} points\");\n * Game.get({id: 5}).then(function(game){\n *   template({game: game});\n * });\n * ```\n *\n *\n */\nvar connect = __webpack_require__(/*! ../../can-connect */ \"./node_modules/can-connect/can-connect.js\");\nvar WeakReferenceMap = __webpack_require__(/*! ../../helpers/weak-reference-map */ \"./node_modules/can-connect/helpers/weak-reference-map.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar constructorStore = __webpack_require__(/*! ../../constructor/store/store */ \"./node_modules/can-connect/constructor/store/store.js\");\nvar define = __webpack_require__(/*! can-define */ \"./node_modules/can-define/can-define.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar makeRef = function(connection) {\n\tvar idProp = canReflect.getSchema(connection.queryLogic).identity[0];\n\t/**\n\t * @property {constructor} can-connect/can/ref/ref.Map.Ref Map.Ref\n\t * @parent can-connect/can/ref/ref.hydrators\n\t * @group can-connect/can/ref/ref.Map.Ref.static static\n\t * @group can-connect/can/ref/ref.Map.Ref.prototype prototype\n\t *\n\t * A reference type with `instanceRef.value` primed to return an existing instance of the\n\t * [can-connect/can/map/map._Map] type, if available, or lazy load an instance upon accessing `instanceRef.value`.\n\t *\n\t * @signature `new Map.Ref(id, value)`\n\t * @param  {string} id    string representing the record id\n\t * @param  {Object} value properties to be loaded / hydrated\n\t * @return {Map.Ref}       instance reference object for the id\n\t */\n\tvar Ref = (function(){\n\t\treturn function(id, value) {\n\t\t\tif (typeof id === \"object\") {\n\t\t\t\tvalue = id;\n\t\t\t\tid = value[idProp];\n\t\t\t}\n\t\t\t// check if this is in the store\n\t\t\tvar storeRef = Ref.store.get(id);\n\t\t\tif (storeRef) {\n\t\t\t\tif (value && !storeRef._value) {\n\t\t\t\t\tif (value instanceof connection.Map) {\n\t\t\t\t\t\tstoreRef._value = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstoreRef._value = connection.hydrateInstance(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn storeRef;\n\t\t\t}\n\t\t\t// if not, create it\n\t\t\tthis[idProp] = id;\n\t\t\tif (value) {\n\t\t\t\t// if the value is already an instance, use it.\n\n\t\t\t\tif (value instanceof connection.Map) {\n\t\t\t\t\tthis._value = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis._value = connection.hydrateInstance(value);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// check if this is being made during a request\n\t\t\t// if it is, save it\n\t\t\tif (constructorStore.requests.count() > 0) {\n\t\t\t\tif (!Ref._requestInstances[id]) {\n\t\t\t\t\tRef.store.addReference(id, this);\n\t\t\t\t\tRef._requestInstances[id] = this;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t})();\n\t/**\n\t * @property {can-connect/helpers/weak-reference-map} can-connect/can/ref/ref.Map.Ref.store store\n\t * @parent can-connect/can/ref/ref.Map.Ref.static\n\t * @hide // not something that needs to be documented for the average user\n\t * A WeakReferenceMap that contains instances being created by their `._cid` property.\n\t */\n\tRef.store = new WeakReferenceMap();\n\tRef._requestInstances = {};\n\t/**\n\t * @function can-connect/can/ref/ref.Map.Ref.type type\n\t * @parent can-connect/can/ref/ref.Map.Ref.static\n\t *\n\t * Returns a new instance of `Map.Ref`.\n\t *\n\t * @signature `Map.Ref.type(reference)`\n\t *\n\t *   @param {Object|String|Number} reference either data or an id for an instance of [can-connect/can/map/map._Map].\n\t *   @return {can-connect/can/ref/ref.Map.Ref} reference instance for the passed data or identifier.\n\t */\n\tRef.type = function(ref) {\n\t\tif (ref && typeof ref !== \"object\") {\n\t\t\t// get or make the existing reference from the store\n\t\t\treturn new Ref(ref);\n\t\t} else {\n\t\t\t// get or make the reference in the store, update the instance too\n\t\t\treturn new Ref(ref[idProp], ref);\n\t\t}\n\t};\n\tvar defs = {\n\t\t/**\n\t\t * @property {Promise} can-connect/can/ref/ref.Map.Ref.prototype.promise promise\n\t\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t\t * @hide // don't know if this is part of the public API\n\t\t *\n\t\t * Returns a resolved promise if the referenced instance is already available, if not, returns a new promise\n\t\t * to retrieve the instance by the id.\n\t\t *\n\t\t * @signature `ref.promise`\n\t\t * @return {Promise} Promise resolving the instance referenced\n\t\t */\n\t\tpromise: {\n\t\t\tget: function() {\n\t\t\t\tif (this._value) {\n\t\t\t\t\treturn Promise.resolve(this._value);\n\t\t\t\t} else {\n\t\t\t\t\tvar props = {};\n\t\t\t\t\tprops[idProp] = this[idProp];\n\t\t\t\t\treturn connection.Map.get(props);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_state: {\n\t\t\tget: function(lastSet, resolve) {\n\t\t\t\tif (resolve) {\n\t\t\t\t\tthis.promise.then(function() {\n\t\t\t\t\t\tresolve(\"resolved\");\n\t\t\t\t\t}, function() {\n\t\t\t\t\t\tresolve(\"rejected\");\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn \"pending\";\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @property {*} can-connect/can/ref/ref.Map.Ref.prototype.value value\n\t\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t\t *\n\t\t * Returns the actual instance the reference points to. Returns `undefined` if the instance is still being loaded.\n\t\t * Accessing this property will start lazy loading if the instance isn't already available.\n\t\t *\n\t\t * @signature `ref.value`\n\t\t * @return {object} actual instance referenced or `undefined` if lazy loading ongoing\n\t\t */\n\t\tvalue: {\n\t\t\tget: function(lastSet, resolve) {\n\t\t\t\tif (this._value) {\n\t\t\t\t\treturn this._value;\n\t\t\t\t} else if (resolve) {\n\t\t\t\t\tthis.promise.then(function(value) {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @property {*} can-connect/can/ref/ref.Map.Ref.prototype.reason reason\n\t\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t\t *\n\t\t * Returns the failure message from the lazy loading promise. Returns `undefined` if the referenced instance is\n\t\t * available or loading is ongoing.\n\t\t *\n\t\t * @signature `ref.reason`\n\t\t * @return {Object} error message if the promise is rejected\n\t\t */\n\t\treason: {\n\t\t\tget: function(lastSet, resolve) {\n\t\t\t\tif (this._value) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\tthis.promise.catch(function(value) {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tdefs[idProp] = {\n\t\ttype: \"*\",\n\t\tset: function() {\n\t\t\tthis._value = undefined;\n\t\t}\n\t};\n\n\tdefine(Ref.prototype, defs);\n\n\tRef.prototype.unobservedId = ObservationRecorder.ignore(function() {\n\t\treturn this[idProp];\n\t});\n\t/**\n\t * @function can-connect/can/ref/ref.Map.Ref.prototype.isResolved isResolved\n\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t *\n\t * Observable property typically for use in templates to indicate to the user if lazy loading has succeeded.\n\t *\n\t * @signature `ref.isResolved`\n\t * @return {boolean} `true` if the lazy loading promise was resolved.\n\t */\n\tRef.prototype.isResolved = function() {\n\t\treturn !!this._value || this._state === \"resolved\";\n\t};\n\t/**\n\t * @function can-connect/can/ref/ref.Map.Ref.prototype.isRejected isRejected\n\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t *\n\t * Observable property typically for use in templates to indicate to the user if lazy loading has failed.\n\t *\n\t * @signature `ref.isRejected`\n\t * @return {boolean} `true` if the lazy loading promise was rejected.\n\t */\n\tRef.prototype.isRejected = function() {\n\t\treturn this._state === \"rejected\";\n\t};\n\n\t/**\n\t * @function can-connect/can/ref/ref.Map.Ref.prototype.isPending isPending\n\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t *\n\t * Observable property typically for use in templates to indicate to the user if lazy loading is ongoing.\n\t *\n\t * @signature `ref.isPending`\n\t * @return {boolean} `true` if the lazy loading promise state is not resolved or rejected.\n\t */\n\tRef.prototype.isPending = function() {\n\t\treturn !this._value && (this._state !== \"resolved\" || this._state !== \"rejected\");\n\t};\n\n\t/**\n\t * @function can-connect/can/ref/ref.Map.Ref.prototype.serialize serialize\n\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t *\n\t * Return the id of the referenced instance when serializing. Prevents the referenced instance from\n\t * being entirely serialized when serializing the referencing instance.\n\t *\n\t * @signature `ref.serialize`\n\t * @return {string} id the id of the referenced instance\n\t */\n\tRef.prototype.serialize = function() {\n\t\treturn this[idProp];\n\t};\n\tcanReflect.assignSymbols(Ref.prototype, {\n\t\t\"can.serialize\": Ref.prototype.serialize,\n\t\t\"can.getName\": function(){\n\t\t\treturn canReflect.getName(this.constructor)+\"{\"+this[idProp]+\"}\";\n\t\t}\n\t});\n\n\tvar baseEventSetup = Ref.prototype._eventSetup;\n\tRef.prototype._eventSetup = function() {\n\t\tRef.store.addReference(this.unobservedId(), this);\n\t\treturn baseEventSetup.apply(this, arguments);\n\t};\n\tvar baseTeardown = Ref.prototype._eventTeardown;\n\tRef.prototype._eventTeardown = function() {\n\t\tRef.store.deleteReference(this.unobservedId(), this);\n\t\treturn baseTeardown.apply(this, arguments);\n\t};\n\n\n\tconstructorStore.requests.on(\"end\", function() {\n\t\tfor (var id in Ref._requestInstances) {\n\t\t\tRef.store.deleteReference(id);\n\t\t}\n\t\tRef._requestInstances = {};\n\t});\n\n\t//!steal-remove-start\n\tObject.defineProperty(Ref, \"name\", {\n\t\tvalue: canReflect.getName(connection.Map) + \"Ref\",\n\t\tconfigurable: true\n\t});\n\t//!steal-remove-end\n\n\treturn Ref;\n};\n\n\nmodule.exports = connect.behavior(\"can/ref\", function(baseConnection) {\n\treturn {\n\t\t/**\n\t\t * @can-connect/can/ref/ref.init init\n\t\t * @parent can-connect/can/ref/ref.methods\n\t\t *\n\t\t * @signature `connection.init()`\n\t\t *\n\t\t * Initializes the base connection and then creates and sets [can-connect/can/ref/ref.Map.Ref].\n\t\t * Typically called by the `connect` helper after the connection behaviors have been assembled.\n\t\t *\n\t\t * @return {undefined} no return value\n\t\t **/\n\t\tinit: function() {\n\t\t\tbaseConnection.init.apply(this, arguments);\n\t\t\tthis.Map.Ref = makeRef(this);\n\t\t}\n\t};\n});\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/can/ref/ref.js?");

/***/ }),

/***/ "./node_modules/can-connect/can/session/session.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-connect/can/session/session.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar reflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar connect = __webpack_require__(/*! ../../connect */ \"./node_modules/can-connect/connect.js\");\nvar singleton = __webpack_require__(/*! can-define-connected-singleton */ \"./node_modules/can-define-connected-singleton/can-define-connected-singleton.js\");\n\nmodule.exports = connect.behavior(\"can/session\", function(higherBehaviors) {\n\treturn {\n\t\t// return a dummy id when destroying, otherwise the constructor behavior will skip making a DELETE request\n\t\tid: function(instance) {\n\t\t\tif (instance.isDestroying()) {\n\t\t\t\treturn reflect.getName(this.Map) + '-singleton';\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t},\n\t\tinit: function() {\n\t\t\thigherBehaviors.init.apply(this, arguments);\n\n\t\t\tsingleton(this.Map);\n\t\t},\n\t\tcreatedInstance: function(instance) {\n\t\t\thigherBehaviors.createdInstance.apply(this, arguments);\n\n\t\t\tthis.Map.current = instance;\n\t\t},\n\t\tdestroyedInstance: function() {\n\t\t\thigherBehaviors.destroyedInstance.apply(this, arguments);\n\n\t\t\tthis.Map.current = undefined;\n\t\t},\n\t};\n});\n\n//# sourceURL=webpack:///./node_modules/can-connect/can/session/session.js?");

/***/ }),

/***/ "./node_modules/can-connect/can/super-map/super-map.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-connect/can/super-map/super-map.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar connect = __webpack_require__(/*! ../../can-connect */ \"./node_modules/can-connect/can-connect.js\");\n\nvar constructor = __webpack_require__(/*! ../../constructor/constructor */ \"./node_modules/can-connect/constructor/constructor.js\");\nvar canMap = __webpack_require__(/*! ../map/map */ \"./node_modules/can-connect/can/map/map.js\");\nvar canRef = __webpack_require__(/*! ../ref/ref */ \"./node_modules/can-connect/can/ref/ref.js\");\nvar constructorStore = __webpack_require__(/*! ../../constructor/store/store */ \"./node_modules/can-connect/constructor/store/store.js\");\nvar dataCallbacks = __webpack_require__(/*! ../../data/callbacks/callbacks */ \"./node_modules/can-connect/data/callbacks/callbacks.js\");\nvar callbacksCache = __webpack_require__(/*! ../../data/callbacks-cache/callbacks-cache */ \"./node_modules/can-connect/data/callbacks-cache/callbacks-cache.js\");\nvar combineRequests = __webpack_require__(/*! ../../data/combine-requests/combine-requests */ \"./node_modules/can-connect/data/combine-requests/combine-requests.js\");\nvar localCache = __webpack_require__(/*! ../../data/localstorage-cache/localstorage-cache */ \"./node_modules/can-connect/data/localstorage-cache/localstorage-cache.js\");\nvar dataParse = __webpack_require__(/*! ../../data/parse/parse */ \"./node_modules/can-connect/data/parse/parse.js\");\nvar dataUrl = __webpack_require__(/*! ../../data/url/url */ \"./node_modules/can-connect/data/url/url.js\");\nvar fallThroughCache = __webpack_require__(/*! ../../fall-through-cache/fall-through-cache */ \"./node_modules/can-connect/fall-through-cache/fall-through-cache.js\");\nvar realTime = __webpack_require__(/*! ../../real-time/real-time */ \"./node_modules/can-connect/real-time/real-time.js\");\nvar callbacksOnce = __webpack_require__(/*! ../../constructor/callbacks-once/callbacks-once */ \"./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js\");\nvar GLOBAL = __webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\n\nvar $ = GLOBAL().$;\n\nconnect.superMap = function(options){\n\n\tvar behaviors = [\n\t\tconstructor,\n\t\tcanMap,\n\t\tcanRef,\n\t\tconstructorStore,\n\t\tdataCallbacks,\n\t\tcombineRequests,\n\t\tdataParse,\n\t\tdataUrl,\n\t\trealTime,\n\t\tcallbacksOnce];\n\n\tif(typeof localStorage !== \"undefined\") {\n\t\tif(!options.cacheConnection) {\n\t\t\toptions.cacheConnection = connect([localCache],{\n\t\t\t\tname: options.name+\"Cache\",\n\t\t\t\tidProp: options.idProp,\n\t\t\t\tqueryLogic: options.queryLogic\n\t\t\t});\n\t\t}\n\t\tbehaviors.push(callbacksCache,fallThroughCache);\n\t}\n\t// Handles if jQuery isn't provided.\n\tif($ && $.ajax) {\n\t\toptions.ajax = $.ajax;\n\t}\n\treturn connect(behaviors,options);\n};\n\nmodule.exports = connect.superMap;\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/can/super-map/super-map.js?");

/***/ }),

/***/ "./node_modules/can-connect/connect.js":
/*!*********************************************!*\
  !*** ./node_modules/can-connect/connect.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var behavior = __webpack_require__(/*! ./behavior */ \"./node_modules/can-connect/behavior.js\");\n\n/**\n *\n * @param {Array<String,Behavior,function>} behaviors - An array of behavior names or custom behaviors.\n * The order of named execution gets run in order.\n * @param {Object} options\n * @hide\n */\nvar connect = function(behaviors, options){\n\n\tbehaviors = behaviors.map(function(behavior, index){\n\t\tvar sortedIndex = -1;\n\t\tif(typeof behavior === \"string\") {\n\t\t\tsortedIndex = connect.order.indexOf(behavior);\n\t\t\tbehavior = behavior.map[behavior];\n\t\t} else if(behavior.isBehavior) {\n\t\t\tsortedIndex = connect.order.indexOf(behavior.behaviorName);\n\t\t} else {\n\t\t\tbehavior = connect.behavior(behavior);\n\t\t}\n\n\t\treturn {\n\t\t\toriginalIndex: index,\n\t\t\tsortedIndex: sortedIndex,\n\t\t\tbehavior: behavior\n\t\t};\n\t});\n\n\tbehaviors.sort(function(b1, b2){\n\t\t// if both have a sorted index\n\t\tif(~b1.sortedIndex && ~b2.sortedIndex) {\n\t\t\treturn b1.sortedIndex - b2.sortedIndex;\n\t\t}\n\t\treturn b1.originalIndex - b2.originalIndex;\n\t});\n\n\tbehaviors = behaviors.map(function(b){\n\t\treturn b.behavior;\n\t});\n\n\tvar behavior = connect.base( connect.behavior(\"options\",function(){return options; })() );\n\n\tbehaviors.forEach(function(behave){\n\t\tbehavior = behave(behavior);\n\t});\n\tif(behavior.init) {\n\t\tbehavior.init();\n\t}\n\treturn behavior;\n};\n\n\n\nconnect.order = [\"data/localstorage-cache\",\"data/url\",\"data/parse\",\"cache-requests\",\"data/combine-requests\",\n\n\t\"constructor\",\"constructor/store\",\"can/map\",\"can/ref\",\n\t\"fall-through-cache\",\n\n\t\"data/worker\",\"real-time\",\n\n\t\"data/callbacks-cache\",\"data/callbacks\",\"constructor/callbacks-once\"\n];\n\nconnect.behavior = behavior;\n\n\n\nmodule.exports= connect;\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/connect.js?");

/***/ }),

/***/ "./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-connect/constructor/callbacks-once/callbacks-once constructor/callbacks-once\n * @parent can-connect.behaviors\n *\n * Prevents duplicate calls to the instance callback methods.\n *\n * @signature `callbacksOnce( baseConnection )`\n *\n *   Prevents duplicate calls to the instance callback methods by tracking the last data the methods were called with.\n *   If called with the same data again, it does not call the base connection's instance callback.\n *\n *   @param {{}} baseConnection `can-connect` connection object that is having the `callbacks-once` behavior added\n *   on to it. Should already contain the behaviors that provide the Instance Callbacks\n *   (e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the\n *   behaviors will automatically be ordered as required.\n *\n *   @return {Object} A `can-connect` connection containing the methods provided by `callbacks-once`.\n *\n */\nvar connect = __webpack_require__(/*! ../../can-connect */ \"./node_modules/can-connect/can-connect.js\");\nvar sortedSetJSON = __webpack_require__(/*! ../../helpers/sorted-set-json */ \"./node_modules/can-connect/helpers/sorted-set-json.js\");\nvar forEach = [].forEach;\n\n// wires up the following methods\nvar callbacks = [\n\t/**\n\t * @function can-connect/constructor/callbacks-once/callbacks-once.createdInstance createdInstance\n\t * @parent can-connect/constructor/callbacks-once/callbacks-once\n\t *\n\t * `createdInstance` callback handler that prevents sequential calls with the same arguments.\n\t *\n\t * @signature `createdInstance(instance, data)`\n\t * Called with the instance created by [can-connect/constructor/constructor.save `connection.save`] and the response data of the\n\t * underlying request. Prevents sequential calls to the underlying `createdInstance` handlers with the same arguments.\n\t *\n\t * @param {} instance the instance created by `connection.save`\n\t * @param {} data the response data returned during `connection.save`\n\t */\n\t\"createdInstance\",\n\t/**\n\t * @function can-connect/constructor/callbacks-once/callbacks-once.updatedInstance updatedInstance\n\t * @parent can-connect/constructor/callbacks-once/callbacks-once\n\t *\n\t * `updatedInstance` callback handler that prevents sequential calls with the same arguments.\n\t *\n\t * @signature `updatedInstance(instance, data)`\n\t * Called with the instance updated by [can-connect/constructor/constructor.save`connection.save`] and the response data of the\n\t * underlying request. Prevents sequential calls to the underlying `updatedInstance` handlers with the same arguments.\n\t *\n\t * @param {} instance the instance created by `connection.save`\n\t * @param {} data the response data returned during `connection.save`\n\t */\n\t\"updatedInstance\",\n\t/**\n\t * @function can-connect/constructor/callbacks-once/callbacks-once.destroyedInstance destroyedInstance\n\t * @parent can-connect/constructor/callbacks-once/callbacks-once\n\t *\n\t * `destroyedInstance` callback handler that prevents sequential calls with the same arguments.\n\t *\n\t * @signature `destroyedInstance(instance, data)`\n\t * Called with the instance created by [can-connect/constructor/constructor.destroy `connection.destroy`] and the response data of the\n\t * underlying request. Prevents sequential calls to the underlying `destroyedInstance` handlers with the same arguments.\n\t *\n\t * @param {} instance the instance created by `connection.destroy`\n\t * @param {} data the response data returned during `connection.destroy`\n\t */\n\t\"destroyedInstance\"\n];\n\n\n\nvar callbacksOnceBehavior = connect.behavior(\"constructor/callbacks-once\",function(baseConnection){\n\n\tvar behavior = {};\n\n\tforEach.call(callbacks, function(name){\n\t\tbehavior[name] = function(instance, data ){\n\n\t\t\tvar lastSerialized = this.getInstanceMetaData(instance, \"last-data-\" + name);\n\n\t\t\tvar serialize = sortedSetJSON(data);\n\t\t\tif(lastSerialized !== serialize) {\n\t\t\t\tvar result =  baseConnection[name].apply(this, arguments);\n\t\t\t\tthis.addInstanceMetaData(instance, \"last-data-\" + name, serialize);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t});\n\n\treturn behavior;\n});\n\nmodule.exports = callbacksOnceBehavior;\n\n//!steal-remove-start\nif(true) {\n\tvar validate = __webpack_require__(/*! ../../helpers/validate */ \"./node_modules/can-connect/helpers/validate.js\");\n\tmodule.exports = validate(callbacksOnceBehavior, callbacks);\n}\n//!steal-remove-end\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js?");

/***/ }),

/***/ "./node_modules/can-connect/constructor/constructor.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-connect/constructor/constructor.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n\n/**\n * @module {connect.Behavior} can-connect/constructor/constructor constructor\n * @parent can-connect.behaviors\n * @group can-connect/constructor/constructor.options 1 behavior options\n * @group can-connect/constructor/constructor.crud 2 CRUD methods\n * @group can-connect/constructor/constructor.callbacks 3 CRUD callbacks\n * @group can-connect/constructor/constructor.hydrators 4 hydrators\n * @group can-connect/constructor/constructor.serializers 5 serializers\n * @group can-connect/constructor/constructor.helpers 6 helpers\n *\n * Adds an interface to interact with custom types via the connection instead of plain Objects and Arrays.\n *\n * @signature `constructor( baseConnection )`\n *\n * Adds an interface that allows the connection to operate on custom types. These fall into the categories:\n * - [can-connect/constructor/constructor#CRUDMethods CRUD Methods] - create, read, update and delete typed instances via the data source\n * - [can-connect/constructor/constructor#CRUDCallbacks CRUD Callbacks] - activities run on typed instances following data source operations\n * - [can-connect/constructor/constructor#Hydrator Hydrators] - conversion of raw data to typed data\n * - [can-connect/constructor/constructor#Serializers Serializers] - conversion of typed data to raw data\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `constructor` behavior added\n * on to it.\n *\n * @return {Object} A `can-connect` connection containing the method implementations provided by `constructor`.\n *\n * @body\n *\n * ## Use\n *\n * The `constructor` behavior allows you to instantiate the raw representation of the data source's data into a\n * custom typed representation with additional methods and behaviors.\n\n * An example might be loading data from a `\"/todos\"` service and being able to call `.timeLeft()`  on the todos that\n * you get back like:\n *\n * ```js\n * todoConnection.get({id: 6}).then(function(todo){\n *   todo.timeLeft() //-> 60000\n * })\n * ```\n *\n * The following creates a `todoConnection` that does exactly that:\n *\n * ```js\n * // require connection plugins\n * var constructor = require(\"can-connect/constructor/\");\n * var dataUrl = require(\"can-connect/data/url/\");\n *\n * // define type constructor function\n * var Todo = function(data){\n *   // add passed properties to new instance\n *   for(var prop in data) {\n *    this[prop] = data;\n *   }\n * };\n *\n * // add method to get time left before due, in milliseconds\n * Todo.prototype.timeLeft = function(){\n *   return new Date() - this.dueDate\n * };\n *\n * // create connection, passing function to instantiate new instances\n * var todoConnection = connect([constuctor, dataUrl], {\n *   url: \"/todos\",\n *   instance: function(data){\n *     return new Todo(data);\n *   }\n * });\n * ```\n *\n * The `constructor` behavior is still useful even if you want to keep your data as untyped objects (which is the\n * default behavior when no [can-connect/constructor/constructor.instance `instance`] implementation is provided).  The\n * behavior provides an interface to the data held by the client. For example,\n * [can-connect/constructor/constructor.updatedInstance] provides an extension point for logic that needs to be executed\n * after an instance held by the client finishes an update request. This is valuable whether that instance is typed or not.\n * Extensions like [can-connect/real-time/real-time] or [can-connect/fall-through-cache/fall-through-cache]\n * require this interface for advanced behavior.\n *\n * ## Interface\n *\n * `constructor` provides the following categories of methods to interact with typed data:\n *\n * ### <span id=\"CRUDMethods\">CRUD Methods</span>\n *\n * Methods that create, read, update and delete (CRUD) typed representations of raw connection data:\n *\n * - [can-connect/constructor/constructor.get] - retrieve a single typed instance from the data source\n * - [can-connect/constructor/constructor.getList] - retrieve a typed list of instances from the data source\n * - [can-connect/constructor/constructor.save] - save a typed instance's data to the data source\n * - [can-connect/constructor/constructor.destroy] - delete a typed instance's data from the data source\n *\n * ### <span id=\"CRUDCallbacks\">CRUD Callbacks</span>\n *\n * \"CRUD Methods\" call these methods with request response data and a related instance. Their implementation here\n * updates the related instance with that data:\n *\n * - [can-connect/constructor/constructor.createdInstance] - after [can-connect/constructor/constructor.save saving] new instance to data source, update that instance with response data\n * - [can-connect/constructor/constructor.updatedInstance] - after [can-connect/constructor/constructor.save saving] existing instance to data source, update that instance with response data\n * - [can-connect/constructor/constructor.destroyedInstance] - after [can-connect/constructor/constructor.destroy deleting] instance from data source, update that instance with response data\n * - [can-connect/constructor/constructor.updatedList] - after new data is read from the data source, update an existing list with instances created from that data\n *\n * ### <span id=\"CRUDMethods\">Hydrators</span>\n *\n * These methods are used to create a typed instance or typed list given raw data objects:\n * - [can-connect/constructor/constructor.hydrateInstance] - create a typed instance given raw instance data\n * - [can-connect/constructor/constructor.hydrateList] - create a typed list of typed instances given given raw list data\n *\n * ### <span id=\"Serializers\">Serializers</span>\n *\n * These methods convert a typed instance or typed list into a raw object:\n * - [can-connect/constructor/constructor.serializeInstance] - return raw data representing the state of the typed instance argument\n * - [can-connect/constructor/constructor.serializeList] - return raw data representing the state of the typed list argument\n *\n */\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar makeArray = canReflect.toArray;\nvar assign = canReflect.assignMap;\nvar WeakReferenceMap = __webpack_require__(/*! ../helpers/weak-reference-map */ \"./node_modules/can-connect/helpers/weak-reference-map.js\");\nvar updateDeepExceptIdentity = __webpack_require__(/*! can-diff/update-deep-except-identity/update-deep-except-identity */ \"./node_modules/can-diff/update-deep-except-identity/update-deep-except-identity.js\");\nvar idMerge = __webpack_require__(/*! ../helpers/id-merge */ \"./node_modules/can-connect/helpers/id-merge.js\");\nvar behavior = __webpack_require__(/*! ../behavior */ \"./node_modules/can-connect/behavior.js\");\n\nmodule.exports = behavior(\"constructor\",function(baseConnection){\n\n\tvar behavior = {\n\t\t// stores references to instances\n\t\t// for now, only during create\n\t\t/**\n\t\t * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/constructor.cidStore cidStore\n\t\t * @parent can-connect/constructor/constructor.helpers\n\t\t *\n\t\t * Temporarily hold references to new instances via their [can-cid] while they are undergoing creation.\n\t\t *\n\t\t * @option {can-connect/helpers/weak-reference-map} Temporarily holds references to instances by\n\t\t * [can-cid] when they are in the process of being created and don't yet have an `id`s. This is typically\n\t\t * accessed in `createdData` handlers (e.g [can-connect/real-time/real-time.createdData real-time.createdData]) that\n\t\t * need to lookup the instance that was being created during a particular request.\n\t\t */\n\t\tcidStore: new WeakReferenceMap(),\n\t\t_cid: 0,\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.get get\n\t\t * @parent can-connect/constructor/constructor.crud\n\t\t *\n\t\t * Retrieve a single instance from the connection data source.\n\t\t *\n\t\t * @signature `connection.get(params)`\n\t\t *\n\t\t * Retrieves instance data from [can-connect/connection.getData], runs the resulting data through\n\t\t * [can-connect/constructor/constructor.hydrateInstance], creating a typed instance with the retrieved data.\n\t\t *\n\t\t * @param {Object} params data specifying the instance to retrieve.  Normally, this is something like like:\n\t\t * `{id: 5}`.\n\t\t *\n\t\t * @return {Promise<can-connect/Instance>} `Promise` resolving to the instance returned by\n\t\t * [can-connect/constructor/constructor.hydrateInstance].\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * Call `.get()` with the parameters that identify the instance you want to load.  `.get()` will return a promise\n\t\t * that resolves to that instance:\n\t\t * ```js\n\t\t * todoConnection.get({id: 6}).then(function(todo){\n\t\t *   todo.id; // 6\n\t\t *   todo.name; // 'Take out the garbage'\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * `.get()` above will call [can-connect/connection.getData `getData`] on the [can-connect/data/url/url]\n\t\t * behavior, which will make an HTTP GET request to `/todos/6`.\n\t\t */\n\t\tget: function(params) {\n\t\t\tvar self = this;\n\t\t\treturn this.getData(params).then(function(data){\n\t\t\t\treturn self.hydrateInstance(data);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.getList getList\n\t\t * @parent can-connect/constructor/constructor.crud\n\t\t *\n\t\t * Retrieve a list of instances from the connection data source.\n\t\t *\n\t\t * @signature `connection.getList(set)`\n\t\t *\n\t\t * Retrieves list data from [can-connect/connection.getListData] and runs the resulting data through\n\t\t * [can-connect/constructor/constructor.hydrateList], creating a typed list of typed instances from  the retrieved\n\t\t * data.\n\t\t *\n\t\t * @param {can-query-logic/query} query data specifying the range of instances to retrieve. This might look something like:\n\t\t * ```{start: 0, end: 50, due: 'today'}```\n\t\t *\n\t\t * @return {Promise<can-connect.List<can-connect/Instance>>} `Promise` resolving to the typed list returned by\n\t\t * [can-connect/constructor/constructor.hydrateList].\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * Call `getList` with the parameters that specify the set of data you want to load.  `.getList()` will return\n\t\t * a promise that resolves to a [can-connect.List] created from that set.\n\t\t *\n\t\t * ```js\n\t\t * todoConnection.getList({due: 'today'}).then(function(todos){\n\t\t *   todos[0].name; // 'Take out the garbage'\n\t\t *   todos[0].due > startOfDay && todos[0].due < endOfDay; // true\n\t\t * })\n\t\t * ```\n\t\t *\n\t\t */\n\t\tgetList: function(set) {\n\t\t\tset = set ||  {};\n\t\t\tvar self = this;\n\t\t\treturn this.getListData( set ).then(function(data){\n\t\t\t\treturn self.hydrateList(data, set);\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.hydrateList hydrateList\n\t\t * @parent can-connect/constructor/constructor.hydrators\n\t\t *\n\t\t * Produce a typed list from the provided raw list data.\n\t\t *\n\t\t * @signature `connection.hydrateList(listData, set)`\n\t\t *\n\t\t *   Call [can-connect/constructor/constructor.hydrateInstance] for each item in the raw list data, and then call\n\t\t *   [can-connect/constructor/constructor.list] with an array of the typed instances returned from\n\t\t *   [can-connect/constructor/constructor.hydrateInstance] .  If [can-connect/constructor/constructor.list] is not\n\t\t *   provided as an argument or implemented by another behavior, a normal array is created.\n\t\t *\n\t\t *   @param {can-connect.listData} listData the raw list data returned by the data source, often via [can-connect/connection.getListData]\n\t\t *   @param {can-query-logic/query} query description of the set of data `listData` represents\n\t\t *\n\t\t *   @return {can-connect.List} a typed list containing typed instances generated from `listData`\n\t\t */\n\t\thydrateList: function(listData, set){\n\t\t\tif(Array.isArray(listData)) {\n\t\t\t\tlistData = {data: listData};\n\t\t\t}\n\n\t\t\tvar arr = [];\n\t\t\tfor(var i = 0; i < listData.data.length; i++) {\n\t\t\t\tarr.push( this.hydrateInstance(listData.data[i]) );\n\t\t\t}\n\t\t\tlistData.data = arr;\n\t\t\tif(this.list) {\n\t\t\t\treturn this.list(listData, set);\n\t\t\t} else {\n\t\t\t\tvar list = listData.data.slice(0);\n\t\t\t\tlist[this.listQueryProp || \"__listQuery\"] = set;\n\t\t\t\tcopyMetadata(listData, list);\n\t\t\t\treturn list;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.hydrateInstance hydrateInstance\n\t\t * @parent can-connect/constructor/constructor.hydrators\n\t\t *\n\t\t * Produce a typed object containing the provided raw data.\n\t\t *\n\t\t * @signature `connection.hydrateInstance(props)`\n\t\t *\n\t\t * If [can-connect/constructor/constructor.instance] has been passed as an option, or defined by another behavior,\n\t\t * pass `props` to it and return the value. Otherwise, return a clone of `props`.\n\t\t *\n\t\t * @param {Object} props the raw instance data returned by the data source, often via [can-connect/connection.getData]\n\t\t * @return {can-connect/Instance} a typed instance containing the data from `props`\n\t\t */\n\t\thydrateInstance: function(props){\n\t\t\tif(this.instance) {\n\t\t\t\treturn this.instance(props);\n\t\t\t}  else {\n\t\t\t\treturn assign({}, props);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.save save\n\t\t * @parent can-connect/constructor/constructor.crud\n\t\t *\n\t\t * @description Create or update an instance on the connection data source\n\t\t *\n\t\t * @signature `connection.save( instance )`\n\t\t *\n\t\t *   First checks if the instance has an [can-connect/base/base.id] or not.  If it has an id, the instance will be\n\t\t *   updated; otherwise, it will be created.\n\t\t *\n\t\t *   When creating an instance, the instance is added to the [can-connect/constructor/constructor.cidStore], and its\n\t\t *   [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n\t\t *   [can-connect/connection.createData].  If `createData`'s promise resolves to anything other than `undefined`,\n\t\t *   [can-connect/constructor/constructor.createdInstance] is called with that data.\n\t\t *\n\t\t *   When updating an instance, its [can-connect/constructor/constructor.serializeInstance serialized data] is\n\t\t *   passed to [can-connect/connection.updateData]. If `updateData`'s promise resolves to anything other than\n\t\t *   `undefined`, [can-connect/constructor/constructor.updatedInstance] is called with that data.\n\t\t *\n\t\t *   @param {can-connect/Instance} instance the instance to create or save\n\t\t *\n\t\t *   @return {Promise<can-connect/Instance>} `Promise` resolving to the same instance that was passed to `save`\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * To use `save` to create an instance, create a connection, then an instance, and call `.save()` on it:\n\t\t *\n\t\t * ```js\n\t\t * // Create a connection\n\t     * var constructor = require('can-connect/constructor/');\n\t\t * var dataUrl = require('can-connect/data/url/');\n\t\t * var todoConnection = connect([dataUrl, constructor], {\n\t\t *   url: \"/todos\"\n\t\t * });\n\t\t *\n\t\t * // Create an instance\n\t\t * var todo = {name: \"do dishes\"};\n\t\t *\n\t\t * // Call .save()\n\t\t * todoConnection.save(todo)\n\t\t * ```\n\t\t *\n\t\t * `.save(todo)` above will call [can-connect/data/url/url.createData `createData`] on the [can-connect/data/url/url]\n\t\t * behavior, which will make an HTTP POST request to `/todos` with the serialized `todo` data.  The server response\n\t\t * data may look something like:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t *  id: 5,\n\t\t *  ownerId: 9\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * That data will be passed to [can-connect/constructor/constructor.createdInstance] which by default\n\t\t * adds those properties to `todo`, resulting in `todo` looking like:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t *  name: \"do dishes\",\n\t\t *  id: 5,\n\t\t *  ownerId: 9\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * As an example of updating an instance, change a property on `todo` and call `.save()` again:\n\t\t *\n\t\t * ```js\n\t\t * // Change a property\n\t\t * todo.name = \"Do dishes now!!\";\n\t\t *\n\t\t * // Call .save()\n\t\t * todoConnection.save(todo)\n\t\t * ```\n\t\t *\n\t\t * The `.save(todo)` above will call [can-connect/data/url/url.updateData `updateData`] on the\n\t\t * [can-connect/data/url/url] behavior, which will make an HTTP PUT request to `/todos` with the serialized `todo`\n\t\t * data.\n\t\t *\n\t\t * A successful server response body should look something like:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t *  name: \"Do dishes now!!\",\n\t\t *  id: 5,\n\t\t *  ownerId: 9\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * This data will be passed to [can-connect/constructor/constructor.updatedInstance] which by default sets\n\t\t * all of `todo`'s properties to look like the response data, even removing properties that are missing from the\n\t\t * response data.\n\t\t */\n\t\tsave: function(instance){\n\t\t\tvar serialized = this.serializeInstance(instance);\n\t\t\tvar id = this.id(instance);\n\t\t\tvar self = this;\n\t\t\tif(id === undefined) {\n\t\t\t\t// If `id` is undefined, we are creating this instance.\n\t\t\t\t// It should be given a local id and temporarily added to the cidStore\n\t\t\t\t// so other hooks can get back the instance that's being created.\n\t\t\t\tvar cid = this._cid++;\n\t\t\t\t// cid is really a token to be able to reference this transaction.\n\t\t\t\tthis.cidStore.addReference(cid, instance);\n\n\t\t\t\t// Call the data layer.\n\t\t\t\t// If the data returned is undefined, don't call `createdInstance`\n\t\t\t\treturn this.createData(serialized, cid).then(function(data){\n\t\t\t\t\t// if undefined is returned, this can't be created, or someone has taken care of it\n\t\t\t\t\tif(data !== undefined) {\n\t\t\t\t\t\tself.createdInstance(instance, data);\n\t\t\t\t\t}\n\t\t\t\t\tself.cidStore.deleteReference(cid, instance);\n\t\t\t\t\treturn instance;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn this.updateData(serialized).then(function(data){\n\t\t\t\t\tif(data !== undefined) {\n\t\t\t\t\t\tself.updatedInstance(instance, data);\n\t\t\t\t\t}\n\t\t\t\t\treturn instance;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.destroy destroy\n\t\t * @parent can-connect/constructor/constructor.crud\n\t\t * @description Delete an instance from the connection data source\n\t\t *\n\t\t * @signature `connection.destroy( instance )`\n\t\t *\n\t\t *   To destroy an instance, it's [can-connect/constructor/constructor.serializeInstance serialized data] is passed\n\t\t *   to [can-connect/connection.destroyData]. If [can-connect/connection.destroyData]'s promise resolves to anything\n\t\t *   other than `undefined`, [can-connect/constructor/constructor.destroyedInstance] is called.\n\t\t *\n\t\t *   @param {can-connect/Instance} instance the instance being deleted from the data source\n\t\t *\n\t\t *   @return {Promise<can-connect/Instance>} `Promise` resolving to the same instance that was passed to `destroy`\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * To use `destroy`, create a connection, retrieve an instance, and then call `.destroy()` with it.\n\t\t *\n\t\t * ```js\n\t\t * // create a connection\n\t\t * var constructor = require('can-connect/constructor/');\n\t\t * var dataUrl = require('can-connect/data/url/');\n\t\t * var todoConnection = connect([dataUrl, constructor], {\n\t\t *   url: \"/todos\"\n\t\t * })\n\t\t *\n\t\t * // retrieve a todo instance\n\t\t * todoConnection.get({id: 5}).then(function(todo){\n\t\t *   // Call .destroy():\n\t\t *   todoConnection.destroy(todo)\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * `.destroy()` above will call [can-connect/connection.destroyData `destroyData`] on the [can-connect/data/url/url]\n\t\t * behavior, which will make an HTTP DELETE request to `/todos/5` with the serialized `todo` data.  The server\n\t\t * response data may look something like:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t *   deleted: true\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * That response data will be passed to [can-connect/constructor/constructor.destroyedInstance], which by default\n\t\t * adds those properties to `todo`.\n\t\t */\n\t\t// ## destroy\n\t\t// Calls the data interface `destroyData` and as long as it\n\t\t// returns something, uses that data to call `destroyedInstance`.\n\t\tdestroy: function(instance){\n\t\t\tvar serialized = this.serializeInstance(instance),\n\t\t\t\tself = this,\n\t\t\t\tid = this.id(instance);\n\n\t\t\tif (id !== undefined) {\n\t\t\t\treturn this.destroyData(serialized).then(function (data) {\n\t\t\t\t\tif (data !== undefined) {\n\t\t\t\t\t\tself.destroyedInstance(instance, data);\n\t\t\t\t\t}\n\t\t\t\t\treturn instance;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.destroyedInstance(instance, {});\n\t\t\t\treturn Promise.resolve(instance);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.createdInstance createdInstance\n\t\t * @parent can-connect/constructor/constructor.callbacks\n\t\t *\n\t\t * A method run whenever a new instance has been saved to the data source. Updates the instance with response data.\n\t\t *\n\t\t * @signature `connection.createdInstance( instance, props )`\n\t\t *\n\t\t * `createdInstance` is run whenever a new instance is saved to the data source. This implementation updates the\n\t\t * instance with the data returned by [can-connect/connection.createData] which made the request to save the raw\n\t\t * instance data.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance that was created\n\t\t * @param {Object} props the data returned from [can-connect/connection.createData] that will update the properties of `instance`\n\t\t */\n\t\tcreatedInstance: function(instance, props){\n\t\t\tassign(instance, props);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.updatedInstance updatedInstance\n\t\t * @parent can-connect/constructor/constructor.callbacks\n\t\t *\n\t\t * A method run whenever an existing instance has been saved to the data source. Overwrites the instance with response\n\t\t * data.\n\t\t *\n\t\t * @signature `connection.updatedInstance( instance, props )`\n\t\t *\n\t\t * `updatedInstance` is run whenever an existing instance is saved to the data source. This implementation overwrites\n\t\t * the instance with the data returned bu [can-connect/connection.updatedData] which made the request to save the\n\t\t * modified instance data.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance that was updated\n\t\t * @param {Object} props the data from [can-connect/connection.updateData] that will overwrite the properties of `instance`\n\t\t */\n\t\tupdatedInstance: function(instance, data){\n\t\t\tupdateDeepExceptIdentity(instance, data, this.queryLogic.schema);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.updatedList updatedList\n\t\t * @parent can-connect/constructor/constructor.callbacks\n\t\t *\n\t\t * A method run whenever new data for an existing list is retrieved from the data source. Updates the list to\n\t\t * include the new data.\n\t\t *\n\t\t * @signature `connection.updatedList( list, listData, set )`\n\t\t *\n\t\t * [can-connect/constructor/constructor.hydrateInstance Hydrates instances] from `listData`'s data and attempts to\n\t\t * merge them into `list`.  The merge is able to identify simple insertions and removals of elements instead of\n\t\t * replacing the entire list.\n\t\t *\n\t\t * @param {can-connect/Instance} list an existing list\n\t\t * @param {can-connect.listData} listData raw data that should be included as part of `list` after conversion to typed instances\n\t\t * @param {can-query-logic/query} query description of the set of data `list` represents\n\t\t */\n\t\tupdatedList: function(list, listData, set) {\n\t\t\tvar instanceList = [];\n\t\t\tfor(var i = 0; i < listData.data.length; i++) {\n\t\t\t\tinstanceList.push( this.hydrateInstance(listData.data[i]) );\n\t\t\t}\n\t\t\t// This only works with \"referenced\" instances because it will not\n\t\t\t// update and assume the instance is already updated\n\t\t\t// this could be overwritten so that if the ids match, then a merge of properties takes place\n\t\t\tidMerge(list, instanceList, this.id.bind(this), this.hydrateInstance.bind(this));\n\n\t\t\tcopyMetadata(listData, list);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.destroyedInstance destroyedInstance\n\t\t * @parent can-connect/constructor/constructor.callbacks\n\t\t *\n\t\t * A method run whenever an instance has been deleted from the data source. Overwrites the instance with response data.\n\t\t *\n\t\t * @signature `connection.destroyedInstance( instance, props )`\n\t\t *\n\t\t * `destroyedInstance` is run whenever an existing instance is deleted from the data source. This implementation\n\t\t * overwrites the instance with the data returned by [can-connect/connection.destroyData] which made the request to\n\t\t * delete the raw instance data.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance that was deleted\n\t\t * @param {Object} props the data returned from [can-connect/connection.destroyData] that will overwrite the\n\t\t * properties of `instance`\n\t\t */\n\t\tdestroyedInstance: function(instance, data){\n\t\t\tupdateDeepExceptIdentity(instance, data, this.queryLogic.schema);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.serializeInstance serializeInstance\n\t\t * @parent can-connect/constructor/constructor.serializers\n\t\t *\n\t\t * @description Generate the serialized form of a typed instance.\n\t\t *\n\t\t * @signature `connection.serializeInstance( instance )`\n\t\t *\n\t\t *   Generate a raw object representation of a typed instance. This default implementation simply clones the\n\t\t *   `instance` object, copying all the properties of the object (excluding properties of it's prototypes) to a new\n\t\t *   object. This is equivalent to `Object.assign({}, instance)`.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance to serialize\n\t\t * @return {Object} a serialized representation of the instance\n\t\t */\n\t\tserializeInstance: function(instance){\n\t\t\treturn assign({}, instance);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.serializeList serializeList\n\t\t * @parent can-connect/constructor/constructor.serializers\n\t\t *\n\t\t * @description Generate the serialized form of a typed list.\n\t\t *\n\t\t * @signature `connection.serializeList( list )`\n\t\t *\n\t\t *   Generate a raw array representation of a typed list. This default implementation simply returns a plain `Array`\n\t\t *   containing the result of calling [can-connect/constructor/constructor.serializeInstance] on each item in the\n\t\t *   typed list.\n\t\t *\n\t\t * @param {can-connect.List} list The instance to serialize.\n\t\t * @return {Object|Array} A serialized representation of the list.\n\t\t */\n\t\tserializeList: function(list){\n\t\t\tvar self = this;\n\t\t\treturn makeArray(list).map(function(instance){\n\t\t\t\treturn self.serializeInstance(instance);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.isNew isNew\n\t\t * @parent can-connect/constructor/constructor.helpers\n\t\t *\n\t\t * Returns if the instance has not been loaded from or saved to the data source.\n\t\t *\n\t\t * @signature `connection.isNew(instance)`\n\t\t * @param {Object} instance the instance to test\n\t\t * @return {Boolean} `true` if [can-connect/base/base.id] is `null` or `undefined`\n\t\t */\n\t\tisNew: function(instance){\n\t\t\tvar id = this.id(instance);\n\t\t\treturn !(id || id === 0);\n\t\t}\n\n\t\t/**\n\t\t * @property can-connect/constructor/constructor.list list\n\t\t * @parent can-connect/constructor/constructor.options\n\t\t *\n\t\t * Behavior option provided to create a typed list from a raw array.\n\t\t *\n\t\t * @signature `connection.list( listData, set )`\n\t\t *\n\t\t * Takes a `listData` argument with a `data` property, that is an array of typed instances, each produced by\n\t\t * [can-connect/constructor/constructor.hydrateInstance], and returns a new typed list containing those typed\n\t\t * instances.\n\t\t * This method is passed as an option to the connection.\n\t\t * Called by [can-connect/constructor/constructor.hydrateList].\n\t\t *\n\t\t * @param {can-connect.listData} listData an object with a `data` property, which is an array of instances.\n\t\t * @param {can-query-logic/query} query the set description of this list\n\t\t * @return {can-connect.List} a typed list type containing the typed instances\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * The following example makes the connection produce `MyList` typed lists including a `completed` method:\n\t\t *\n\t\t * ```js\n\t\t * var constructor = require(\"can-connect/constructor/\");\n\t\t * var dataUrl = require(\"can-connect/data/url/\");\n\t\t *\n\t\t * // define custom list type constructor\n\t\t * var MyList = function(items) {\n\t\t *  this.push.apply(this, items);\n\t\t * }\n\t\t * // inherit Array functionality\n\t\t * MyList.prototype = Object.create(Array.prototype);\n\t\t * // add custom methods to new list type\n\t\t * MyList.prototype.completed = function(){\n\t\t *  return this.filter(function(){ return this.completed });\n\t\t * };\n\t\t *\n\t\t * // create connection\n\t\t * var todosConnection = connect([constructor, dataUrl], {\n\t\t *   url: \"/todos\",\n\t\t *   list: function(listData, set){\n\t\t *     // create custom list instance\n\t\t *     var collection = new MyList(listData.data);\n\t\t *     // add set info for use by other behaviors\n\t\t *     collection.__listQuery = set;\n\t\t *     return collection;\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * // use connection to get typed list & use custom method\n\t\t * todosConnection.getList({}).then(function(todoList){\n\t\t *   console.log(\"There are\", todoList.completed().length, \"completed todos\");\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * **Note:** we added the [can-connect/base/base.listQueryProp] property (`Symbol.for(\"can.listQuery\")` by default) on the list. This is\n\t\t * expected by other behaviors.\n\t\t */\n\n\t\t/**\n\t\t * @property can-connect/constructor/constructor.instance instance\n\t\t * @parent can-connect/constructor/constructor.options\n\t\t *\n\t\t * Behavior option provided to create a typed form of passed raw data.\n\t\t *\n\t\t * @signature `connection.instance( props )`\n\t\t *\n\t\t * Creates a typed instance for the passed raw data object. This method is passed as an option to the connection.\n\t\t * Called by [can-connect/constructor/constructor.hydrateInstance].\n\t\t *\n\t\t * @param {Object} props a raw object containing the properties from the data source\n\t\t * @return {can-connect/Instance} the typed instance created from the passed `props` object\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * The following example makes the connection produce `Todo` typed objects including a `complete` method:\n\t\t *\n\t\t * ```js\n\t\t * var constructor = require(\"can-connect/constructor/\");\n\t\t * var dataUrl = require(\"can-connect/data/url/\");\n\t\t *\n\t\t * // define type constructor\n\t\t * var Todo = function(rawData){\n\t\t *   // add raw data to new instance\n\t\t *   Object.assign(this, rawData);\n\t\t * };\n\t\t *\n\t\t * // add methods to custom type\n\t\t * Todo.prototype.complete = function(){\n\t\t *   this.completed = true;\n\t\t * }\n\t\t *\n\t\t * // create connection\n\t\t * var todosConnection = connect([constructor, dataUrl], {\n\t\t *   url: \"/todos\",\n\t\t *   instance: function(rawData) {\n\t\t *     return new Todo(rawData);\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * // use connection to get typed instance & use custom method\n\t\t * todosConnection.get({id: 5}).then(function(todo){\n\t\t *   todo.completed; // false\n\t\t *   todo.complete();\n\t\t *   todo.completed; // true\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t */\n\t};\n\n\treturn behavior;\n\n});\n\nfunction copyMetadata(listData, list){\n\tfor(var prop in listData) {\n\t\tif(prop !== \"data\") {\n\t\t\t// this is map infultrating constructor, but it's alright here.\n\t\t\tif(typeof list.set === \"function\") {\n\t\t\t\tlist.set(prop, listData[prop]);\n\t\t\t} else if(typeof list.attr === \"function\") {\n\t\t\t\tlist.attr(prop, listData[prop]);\n\t\t\t} else {\n\t\t\t\tlist[prop] = listData[prop];\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/constructor/constructor.js?");

/***/ }),

/***/ "./node_modules/can-connect/constructor/store/store.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-connect/constructor/store/store.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {connect.Behavior} can-connect/constructor/store/store constructor/store\n * @parent can-connect.behaviors\n * @group can-connect/constructor/store/store.stores 0 stores\n * @group can-connect/constructor/store/store.callbacks 1 CRUD callbacks\n * @group can-connect/constructor/store/store.crud 2 CRUD methods\n * @group can-connect/constructor/store/store.hydrators 3 hydrators\n *\n * Adds support for keeping references to active lists and instances. Prevents different copies of an instance from\n * being used by the application at once. Allows other behaviors to look up instances currently active in the\n * application.\n *\n *\n * @signature `constructorStore( baseConnection )`\n *\n * Overwrites `baseConnection` so it contains a store for instances and lists.  This behavior:\n * - extends the [can-connect/constructor/store/store.hydrateInstance] and\n * [can-connect/constructor/store/store.hydrateList] methods to return instances or lists from the store, if available\n * - overwrites \"CRUD\" methods to make sure that while requests are pending, new lists and instances have references\n * kept in the store. This prevents duplicated instances from being created during concurrent requests.\n * - provides methods to add and remove items in the store by counting references\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `constructor/store` behavior added\n * on to it. Should already contain a behavior that provides the InstanceInteface\n * (e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the behaviors\n * will automatically be ordered as required.\n *\n * @return {Object} a `can-connect` connection containing the method implementations provided by `constructor/store`.\n *\n * @body\n *\n * ## Use\n *\n * The `constructor-store` behavior is used to:\n *  - provide a store of instances and lists in use by the client\n *  - prevent multiple instances from being generated for the same [can-connect/base/base.id] or multiple\n *    lists for the same [can-connect/base/base.listQuery].\n *\n * The store provides access to an instance by its [can-connect/base/base.id] or a list by its\n * [can-connect/base/base.listQuery]. This is used by other behaviors to lookup instances that should have changes applied.\n * Two examples, when there is a new instance that should be added to a list ([can-connect/real-time/real-time]) or\n * when newer data is available for a cached instance that is used in the page\n * ([can-connect/fall-through-cache/fall-through-cache]).\n *\n * Below you can see how `constructor-store`'s behavior be used to prevent multiple instances from being generated. This\n * example allows you to create multiple instances of a `todoEditor` that loads and edits a todo instance:\n *\n * @demo demos/can-connect/constructor-store.html\n *\n * You can see in this example that you can edit one todo and the other todos update.  This is because each `todoEditor`\n * is acting on same instance in memory. When it updates the todo's name here:\n *\n * ```\n * var updateData = function(newName) {\n *   todo.name = newName; // update name on todo instance\n *   ...\n * };\n * ```\n *\n * The other widgets update because they are bound to the same instance:\n *\n * ```\n * todo.on(\"name\", updateElement); // when todo name changes update input element\n * todosConnection.addInstanceReference(todo); // previous line is a new usage of todo, so increase reference count\n * ```\n *\n * Each `todoEditor` receives the same instance because it was added to the\n * [can-connect/constructor/store/store.instanceStore connnection.instanceStore] by\n * [can-connect/constructor/store/store.addInstanceReference]. During all instance retrievals, a connection using the\n * `constructor/store` behavior checks the [can-connect/constructor/store/store.instanceStore] for an instance with a\n * matching `id` and return that if it exists. This example always requests `id: 5`, so all the `todoEditor`s use the\n * same instance held in the [can-connect/constructor/store/store.instanceStore].\n *\n * This widget cleans itself up when it is removed by removing the listener on the `todo` instance and\n * [can-connect/constructor/store/store.deleteInstanceReference reducing the instance reference count]:\n *\n * ```\n * todo.off(\"name\", updateElement); // stop listening to todo name change\n * todosConnection.deleteInstanceReference(todo); // previous line removed a usage of todo, so reduce reference count\n * ```\n * This is done to prevent a memory leak produced by keeping instances in the `instanceStore` when they are no longer\n * needed by the application.\n *\n * **Note:** a hazard of sharing the same instance is that if new instance data is loaded from the server during\n * on-going editing of the instance, the new server data will replace the data that is edited but not yet saved.\n * This is because whenever data is loaded from the server, it is passed to\n * [can-connect/constructor/constructor.updatedInstance] which updates the shared instance properties with the new\n * server data.\n */\nvar connect = __webpack_require__(/*! ../../can-connect */ \"./node_modules/can-connect/can-connect.js\");\nvar WeakReferenceMap = __webpack_require__(/*! ../../helpers/weak-reference-map */ \"./node_modules/can-connect/helpers/weak-reference-map.js\");\nvar WeakReferenceSet = __webpack_require__(/*! ../../helpers/weak-reference-set */ \"./node_modules/can-connect/helpers/weak-reference-set.js\");\nvar sortedSetJSON = __webpack_require__(/*! ../../helpers/sorted-set-json */ \"./node_modules/can-connect/helpers/sorted-set-json.js\");\nvar eventQueue = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\n\n// shared across all connections\nvar pendingRequests = 0;\nvar noRequestsTimer = null;\nvar requests = {\n\tincrement: function(connection){\n\t\tpendingRequests++;\n\t\tclearTimeout(noRequestsTimer);\n\t},\n\tdecrement: function(connection){\n\t\tpendingRequests--;\n\t\tif(pendingRequests === 0) {\n\t\t\tnoRequestsTimer = setTimeout(function(){\n\t\t\t\trequests.dispatch(\"end\");\n\t\t\t},module.exports.requestCleanupDelay);\n\t\t}\n\t\tif(pendingRequests < 0) {\n\t\t\tpendingRequests = 0;\n\t\t}\n\t},\n\tcount: function(){\n\t\treturn pendingRequests;\n\t}\n};\neventQueue(requests);\n\n\nvar constructorStore = connect.behavior(\"constructor/store\",function(baseConnection){\n\n\tvar behavior = {\n\t\t/**\n\t\t * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/store/store.instanceStore instanceStore\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * A mapping of instances keyed by their [can-connect/base/base.id].\n\t\t *\n\t\t * @type {can-connect/helpers/weak-reference-map}\n\t\t *\n\t\t * Stores instances by their [can-connect/base/base.id]. Holds instances based on reference counts which\n\t\t * are incremented by [can-connect/constructor/store/store.addInstanceReference] and decremented by\n\t\t * [can-connect/constructor/store/store.deleteInstanceReference]. Once a reference count is 0, the instance is no\n\t\t * longer held in the store. Once a reference count is greater than 0, the instance is added to the store.\n\t\t *\n\t\t * ```js\n\t\t * connection.addInstanceReference(todo5);\n\t\t * connection.instanceStore.get(\"5\") //-> todo5\n\t\t * ```\n\t\t */\n\t\tinstanceStore: new WeakReferenceMap(),\n\t\t// This really should be a set ... we just need it \"weak\" so we know how many references through binding\n\t\t// it has.\n\t\tnewInstanceStore: new WeakReferenceSet(),\n\t\t/**\n\t\t * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/store/store.listStore listStore\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * A mapping of lists keyed by their [can-connect/base/base.listQuery].\n\t\t *\n\t\t * @type {can-connect/helpers/weak-reference-map}\n\t\t *\n\t\t * Stores lists by their [can-connect/base/base.listQuery]. Hold lists based on reference counts which are incremented\n\t\t * by [can-connect/constructor/store/store.addListReference] and decremented by\n\t\t * [can-connect/constructor/store/store.deleteListReference]. Once a reference count is 0, the list is no\n\t\t * longer held in the store. Once a reference count is greater than 0, the list is added to the store.\n\t\t *\n\t\t * ```js\n\t\t * connection.addInstanceReference(allTodos, {});\n\t\t * connection.instanceStore.get({}) //-> allTodos\n\t\t * ```\n\t\t */\n\t\tlistStore: new WeakReferenceMap(),\n\t\t // Set up the plain objects for tracking requested lists and instances for this connection,\n\t\t // and add a handler to the requests counter to flush list and instance references when all\n\t\t // requests have completed\n\t\t //\n\t\t // This function is called automatically when connect() is called on this behavior,\n\t\t // and should not need to be called manually.\n\t\tinit: function() {\n\t\t\tif(baseConnection.init) {\n\t\t\t\tbaseConnection.init.apply(this, arguments);\n\t\t\t}\n\n\t\t\tif(!this.hasOwnProperty(\"_requestInstances\")) {\n\t\t\t\tthis._requestInstances = {};\n\t\t\t}\n\t\t\tif(!this.hasOwnProperty(\"_requestLists\")) {\n\t\t\t\tthis._requestLists = {};\n\t\t\t}\n\n\t\t\trequests.on(\"end\", function onRequestsEnd_deleteStoreReferences(){\n\t\t\t\tvar id;\n\t\t\t\tfor(id in this._requestInstances) {\n\t\t\t\t\tthis.instanceStore.deleteReference(id);\n\t\t\t\t}\n\t\t\t\tthis._requestInstances = {};\n\t\t\t\tfor(id in this._requestLists) {\n\t\t\t\t\tthis.listStore.deleteReference(id);\n\t\t\t\t\tthis._requestLists[id].forEach(this.deleteInstanceReference.bind(this));\n\t\t\t\t}\n\t\t\t\tthis._requestLists = {};\n\t\t\t}.bind(this));\n\t\t},\n\t\t_finishedRequest: function(){\n\t\t\trequests.decrement(this);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.addInstanceReference addInstanceReference\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * Add a reference to the [can-connect/constructor/store/store.instanceStore] so an instance can be easily looked up.\n\t\t *\n\t\t * @signature `connection.addInstanceReference( instance )`\n\t\t * Adds a reference to an instance by [can-connect/base/base.id] to the [can-connect/constructor/store/store.instanceStore].\n\t\t * Keeps a count of the number of references, removing the instance from the store when the count reaches 0.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance to add\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * The [can-connect/constructor/store/store.instanceStore] contains a mapping of instances keyed by their\n\t\t * [can-connect/base/base.id]. The [can-connect/constructor/store/store.instanceStore] is used to prevent creating\n\t\t * the same instance multiple times, and for finding active instance for a given id.  Instances need to be added to\n\t\t * this store for this to work.  To do this, call `addInstanceReference`:\n\t\t *\n\t\t * ```\n\t\t * // a basic connection\n\t\t * var constructorStore = require(\"can-connect/constructor/store/\");\n\t\t * var constructor = require(\"can-connect/constructor/\");\n\t\t * var dataUrl = require(\"can-connect/data/url/\");\n\t\t * var todoConnection = connect([dataUrl, constructorStore, constructor], {\n\t\t *   url: \"/todos\"\n\t\t * });\n\t\t *\n\t\t * var originalTodo;\n\t\t *\n\t\t * // get a todo\n\t\t * todoConnection.get({id: 5}).then(function( todo ){\n\t\t *   // add it to the store\n\t\t *   todoConnection.addInstanceReference(todo);\n\t\t *   originalTodo = todo;\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * Now, if you were to retrieve the same data sometime later, it would be the same instance:\n\t\t *\n\t\t * ```\n\t\t * todoConnection.get({id: 5}).then(function( todo ){\n\t\t *   todo === originalTodo // true\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * The `.getData` response data (underlying the call to `todoConnection.get`) is passed, along with the existing todo\n\t\t * instance (`originalTodo`) to [can-connect/constructor/constructor.updatedInstance]. That updates the shared\n\t\t * instance with the newly retrieved data.\n\t\t *\n\t\t * All the referenced instances are held in memory.  Use\n\t\t * [can-connect/constructor/store/store.deleteInstanceReference] to remove them.\n\t\t *\n\t\t * Typically, `addInstanceReference` is called when something expresses interest in the instance, such\n\t\t * as an event binding, and `deleteInstanceReference` is called when the interest is removed.\n\t\t */\n\t\taddInstanceReference: function(instance, id) {\n\t\t\tvar ID = id || this.id(instance);\n\t\t\tif(ID === undefined) {\n\t\t\t\t// save in the newInstanceStore store temporarily.\n\t\t\t\tthis.newInstanceStore.addReference(instance);\n\t\t\t} else {\n\t\t\t\tthis.instanceStore.addReference( ID, instance );\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.callbacks.createdInstance createdInstance\n\t\t * @parent can-connect/constructor/store/store.callbacks\n\t\t *\n\t\t * Calls `createdInstance` on the underlying behavior and moves the new instance from the `newInstanceStore` to\n\t\t * `instanceStore` if needed.\n\t\t *\n\t\t * @signature `connection.createdInstance( instance, props )`\n\t\t * Calls the base behavior. Then calls [can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore]\n\t\t * to move any pre-creation instance references to the standard instance reference store.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance that was created\n\t\t * @param {Object} props the data returned from [can-connect/connection.createData]\n\t\t */\n\t\tcreatedInstance: function(instance, props){\n\t\t\t// when an instance is created, and it is in the newInstance store\n\t\t\t// transfer it to the instanceStore\n\t\t\tbaseConnection.createdInstance.apply(this, arguments);\n\t\t\tthis.moveCreatedInstanceToInstanceStore(instance);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore moveCreatedInstanceToInstanceStore\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * Moves recently created instances into the [can-connect/constructor/store/store.instanceStore].\n\t\t *\n\t\t * @signature `moveCreatedInstanceToInstanceStore( instance )`\n\t\t * Checks if an instance has an `id` and is in the `newInstanceStore`. If so, it adds it into the\n\t\t * [can-connect/constructor/store/store.instanceStore] and removes it from the `newInstanceStore`.\n\t\t *\n\t\t * A new instances may have been added to the `newInstanceStore` if [can-connect/constructor/store/store.addInstanceReference]\n\t\t * is called on is before the instance has been saved. This is done so we can keep track of references for unsaved\n\t\t * instances and update the references to be keyed by `id` when one is available. Without this a request for a\n\t\t * currently referenced instance that was just saved for the first time will erroneously result in a new instance.\n\t\t *\n\t\t * @param {can-connect/Instance} instance an instance.  If it was \"referenced\" (bound to) prior to\n\t\t * being created, this will check for that condition and move this instance into the\n\t\t * [can-connect/constructor/store/store.instanceStore].\n\t\t */\n\t\tmoveCreatedInstanceToInstanceStore: function(instance){\n\t\t\tvar ID = this.id(instance);\n\t\t\tif(this.newInstanceStore.has(instance) && ID !== undefined) {\n\t\t\t\tvar referenceCount = this.newInstanceStore.referenceCount(instance);\n\t\t\t\tthis.newInstanceStore.delete(instance);\n\t\t\t\tthis.instanceStore.addReference( ID, instance, referenceCount );\n\t\t\t}\n\t\t},\n\t\taddInstanceMetaData: function(instance, name, value){\n\t\t\tvar data = this.instanceStore.set[this.id(instance)];\n\t\t\tif(data) {\n\t\t\t\tdata[name] = value;\n\t\t\t}\n\t\t},\n\t\tgetInstanceMetaData: function(instance, name){\n\t\t\tvar data = this.instanceStore.set[this.id(instance)];\n\t\t\tif(data) {\n\t\t\t\treturn data[name];\n\t\t\t}\n\t\t},\n\t\tdeleteInstanceMetaData: function(instance, name){\n\t\t\tvar data = this.instanceStore.set[this.id(instance)];\n\n\t\t\tdelete data[name];\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.deleteInstanceReference deleteInstanceReference\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * Remove a reference from the [can-connect/constructor/store/store.instanceStore] so an instance can be garbage\n\t\t * collected.\n\t\t *\n\t\t * @signature `connection.addInstanceReference( instance )`\n\t\t * Decrements the number of references to an instance in the [can-connect/constructor/store/store.instanceStore].\n\t\t * Removes the instance if there are no longer any references.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance to remove\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * `deleteInstanceReference` is called to remove references to instances in the\n\t\t * [can-connect/constructor/store/store.instanceStore] so that instances maybe garbage collected.  It's usually\n\t\t * called when the application or some part of the application no longer is interested in an instance.\n\t\t *\n\t\t * [can-connect/constructor/store/store.addInstanceReference] has an example of adding an instance to the store.\n\t\t * The following continues that example to remove the `originalTodo` instance from the store:\n\t\t *\n\t\t * ```\n\t\t * todoConnection.deleteInstanceReference(originalTodo);\n\t\t * ```\n\t\t *\n\t\t * Also see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete\n\t\t * example of the lifecycle of a reference.\n\t\t */\n\t\tdeleteInstanceReference: function(instance) {\n\t\t\tvar ID = this.id(instance);\n\t\t\tif(ID === undefined) {\n\t\t\t\t// if there is no id, remove this from the newInstanceStore\n\t\t\t\tthis.newInstanceStore.deleteReference(instance);\n\t\t\t} else {\n\t\t\t\tthis.instanceStore.deleteReference( this.id(instance), instance );\n\t\t\t}\n\n\t\t},\n\t\t/**\n\t\t * @property {WeakReferenceMap} can-connect/constructor/store/store.addListReference addListReference\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * Add a reference to the [can-connect/constructor/store/store.listStore] so a list can be easily looked up.\n\t\t *\n\t\t * @signature `connection.addListReference( list[, set] )`\n\t\t * Adds a reference to a list by `set` (or by [can-connect/base/base.listQuery]) to the\n\t\t * [can-connect/constructor/store/store.listStore].  Keeps a count of the number of references, removing the list\n\t\t * from the store when the count reaches 0.\n\t\t *\n\t\t * @param {can-connect.List} list The list to add.\n\t\t * @param {can-query-logic/query} [query] The set this list represents if it can't be identified with [can-connect/base/base.listQuery].\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * The [can-connect/constructor/store/store.listStore] contains a mapping of lists keyed by their `set`. The\n\t\t * [can-connect/constructor/store/store.listStore] is used to prevent creating the same list multiple times and for\n\t\t * identifying a list for a given set. Lists need to be added to this store for this to work.  To do this, call\n\t\t * `addListReference`:\n\t\t *\n\t\t * ```\n\t\t * // A basic connection:\n\t\t * var constructorStore = require(\"can-connect/constructor/store/\");\n\t\t * var constructor = require(\"can-connect/constructor/\");\n\t\t * var dataUrl = require(\"can-connect/data/url/\");\n\t\t * var todoConnection = connect([dataUrl, constructorStore, constructor], {\n\t\t *   url: \"/todos\"\n\t\t * });\n\t\t *\n\t\t * var dueToday;\n\t\t *\n\t\t * // get a todo list\n\t\t * todoConnection.getList({due: \"today\"}).then(function( todos ){\n\t\t *   // add it to the store\n\t\t *   todoConnection.addListReference(todos, {due: \"today\"});\n\t\t *   dueToday = todos;\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * Now, if you were to retrieve the same set of data sometime later, it would be the same list instance:\n\t\t *\n\t\t * ```\n\t\t * todoConnection.get({due: \"today\"}).then(function( todos ){\n\t\t *   todos === dueToday //-> true\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * The `.getListData`  response data (underlying the call to `todoConnection.getList`) is passed, along with the\n\t\t * existing list (`dueToday`) to [can-connect/constructor/constructor.updatedList]. That updates the shared list\n\t\t * instance with the newly retrieved data.\n\t\t *\n\t\t * All the referenced lists stay in memory.  Use [can-connect/constructor/store/store.deleteListReference]\n\t\t * to remove them.\n\t\t *\n\t\t * Typically, `addListReference` is called when something expresses interest in the list, such\n\t\t * as an event binding, and `deleteListReference` is called when interest is removed.\n\t\t *\n\t\t */\n\t\taddListReference: function(list, set) {\n\t\t\tvar id = sortedSetJSON( set || this.listQuery(list) );\n\t\t\tif(id) {\n\t\t\t\tthis.listStore.addReference( id, list );\n\t\t\t\tlist.forEach(function(instance) {\n\t\t\t\t\tthis.addInstanceReference(instance);\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.deleteListReference deleteListReference\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * Removes a reference from the [can-connect/constructor/store/store.listStore] so a list can can be garbage\n\t\t * collected.\n\t\t *\n\t\t * @signature `connection.addInstanceReference( instance )`\n\t\t * Decrements the number of references to a list in the [can-connect/constructor/store/store.listStore].\n\t\t * Removes the list if there are no longer any references.\n\t\t *\n\t\t * @param {can-connect/Instance} list the list to remove\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * `deleteListReference` is called to remove references to instances in the\n\t\t * [can-connect/constructor/store/store.listStore] so that lists maybe garbage collected.  It's usually called when\n\t\t * the application or some part of the application no longer is interested in a list.\n\t\t *\n\t\t * [can-connect/constructor/store/store.addListReference] has an example of adding a list to the store.  The\n\t\t * following continues that example to remove the `dueToday` list from the store:\n\t\t *\n\t\t * ```\n\t\t * todoConnection.deleteListReference(dueToday);\n\t\t * ```\n\t\t *\n\t\t * Also see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete\n\t\t * example of the lifecycle of a reference.\n\t\t */\n\t\tdeleteListReference: function(list, set) {\n\t\t\tvar id = sortedSetJSON( set || this.listQuery(list) );\n\t\t\tif(id) {\n\t\t\t\tthis.listStore.deleteReference( id, list );\n\t\t\t\tlist.forEach(this.deleteInstanceReference.bind(this));\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.hydratedInstance hydratedInstance\n\t\t * @parent can-connect/constructor/store/store.hydrators\n\t\t *\n\t\t * Keeps new instances in the [can-connect/constructor/store/store.instanceStore] for the lifetime of any\n\t\t * concurrent requests.\n\t\t *\n\t\t * @signature `hydratedInstance(instance)`\n\t\t * Adds a reference for new instances for the lifetime of any concurrent requests. Called when a new instance is\n\t\t * created during [can-connect/constructor/store/store.hydrateInstance hydration]. This prevents concurrent requests\n\t\t * for the same data from returning different instances.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the newly hydrated instance\n\t\t */\n\t\t// ## hydratedInstance\n\t\thydratedInstance: function(instance){\n\t\t\tif( requests.count() > 0) {\n\t\t\t\tvar id = this.id(instance);\n\t\t\t\tif(! this._requestInstances[id] ) {\n\t\t\t\t\tthis.addInstanceReference(instance);\n\t\t\t\t\tthis._requestInstances[id] = instance;\n\t\t\t\t}\n\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.hydrateInstance hydrateInstance\n\t\t * @parent can-connect/constructor/store/store.hydrators\n\t\t *\n\t\t * Returns an instance given raw data, returning it from the [can-connect/constructor/store/store.instanceStore] if\n\t\t * available.\n\t\t *\n\t\t * @signature `connection.hydrateInstance(props)`\n\t\t * Overwrites the base `hydrateInstance` so that if a matching instance is in the\n\t\t * [can-connect/constructor/store/store.instanceStore], that instance will be\n\t\t * [can-connect/constructor/constructor.updatedInstance updated] with `props` and returned.  If there isn't a\n\t\t * matching instance, the base `hydrateInstance` will be called.\n\t\t *\n\t\t * @param {Object} props the raw data used to create an instance\n\t\t * @return {can-connect/Instance} a typed instance either created or updated with the data from `props`.\n\t\t */\n\t\thydrateInstance: function(props){\n\t\t\tvar id = this.id(props);\n\t\t\tif((id || id === 0) && this.instanceStore.has(id) ) {\n\t\t\t\tvar storeInstance = this.instanceStore.get(id);\n\t\t\t\t// TODO: find a way to prevent this from being called so many times.\n\t\t\t\tthis.updatedInstance(storeInstance, props);\n\t\t\t\treturn storeInstance;\n\t\t\t}\n\t\t\tvar instance = baseConnection.hydrateInstance.call(this, props);\n\t\t\tthis.hydratedInstance(instance);\n\t\t\treturn instance;\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.hydratedList hydratedList\n\t\t * @parent can-connect/constructor/store/store.hydrators\n\t\t *\n\t\t * Keeps new lists in the [can-connect/constructor/store/store.listStore] for the lifetime of any concurrent\n\t\t * requests.\n\t\t *\n\t\t * @signature `hydratedList(list)`\n\t\t * Adds a reference for new lists for the lifetime of any concurrent requests. Called when a new list is\n\t\t * created during [can-connect/constructor/store/store.hydrateList hydration]. This prevents concurrent requests\n\t\t * for the same data from returning different instances.\n\t\t *\n\t\t * @param {can-connect.List} list the newly hydrated list\n\t\t */\n\t\thydratedList: function(list, set){\n\t\t\tif( requests.count() > 0) {\n\t\t\t\tvar id = sortedSetJSON( set || this.listQuery(list) );\n\t\t\t\tif(id) {\n\t\t\t\t\tif(! this._requestLists[id] ) {\n\t\t\t\t\t\tthis.addListReference(list, set);\n\t\t\t\t\t\tthis._requestLists[id] = list;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.hydrateList hydrateList\n\t\t * @parent can-connect/constructor/store/store.hydrators\n\t\t *\n\t\t * Returns a list given raw data, returning it from the [can-connect/constructor/store/store.listStore] if\n\t\t * available.\n\t\t *\n\t\t * @signature `connection.hydrateList( listData, set )`\n\t\t *\n\t\t *   Overwrites the base `hydrateList` so that if a matching list is in the\n\t\t *   [can-connect/constructor/store/store.listStore], that list will be\n\t\t *   [can-connect/constructor/constructor.updatedList updated] with `listData` and returned.\n\t\t *   If there isn't a matching list, the base `hydrateList` will be called.\n\t\t *\n\t\t *   @param {can-connect.listData} listData raw list data to hydrate into a list type\n\t\t *   @param {can-query-logic/query} query the parameters that represent the set of data in `listData`\n\t\t *   @return {List} a typed list from either created or updated with the data from `listData`\n\t\t */\n\t\thydrateList: function(listData, set){\n\t\t\tset = set || this.listQuery(listData);\n\t\t\tvar id = sortedSetJSON( set );\n\n\t\t\tif( id && this.listStore.has(id) ) {\n\t\t\t\tvar storeList = this.listStore.get(id);\n\t\t\t\tthis.updatedList(storeList, listData, set);\n\t\t\t\treturn storeList;\n\t\t\t}\n\t\t\tvar list = baseConnection.hydrateList.call(this, listData, set);\n\t\t\tthis.hydratedList(list, set);\n\t\t\treturn list;\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.getList getList\n\t\t * @parent can-connect/constructor/store/store.crud\n\t\t *\n\t\t * Extends the underlying [can-connect/connection.getList] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\n\t\t * or [can-connect/constructor/store/store.hydrateList lists hydrated] during this request are kept in the store until\n\t\t * all the concurrent requests complete.\n\t\t *\n\t\t * @signature `connection.getList( set )`\n\t\t * Increments an internal request counter so instances hydrated during this request will be stored, and then\n\t\t * decrements the counter after the request is complete. This prevents concurrent requests for the same data from\n\t\t * returning different instances.\n\t\t *\n\t\t * @param {can-query-logic/query} listQuery parameters specifying the list to retrieve\n\t\t * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.getList]\n\t\t */\n\t\tgetList: function(listQuery) {\n\t\t\tvar self = this;\n\t\t\trequests.increment(this);\n\t\t\tvar promise = baseConnection.getList.call(this, listQuery);\n\n\t\t\tpromise.then(function(instances){\n\t\t\t\tself._finishedRequest();\n\t\t\t}, function(){\n\t\t\t\tself._finishedRequest();\n\t\t\t});\n\t\t\treturn promise;\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.get get\n\t\t * @parent can-connect/constructor/store/store.crud\n\t\t *\n\t\t * Extends the underlying [can-connect/connection.get] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\n\t\t * during this request are kept in the store until all the concurrent requests complete.\n\t\t *\n\t\t * @signature `connection.get( params )`\n\t\t * Increments an internal request counter so instances hydrated during this request will be stored, and then\n\t\t * decrements the counter after the request is complete. This prevents concurrent requests for the same data from\n\t\t * returning different instances.\n\t\t *\n\t\t * @param {Object} params params used to specify which instance to retrieve.\n\t\t * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.get]\n\t\t */\n\t\tget: function(params) {\n\t\t\tvar self = this;\n\t\t\trequests.increment(this);\n\t\t\tvar promise = baseConnection.get.call(this, params);\n\n\t\t\tpromise.then(function(instance){\n\t\t\t\tself._finishedRequest();\n\t\t\t}, function(){\n\t\t\t\tself._finishedRequest();\n\t\t\t});\n\t\t\treturn promise;\n\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.save save\n\t\t * @parent can-connect/constructor/store/store.crud\n\t\t *\n\t\t * Extends the underlying [can-connect/connection.save] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\n\t\t * during this request are kept in the store until all the concurrent requests complete.\n\t\t *\n\t\t * @signature `connection.save( instance )`\n\t\t *\n\t\t * Increments an internal request counter so instances hydrated during this request will be stored, and then\n\t\t * decrements the counter after the request is complete. This prevents concurrent requests for the same data from\n\t\t * returning different instances.\n\t\t *\n\t\t * @param {Object} instance a typed instance being saved\n\t\t * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.save]\n\t\t */\n\t\tsave: function(instance) {\n\t\t\tvar self = this;\n\t\t\trequests.increment(this);\n\n\t\t\tvar updating = !this.isNew(instance);\n\t\t\tif(updating) {\n\t\t\t\tthis.addInstanceReference(instance);\n\t\t\t}\n\n\t\t\tvar promise = baseConnection.save.call(this, instance);\n\n\t\t\tpromise.then(function(instances){\n\t\t\t\tif(updating) {\n\t\t\t\t\tself.deleteInstanceReference(instance);\n\t\t\t\t}\n\t\t\t\tself._finishedRequest();\n\t\t\t}, function(){\n\t\t\t\tself._finishedRequest();\n\t\t\t});\n\t\t\treturn promise;\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.destroy destroy\n\t\t * @parent can-connect/constructor/store/store.crud\n\t\t *\n\t\t * Extends the underlying [can-connect/connection.destroy] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\n\t\t * during this request are kept in the store until all the concurrent requests complete.\n\t\t *\n\t\t * @signature `connection.destroy( instance )`\n\t\t * Increments an internal request counter so instances hydrated during this request will be stored, and then\n\t\t * decrements the counter after the request is complete. This prevents concurrent requests for the same data from\n\t\t * returning different instances.\n\t\t *\n\t\t * @param {Object} instance a typed instance being deleted\n\t\t * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.destroy]\n\t\t */\n\t\tdestroy: function(instance) {\n\t\t\tvar self = this;\n\t\t\t// Add to instance store, for the duration of the\n\t\t\t// destroy callback\n\t\t\tthis.addInstanceReference(instance);\n\t\t\trequests.increment(this);\n\t\t\tvar promise = baseConnection.destroy.call(this, instance);\n\n\t\t\tpromise.then(function(instance){\n\t\t\t\tself._finishedRequest();\n\t\t\t\tself.deleteInstanceReference(instance);\n\t\t\t}, function(){\n\t\t\t\tself._finishedRequest();\n\t\t\t});\n\t\t\treturn promise;\n\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.updatedList updatedList\n\t\t * @parent can-connect/constructor/store/store.callbacks\n\t\t *\n\t\t * Extends the underlying [can-connect/connection.updatedList] so any instances that have been added or removed\n\t\t * from the list have their reference counts updated accordingly.\n\t\t *\n\t\t * @signature `connection.updatedList( list, listData, set )`\n\t\t * Increments an internal request counter so instances on this list during this request will be stored, and decrements\n\t\t * the same counter for all items previously on the list (found in `listData.data`).\n\t\t *\n\t\t * @param {can-connect.List} list a typed list of instances being updated\n\t\t * @param {Object} listData an object representing the previous state of the list\n\t\t * @param {Object} set the retrieval set used to get the list\n\t\t */\n\t\tupdatedList: function(list, listData, set) {\n\t\t\tvar oldList = list.slice(0);\n\t\t\tif(!listData.data && typeof listData.length === \"number\") {\n\t\t\t\tlistData = { data: listData };\n\t\t\t}\n\t\t\tif(baseConnection.updatedList) {\n\t\t\t\tbaseConnection.updatedList.call(this, list, listData, set);\n\t\t\t\tlist.forEach(function(instance) {\n\t\t\t\t\tthis.addInstanceReference(instance);\n\t\t\t\t}.bind(this));\n\t\t\t} else if(listData.data) {\n\t\t\t\tlistData.data.forEach(function(instance) {\n\t\t\t\t\tthis.addInstanceReference(instance);\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t\toldList.forEach(this.deleteInstanceReference.bind(this));\n\t\t}\n\t};\n\n\treturn behavior;\n\n});\nconstructorStore.requests = requests;\n// The number of ms to wait after all known requests have finished,\n//  before starting request cleanup.\n// If a new request comes in before timeout, wait until that request\n//  has finished (+ delay) before starting cleanup.\n// This is configurable, for use cases where more waiting is desired,\n//  or for the can-connect tests which expect everything to clean up\n//  in 1ms.\nconstructorStore.requestCleanupDelay = 10;\n\nmodule.exports = constructorStore;\n\n//!steal-remove-start\nif(true) {\n\tvar validate = __webpack_require__(/*! ../../helpers/validate */ \"./node_modules/can-connect/helpers/validate.js\");\n\tmodule.exports = validate(constructorStore, ['hydrateInstance', 'hydrateList', 'getList', 'get', 'save', 'destroy']);\n}\n//!steal-remove-end\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/constructor/store/store.js?");

/***/ }),

/***/ "./node_modules/can-connect/data/callbacks-cache/callbacks-cache.js":
/*!**************************************************************************!*\
  !*** ./node_modules/can-connect/data/callbacks-cache/callbacks-cache.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module can-connect/data/callbacks-cache/callbacks-cache data/callbacks-cache\n * @parent can-connect.behaviors\n *\n * Implements the data interface callbacks to call the [can-connect/base/base.cacheConnection]\n * [can-connect/DataInterface]. These calls keep the [can-connect/base/base.cacheConnection] contents\n * up to date.\n *\n * @signature `dataCallbacksCache( baseConnection )`\n * Implements the data interface callbacks so that a corresponding [can-connect/DataInterface] method is called on the\n * [can-connect/base/base.cacheConnection]. This updates the [can-connect/base/base.cacheConnection] contents whenever\n * data is updated on the primary connection.\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `data/callbacks-cache` behavior added\n * on to it.\n *\n * @return {{}} a `can-connect` connection containing the method implementations provided by `data/callbacks-cache`.\n *\n * ### Example\n * Shows synchronization between primary connection and cacheConnection data when using this behavior:\n * ```\n * import dataUrl from \"can-connect/data/url/\";\n * import dataCallbacks from \"can-connect/data/callbacks/\";\n * import cacheCallbacks from \"can-connect/data/callbacks-cache/\";\n * import memoryCache from \"can-connect/data/memory-cache/\";\n *\n * var cacheConnection = connect([memoryCache], {});\n * var todoConnection = connect([dataUrl, dataCallback, cacheCallbacks], {\n *   cacheConnection,\n *   url: \"/todo\"\n * });\n *\n * todoConnection.createData({name:'do the dishes', completed: false}).then(function(data) {\n *   todoConnection.cacheConnection.getData({id: data.id}).then(function(cachedData) {\n *     // data returned from connection and data returned from cache have the same contents\n *     data.id === cachedData.id; // true\n *     data.name === cachedData.name; // true\n *     data.completed === cachedData.completed; // true\n *     data === cachedData; // false, since callbacks-cache creates a copy of the data when adding it to the cache\n *   })\n * });\n * ```\n */\nvar connect = __webpack_require__(/*! ../../can-connect */ \"./node_modules/can-connect/can-connect.js\");\nvar assign = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\").assignMap;\nvar each = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\").each;\n\n// wires up the following methods\nvar pairs = {\n\t/**\n\t * @function can-connect/data/callbacks-cache/callbacks-cache.createdData createdData\n\t * @parent can-connect/data/callbacks-cache/callbacks-cache\n\t *\n\t * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a new data record is created.\n\t *\n\t * @signature `connection.createdData(responseData, requestData, cid)`\n\t *\n\t * Calls `createData` on the [can-connect/base/base.cacheConnection] to add a newly created data record to the cache.\n\t * Calls and returns the response from any underlying behavior's `createdData` callback.\n\t *\n\t * @param {{}} responseData the data returned by the data creation request\n\t * @param {{}} requestData the data that was passed to the data creation request\n\t * @param {Number} cid the unique identifier for this data. Used before data has a [can-connect/base/base.id] added\n\t * at creation time.\n\t *\n\t * @return {{}} the data returned from an underlying behavior's `createdData` callback, if one exists. Otherwise\n\t * returns the `responseData`.\n\t */\n\tcreatedData: \"createData\",\n\n\t/**\n\t * @function can-connect/data/callbacks-cache/callbacks-cache.updatedData updatedData\n\t * @parent can-connect/data/callbacks-cache/callbacks-cache\n\t *\n\t * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a data record is modified.\n\t *\n\t * @signature `connection.updatedData(responseData, requestData)`\n\t *\n\t * Calls `updateData` on the [can-connect/base/base.cacheConnection] to modify a data record stored in the cache.\n\t * Calls and returns the response from any underlying behavior's `updatedData` callback.\n\t *\n\t * @param {{}} responseData the data returned by the data update request\n\t * @param {{}} requestData the data that was passed to the data update request\n\t *\n\t * @return {{}} the data returned from an underlying behavior's `updatedData` callback, if one exists. Otherwise\n\t * returns the `responseData`.\n\t */\n\tupdatedData: \"updateData\",\n\n\t/**\n\t * @function can-connect/data/callbacks-cache/callbacks-cache.destroyedData destroyedData\n\t * @parent can-connect/data/callbacks-cache/callbacks-cache\n\t *\n\t * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a data record is deleted.\n\t *\n\t * @signature `connection.destroyedData(responseData, requestData)`\n\t *\n\t * Calls `destroyData` on the [can-connect/base/base.cacheConnection] to remove a data record stored in the cache.\n\t * Calls and returns the response from any underlying behavior's `destroyedData` callback.\n\t *\n\t * @param {{}} responseData the data returned by the data destroy request\n\t * @param {{}} requestData the data that was passed to the data destroy request\n\t *\n\t * @return {{}} the data returned from an underlying behavior's `destroyedData` callback, if one exists. Otherwise\n\t * returns the `responseData`.\n\t */\n\tdestroyedData: \"destroyData\"\n};\n\n\n\nvar callbackCache = connect.behavior(\"data/callbacks-cache\",function(baseConnection){\n\tvar behavior = {};\n\n\teach(pairs, function(crudMethod, dataCallback){\n\t\tbehavior[dataCallback] = function(data, params, cid){\n\n\t\t\t// update the data in the cache\n\t\t\tthis.cacheConnection[crudMethod]( assign(assign({}, params), data) );\n\n\t\t\t// return underlying dataCallback implementation if one exists or return input data\n\t\t\tif (baseConnection[dataCallback]) {\n\t\t\t\treturn baseConnection[dataCallback].call(this, data, params, cid);\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t};\n\t});\n\n\treturn behavior;\n});\n\nmodule.exports = callbackCache;\n\n//!steal-remove-start\nif(true) {\n\tvar validate = __webpack_require__(/*! ../../helpers/validate */ \"./node_modules/can-connect/helpers/validate.js\");\n\tmodule.exports = validate(callbackCache, []);\n}\n//!steal-remove-end\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/data/callbacks-cache/callbacks-cache.js?");

/***/ }),

/***/ "./node_modules/can-connect/data/callbacks/callbacks.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-connect/data/callbacks/callbacks.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module can-connect/data/callbacks/callbacks data/callbacks\n * @parent can-connect.behaviors\n *\n * Extend [can-connect/DataInterface] methods to call callbacks with the raw response data.\n *\n * @signature `dataCallbacks( baseConnection )`\n *\n * Extends the [can-connect/DataInterface] create, update, read & delete methods to call 'callback' methods following\n * their execution. Callbacks are called with the data returned from the underlying behavior's [can-connect/DataInterface]\n * implementation.\n *\n * For example:\n * ```\n * var dataUrl = require(\"can-connect/data/url/\");\n * var dataCallbacks = require(\"can-connect/data/url\");\n * var logging = {\n *   createdData: function(responseData) {\n *     console.log('New Todo Saved: ', responseData);\n *     return responseData;\n *   }\n * };\n * var todoConnection = connect([dataUrl, dataCallbacks, logging}],  {\n *   url: '/todos'\n * });\n *\n * // create a new todo\n * todoConnection.createData({name: \"do the dishes\", completed: false}).then(function(responseData) {\n *   responseData; // {id: 5}\n * });\n *\n * // after create request is completed, following is logged by the \"logging\" createdData callback:\n * // > New Todo Saved: {id: 5}\n * ```\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `data/callbacks` behavior added\n * on to it. Should already contain a behavior that provides the DataInterface (e.g [can-connect/data/url/url]). If\n * the `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.\n *\n * @return {{}} a `can-connect` connection containing the method implementations provided by `data/callbacks`.\n */\nvar connect = __webpack_require__(/*! ../../can-connect */ \"./node_modules/can-connect/can-connect.js\");\nvar each = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\").each;\n\n// wires up the following methods\nvar pairs = {\n\t/**\n\t * @function can-connect/data/callbacks/callbacks.getListData getListData\n\t * @parent can-connect/data/callbacks/callbacks\n\t *\n\t * Call `gotListData` with the data returned from underlying behavior's implementation of\n\t * [can-connect/connection.gotListData].\n\t *\n\t * @signature `getListData(listQuery)`\n\t *\n\t *   Extends the underlying behavior's [can-connect/connection.getListData] to call `gotListData` with the returned\n\t *   response data. The result of the call to `gotListData` will be used as the new response data.\n\t *\n\t *   @param {Object} listQuery an object that represents the set of data to be loaded\n\t *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `gotListData`.\n\t */\n\tgetListData: \"gotListData\",\n\n\t/**\n\t * @function can-connect/data/callbacks/callbacks.createData createData\n\t * @parent can-connect/data/callbacks/callbacks\n\t *\n\t * Call `createdData` with the data returned from underlying behavior's implementation of\n\t * [can-connect/connection.createData].\n\t *\n\t * @signature `createData(instanceData, cid)`\n\t *\n\t *   Extends the underlying behavior's [can-connect/connection.createData] to call `createdData` with the returned\n\t *   response data. The result of the call to `createdData` will be used as the new response data.\n\t *\n\t *   @param {Object} instanceData the raw data of an instance\n\t *   @param {Number} cid unique id that represents the instance that is being created\n\t *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `createdData`.\n\t */\n\tcreateData: \"createdData\",\n\n\t/**\n\t * @function can-connect/data/callbacks/callbacks.updateData updatedData\n\t * @parent can-connect/data/callbacks/callbacks\n\t *\n\t * Call `updatedData` with the data returned from underlying behavior's implementation of\n\t * [can-connect/connection.updateData].\n\t *\n\t * @signature `updateData(instanceData)`\n\t *\n\t *   Extends the underlying behavior's [can-connect/connection.updateData] to call `updatedData` with the returned\n\t *   response data. The result of the call to `updatedData` will be used as the new response data.\n\t *\n\t *   @param {Object} instanceData the raw data of an instance\n\t *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `updatedData`.\n\t */\n\tupdateData: \"updatedData\",\n\n\t/**\n\t * @function can-connect/data/callbacks/callbacks.destroyData destroyData\n\t * @parent can-connect/data/callbacks/callbacks\n\t *\n\t * Call `destroyedData` with the data returned from underlying behavior's implementation of\n\t * [can-connect/connection.destroyData].\n\t *\n\t * @signature `destroyData(params, cid)`\n\t *\n\t *   Extends the underlying behavior's [can-connect/connection.destroyData] to call `destroyedData` with the returned\n\t *   response data. The result of the call to `destroyedData` will be used as the new response data.\n\t *\n\t *   @param {Object} instanceData the raw data of an instance\n\t *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `destroyedData`.\n\t */\n\tdestroyData: \"destroyedData\"\n};\n\nvar dataCallbackBehavior = connect.behavior(\"data/callbacks\",function(baseConnection){\n\n\tvar behavior = {\n\t};\n\n\t// overwrites createData to createdData\n\teach(pairs, function(callbackName, name){\n\n\t\tbehavior[name] = function(params, cid){\n\t\t\tvar self = this;\n\n\t\t\treturn baseConnection[name].call(this, params).then(function(data){\n\t\t\t\tif(self[callbackName]) {\n\t\t\t\t\treturn self[callbackName].call(self,data, params, cid );\n\t\t\t\t} else {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t});\n\treturn behavior;\n});\n\nmodule.exports = dataCallbackBehavior;\n\n//!steal-remove-start\nif(true) {\n\tvar validate = __webpack_require__(/*! ../../helpers/validate */ \"./node_modules/can-connect/helpers/validate.js\");\n\tmodule.exports = validate(dataCallbackBehavior, [\n\t\t\"getListData\", \"createData\", \"updateData\", \"destroyData\"\n\t]);\n}\n//!steal-remove-end\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/data/callbacks/callbacks.js?");

/***/ }),

/***/ "./node_modules/can-connect/data/combine-requests/combine-requests.js":
/*!****************************************************************************!*\
  !*** ./node_modules/can-connect/data/combine-requests/combine-requests.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var connect = __webpack_require__(/*! ../../can-connect */ \"./node_modules/can-connect/can-connect.js\");\nvar getItems = __webpack_require__(/*! ../../helpers/get-items */ \"./node_modules/can-connect/helpers/get-items.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar makeDeferred = __webpack_require__(/*! ../../helpers/deferred */ \"./node_modules/can-connect/helpers/deferred.js\");\nvar forEach = [].forEach;\n/**\n * @module can-connect/data/combine-requests/combine-requests combine-requests\n * @parent can-connect.behaviors\n * @group can-connect/data/combine-requests.options 1 behavior options\n * @group can-connect/data/combine-requests.types 2 types\n * @group can-connect/data/combine-requests.data-methods 3 data methods\n * @group can-connect/data/combine-requests.queryLogic 4 queryLogic methods\n *\n * Combines multiple incoming lists requests into a single list request when possible.\n *\n * @signature `combineRequests( baseConnection )`\n *\n * Implements [can-connect/data/combine-requests.getListData] to collect the requested sets for some\n * [can-connect/data/combine-requests.time].  Once the configured amount of time has passed, it tries to take the\n * [can-connect/data/combine-requests.unionPendingRequests union] of the requested sets. It then makes requests with\n * those unified sets. Once the unified set requests have returned, the original requests are resolved by taking\n * [can-connect/data/combine-requests.filterMembers subsets] of the unified response data.\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `combine-requests` behavior added\n * on to it. Should already contain a behavior that provides `getListData` (e.g [can-connect/data/url/url]). If\n * the `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.\n *\n * @return {{}} a `can-connect` connection containing the method implementations provided by `combine-requests`.\n *\n * @body\n *\n * ## Use\n *\n * Create a connection with the `combine-requests` plugin:\n *\n * ```\n * var combineRequests = require(\"can-connect/data/combine-requests/\");\n * var dataUrl = require(\"can-connect/data/url/\");\n * var todosConnection = connect([dataUrl, combineRequests], {\n *   url: \"/todos\"\n * });\n * ```\n * Since the configuration above doesn't include the [can-connect/data/combine-requests.time] option, the following\n * will only make a single request if all requests are made during the same \"thread of execution\" (i.e. before the\n * browser takes a break from executing the current JavaScript):\n *\n * ```\n * todosConnection.getListData({})\n * todosConnection.getListData({filter: {userId: 5}});\n * todosConnection.getListData({filter: {userId: 5, type: \"critical\"}});\n * ```\n *\n * The above requests can all be joined since [can-set] intuitively knows that\n * `({filter: {userId: 5}}` and `{filter: {userId: 5, type: \"critical\"}}` are subsets of the complete set of todos, `{}`.\n *\n * For more advanced combining, a [can-query-logic queryLogic] must be configured. This allows `combine-requests` to understand\n * what certain parameters of a set mean, and how they might be combined.\n *\n *\n *\n */\nvar combineRequests = connect.behavior(\"data/combine-requests\",function(baseConnection){\n\tvar pendingRequests; //[{set, deferred}]\n\n\treturn {\n\t\t/**\n\t\t * @function can-connect/data/combine-requests.unionPendingRequests unionPendingRequests\n\t\t * @parent can-connect/data/combine-requests.queryLogic\n\t\t *\n\t\t * Group pending requests by the request that they are a subset of.\n\t\t *\n\t\t * @signature `connection.unionPendingRequests( pendingRequests )`\n\t\t *\n\t\t * This is called by [can-connect/data/combine-requests.getListData] to determine which pending requests can be unified\n\t\t * into a broader request. This produces a grouping of 'parent' sets to 'child' requests whose data will be\n\t\t * derived from the data retrieved by the parent.\n\t\t *\n\t\t * After this grouping is returned, [can-connect/data/combine-requests.getListData] executes requests for the parent\n\t\t * sets. After a parent request succeeds, the child requests will have their data calculated from the parent data.\n\t\t *\n\t\t * @param {Array<can-connect/data/combine-requests.PendingRequest>} pendingRequests\n\t\t * an array of objects, each containing:\n\t\t *   - `set` - the requested set\n\t\t *   - `deferred` - a wrapper around a `Promise` that will be resolved with this sets data\n\t\t *\n\t\t * @return {Array<{set: Set, pendingRequests: can-connect/data/combine-requests.PendingRequest}>}\n\t\t * an array of each of the unified requests to be made.  Each unified request should have:\n\t\t *   - `set` - the set to request\n\t\t *   - `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the `set` satisfies\n\t\t *\n\t\t * ### Example\n\t\t *\n\t\t * This function converts something like:\n\t\t *\n\t\t * ```\n\t\t * [\n\t\t *   {set: {completed: false}, deferred: def1},\n\t\t *   {set: {completed: true}, deferred: def2}\n\t\t * ]\n\t\t * ```\n\t\t *\n\t\t * to:\n\t\t *\n\t\t * ```\n\t\t * [\n\t\t *   {\n\t\t *    set: {},\n\t\t *    pendingRequests: [\n\t\t *      {set: {completed: false}, deferred: def1},\n\t\t *      {set: {completed: true}, deferred: def2}\n\t\t *    ]\n\t\t *   }\n\t\t * ]\n\t\t * ```\n\t\t *\n\t\t */\n\t\tunionPendingRequests: function(pendingRequests){\n\t\t\t// this should try to merge existing param requests, into an array of\n\t\t\t// others to send out\n\t\t\t// but this data structure keeps the original promises.\n\n\n\t\t\t// we need the \"biggest\" sets first so they can swallow up everything else\n\t\t\t// O(n log n)\n\t\t\tvar self = this;\n\n\t\t\tpendingRequests.sort(function(pReq1, pReq2){\n\n\t\t\t\tif(self.queryLogic.isSubset(pReq1.set, pReq2.set)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else if( self.queryLogic.isSubset(pReq2.set, pReq1.set) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t// O(n^2).  This can probably be made faster, but there are rarely lots of pending requests.\n\t\t\tvar combineData = [];\n\t\t\tvar current;\n\n\t\t\tdoubleLoop(pendingRequests, {\n\t\t\t\tstart: function(pendingRequest){\n\t\t\t\t\tcurrent = {\n\t\t\t\t\t\tset: pendingRequest.set,\n\t\t\t\t\t\tpendingRequests: [pendingRequest]\n\t\t\t\t\t};\n\t\t\t\t\tcombineData.push(current);\n\t\t\t\t},\n\t\t\t\titerate: function(pendingRequest){\n\t\t\t\t\tvar combined = self.queryLogic.union(current.set, pendingRequest.set);\n\t\t\t\t\tif( self.queryLogic.isDefinedAndHasMembers(combined) ) {\n\t\t\t\t\t\t// add next\n\t\t\t\t\t\tcurrent.set = combined;\n\t\t\t\t\t\tcurrent.pendingRequests.push(pendingRequest);\n\t\t\t\t\t\t// removes this from iteration\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn Promise.resolve(combineData);\n\t\t},\n\n\t\t/**\n\t\t * @property {Number} can-connect/data/combine-requests.time time\n\t\t * @parent can-connect/data/combine-requests.options\n\t\t *\n\t\t * Specifies the amount of time to wait to combine requests.\n\t\t *\n\t\t * @option {Number} Defaults to `1`, meaning only requests made within the same \"thread of execution\" will be\n\t\t * combined (i.e. requests made before the browser takes a break from the ongoing JavaScript execution).\n\t\t *\n\t\t * Increasing this number will mean that requests are delayed that length of time in case other requests\n\t\t * are made. In general, we advise against increasing this amount of time except in cases where loads take a\n\t\t * significant amount of time and the increased delay is unlikely to be noticed.\n\t\t *\n\t\t * ```\n\t\t * var combineRequests = require(\"can-connect/data/combine-requests/\");\n\t\t * connect([... combineRequests, ...],{\n\t\t *   time: 100\n\t\t * })\n\t\t * ```\n\t\t */\n\t\ttime:1,\n\n\t\t/**\n\t\t * @function can-connect/data/combine-requests.getListData getListData\n\t\t * @parent can-connect/data/combine-requests.data-methods\n\t\t *\n\t\t * Combines multiple list data requests into a single request, when possible.\n\t\t *\n\t\t * @signature `connection.getListData( set )`\n\t\t *\n\t\t * Extension of [can-connect/connection.getListData `getListData`] that tries to combine calls to it into a single\n\t\t * call. The calls are fulfilled by an underlying behavior's `getListData` implementation.\n\t\t *\n\t\t * Waits for a configured [can-connect/data/combine-requests.time] then tries to unify the sets requested during it.\n\t\t * After unification, calls for the unified sets are made to the underlying `getListData`. Once the unified\n\t\t * data has returned, the individual calls to `getListData` are resolved with a\n\t\t * [can-query-logic.prototype.filterMembers calculated subset] of the unified data.\n\t\t *\n\t\t * @param {can-query-logic/query} query the parameters of the requested set of data\n\t\t * @return {Promise<can-connect.listData>} `Promise` resolving the data of the requested set\n\t\t */\n\t\tgetListData: function(set){\n\t\t\tset = set || {};\n\t\t\tvar self = this;\n\n\t\t\tif(!pendingRequests) {\n\n\t\t\t\tpendingRequests = [];\n\n\t\t\t\tsetTimeout(function(){\n\n\t\t\t\t\tvar combineDataPromise = self.unionPendingRequests(pendingRequests);\n\t\t\t\t\tpendingRequests = null;\n\t\t\t\t\tcombineDataPromise.then(function(combinedData){\n\t\t\t\t\t\t// farm out requests\n\t\t\t\t\t\tforEach.call(combinedData, function(combined){\n\t\t\t\t\t\t\t// clone combine.set to prevent mutations by baseConnection.getListData\n\t\t\t\t\t\t\tvar combinedSet = canReflect.serialize(combined.set);\n\n\t\t\t\t\t\t\tbaseConnection.getListData(combinedSet).then(function(data){\n\t\t\t\t\t\t\t\tif(combined.pendingRequests.length === 1) {\n\t\t\t\t\t\t\t\t\tcombined.pendingRequests[0].deferred.resolve(data);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tforEach.call(combined.pendingRequests, function(pending){\n\t\t\t\t\t\t\t\t\t\t// get the subset using the combine.set property before being passed down\n\t\t\t\t\t\t\t\t\t\t// to baseConnection.getListData which might mutate it causing combinedRequests\n\t\t\t\t\t\t\t\t\t\t// to resolve with an `undefined` value instead of an actual set\n\t\t\t\t\t\t\t\t\t\t// https://github.com/canjs/can-connect/issues/139\n\t\t\t\t\t\t\t\t\t\tpending.deferred.resolve( {data: self.queryLogic.filterMembers(pending.set, combined.set, getItems(data))} );\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, function(err){\n\t\t\t\t\t\t\t\tif(combined.pendingRequests.length === 1) {\n\t\t\t\t\t\t\t\t\tcombined.pendingRequests[0].deferred.reject(err);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tforEach.call(combined.pendingRequests, function(pending){\n\t\t\t\t\t\t\t\t\t\tpending.deferred.reject(err);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\n\t\t\t\t}, this.time || 1);\n\t\t\t}\n\t\t\tvar deferred = makeDeferred();\n\n\t\t\tpendingRequests.push({deferred: deferred, set: set});\n\n\t\t\treturn deferred.promise;\n\t\t}\n\t};\n});\n\nmodule.exports = combineRequests;\n\n//!steal-remove-start\nvar validate = __webpack_require__(/*! ../../helpers/validate */ \"./node_modules/can-connect/helpers/validate.js\");\nmodule.exports = validate(combineRequests, ['getListData']);\n//!steal-remove-end\n\n/**\n * @typedef {PendingRequest} can-connect/data/combine-requests.PendingRequest PendingRequest\n * @parent can-connect/data/combine-requests.types\n *\n * @description Type to keep track of the multiple requests that were unified into a single request.\n *\n * @type {PendingRequest} Record of an individual request that has been unified as part of the combined request. After\n * the unified request completes instances of these types are processed to complete the individual requests with the\n * subset of the unified data.\n *\n * @option {can-query-logic/query} query a requested [can-set/Set set] of data that has been unified into the combined request\n * @option {{}} deferred a type that keeps track of the individual [can-connect/data/combine-requests.getListData]\n * promise that will be resolved after the unified request completes\n */\n\n// ### doubleLoop\nvar doubleLoop = function(arr, callbacks){\n\tvar i = 0;\n\twhile(i < arr.length) {\n\t\tcallbacks.start(arr[i]);\n\t\tvar j = i+1;\n\t\twhile( j < arr.length ) {\n\t\t\tif(callbacks.iterate(arr[j]) === true) {\n\t\t\t\tarr.splice(j, 1);\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/data/combine-requests/combine-requests.js?");

/***/ }),

/***/ "./node_modules/can-connect/data/localstorage-cache/localstorage-cache.js":
/*!********************************************************************************!*\
  !*** ./node_modules/can-connect/data/localstorage-cache/localstorage-cache.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module can-connect/data/localstorage-cache/localstorage-cache localstorage-cache\n * @parent can-connect.deprecated\n * @group can-connect/data/localstorage-cache/localstorage-cache.identifiers 0 identifiers\n * @group can-connect/data/localstorage-cache/localstorage-cache.data-methods 1 data methods\n *\n * Saves raw data in localStorage.\n *\n * @deprecated {5.0} Use [can-local-store] instead.\n *\n * @signature `localStorage( baseConnection )`\n *\n *   Creates a cache of instances and a cache of sets of instances that is\n *   accessible to read via [can-connect/data/localstorage-cache/localstorage-cache.getSets],\n *   [can-connect/data/localstorage-cache/localstorage-cache.getData], and [can-connect/data/localstorage-cache/localstorage-cache.getListData].\n *   The caches are updated via [can-connect/data/localstorage-cache/localstorage-cache.createData],\n *   [can-connect/data/localstorage-cache/localstorage-cache.updateData], [can-connect/data/localstorage-cache/localstorage-cache.destroyData],\n *   and [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n *\n *   [can-connect/data/localstorage-cache/localstorage-cache.createData],\n *   [can-connect/data/localstorage-cache/localstorage-cache.updateData],\n *   [can-connect/data/localstorage-cache/localstorage-cache.destroyData] are able to move items in and out\n *   of sets.\n *\n * @body\n *\n * ## Use\n *\n * `data/localstorage-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n * [can-connect/cache-requests/cache-requests].  Make sure you configure the connection's [can-connect/data/localstorage-cache/localstorage-cache.name].\n *\n * ```\n * var cacheConnection = connect([\n *   require(\"can-connect/data/localstorage-cache/localstorage-cache\")\n * ],{\n *   name: \"todos\"\n * });\n *\n * var todoConnection = connect([\n *   require(\"can-connect/data/url/url\"),\n *   require(\"can-connect/fall-through-cache/fall-through-cache\")\n * ],\n * {\n *   url: \"/services/todos\",\n *   cacheConnection: cacheConnection\n * });\n * ```\n *\n */\n \nmodule.exports = __webpack_require__(/*! can-local-store */ \"./node_modules/can-local-store/can-local-store.js\");\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/data/localstorage-cache/localstorage-cache.js?");

/***/ }),

/***/ "./node_modules/can-connect/data/memory-cache/memory-cache.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-connect/data/memory-cache/memory-cache.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module can-connect/data/memory-cache/memory-cache memory-cache\n * @parent can-connect.deprecated\n * @group can-connect/data/memory-cache/memory-cache.data-methods data methods\n *\n * Saves raw data in JavaScript memory that disappears when the page refreshes.\n *\n * @deprecated {5.0} Use [can-memory-store] instead.\n *\n * @signature `memoryCache( baseConnection )`\n *\n *   Creates a cache of instances and a cache of sets of instances that is\n *   accessible to read via [can-connect/data/memory-cache/memory-cache.getSets],\n *   [can-connect/data/memory-cache/memory-cache.getData], and [can-connect/data/memory-cache/memory-cache.getListData].\n *   The caches are updated via [can-connect/data/memory-cache/memory-cache.createData],\n *   [can-connect/data/memory-cache/memory-cache.updateData], [can-connect/data/memory-cache/memory-cache.destroyData],\n *   and [can-connect/data/memory-cache/memory-cache.updateListData].\n *\n *   [can-connect/data/memory-cache/memory-cache.createData],\n *   [can-connect/data/memory-cache/memory-cache.updateData],\n *   [can-connect/data/memory-cache/memory-cache.destroyData] are able to move items in and out\n *   of sets.\n *\n * @body\n *\n * ## Use\n *\n * `data/memory-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n * [can-connect/cache-requests/cache-requests].\n *\n * ```js\n * var cacheConnection = connect([\n *   require(\"can-connect/data/memory-cache/memory-cache\")\n * ],{});\n *\n * var todoConnection = connect([\n *   require(\"can-connect/data/url/url\"),\n *   require(\"can-connect/fall-through-cache/fall-through-cache\")\n * ],\n * {\n *   url: \"/services/todos\",\n *   cacheConnection: cacheConnection\n * });\n * ```\n */\nvar memoryStore = __webpack_require__(/*! can-memory-store */ \"./node_modules/can-memory-store/can-memory-store.js\");\n\nmodule.exports = memoryStore;\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/data/memory-cache/memory-cache.js?");

/***/ }),

/***/ "./node_modules/can-connect/data/parse/parse.js":
/*!******************************************************!*\
  !*** ./node_modules/can-connect/data/parse/parse.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {connect.Behavior} can-connect/data/parse/parse\n * @parent can-connect.behaviors\n *\n * Extract response data into a format needed for other extensions.\n *\n * @signature `dataParse( baseConnection )`\n *\n *   Overwrites the [can-connect/DataInterface] methods to run their results through\n *   either [can-connect/data/parse/parse.parseInstanceData] or [can-connect/data/parse/parse.parseListData].\n *\n *   @param {{}} baseConnection The base connection.\n *\n * @body\n *\n * ## Use\n *\n * `data/parse` is used to modify the response data of \"data interface\" methods to comply with what\n * is expected by \"instance interface\" methods.  For example, if a service was returning list data\n * at the `/services/todos` url like:\n *\n * ```\n * {\n *   todos: [\n *     {todo: {id: 0, name: \"dishes\"}},\n *     {todo: {id: 2, name: \"lawn\"}}\n *   ]\n * }\n * ```\n *\n * That service does not return [can-connect.listData] in the right format which should look like:\n *\n * ```\n * {\n *   data: [\n *     {id: 0, name: \"dishes\"},\n *     {id: 2, name: \"lawn\"}\n *   ]\n * }\n * ```\n *\n * To correct this, you can configure `data-parse` to use the [can-connect/data/parse/parse.parseListProp] and [can-connect/data/parse/parse.parseInstanceProp]\n * as follows:\n *\n * ```\n * connect([\n *   require(\"can-connect/data/parse/parse\"),\n *   require(\"can-connect/data/url/url\")\n * ],{\n *  parseListProp: \"todos\",\n *  parseInstanceProp: \"todo\"\n * })\n * ```\n *\n */\nvar each = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\").each;\nvar getObject = __webpack_require__(/*! can-key/get/get */ \"./node_modules/can-key/get/get.js\");\nvar behavior = __webpack_require__(/*! ../../behavior */ \"./node_modules/can-connect/behavior.js\");\n\nmodule.exports = behavior(\"data/parse\",function(baseConnection){\n\n\tvar behavior = {\n    /**\n     * @function can-connect/data/parse/parse.parseListData parseListData\n     * @parent can-connect/data/parse/parse\n     *\n     * @description Given a response from [can-connect/connection.getListData] returns its data in the\n     * proper [can-connect.listData] format.\n     *\n     * @signature `connection.parseListData(responseData)`\n     *\n     *   This function uses [can-connect/data/parse/parse.parseListProp] to find the array\n     *   containing the data for each instance.  Then it uses [can-connect/data/parse/parse.parseInstanceData]\n     *   on each item in the array  Finally, it returns data in the\n     *   [can-connect.listData] format.\n     *\n     *   @param {Object} responseData The response data from the AJAX request.\n     *\n     *   @return {can-connect.listData} An object like `{data: [props, props, ...]}`.\n     *\n     * @body\n     *\n     * ## Use\n     *\n     * `parseListData` comes in handy when dealing with an irregular API\n     * that can be improved with data transformation.\n     *\n     * Suppose an endpoint responds with a status of 200 OK, even when the\n     * request generates an empty result set. Worse yet, instead of representing\n     * an emtpy set with an empty list, it removes the property.\n     *\n     * A request to `/services/todos` may return:\n     *\n     * ```js\n     * {\n     *   todos: [\n     *     {todo: {id: 0, name: \"dishes\"}},\n     *     {todo: {id: 2, name: \"lawn\"}}\n     *   ]\n     * }\n     * ```\n     *\n     * What if a request for `/services/todos?filterName=bank` responds with\n     * 200 OK:\n     *\n     * ```\n     * {\n     * }\n     * ```\n     *\n     * This response breaks its own schema. One way to bring it in line\n     * with a format compatible with [can-connect.listData] is:\n     *\n     * ```js\n     * connect([\n     *   require(\"can-connect/data/parse/parse\"),\n     *   require(\"can-connect/data/url/url\")\n     * ],{\n     *   parseListProp: \"todos\",\n     *   parseListData(responseData) {\n     *     if (responseData && !responseData.todos) {\n     *       responseData = { todos: [] };\n     *     }\n     *\n     *     return responseData;\n     *   }\n     * })\n     * ```\n     */\n\t\tparseListData: function( responseData ) {\n\n\t\t\t// call any base parseListData\n\t\t\tif(baseConnection.parseListData) {\n\t\t\t   responseData = baseConnection.parseListData.apply(this, arguments);\n\t\t\t}\n\n\t\t\tvar result;\n\t\t\tif( Array.isArray(responseData) ) {\n\t\t\t\tresult = {data: responseData};\n\t\t\t} else {\n\t\t\t\tvar prop = this.parseListProp || 'data';\n\n\t\t\t\tresponseData.data = getObject(responseData, prop);\n\t\t\t\tresult = responseData;\n\t\t\t\tif(prop !== \"data\") {\n\t\t\t\t\tdelete responseData[prop];\n\t\t\t\t}\n\t\t\t\tif(!Array.isArray(result.data)) {\n\t\t\t\t\tthrow new Error('Could not get any raw data while converting using .parseListData');\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tvar arr = [];\n\t\t\tfor(var i =0 ; i < result.data.length; i++) {\n\t\t\t\tarr.push( this.parseInstanceData(result.data[i]) );\n\t\t\t}\n\t\t\tresult.data = arr;\n\t\t\treturn result;\n\t\t},\n    /**\n     * @function can-connect/data/parse/parse.parseInstanceData parseInstanceData\n     * @parent can-connect/data/parse/parse\n     *\n     * @description Returns the properties that should be used to [can-connect/constructor/constructor.hydrateInstance make an instance]\n     * given the results of [can-connect/connection.getData], [can-connect/connection.createData], [can-connect/connection.updateData],\n     * and [can-connect/connection.destroyData].\n     *\n     * @signature `connection.parseInstanceData(responseData)`\n     *\n     *   This function will use [can-connect/data/parse/parse.parseInstanceProp] to find the data object\n     *   representing the instance that will be created.\n     *\n     *   @param {Object} responseData The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].\n     *\n     *   @return {Object} The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].\n     *\n     * @body\n     *\n     * ## Use\n     *\n     * `parseInstanceData` comes in handy when dealing with an irregular API\n     * that can be improved with data transformation.\n     *\n     * Suppose a request to `/services/todos` returns:\n     * ```\n     * {\n     *   baseUrl: \"/proxy/share\",\n     *   todo: {\n     *     id: 0,\n     *     name: \"dishes\",\n     *     friendFaceUrl: \"friendface?id=0\",\n     *     fiddlerUrl: \"fiddler?id=0\"\n     *   }\n     * }\n     * ```\n     *\n     * The baseUrl property is meta-data that needs to be incorporated into the\n     * instance data. One way to deal with this is:\n     *\n     * ```\n     * connect([\n     *   require(\"can-connect/data/parse/parse\"),\n     *   require(\"can-connect/data/url/url\")\n     * ],{\n     *   parseInstanceProp: \"todo\",\n     *   parseInstanceData(responseData) {\n     *     ['friendFaceUrl', 'fiddlerUrl'].map(urlProp => {\n     *       responseData.todo[urlProp] = [\n     *         responseData.baseUrl,\n     *         responseData.todo[urlProp]\n     *       ].join('/');\n     *     });\n     *\n     *     return responseData;\n     *   }\n     * })\n     * ```\n     *\n     * This results in an object like:\n     *\n     * ```js\n     * {\n     *   id: 0,\n     *   name: \"dishes\",\n     *   friendFaceUrl: \"/proxy/share/friendface?id=0\",\n     *   fiddlerUrl: \"/proxy/share/fiddler?id=0\"\n     * }\n     * ```\n     */\n\t\tparseInstanceData: function( props ) {\n\t\t\t// call any base parseInstanceData\n\t\t\tif(baseConnection.parseInstanceData) {\n\t\t\t\t// It's possible this might be looking for a property that only exists in some\n\t\t\t\t// responses. So if it doesn't return anything, go back to using props.\n\t\t\t   props = baseConnection.parseInstanceData.apply(this, arguments) || props;\n\t\t\t}\n\t\t\treturn this.parseInstanceProp ? getObject(props, this.parseInstanceProp) || props : props;\n\t\t}\n\t\t/**\n\t\t * @property {String} can-connect/data/parse/parse.parseListProp parseListProp\n\t\t * @parent can-connect/data/parse/parse\n\t\t *\n\t\t * The property to find the array-like data that represents each instance item.\n\t\t *\n\t\t * @option {String} [can-connect/data/parse/parse.parseListData] uses this property to find an array-like data struture\n\t\t * on the result of [can-connect/connection.getListData].\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * Set `parseListProp` if your response data does not look like: `{data: [props, props]}`.\n\t\t *\n\t\t * For example, if [can-connect/connection.getListData] returns data like:\n\t\t *\n\t\t * ```\n\t\t * {\n\t\t * \t  todos: [{id: 1, name: \"dishes\"}, {id: 2, name: \"lawn\"}]\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * Set `parseListProp` to `\"todos\"` like:\n\t\t *\n\t\t * ```\n\t\t * connect([\n         *   require(\"can-connect/data/parse/parse\"),\n         *   require(\"can-connect/data/url/url\")\n         * ],{\n\t\t *   url : \"/todos\",\n\t\t *   parseListProp: \"todos\"\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t */\n\t\t/**\n\t\t * @property {String} can-connect/data/parse/parse.parseInstanceProp parseInstanceProp\n\t\t * @parent can-connect/data/parse/parse\n\t\t *\n\t\t * The property to find the data that represents an instance item.\n\t\t *\n\t\t * @option {String} [can-connect/data/parse/parse.parseInstanceData] uses this property's value to\n\t\t * [can-connect/constructor/constructor.hydrateInstance make an instance].\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * Set `parseInstanceData` if your response data does not directly contain the data you would like to pass to\n\t\t * [connection.hydrateInstance].\n\t\t *\n\t\t * For example, if [can-connect/connection.getData] returns data like:\n\t\t *\n\t\t * ```\n\t\t * {\n\t\t *   todo: {\n\t\t * \t   id: 1,\n\t\t *     name: \"dishes\"\n\t\t *   }\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * Set `parseInstanceProp` to `\"todo\"` like:\n\t\t *\n\t\t * ```\n\t\t * connect([\n         *   require(\"can-connect/data/parse/parse\"),\n         *   require(\"can-connect/data/url/url\")\n         * ],{\n\t\t *   url : \"/todos\",\n\t\t *   parseInstanceProp: \"todo\"\n\t\t * });\n\t\t * ```\n\t\t */\n\n\t};\n\n\teach(pairs, function(parseFunction, name){\n\t\tbehavior[name] = function(params){\n\t\t\tvar self = this;\n\t\t\treturn baseConnection[name].call(this, params).then(function(){\n\t\t\t\treturn self[parseFunction].apply(self, arguments);\n\t\t\t});\n\t\t};\n\t});\n\n\treturn behavior;\n\n});\n\nvar pairs = {\n\tgetListData: \"parseListData\",\n\tgetData: \"parseInstanceData\",\n\tcreateData: \"parseInstanceData\",\n\tupdateData: \"parseInstanceData\",\n\tdestroyData: \"parseInstanceData\"\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/data/parse/parse.js?");

/***/ }),

/***/ "./node_modules/can-connect/data/url/url.js":
/*!**************************************************!*\
  !*** ./node_modules/can-connect/data/url/url.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {connect.Behavior} can-connect/data/url/url data/url\n * @parent can-connect.behaviors\n * @group can-connect/data/url/url.data-methods data methods\n * @group can-connect/data/url/url.option options\n *\n * @option {connect.Behavior}\n *\n * Uses the [can-connect/data/url/url.url] option to implement the behavior of\n * [can-connect/connection.getListData],\n * [can-connect/connection.getData],\n * [can-connect/connection.createData],\n * [can-connect/connection.updateData], and\n * [can-connect/connection.destroyData] to make an AJAX request\n * to urls.\n *\n * @body\n *\n * ## Use\n *\n * The `data/url` behavior implements many of the [can-connect/DataInterface]\n * methods to send instance data to a URL.\n *\n * For example, the following `todoConnection`:\n *\n * ```js\n * var todoConnection = connect([\n *   require(\"can-connect/data/url/url\")\n * ],{\n *   url: {\n *     getListData: \"GET /todos\",\n *     getData: \"GET /todos/{id}\",\n *     createData: \"POST /todos\",\n *     updateData: \"PUT /todos/{id}\",\n *     destroyData: \"DELETE /todos/{id}\"\n *   }\n * });\n * ```\n *\n * Will make the following request when the following\n * methods are called:\n *\n * ```\n * // GET /todos?due=today\n * todoConnection.getListData({due: \"today\"});\n *\n * // GET /todos/5\n * todosConnection.getData({id: 5})\n *\n * // POST /todos \\\n * // name=take out trash\n * todosConnection.createData({\n *   name: \"take out trash\"\n * });\n *\n * // PUT /todos/5 \\\n * // name=do the dishes\n * todosConnection.updateData({\n *   name: \"do the dishes\",\n *   id: 5\n * });\n *\n * // DELETE /todos/5\n * todosConnection.destroyData({\n *   id: 5\n * });\n * ```\n *\n * There's a few things to notice:\n *\n * 1. URL values can include simple templates like `{id}`\n *    that replace that part of the URL with values in the data\n *    passed to the method.\n * 2. GET and DELETE request data is put in the URL using [can-param].\n * 3. POST and PUT requests put data that is not templated in the URL in POST or PUT body\n *    as JSON-encoded data.  To use form-encoded requests instead, add the property\n *    `contentType:'application/x-www-form-urlencoded'` to your [can-connect/data/url/url.url].\n * 4. If a provided URL doesn't include the method, the following default methods are provided:\n *    - `getListData` - `GET`\n *    - `getData` - `GET`\n *    - `createData` - `POST`\n *    - `updateData` - `PUT`\n *    - `destroyData` - `DELETE`\n *\n * If [can-connect/data/url/url.url] is provided as a string like:\n *\n * ```js\n * var todoConnection = connect([\n *   require(\"can-connect/data/url/url\")\n * ],{\n *   url: \"/todos\"\n * });\n * ```\n *\n * This does the same thing as the first `todoConnection` example.\n */\nvar ajax = __webpack_require__(/*! can-ajax */ \"./node_modules/can-ajax/dist/cjs/can-ajax.js\");\nvar replaceWith = __webpack_require__(/*! can-key/replace-with/replace-with */ \"./node_modules/can-key/replace-with/replace-with.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar behavior = __webpack_require__(/*! ../../behavior */ \"./node_modules/can-connect/behavior.js\");\nvar makeRest = __webpack_require__(/*! can-make-rest */ \"./node_modules/can-make-rest/can-make-rest.js\");\n\nvar defaultRest = makeRest(\"/resource/{id}\");\n\nvar makePromise = __webpack_require__(/*! ../../helpers/make-promise */ \"./node_modules/can-connect/helpers/make-promise.js\");\n\n// # can-connect/data/url/url\n// For each pair, create a function that checks the url object\n// and creates an ajax request.\nvar urlBehavior = behavior(\"data/url\", function(baseConnection) {\n\tvar behavior = {};\n\tcanReflect.eachKey(defaultRest, function(defaultData, dataInterfaceName){\n\t\tbehavior[dataInterfaceName] = function(params) {\n\t\t\tvar meta = methodMetaData[dataInterfaceName];\n\t\t\tvar defaultBeforeSend;\n\n\t\t\tif(typeof this.url === \"object\") {\n\t\t\t\tdefaultBeforeSend = this.url.beforeSend;\n\n\t\t\t\tif(typeof this.url[dataInterfaceName] === \"function\") {\n\n\t\t\t\t\treturn makePromise(this.url[dataInterfaceName](params));\n\t\t\t\t}\n\t\t\t\telse if(this.url[dataInterfaceName]) {\n\t\t\t\t\tvar promise = makeAjax(\n\t\t\t\t\t\t\tthis.url[dataInterfaceName],\n\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\tdefaultData.method,\n\t\t\t\t\t\t\tthis.ajax || ajax,\n\t\t\t\t\t\t\tfindContentType(this.url, defaultData.method),\n\t\t\t\t\t\t\tmeta,\n\t\t\t\t\t\t\tdefaultBeforeSend\n\t\t\t\t\t);\n\t\t\t\t\treturn makePromise(promise);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar resource = typeof this.url === \"string\" ? this.url : this.url.resource;\n\t\t\tif( resource ) {\n\t\t\t\tvar idProps = canReflect.getSchema(this.queryLogic).identity;\n\t\t\t\tvar resourceWithoutTrailingSlashes = resource.replace(/\\/+$/, \"\");\n\t\t\t\tvar result = makeRest(resourceWithoutTrailingSlashes, idProps[0])[dataInterfaceName];\n\t\t\t\treturn makePromise(makeAjax(\n\t\t\t\t\tresult.url,\n\t\t\t\t\tparams,\n\t\t\t\t\tresult.method,\n\t\t\t\t\tthis.ajax || ajax,\n\t\t\t\t\tfindContentType(this.url, result.method),\n\t\t\t\t\tmeta,\n\t\t\t\t\tdefaultBeforeSend\n\t\t\t\t));\n\t\t\t}\n\n\t\t\treturn baseConnection[name].call(this, params);\n\t\t};\n\t});\n\n\treturn behavior;\n});\n/**\n * @property {String|Object} can-connect/data/url/url.url url\n * @parent can-connect/data/url/url.option\n *\n * Specify the url and methods that should be used for the \"Data Methods\".\n *\n * @option {String} If a string is provided, it's assumed to be a RESTful interface. For example,\n * if the following is provided:\n *\n * ```\n * url: \"/services/todos\"\n * ```\n *\n * ... the following methods and requests are used:\n *\n *  - `getListData` - `GET /services/todos`\n *  - `getData` - `GET /services/todos/{id}`\n *  - `createData` - `POST /services/todos`\n *  - `updateData` - `PUT /services/todos/{id}`\n *  - `destroyData` - `DELETE /services/todos/{id}`\n *\n * @option {Object} If an object is provided, it can customize each method and URL directly\n * like:\n *\n * ```js\n * url: {\n *   getListData: \"GET /services/todos\",\n *   getData: \"GET /services/todo/{id}\",\n *   createData: \"POST /services/todo\",\n *   updateData: \"PUT /services/todo/{id}\",\n *   destroyData: \"DELETE /services/todo/{id}\"\n * }\n * ```\n *\n * You can provide a `resource` property that works like providing `url` as a string, but overwrite\n * other values like:\n *\n * ```js\n * url: {\n *   resource: \"/services/todo\",\n *   getListData: \"GET /services/todos\"\n * }\n * ```\n *\n * You can also customize per-method the parameters passed to the [can-connect/data/url/url.ajax ajax implementation], like:\n * ```js\n * url: {\n *   resource: \"/services/todos\",\n *   getListData: {\n *     url: \"/services/todos\",\n *     type: \"GET\",\n *     beforeSend: () => {\n *       return fetch('/services/context').then(processContext);\n *     }\n *   }\n * }\n * ```\n * This can be particularly useful for passing a handler for the [can-ajax <code>beforeSend</code>] hook.\n *\n * The [can-ajax <code>beforeSend</code>] hook can also be passed for all request methods. This can be useful when\n * attaching a session token header to a request:\n * \n * ```js\n * url: {\n *   resource: \"/services/todos\",\n *   beforeSend: (xhr) => {\n *     xhr.setRequestHeader('Authorization', `Bearer: ${Session.current.token}`);\n *   }\n * }\n * ```\n *\n * Finally, you can provide your own method to totally control how the request is made:\n *\n * ```js\n * url: {\n *   resource: \"/services/todo\",\n *   getListData: \"GET /services/todos\",\n *   getData: function(param){\n *     return new Promise(function(resolve, reject){\n *       $.get(\"/services/todo\", {identifier: param.id}).then(resolve, reject);\n *     });\n *   }\n * }\n * ```\n */\n\n\n /**\n  * @property {function} can-connect/data/url/url.ajax ajax\n  * @parent can-connect/data/url/url.option\n  *\n  * Specify the ajax functionality that should be used to make the request.\n  *\n  * @option {function} Provides an alternate function to be used to make\n  * ajax requests.  By default [can-ajax] provides the ajax\n  * functionality. jQuery's ajax method can be substituted as follows:\n  *\n  * ```js\n  * connect([\n  *   require(\"can-connect/data/url/url\")\n  * ],{\n  *   url: \"/things\",\n  *   ajax: $.ajax\n  * });\n  * ```\n  *\n  *   @param {Object} settings Configuration options for the AJAX request.\n  *   @return {Promise} A Promise that resolves to the data.\n  */\n\n// ## methodMetaData\n// Metadata on different methods that is passed to makeAjax\nvar methodMetaData = {\n\t/**\n\t * @function can-connect/data/url/url.getListData getListData\n\t * @parent can-connect/data/url/url.data-methods\n\t *\n\t * @signature `getListData(set)`\n\t *\n\t *   Retrieves list data for a particular set given the [can-connect/data/url/url.url] settings.\n\t *   If `url.getListData` is a function, that function will be called.  If `url.getListData` is a\n\t *   string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n\t *   `url`.\n\t *\n\t *   @param {can-query-logic/query} query A object that represents the set of data needed to be loaded.\n\t *   @return {Promise<can-connect.listData>} A promise that resolves to the ListData format.\n\t */\n\tgetListData: {},\n\t/**\n\t * @function can-connect/data/url/url.getData getData\n\t * @parent can-connect/data/url/url.data-methods\n\t *\n\t * @signature `getData(params)`\n\t *\n\t *   Retrieves raw instance data given the [can-connect/data/url/url.url] settings.\n\t *   If `url.getData` is a function, that function will be called.  If `url.getData` is a\n\t *   string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n\t *   `url+\"/\"+IDPROP`.\n\t *\n\t *   @param {Object} params A object that represents the set of data needed to be loaded.\n\t *   @return {Promise<Object>} A promise that resolves to the instance data.\n\t */\n\tgetData: {},\n\t/**\n\t * @function can-connect/data/url/url.createData createData\n\t * @parent can-connect/data/url/url.data-methods\n\t *\n\t * @signature `createData(instanceData, cid)`\n\t *\n\t *   Creates instance data given the serialized form of the data and\n\t *   the [can-connect/data/url/url.url] settings.\n\t *   If `url.createData` is a function, that function will be called.  If `url.createData` is a\n\t *   string, a request to that string will be made. If `url` is a string, a `POST` request is made to\n\t *   `url`.\n\t *\n\t *   @param {Object} instanceData The serialized data of the instance.\n\t *   @param {Number} cid A unique id that represents the instance that is being created.\n\t *   @return {Promise<Object>} A promise that resolves to the newly created instance data.\n\t */\n\tcreateData: {},\n\t/**\n\t * @function can-connect/data/url/url.updateData updateData\n\t * @parent can-connect/data/url/url.data-methods\n\t *\n\t * @signature `updateData(instanceData)`\n\t *\n\t * Updates instance data given the serialized form of the data and\n\t *   the [can-connect/data/url/url.url] settings.\n\t *   If `url.updateData` is a function, that function will be called.  If `url.updateData` is a\n\t *   string, a request to that string will be made. If `url` is a string, a `PUT` request is made to\n\t *   `url+\"/\"+IDPROP`.\n\t *\n\t *   @param {Object} instanceData The serialized data of the instance.\n\t *   @return {Promise<Object>} A promise that resolves to the updated instance data.\n\t */\n\tupdateData: {},\n\t/**\n\t * @function can-connect/data/url/url.destroyData destroyData\n\t * @parent can-connect/data/url/url.data-methods\n\t *\n\t * @signature `destroyData(instanceData)`\n\t *\n\t * Deletes instance data given the serialized form of the data and\n\t *   the [can-connect/data/url/url.url] settings.\n\t *   If `url.destroyData` is a function, that function will be called.  If `url.destroyData` is a\n\t *   string, a request to that string will be made. If `url` is a string, a `DELETE` request is made to\n\t *   `url+\"/\"+IDPROP`.\n\t *\n\t *   @param {Object} instanceData The serialized data of the instance.\n\t *   @return {Promise<Object>} A promise that resolves to the deleted instance data.\n\t */\n\tdestroyData: {includeData: false}\n};\n\nvar findContentType = function( url, method ) {\n\tif ( typeof url === 'object' && url.contentType ) {\n\t\tvar acceptableType = url.contentType === 'application/x-www-form-urlencoded' ||\n\t\t\turl.contentType === 'application/json';\n\t\tif ( acceptableType ) {\n\t\t\treturn url.contentType;\n\t\t} else {\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tdev.warn(\"Unacceptable contentType on can-connect request. \" +\n\t\t\t\t\t\"Use 'application/json' or 'application/x-www-form-urlencoded'\");\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\t}\n\treturn method === \"GET\" ? \"application/x-www-form-urlencoded\" : \"application/json\";\n};\n\nfunction urlParamEncoder (key, value) {\n\treturn encodeURIComponent(value);\n}\n\nvar makeAjax = function ( ajaxOb, data, type, ajax, contentType, reqOptions, defaultBeforeSend ) {\n\n\tvar params = {};\n\n\t// A string here would be something like `\"GET /endpoint\"`.\n\tif (typeof ajaxOb === 'string') {\n\t\t// Split on spaces to separate the HTTP method and the URL.\n\t\tvar parts = ajaxOb.split(/\\s+/);\n\t\tparams.url = parts.pop();\n\t\tif (parts.length) {\n\t\t\tparams.type = parts.pop();\n\t\t}\n\t} else {\n\t\t// If the first argument is an object, just load it into `params`.\n\t\tcanReflect.assignMap(params, ajaxOb);\n\t}\n\n\t// If the `data` argument is a plain object, copy it into `params`.\n\tparams.data = typeof data === \"object\" && !Array.isArray(data) ?\n\t\tcanReflect.assignMap(params.data || {}, data) : data;\n\n\t// Substitute in data for any templated parts of the URL.\n\tparams.url = replaceWith(params.url, params.data, urlParamEncoder, true);\n\tparams.contentType = contentType;\n\n\tif(reqOptions.includeData === false) {\n\t\tdelete params.data;\n\t}\n\n\treturn ajax(canReflect.assignMap({\n\t\ttype: type || 'post',\n\t\tdataType: 'json',\n\t\tbeforeSend: defaultBeforeSend,\n\t}, params));\n};\n\nmodule.exports = urlBehavior;\n\n//!steal-remove-start\nif(true) {\n\tvar validate = __webpack_require__(/*! ../../helpers/validate */ \"./node_modules/can-connect/helpers/validate.js\");\n\tmodule.exports = validate(urlBehavior, ['url']);\n}\n//!steal-remove-end\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/data/url/url.js?");

/***/ }),

/***/ "./node_modules/can-connect/fall-through-cache/fall-through-cache.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-connect/fall-through-cache/fall-through-cache.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module can-connect/fall-through-cache/fall-through-cache fall-through-cache\n * @parent can-connect.behaviors\n * @group can-connect/fall-through-cache/fall-through-cache.data data callbacks\n * @group can-connect/fall-through-cache/fall-through-cache.hydrators hydrators\n *\n * Add fall-through caching with the `cacheConnection`.\n *\n * @signature `fallThroughCache( baseConnection )`\n *\n *   Implements a `getData` and `getListData` that\n *   check their [can-connect/base/base.cacheConnection] for data. If there is data,\n *   this data will be immediately returned.\n *   In the background, the `baseConnection` method will be called and used to update the instance or list.\n *\n * @body\n *\n * ## Use\n *\n * To use the `fall-through-cache`, create a connection with a\n * [can-connect/base/base.cacheConnection] and a behavior that implements\n * [can-connect/connection.getData] and [can-connect/connection.getListData].\n *\n * ```js\n * var QueryLogic = require(\"can-query-logic\");\n *\n * var queryLogic = new QueryLogic();\n *\n * var cache = connect([\n *   require(\"can-local-store\")\n * ],{\n *   name: \"todos\",\n *   queryLogic: queryLogic\n * });\n *\n * var todoConnection = connect([\n *    require(\"can-connect/fall-through-cache/fall-through-cache\"),\n *    require(\"can-connect/data/url/url\"),\n *    require(\"can-connect/constructor/constructor\"),\n *    require(\"can-connect/constructor/store/store\")\n *   ], {\n *   url: \"/todos\",\n *   cacheConnection: cache,\n *   queryLogic: queryLogic\n * });\n * ```\n *\n * Then, make requests.  If the cache has the data,\n * it will be returned immediately, and then the item or list updated later\n * with the response from the base connection:\n *\n * ```js\n * todoConnection.getList({due: \"today\"}).then(function(todos){\n *\n * })\n * ```\n *\n * ## Demo\n *\n * The following shows the `fall-through-cache` behavior.\n *\n * @demo demos/can-connect/fall-through-cache.html\n *\n * Clicking\n * \"Completed\" or \"Incomplete\" will make one of the following requests and\n * display the results in the page:\n *\n * ```\n * todoConnection.getList({completed: true});\n * todoConnection.getList({completed: false});\n * ```\n *\n * If you click back and forth between \"Completed\" and \"Incomplete\" multiple times\n * you'll notice that the old data is displayed immediately and then\n * updated after about a second.\n *\n */\nvar connect = __webpack_require__(/*! ../can-connect */ \"./node_modules/can-connect/can-connect.js\");\nvar sortedSetJSON = __webpack_require__(/*! ../helpers/sorted-set-json */ \"./node_modules/can-connect/helpers/sorted-set-json.js\");\nvar canLog = __webpack_require__(/*! can-log */ \"./node_modules/can-log/can-log.js\");\n\nvar fallThroughCache = connect.behavior(\"fall-through-cache\",function(baseConnection){\n\n\tvar behavior = {\n\t\t/**\n\t\t * @function can-connect/fall-through-cache/fall-through-cache.hydrateList hydrateList\n\t\t * @parent can-connect/fall-through-cache/fall-through-cache.hydrators\n\t\t *\n\t\t * Returns a List instance given raw data.\n\t\t *\n\t\t * @signature `connection.hydrateList(listData, set)`\n\t\t *\n\t\t *   Calls the base `hydrateList` to create a List for `listData`.\n\t\t *\n\t\t *   Then, Looks for registered hydrateList callbacks for a given `set` and\n\t\t *   calls them.\n\t\t *\n\t\t *   @param {can-connect.listData} listData\n\t\t *   @param {can-query-logic/query} query\n\t\t *   @return {can-connect.List}\n\t\t */\n\t\thydrateList: function(listData, set){\n\t\t\tset = set || this.listQuery(listData);\n\t\t\tvar id = sortedSetJSON( set );\n\t\t\tvar list = baseConnection.hydrateList.call(this, listData, set);\n\n\t\t\tif(this._getHydrateListCallbacks[id]) {\n\t\t\t\tthis._getHydrateListCallbacks[id].shift()(list);\n\t\t\t\tif(!this._getHydrateListCallbacks[id].length){\n\t\t\t\t\tdelete this._getHydrateListCallbacks[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn list;\n\t\t},\n\t\t_getHydrateListCallbacks: {},\n\t\t_getHydrateList: function(set, callback){\n\t\t\tvar id = sortedSetJSON( set );\n\t\t\tif(!this._getHydrateListCallbacks[id]) {\n\t\t\t\tthis._getHydrateListCallbacks[id]= [];\n\t\t\t}\n\t\t\tthis._getHydrateListCallbacks[id].push(callback);\n\t\t},\n\t\t/**\n\t\t * @function can-connect/fall-through-cache/fall-through-cache.getListData getListData\n\t\t * @parent can-connect/fall-through-cache/fall-through-cache.data\n\t\t *\n\t\t * Get raw data from the cache if available, and then update\n\t\t * the list later with data from the base connection.\n\t\t *\n\t\t * @signature `connection.getListData(set)`\n\t\t *\n\t\t *   Checks the [can-connect/base/base.cacheConnection] for `set`'s data.\n\t\t *\n\t\t *   If the cache connection has data, the cached data is returned. Prior to\n\t\t *   returning the data, the [can-connect/constructor.hydrateList] method\n\t\t *   is intercepted so we can get a handle on the list that's being created\n\t\t *   for the returned data. Once the intercepted list is retrieved,\n\t\t *   we use the base connection to get data and update the intercepted list and\n\t\t *   the cacheConnection.\n\t\t *\n\t\t *   If the cache connection does not have data, the base connection\n\t\t *   is used to load the data and the cached connection is updated with that\n\t\t *   data.\n\t\t *\n\t\t *   @param {can-query-logic/query} query The set to load.\n\t\t *\n\t\t *   @return {Promise<can-connect.listData>} A promise that returns the\n\t\t *   raw data.\n\t\t */\n\t\t// if we do getList, the cacheConnection runs on\n\t\t// if we do getListData, ... we need to register the list that is going to be created\n\t\t// so that when the data is returned, it updates this\n\t\tgetListData: function(set){\n\t\t\tset = set || {};\n\t\t\tvar self = this;\n\t\t\treturn this.cacheConnection.getListData(set).then(function(data){\n\n\t\t\t\t// get the list that is going to be made\n\t\t\t\t// it might be possible that this never gets called, but not right now\n\t\t\t\tself._getHydrateList(set, function(list){\n\t\t\t\t\tself.addListReference(list, set);\n\n\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\tbaseConnection.getListData.call(self, set).then(function(listData){\n\n\t\t\t\t\t\t\tself.cacheConnection.updateListData(listData, set);\n\t\t\t\t\t\t\tself.updatedList(list, listData, set);\n\t\t\t\t\t\t\tself.deleteListReference(list, set);\n\n\t\t\t\t\t\t}, function(e){\n\t\t\t\t\t\t\t// what do we do here?  self.rejectedUpdatedList ?\n\t\t\t\t\t\t\tcanLog.log(\"REJECTED\", e);\n\t\t\t\t\t\t});\n\t\t\t\t\t},1);\n\t\t\t\t});\n\t\t\t\t// TODO: if we wired up all responses to updateListData, this one should not\n\t\t\t\t// updateListData with itself.\n\t\t\t\t// But, how would we do a bypass?\n\t\t\t\treturn data;\n\t\t\t}, function(){\n\n\t\t\t\tvar listData = baseConnection.getListData.call(self, set);\n\t\t\t\tlistData.then(function(listData){\n\n\t\t\t\t\tself.cacheConnection.updateListData(listData, set);\n\t\t\t\t});\n\n\t\t\t\treturn listData;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * @function can-connect/fall-through-cache/fall-through-cache.hydrateInstance hydrateInstance\n\t\t * @parent can-connect/fall-through-cache/fall-through-cache.hydrators\n\t\t *\n\t\t * Returns an instance given raw data.\n\t\t *\n\t\t * @signature `connection.hydrateInstance(props)`\n\t\t *\n\t\t *   Calls the base `hydrateInstance` to create an Instance for `props`.\n\t\t *\n\t\t *   Then, Looks for registered hydrateInstance callbacks for a given [can-connect/base/base.id] and\n\t\t *   calls them.\n\t\t *\n\t\t *   @param {Object} props\n\t\t *   @return {can-connect/Instance}\n\t\t */\n\t\thydrateInstance: function(props){\n\n\t\t\tvar id = this.id( props );\n\t\t\tvar instance = baseConnection.hydrateInstance.apply(this, arguments);\n\n\t\t\tif(this._getMakeInstanceCallbacks[id]) {\n\t\t\t\tthis._getMakeInstanceCallbacks[id].shift()(instance);\n\t\t\t\tif(!this._getMakeInstanceCallbacks[id].length){\n\t\t\t\t\tdelete this._getMakeInstanceCallbacks[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn instance;\n\t\t},\n\t\t_getMakeInstanceCallbacks: {},\n\t\t_getMakeInstance: function(id, callback){\n\t\t\tif(!this._getMakeInstanceCallbacks[id]) {\n\t\t\t\tthis._getMakeInstanceCallbacks[id]= [];\n\t\t\t}\n\t\t\tthis._getMakeInstanceCallbacks[id].push(callback);\n\t\t},\n\t\t/**\n\t\t * @function can-connect/fall-through-cache/fall-through-cache.getData getData\n\t\t * @parent can-connect/fall-through-cache/fall-through-cache.data\n\t\t *\n\t\t * Get raw data from the cache if available, and then update\n\t\t * the instance later with data from the base connection.\n\t\t *\n\t\t * @signature `connection.getData(params)`\n\t\t *\n\t\t *   Checks the [can-connect/base/base.cacheConnection] for `params`'s data.\n\t\t *\n\t\t *   If the cache connection has data, the cached data is returned. Prior to\n\t\t *   returning the data, the [can-connect/constructor/constructor.hydrateInstance] method\n\t\t *   is intercepted so we can get a handle on the instance that's being created\n\t\t *   for the returned data. Once the intercepted instance is retrieved,\n\t\t *   we use the base connection to get data and update the intercepted instance and\n\t\t *   the cacheConnection.\n\t\t *\n\t\t *   If the cache connection does not have data, the base connection\n\t\t *   is used to load the data and the cached connection is updated with that\n\t\t *   data.\n\t\t *\n\t\t *   @param {Object} params The set to load.\n\t\t *\n\t\t *   @return {Promise<Object>} A promise that returns the\n\t\t *   raw data.\n\t\t */\n\t\tgetData: function(params){\n\t\t\t// first, always check the cache connection\n\t\t\tvar self = this;\n\t\t\treturn this.cacheConnection.getData(params).then(function(instanceData){\n\n\t\t\t\t// get the list that is going to be made\n\t\t\t\t// it might be possible that this never gets called, but not right now\n\t\t\t\tself._getMakeInstance(self.id(instanceData) || self.id(params), function(instance){\n\t\t\t\t\tself.addInstanceReference(instance);\n\n\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\tbaseConnection.getData.call(self, params).then(function(instanceData2){\n\n\t\t\t\t\t\t\tself.cacheConnection.updateData(instanceData2);\n\t\t\t\t\t\t\tself.updatedInstance(instance, instanceData2);\n\t\t\t\t\t\t\tself.deleteInstanceReference(instance);\n\n\t\t\t\t\t\t}, function(e){\n\t\t\t\t\t\t\t// what do we do here?  self.rejectedUpdatedList ?\n\t\t\t\t\t\t\tcanLog.log(\"REJECTED\", e);\n\t\t\t\t\t\t});\n\t\t\t\t\t},1);\n\t\t\t\t});\n\n\t\t\t\treturn instanceData;\n\t\t\t}, function(){\n\t\t\t\tvar listData = baseConnection.getData.call(self, params);\n\t\t\t\tlistData.then(function(instanceData){\n\t\t\t\t\tself.cacheConnection.updateData(instanceData);\n\t\t\t\t});\n\n\t\t\t\treturn listData;\n\t\t\t});\n\t\t}\n\n\t};\n\n\treturn behavior;\n\n});\n\nmodule.exports = fallThroughCache;\n\n//!steal-remove-start\nif(true) {\n\tvar validate = __webpack_require__(/*! ../helpers/validate */ \"./node_modules/can-connect/helpers/validate.js\");\n\tmodule.exports = validate(fallThroughCache, ['hydrateList', 'hydrateInstance', 'getListData', 'getData']);\n}\n//!steal-remove-end\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/fall-through-cache/fall-through-cache.js?");

/***/ }),

/***/ "./node_modules/can-connect/helpers/deferred.js":
/*!******************************************************!*\
  !*** ./node_modules/can-connect/helpers/deferred.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function(){\n\tvar def = {};\n\tdef.promise = new Promise(function(resolve, reject){\n\t\tdef.resolve = resolve;\n\t\tdef.reject = reject;\n\t});\n\treturn def;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/helpers/deferred.js?");

/***/ }),

/***/ "./node_modules/can-connect/helpers/get-items.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-connect/helpers/get-items.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(data){\n\tif(Array.isArray(data)) {\n\t\treturn data;\n\t} else {\n\t\treturn data.data;\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/helpers/get-items.js?");

/***/ }),

/***/ "./node_modules/can-connect/helpers/id-merge.js":
/*!******************************************************!*\
  !*** ./node_modules/can-connect/helpers/id-merge.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar diffList = __webpack_require__(/*! can-diff/list/list */ \"./node_modules/can-diff/list/list.js\");\n\nmodule.exports = function(list, update, id, make){\n\n\tvar patches = diffList(list, update, function(a, b){\n\t\treturn id(a) === id(b);\n\t});\n\tpatches.forEach(function(patch){\n\t\tcanReflect.splice(list, patch.index, patch.deleteCount, patch.insert.map(make));\n\t});\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/helpers/id-merge.js?");

/***/ }),

/***/ "./node_modules/can-connect/helpers/make-promise.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-connect/helpers/make-promise.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nmodule.exports = function(obj){\n\tif (obj && typeof obj.then === \"function\" && !canReflect.isPromise(obj)) {\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tobj.then(resolve, reject);\n\t\t});\n\t}\n\telse {\n\t\treturn obj;\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/helpers/make-promise.js?");

/***/ }),

/***/ "./node_modules/can-connect/helpers/sorted-set-json.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-connect/helpers/sorted-set-json.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nmodule.exports = function(set){\n\tif(set == null) {\n\t\treturn set;\n\t} else {\n\t\treturn JSON.stringify(canReflect.cloneKeySort(set));\n\t}\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/helpers/sorted-set-json.js?");

/***/ }),

/***/ "./node_modules/can-connect/helpers/validate.js":
/*!******************************************************!*\
  !*** ./node_modules/can-connect/helpers/validate.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// return wrapped can-connect behavior mixin that validates interface of the input behavior being extended\n// deprecate this and use can-validate-interface decorator once available\n\nvar makeInterfaceValidator = __webpack_require__(/*! can-validate-interface */ \"./node_modules/can-validate-interface/index.js\");\n\nmodule.exports = function(extendingBehavior, interfaces){\n\tvar validatedBehaviour = validateArgumentInterface(extendingBehavior, 0, interfaces, function(errors, baseBehavior) {\n\t\tthrow new BehaviorInterfaceError(baseBehavior, extendingBehavior, errors);\n\t});\n\n\t// copy properties on behavior to validator wrapped behavior\n\tObject.keys(extendingBehavior).forEach(function (k) {\n\t\tvalidatedBehaviour[k] = extendingBehavior[k];\n\t});\n\t// add interfaces for building behavior ordering\n\tvalidatedBehaviour.__interfaces = interfaces;\n\n\treturn validatedBehaviour;\n};\n\nfunction validateArgumentInterface(func, argIndex, interfaces, errorHandler) {\n\treturn function() {\n\t\tvar errors = makeInterfaceValidator(interfaces)(arguments[argIndex]);\n\t\tif (errors && errorHandler) {\n\t\t\terrorHandler(errors, arguments[argIndex]);\n\t\t}\n\n\t\treturn func.apply(this, arguments);\n\t};\n}\n\n\n// change to 'BehaviourInterfaceError extends Error' once we drop support for pre-ES2015\nfunction BehaviorInterfaceError(baseBehavior, extendingBehavior, missingProps) {\n\tvar extendingName = extendingBehavior.behaviorName || 'anonymous behavior',\n\t\tbaseName = baseBehavior.__behaviorName || 'anonymous behavior',\n\t\tmessage = 'can-connect: Extending behavior \"' + extendingName + '\" found base behavior \"' + baseName + '\" was missing required properties: ' + JSON.stringify(missingProps.related),\n\t\tinstance = new Error(message);\n\n\tif (Object.setPrototypeOf){\n\t\tObject.setPrototypeOf(instance, Object.getPrototypeOf(this));\n\t}\n\treturn instance;\n}\nBehaviorInterfaceError.prototype = Object.create(Error.prototype, {\n\tconstructor: {value: Error}\n});\nif (Object.setPrototypeOf){\n\tObject.setPrototypeOf(BehaviorInterfaceError, Error);\n} else {\n\t/* jshint proto: true */\n\tBehaviorInterfaceError.__proto__ = Error;\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/helpers/validate.js?");

/***/ }),

/***/ "./node_modules/can-connect/helpers/weak-reference-map.js":
/*!****************************************************************!*\
  !*** ./node_modules/can-connect/helpers/weak-reference-map.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar assign = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\").assignMap;\n\n/**\n * @module {function} can-connect/helpers/weak-reference-map WeakReferenceMap\n * @parent can-connect.modules\n *\n * Provides a map that only contains keys that are referenced.\n *\n * @signature `new WeakReferenceMap()`\n *\n *   Creates a new weak reference map.\n *\n * @body\n *\n * ## Use\n *\n * ```\n * var WeakReferenceMap = require(\"can-connect/helpers/weak-reference-map\");\n * var wrm = new WeakReferenceMap();\n * var task1 = {id: 1, name: \"do dishes\"};\n *\n * wrm.addReference(\"1\", task1);\n * wrm.has(\"1\") //-> true\n * wrm.addReference(\"1\", task1);\n * wrm.has(\"1\") //-> true\n * wrm.deleteReference(\"1\");\n * wrm.has(\"1\") //-> true\n * wrm.deleteReference(\"1\");\n * wrm.has(\"1\") //-> false\n * ```\n */\n\nvar WeakReferenceMap = function(){\n\tthis.set = {};\n};\n\n// if weakmap, we can add and never worry ...\n// otherwise, we need to have a count ...\n\nassign(WeakReferenceMap.prototype,\n/**\n * @prototype\n */\n\t{\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.has has\n\t * @signature `weakReferenceMap.has(key)`\n\t *\n\t *   Returns if key is in the set.\n\t *\n\t *   @param  {String} key A key to look for.\n\t *   @return {Boolean} If the key exists.\n\t */\n\thas: function(key){\n\t\treturn !!this.set[key];\n\t},\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.addReference addReference\n\t * @signature `WeakReferenceMap.addReference(key, item)`\n\t *\n\t *   Adds a reference to item as key and increments the reference count. This should be called\n\t *   when a value should be managed by something, typically the [can-connect/constructor/store/store].\n\t *\n\t *   @param  {String} key The key of the item in the store.\n\t */\n\taddReference: function(key, item, referenceCount){\n\t\t// !steal-remove-start\n\t\tif (typeof key === 'undefined'){\n\t\t\tthrow new Error(\"can-connect: You must provide a key to store a value in a WeakReferenceMap\");\n\t\t}\n\t\t// !steal-remove-end\n\t\tvar data = this.set[key];\n\t\tif(!data) {\n\t\t\tdata = this.set[key] = {\n\t\t\t\titem: item,\n\t\t\t\treferenceCount: 0,\n\t\t\t\tkey: key\n\t\t\t};\n\t\t}\n\t\tdata.referenceCount += (referenceCount || 1);\n\t},\n\treferenceCount: function(key) {\n\t\tvar data = this.set[key];\n\t\tif(data) {\n\t\t\treturn data.referenceCount;\n\t\t}\n\t},\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.deleteReference deleteReference\n\t * @signature `weakReferenceMap.deleteReference(key)`\n\t *\n\t *   Decrements the reference count for key and removes it if the reference count is `0`. This should be called\n\t *   when a value should not be managed by something, typically the [can-connect/constructor/store/store].\n\t *\n\t *   @param  {String} key The key of the item in the store.\n\t */\n\tdeleteReference: function(key){\n\t\tvar data = this.set[key];\n\t\tif(data){\n\t\t\tdata.referenceCount--;\n\t\t\tif( data.referenceCount === 0 ) {\n\t\t\t\tdelete this.set[key];\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.get get\n\t * @signature `weakReferenceMap.get(key)`\n\t *\n\t *   Returns the value stored at key if it's in the store.\n\t *\n\t *   @param  {String} key The key of the item in the store.\n\t *   @return {*|undefined} The item if it's available.\n\t */\n\tget: function(key){\n\t\tvar data = this.set[key];\n\t\tif(data) {\n\t\t\treturn data.item;\n\t\t}\n\t},\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.forEach forEach\n\t * @signature `weakReferenceMap.forEach(callback)`\n\t *\n\t *   Calls `callback` for every value in the store.\n\t *\n\t *   @param  {function(*,String)} callback(item,key) A callback handler.\n\t */\n\tforEach: function(cb){\n\t\tfor(var id in this.set) {\n\t\t\tcb(this.set[id].item, id);\n\t\t}\n\t}\n});\n\nmodule.exports = WeakReferenceMap;\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/helpers/weak-reference-map.js?");

/***/ }),

/***/ "./node_modules/can-connect/helpers/weak-reference-set.js":
/*!****************************************************************!*\
  !*** ./node_modules/can-connect/helpers/weak-reference-set.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var assign = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\").assignMap;\n\n\nvar WeakReferenceSet = function(){\n\tthis.set = [];\n};\n\n// if weakmap, we can add and never worry ...\n// otherwise, we need to have a count ...\n\nassign(WeakReferenceSet.prototype,{\n\n\thas: function(item){\n\t\treturn this._getIndex(item) !== -1;\n\t},\n\taddReference: function(item, referenceCount){\n\n\t\tvar index = this._getIndex(item);\n\t\tvar data = this.set[index];\n\n\t\tif(!data) {\n\t\t\tdata = {\n\t\t\t\titem: item,\n\t\t\t\treferenceCount: 0\n\t\t\t};\n\t\t\tthis.set.push(data);\n\t\t}\n\t\tdata.referenceCount += (referenceCount || 1);\n\t},\n\tdeleteReference: function(item){\n\t\tvar index = this._getIndex(item);\n\t\tvar data = this.set[index];\n\t\tif(data){\n\t\t\tdata.referenceCount--;\n\t\t\tif( data.referenceCount === 0 ) {\n\t\t\t\tthis.set.splice(index,1);\n\t\t\t}\n\t\t}\n\t},\n\tdelete: function(item){\n\t\tvar index = this._getIndex(item);\n\t\tif(index !== -1) {\n\t\t\tthis.set.splice(index,1);\n\t\t}\n\t},\n\tget: function(item){\n\t\tvar data = this.set[this._getIndex(item)];\n\t\tif(data) {\n\t\t\treturn data.item;\n\t\t}\n\t},\n\treferenceCount: function(item) {\n\t\tvar data = this.set[this._getIndex(item)];\n\t\tif(data) {\n\t\t\treturn data.referenceCount;\n\t\t}\n\t},\n\t_getIndex: function(item){\n\t\tvar index;\n\t\tthis.set.every(function(data, i){\n\t\t\tif(data.item === item) {\n\n\t\t\t\tindex = i;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn index !== undefined ? index : -1;\n\t},\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.forEach forEach\n\t * @signature `weakReferenceMap.forEach(callback)`\n\t *\n\t *   Calls `callback` for every value in the store.\n\t *\n\t *   @param  {function(*,String)} callback(item,key) A callback handler.\n\t */\n\tforEach: function(cb){\n\t\treturn this.set.forEach(cb);\n\t}\n});\n\nmodule.exports = WeakReferenceSet;\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/helpers/weak-reference-set.js?");

/***/ }),

/***/ "./node_modules/can-connect/real-time/real-time.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-connect/real-time/real-time.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module can-connect/real-time/real-time real-time\n * @parent can-connect.behaviors\n * @group can-connect/real-time/real-time.methods 0 methods\n * @group can-connect/real-time/real-time.callbacks 1 data callbacks\n *\n * Update lists to include or exclude instances based\n * on set logic.\n *\n * @signature `realTime( baseConnection )`\n *\n *   Overwrites the \"data callback\" methods and provides\n *   [can-connect/real-time/real-time.createInstance],\n *   [can-connect/real-time/real-time.updateInstance], and\n *   [can-connect/real-time/real-time.destroyInstance] methods\n *   that\n *   update lists to include or exclude a created,\n *   updated, or destroyed instance.\n *\n *   An instance is put in a list if it is a\n *   [can-query-logic/queryLogic.prototype.isSubset]\n *   of the [can-connect/base/base.listQuery].  The item is inserted using [can-query-logic.prototype.index].\n *\n * @body\n *\n * ## Use\n *\n * To use `real-time`, create a connection with its dependent\n * behaviors like:\n *\n * ```js\n * var todoConnection = connect(\n *    [\"data/callbacks\",\n *     \"real-time\",\n *     \"constructor/callbacks-once\",\n *     \"constructor/store\",\n *     \"constructor\",\n *     \"data/url\"],{\n *   url: \"/todos\"\n * });\n * ```\n *\n * Next, use the connection to load lists and save those lists in the\n * store:\n *\n * ```js\n * todoConnection.getList({complete: false}).then(function(todos){\n *   todoConnection.addListReference(todos);\n * })\n * ```\n *\n * Finally, use one of the  [can-connect/real-time/real-time.createInstance],\n * [can-connect/real-time/real-time.updateInstance], and\n * [can-connect/real-time/real-time.destroyInstance] methods to tell the connection\n * that data has changed.  The connection will update (by calling splice)\n * each list accordingly.\n *\n *\n * ## Example\n *\n * The following demo shows two lists that use this connection.  The\n * \"Run Code\" button sends the connection data changes which the\n * connection will then update lists accordingly:\n *\n *\n * @demo demos/can-connect/real-time.html\n *\n * This example creates a `todoList` function and `todoItem` function\n * that manage the behavior of a list of todos and a single todo respectfully.\n * It uses [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe)\n * to observe changes in the todo list and individual todo data. Other\n * frameworks will typically provide their own observable system.\n *\n * ### todoList\n *\n * When `todoList` is created, it is passed the `set` of data to load.  It uses\n * this to get todos from the `todoConnection` like:\n *\n *\n * ```js\n * todosConnection.getList(set).then(function(retrievedTodos){\n * ```\n *\n * It then adds those `todos` to the [can-connect/constructor/store/store.listStore] so\n * they can be updated automatically.  And, it listens to changes in `todos` and calls an `update` function:\n *\n * ```js\n * todosConnection.addListReference(todos);\n * Object.observe(todos, update, [\"add\", \"update\", \"delete\"] );\n * ```\n *\n * The update function is able to inserted new `todoItem`s in the page when items are added\n * to or removed from `todos`.  We exploit that by calling `update` as if it just added\n * each todo in the list:\n *\n * ```js\n * update(todos.map(function(todo, i){\n *   return {\n *     type: \"add\",\n *     name: \"\"+i\n *   };\n * }));\n * ```\n *\n * ### todoItem\n *\n * The `todoItem` creates an element that updates with changes\n * in its `todo`.  It listens to changes in the `todo` and saves\n * the todo in the [can-connect/constructor/store/store.instanceStore] with the\n * following:\n *\n * ```js\n * Object.observe(todo, update, [\"add\", \"update\", \"delete\"] );\n * todosConnection.addInstanceReference(todo);\n * ```\n *\n * A `todoItem` needs to be able to stop listening on the `todo` and remove itself from the\n * `instanceStore` if the `todo` is removed from the page.  To provide this teardown\n * functionality, `todoItem` listens to a `\"removed\"` event on its element and\n * `unobserves` the todo and removes it from the `instanceStore`:\n *\n * ```js\n * $(li).bind(\"removed\", function(){\n *   Object.unobserve(todo, update, [\"add\", \"update\", \"delete\"] );\n *   todosConnection.deleteInstanceReference(todo);\n * });\n * ```\n */\nvar connect = __webpack_require__(/*! ../can-connect */ \"./node_modules/can-connect/can-connect.js\");\nvar indexByIdentity = __webpack_require__(/*! can-diff/index-by-identity/index-by-identity */ \"./node_modules/can-diff/index-by-identity/index-by-identity.js\");\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar spliceSymbol = canSymbol.for(\"can.splice\");\n\nfunction updateList(list, getRecord, currentIndex, newIndex) {\n\tif(currentIndex === -1) { // item is not in the list\n\n\t\tif(newIndex !== -1) { // item should be in the list\n\t\t\tcanReflect.splice(list, newIndex, 0, [getRecord()]);\n\t\t}\n\t}\n\telse { // item is already in the list\n\t\tif(newIndex === -1) { // item should be removed from the lists\n\t\t\tcanReflect.splice(list, currentIndex, 1, []);\n\t\t}\n\t\telse if(newIndex !== currentIndex){ // item needs to be moved\n\n\t\t\tif(currentIndex < newIndex) {\n\t\t\t\tcanReflect.splice(list, newIndex, 0, [getRecord()]);\n\t\t\t\tcanReflect.splice(list, currentIndex, 1, []);\n\t\t\t} else {\n\t\t\t\tcanReflect.splice(list, currentIndex,1, []);\n\t\t\t\tcanReflect.splice(list, newIndex, 0, [getRecord()]);\n\t\t\t}\n\t\t}\n\t\telse { // item in the same place\n\n\t\t}\n\t}\n}\n\n\nfunction updateListWithItem(list, recordData, currentIndex, newIndex, connection, set){\n\t// we are inserting right where we already are.\n\tif(currentIndex !== -1 && (newIndex === currentIndex + 1 || newIndex === currentIndex)) {\n\t\treturn;\n\t}\n\tif(list[spliceSymbol] !== undefined) {\n\t\tupdateList(list, function(){\n\t\t\treturn connection.hydrateInstance(recordData);\n\t\t},currentIndex, newIndex);\n\n\t} else {\n\t\tvar copy = connection.serializeList(list);\n\t\tupdateList(copy, function(){\n\t\t\treturn recordData;\n\t\t},currentIndex, newIndex);\n\t\tconnection.updatedList(list,  { data: copy }, set);\n\t}\n}\n\n\nmodule.exports = connect.behavior(\"real-time\",function(baseConnection){\n\n\tvar createPromise = Promise.resolve();\n\tvar behavior;\n\n\tbehavior = {\n\t\tcreateData: function(){\n\t\t\tvar promise = baseConnection.createData.apply(this, arguments);\n\t\t\tvar cleanPromise = promise.catch(function () { return ''; });\n\t\t\tcreatePromise = Promise.all([createPromise, cleanPromise]);\n\t\t\treturn promise;\n\t\t},\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.createInstance createInstance\n\t\t * @parent can-connect/real-time/real-time.methods\n\t\t *\n\t\t * Programatically indicate a new instance has been created.\n\t\t *\n\t\t * @signature `connection.createInstance(props)`\n\t\t *\n\t\t *   If there is no instance in the [can-connect/constructor/store/store.instanceStore]\n\t\t *   for `props`'s [can-connect/base/base.id], an instance is [can-connect/constructor/constructor.hydrateInstance hydrated],\n\t\t *   added to the store, and then [can-connect/real-time/real-time.createdData] is called with\n\t\t *   `props` and the hydrated instance's serialized data. [can-connect/real-time/real-time.createdData]\n\t\t *   will add this instance to any lists the instance belongs to.\n\t\t *\n\t\t *   If this instance has already been created, calls\n\t\t *   [can-connect/real-time/real-time.updateInstance] with `props`.\n\t\t *\n\t\t *   @param {Object} props The raw properties of the instance was created.\n\t\t *\n\t\t *   @return {Promise<Instance>} A promise that resolves to the created instance.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * With a `real-time` connection, call `createInstance` when an instance is created that\n\t\t * the connection itself did not make.  For instance, the following might listen to\n\t\t * [socket.io](http://socket.io/) for when a `todo` is created and update the connection\n\t\t * accordingly:\n\t\t *\n\t\t * ```js\n\t\t * socket.on('todo created', function(todo){\n\t\t *   todoConnection.createInstance(todo);\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t */\n\t\tcreateInstance: function(props){\n\t\t\tvar self = this;\n\t\t\treturn new Promise(function(resolve, reject){\n\t\t\t\t// Wait until all create promises are done\n\t\t\t\t// so that we can find data in the instance store\n\t\t\t\tcreatePromise.then(function(){\n\t\t\t\t\t// Allow time for the store to get hydrated\n\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\tvar id = self.id(props);\n\t\t\t\t\t\tvar instance = self.instanceStore.get(id);\n\t\t\t\t\t\tvar serialized;\n\n\t\t\t\t\t\tif( instance ) {\n\t\t\t\t\t\t\t// already created, lets update\n\t\t\t\t\t\t\tresolve(self.updateInstance(props));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinstance = self.hydrateInstance(props);\n\t\t\t\t\t\t\tserialized = self.serializeInstance(instance);\n\n\t\t\t\t\t\t\tself.addInstanceReference(instance);\n\n\t\t\t\t\t\t\tPromise.resolve( self.createdData(props, serialized) ).then(function(){\n\t\t\t\t\t\t\t\tself.deleteInstanceReference(instance);\n\t\t\t\t\t\t\t\tresolve(instance);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 1);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.createdData createdData\n\t\t * @parent can-connect/real-time/real-time.callbacks\n\t\t *\n\t\t * Called whenever instance data is created.\n\t\t *\n\t\t * @signature `connection.createdData(props, params, [cid])`\n\t\t *\n\t\t *   Updates lists with the created instance.\n\t\t *\n\t\t *   Gets the instance created for this request. Then, updates the instance with\n\t\t *   the response data `props`.\n\t\t *\n\t\t *   Next, it goes through every list in the [can-connect/constructor/store/store.listStore],\n\t\t *   test if the instance's data belongs in that list.  If it does,\n\t\t *   adds the instance's data to the serialized list data and\n\t\t *   [can-connect/constructor/constructor.updatedList updates the list].\n\t\t */\n\t\tcreatedData: function(props, params, cid){\n\t\t\tvar instance;\n\t\t\tif(cid !== undefined) {\n\t\t\t\tinstance = this.cidStore.get(cid);\n\t\t\t} else {\n\t\t\t\tinstance = this.instanceStore.get( this.id(props) );\n\t\t\t}\n\t\t\t// pre-register so everything else finds this even if it doesn't have an id\n\t\t\tthis.addInstanceReference(instance, this.id(props));\n\t\t\tthis.createdInstance(instance, props);\n\t\t\tcreate.call(this, this.serializeInstance(instance));\n\t\t\tthis.deleteInstanceReference(instance);\n\t\t\treturn undefined;\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.updatedData updatedData\n\t\t * @parent can-connect/real-time/real-time.callbacks\n\t\t *\n\t\t * Called whenever instance data is updated.\n\t\t *\n\t\t * @signature `connection.updatedData(props, params)`\n\t\t *\n\t\t *   Gets the instance that is updated, updates\n\t\t *   it with `props` and the adds or removes it to\n\t\t *   lists it belongs in.\n\t\t *\n\t\t *   @return {undefined} Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t\t */\n\t\t// Go through each list in the listStore and see if there are lists that should have this,\n\t\t// or a list that shouldn't.\n\t\tupdatedData: function(props, params){\n\n\t\t\tvar instance = this.instanceStore.get( this.id(params) );\n\t\t\tthis.updatedInstance(instance, props);\n\t\t\tupdate.call(this, this.serializeInstance(instance));\n\n\t\t\t// Returning undefined prevents other behaviors from running.\n\t\t\treturn undefined;\n\t\t},\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.updateInstance updateInstance\n\t\t * @parent can-connect/real-time/real-time.methods\n\t\t *\n\t\t * Programatically indicate a new instance has been updated.\n\t\t *\n\t\t * @signature `connection.updateInstance(props)`\n\t\t *\n\t\t *   Calls [can-connect/real-time/real-time.updatedData] in the right way so\n\t\t *   that the instance is updated and added to or removed from\n\t\t *   any lists it belongs in.\n\t\t *\n\t\t *   @param {Object} props The properties of the instance that needs to be updated.\n\t\t *\n\t\t *   @return {Promise<Instance>} the updated instance.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * ```js\n\t\t * socket.on('todo updated', function(todo){\n\t\t *   todoConnection.updateInstance(todo);\n\t\t * });\n\t\t * ```\n\t\t */\n\t\tupdateInstance: function(props){\n\t\t\tvar id = this.id(props);\n\t\t\tvar instance = this.instanceStore.get(id);\n\t\t\tif( !instance ) {\n\t\t\t\tinstance = this.hydrateInstance(props);\n\t\t\t}\n\t\t\tthis.addInstanceReference(instance);\n\n\t\t\tvar serialized = this.serializeInstance(instance),\n\t\t\t\tself = this;\n\n\t\t\treturn Promise.resolve( this.updatedData(props, serialized) ).then(function(){\n\n\t\t\t\tself.deleteInstanceReference(instance);\n\t\t\t\treturn instance;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.destroyedData destroyedData\n\t\t * @parent can-connect/real-time/real-time.callbacks\n\t\t *\n\t\t * @signature `connection.destroyedData(props, params)`\n\t\t *\n\t\t * Gets the instance for this request.  Then tests if the instance\n\t\t * is in any list in the [can-connect/constructor/store/store.listStore].  If\n\t\t * it is, removes the instance from the list.\n\t\t *\n\t\t * @param {Object} props The properties of the destroyed instance.\n\t\t * @param {Object} [params] The parameters used to destroy the data.\n\t\t */\n\t\tdestroyedData: function(props, params){\n\t\t\tvar id = this.id(params || props);\n\t\t\tvar instance = this.instanceStore.get(id);\n\t\t\tif( !instance ) {\n\t\t\t\tinstance = this.hydrateInstance(props);\n\t\t\t}\n\t\t\tvar serialized = this.serializeInstance(instance);\n\t\t\tthis.destroyedInstance(instance, props);\n\t\t\t// we can pre-register it so everything else finds it\n\t\t\tdestroy.call(this, serialized);\n\t\t\treturn undefined;\n\t\t},\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.destroyInstance destroyInstance\n\t\t * @parent can-connect/real-time/real-time.methods\n\t\t *\n\t\t * Programatically indicate a new instance has been destroyed.\n\t\t *\n\t\t * @signature `connection.destroyInstance(props)`\n\t\t *\n\t\t *   Gets or creates an instance from `props` and uses\n\t\t *   it to call [can-connect/real-time/real-time.destroyedData]\n\t\t *   correctly.\n\t\t *\n\t\t * @param {Object} props The properties of the destroyed instance.\n\t\t * @return {Promise<Instance>}  A promise with the destroyed instance.\n\t\t *\n\t\t * @body\n\t\t * ## Use\n\t\t *\n\t\t * ```js\n\t\t * socket.on('todo destroyed', function(todo){\n\t\t *   todoConnection.destroyInstance(todo);\n\t\t * });\n\t\t * ```\n\t\t */\n\t\tdestroyInstance: function(props){\n\t\t\tvar id = this.id(props);\n\t\t\tvar instance = this.instanceStore.get(id);\n\t\t\tif( !instance ) {\n\t\t\t\tinstance = this.hydrateInstance(props);\n\t\t\t}\n\t\t\tthis.addInstanceReference(instance);\n\n\t\t\tvar serialized = this.serializeInstance(instance),\n\t\t\t\tself = this;\n\n\t\t\treturn Promise.resolve( this.destroyedData(props, serialized) ).then(function(){\n\n\t\t\t\tself.deleteInstanceReference(instance);\n\t\t\t\treturn instance;\n\t\t\t});\n\t\t}\n\t};\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tbehavior.gotListData = function(items, set) {\n\t\t\tvar self = this;\n\t\t\tif (this.queryLogic) {\n\t\t\t\tif(Array.isArray(items)) {\n\t\t\t\t\titems = {data: items};\n\t\t\t\t}\n\t\t\t\tfor(var item, i = 0, l = items.data.length; i < l; i++) {\n\t\t\t\t\titem = items.data[i];\n\t\t\t\t\tif( !self.queryLogic.isMember(set, item) ) {\n\t\t\t\t\t\tvar msg = [\n\t\t\t\t\t\t\t\"One or more items were retrieved which do not match the 'Set' parameters used to load them. \",\n\t\t\t\t\t\t\t\"Read the docs for more information: https://canjs.com/doc/can-query-logic.html#TestingyourQueryLogic\",\n\t\t\t\t\t\t\t\"\\n\\nBelow are the 'query' parameters:\",\n\t\t\t\t\t\t\t\"\\n\" + canDev.stringify(set),\n\t\t\t\t\t\t\t\"\\n\\nAnd below is an item which does not match those parameters:\",\n\t\t\t\t\t\t\t\"\\n\" + canDev.stringify(item)\n\t\t\t\t\t\t].join(\"\");\n\t\t\t\t\t\tcanDev.warn(msg);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Promise.resolve(items);\n\t\t};\n\t}\n\t//!steal-remove-end\n\n\treturn behavior;\n});\n\nvar create = function(props){\n\tvar self = this;\n\t// go through each list\n\tthis.listStore.forEach(function(list, id){\n\t\tvar set = JSON.parse(id);\n\t\t// ideally there should be speed up ... but this is fine for now.\n\n\n\t\tvar index = indexByIdentity(list, props, self.queryLogic.schema);\n\n\t\tif(self.queryLogic.isMember(set, props)) {\n\t\t\tvar newIndex = self.queryLogic.index(set, list, props);\n\n\t\t\tupdateListWithItem(list, props, index, newIndex, self, set);\n\t\t}\n\n\t});\n};\n\n// ## update\n// Goes through each list and sees if the list should be updated\n// with the new.\nvar update = function(props) {\n\tvar self = this;\n\n\tthis.listStore.forEach(function(list, id){\n\t\tvar set = JSON.parse(id);\n\t\t// ideally there should be speed up ... but this is fine for now.\n\n\n\t\tvar currentIndex = indexByIdentity(list, props, self.queryLogic.schema);\n\n\t\tif(self.queryLogic.isMember( set, props )) {\n\n\t\t\tvar newIndex = self.queryLogic.index(set, list, props);\n\n\t\t\tupdateListWithItem(list, props, currentIndex, newIndex, self, set);\n\n\t\t}  else if(currentIndex !== -1){ // its still in the list\n\t\t\t// otherwise remove it\n\t\t\tupdateListWithItem(list, props, currentIndex, -1, self, set);\n\t\t}\n\n\t});\n};\n\nvar destroy = function(props) {\n\tvar self = this;\n\tthis.listStore.forEach(function(list, id){\n\t\tvar set = JSON.parse(id);\n\t\t// ideally there should be speed up ... but this is fine for now.\n\n\t\tvar currentIndex = indexByIdentity(list, props, self.queryLogic.schema);\n\n\t\tif(currentIndex !== -1){\n\t\t\t// otherwise remove it\n\t\t\tupdateListWithItem(list, props, currentIndex, -1, self, set);\n\t\t}\n\n\t});\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-connect/real-time/real-time.js?");

/***/ }),

/***/ "./node_modules/can-construct-super/can-construct-super.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-construct-super/can-construct-super.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* global require, module */\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar Construct = __webpack_require__(/*! can-construct */ \"./node_modules/can-construct/can-construct.js\");\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n// tests if we can get super in .toString()\nvar isFunction = function(val) {\n\treturn typeof val === 'function';\n},\n\tfnTest = /xyz/.test(function () {\n\t\treturn this.xyz;\n\t}) ? /\\b_super\\b/ : /.*/,\n\tgetset = ['get', 'set'],\n\tgetSuper = function (base, name, fn) {\n\t\treturn function () {\n\t\t\tvar hasExistingValue = false;\n\t\t\tvar existingValue;\n\t\t\tvar prototype = getPrototypeOf(this);\n\t\t\tvar existingPrototypeValue = prototype._super;\n\n\t\t\t/* We must delete the instance's _super so the lookup\n\t\t\t\t\twill reach the prototype. */\n\t\t\tif (hasOwnProperty.call(this, '_super')) {\n\t\t\t\thasExistingValue = true;\n\t\t\t\texistingValue = this._super;\n\t\t\t\t/* NOTE: if the object is sealed this will not work.\n\t\t\t\t\t\tThe '_super' key cannot be used on the instance\n\t\t\t\t\t\tin that rare case. */\n\t\t\t\tdelete this._super;\n\t\t\t}\n\n\t\t\t/* Add a new ._super() method that is the same method\n\t\t\t\t\tbut on the super-class. It must be set on the prototype\n\t\t\t\t\tbecause the instance may be sealed. */\n\t\t\tprototype._super = base[name];\n\n\t\t\t// The method only need to be bound temporarily, so we\n\t\t\t// remove it when we're done executing\n\t\t\tvar ret = fn.apply(this, arguments);\n\t\t\tprototype._super = existingPrototypeValue;\n\t\t\tif (hasExistingValue) {\n\t\t\t\tthis._super = existingValue;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t};\n\nConstruct._defineProperty = function(addTo, base, name, descriptor) {\n\tvar _super = Object.getOwnPropertyDescriptor(base, name);\n\tif(_super) {\n\t\tcanReflect.each(getset, function (method) {\n\t\t\tif(isFunction(_super[method]) && isFunction(descriptor[method])) {\n\t\t\t\tdescriptor[method] = getSuper(_super, method, descriptor[method]);\n\t\t\t} else if(!isFunction(descriptor[method])) {\n\t\t\t\tdescriptor[method] = _super[method];\n\t\t\t}\n\t\t});\n\t}\n\n\tObject.defineProperty(addTo, name, descriptor);\n};\n\nvar getPrototypeOf = Object.getPrototypeOf || function(obj){\n\treturn obj.__proto__; // jshint ignore:line\n};\n\nvar getPropertyDescriptor = Object.getPropertyDescriptor || function(subject, name) {\n\tif(name in subject) {\n\t\tvar pd = Object.getOwnPropertyDescriptor(subject, name);\n\t\tvar proto = getPrototypeOf(subject);\n\t\twhile (pd === undefined && proto !== null) {\n\t\t\tpd = Object.getOwnPropertyDescriptor(proto, name);\n\t\t\tproto = getPrototypeOf(proto);\n\t\t}\n\t\treturn pd;\n\t}\n};\n\n// overwrites a single property so it can still call super\nConstruct._overwrite = function (addTo, base, name, val) {\n\t// Check if we're overwriting an existing function\n\tvar baseDescriptor = getPropertyDescriptor(base, name);\n\tvar baseValue = baseDescriptor && baseDescriptor.value;\n\n\tObject.defineProperty(addTo, name, {\n\t\tvalue: isFunction(val) && isFunction(baseValue) && fnTest.test(val) ?\n\t\t\t\tgetSuper(base, name, val) : val,\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t\twritable: true\n\t});\n};\n\nmodule.exports = Construct;\n\n\n//# sourceURL=webpack:///./node_modules/can-construct-super/can-construct-super.js?");

/***/ }),

/***/ "./node_modules/can-construct/can-construct.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-construct/can-construct.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar inSetupSymbol = canSymbol.for(\"can.initializing\");\n\n//!steal-remove-start\nif(true) {\n\tvar CanString = __webpack_require__(/*! can-string */ \"./node_modules/can-string/can-string.js\");\n\tvar reservedWords = {\n\t\t\"abstract\": true,\n\t\t\"boolean\": true,\n\t\t\"break\": true,\n\t\t\"byte\": true,\n\t\t\"case\": true,\n\t\t\"catch\": true,\n\t\t\"char\": true,\n\t\t\"class\": true,\n\t\t\"const\": true,\n\t\t\"continue\": true,\n\t\t\"debugger\": true,\n\t\t\"default\": true,\n\t\t\"delete\": true,\n\t\t\"do\": true,\n\t\t\"double\": true,\n\t\t\"else\": true,\n\t\t\"enum\": true,\n\t\t\"export\": true,\n\t\t\"extends\": true,\n\t\t\"false\": true,\n\t\t\"final\": true,\n\t\t\"finally\": true,\n\t\t\"float\": true,\n\t\t\"for\": true,\n\t\t\"function\": true,\n\t\t\"goto\": true,\n\t\t\"if\": true,\n\t\t\"implements\": true,\n\t\t\"import\": true,\n\t\t\"in\": true,\n\t\t\"instanceof\": true,\n\t\t\"int\": true,\n\t\t\"interface\": true,\n\t\t\"let\": true,\n\t\t\"long\": true,\n\t\t\"native\": true,\n\t\t\"new\": true,\n\t\t\"null\": true,\n\t\t\"package\": true,\n\t\t\"private\": true,\n\t\t\"protected\": true,\n\t\t\"public\": true,\n\t\t\"return\": true,\n\t\t\"short\": true,\n\t\t\"static\": true,\n\t\t\"super\": true,\n\t\t\"switch\": true,\n\t\t\"synchronized\": true,\n\t\t\"this\": true,\n\t\t\"throw\": true,\n\t\t\"throws\": true,\n\t\t\"transient\": true,\n\t\t\"true\": true,\n\t\t\"try\": true,\n\t\t\"typeof\": true,\n\t\t\"var\": true,\n\t\t\"void\": true,\n\t\t\"volatile\": true,\n\t\t\"while\": true,\n\t\t\"with\": true\n\t};\n\tvar constructorNameRegex = /[^A-Z0-9_]/gi;\n}\n//!steal-remove-end\n\n// ## construct.js\n// `Construct`\n// _This is a modified version of\n// [John Resig's class](http://ejohn.org/blog/simple-javascript-inheritance/).\n// It provides class level inheritance and callbacks._\n// A private flag used to initialize a new class instance without\n// initializing it's bindings.\nvar initializing = 0;\n\n//!steal-remove-start\nif(true) {\n\tvar namedCtor = (function(cache){\n\t\treturn function(name, fn) {\n\t\t\treturn ((name in cache) ? cache[name] : cache[name] = new Function(\n\t\t\t\t\"__\", \"function \"+name+\"(){return __.apply(this,arguments)};return \"+name\n\t\t\t))( fn );\n\t\t};\n\t}({}));\n}\n//!steal-remove-end\n\n/**\n * @add can-construct\n */\nvar Construct = function () {\n\tif (arguments.length) {\n\t\treturn Construct.extend.apply(Construct, arguments);\n\t}\n};\n\nvar canGetDescriptor;\ntry {\n\tObject.getOwnPropertyDescriptor({});\n\tcanGetDescriptor = true;\n} catch(e) {\n\tcanGetDescriptor = false;\n}\n\nvar getDescriptor = function(newProps, name) {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(newProps, name);\n\t\tif(descriptor && (descriptor.get || descriptor.set)) {\n\t\t\treturn descriptor;\n\t\t}\n\t\treturn null;\n\t},\n\tinheritGetterSetter = function(newProps, oldProps, addTo) {\n\t\taddTo = addTo || newProps;\n\t\tvar descriptor;\n\n\t\tfor (var name in newProps) {\n\t\t\tif( (descriptor = getDescriptor(newProps, name)) ) {\n\t\t\t\tthis._defineProperty(addTo, oldProps, name, descriptor);\n\t\t\t} else {\n\t\t\t\tConstruct._overwrite(addTo, oldProps, name, newProps[name]);\n\t\t\t}\n\t\t}\n\t},\n\tsimpleInherit = function (newProps, oldProps, addTo) {\n\t\taddTo = addTo || newProps;\n\n\t\tfor (var name in newProps) {\n\t\t\tConstruct._overwrite(addTo, oldProps, name, newProps[name]);\n\t\t}\n\t},\n\tdefineNonEnumerable = function(obj, prop, value) {\n\t\tObject.defineProperty(obj, prop, {\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value\n\t\t});\n\t};\n/**\n * @static\n */\ncanReflect.assignMap(Construct, {\n\t/**\n\t * @property {Boolean} can-construct.constructorExtends constructorExtends\n\t * @parent can-construct.static\n\t *\n\t * @description\n\t * Toggles the behavior of a constructor function called\n\t * without the `new` keyword to extend the constructor function or\n\t * create a new instance.\n\t *\n\t * ```js\n\t * var animal = Animal();\n\t * // vs\n\t * var animal = new Animal();\n\t * ```\n\t *\n\t * @body\n\t *\n\t * If `constructorExtends` is:\n\t *\n\t *  - `true` - the constructor extends\n\t *  - `false` - a new instance of the constructor is created\n\t *\n\t * This property defaults to false.\n\t *\n\t * Example of constructExtends as `true`:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   constructorExtends: true // the constructor extends\n\t * },{\n\t *   sayHi: function() {\n\t *     console.log(\"hai!\");\n\t *   }\n\t * });\n\t *\n\t * var Pony = Animal({\n\t *   gallop: function () {\n\t *      console.log(\"Galloping!!\");\n\t *   }\n\t * }); // Pony is now a constructor function extended from Animal\n\t *\n\t * var frank = new Animal(); // frank is a new instance of Animal\n\t *\n\t * var gertrude = new Pony(); // gertrude is a new instance of Pony\n\t * gertrude.sayHi(); // \"hai!\" - sayHi is \"inherited\" from Animal\n\t * gertrude.gallop(); // \"Galloping!!\" - gallop is unique to instances of Pony\n\t *```\n\t *\n\t * The default behavior is shown in the example below:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   constructorExtends: false // the constructor does NOT extend\n\t * },{\n\t *   sayHi: function() {\n\t *     console.log(\"hai!\");\n\t *   }\n\t * });\n\t *\n\t * var pony = Animal(); // pony is a new instance of Animal\n\t * var frank = new Animal(); // frank is a new instance of Animal\n\t *\n\t * pony.sayHi() // \"hai!\"\n\t * frank.sayHi() // \"hai!\"\n\t *```\n\t * By default to extend a constructor, you must use [can-construct.extend extend].\n\t */\n\tconstructorExtends: true,\n\t/**\n\t * @function can-construct.newInstance newInstance\n\t * @parent can-construct.static\n\t *\n\t * @description Returns an instance of `Construct`. This method\n\t * can be overridden to return a cached instance.\n\t *\n\t * @signature `Construct.newInstance([...args])`\n\t *\n\t * @param {*} [args] arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\n\t * that if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\n\t * instead.\n\t * @return {class} instance of the class\n\t *\n\t * @body\n\t * Creates a new instance of the constructor function. This method is useful for creating new instances\n\t * with arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n\t * __new__ operator.\n\t *\n\t * ## Example\n\t *\n\t * The following creates a `Person` Construct and overrides `newInstance` to cache all\n\t * instances of Person to prevent duplication. If the properties of a new Person match an existing one it\n\t * will return a reference to the previously created object, otherwise it returns a new object entirely.\n\t *\n\t * ```js\n\t * // define and create the Person constructor\n\t * var Person = Construct.extend({\n\t *   init : function(first, middle, last) {\n\t *     this.first = first;\n\t *     this.middle = middle;\n\t *     this.last = last;\n\t *   }\n\t * });\n\t *\n\t * // store a reference to the original newInstance function\n\t * var _newInstance = Person.newInstance;\n\t *\n\t * // override Person's newInstance function\n\t * Person.newInstance = function() {\n\t *   // if cache does not exist make it an new object\n\t *   this.__cache = this.__cache || {};\n\t *   // id is a stingified version of the passed arguments\n\t *   var id = JSON.stringify(arguments);\n\t *\n\t *   // look in the cache to see if the object already exists\n\t *   var cachedInst = this.__cache[id];\n\t *   if(cachedInst) {\n\t *     return cachedInst;\n\t *   }\n\t *\n\t *   //otherwise call the original newInstance function and return a new instance of Person.\n\t *   var newInst = _newInstance.apply(this, arguments);\n\t *   this.__cache[id] = newInst;\n\t *   return newInst;\n\t * };\n\t *\n\t * // create two instances with the same arguments\n\t * var justin = new Person('Justin', 'Barry', 'Meyer'),\n\t *\t\tbrian = new Person('Justin', 'Barry', 'Meyer');\n\t *\n\t * console.log(justin === brian); // true - both are references to the same instance\n\t * ```\n\t *\n\t */\n\tnewInstance: function () {\n\t\t// Get a raw instance object (`init` is not called).\n\t\tvar inst = this.instance(),\n\t\t\targs;\n\t\t// Call `setup` if there is a `setup`\n\t\tif (inst.setup) {\n\t\t\tObject.defineProperty(inst,\"__inSetup\",{\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t\tObject.defineProperty(inst, inSetupSymbol, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t\targs = inst.setup.apply(inst, arguments);\n\t\t\tif (args instanceof Construct.ReturnValue){\n\t\t\t\treturn args.value;\n\t\t\t}\n\t\t\tinst.__inSetup = false;\n\t\t\tinst[inSetupSymbol] = false;\n\t\t}\n\t\t// Call `init` if there is an `init`\n\t\t// If `setup` returned `args`, use those as the arguments\n\t\tif (inst.init) {\n\t\t\tinst.init.apply(inst, args || arguments);\n\t\t}\n\t\treturn inst;\n\t},\n\t// Overwrites an object with methods. Used in the `super` plugin.\n\t// `newProps` - New properties to add.\n\t// `oldProps` - Where the old properties might be (used with `super`).\n\t// `addTo` - What we are adding to.\n\t_inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,\n\n\t// Adds a `defineProperty` with the given name and descriptor\n\t// Will only ever be called if ES5 is supported\n\t_defineProperty: function(what, oldProps, propName, descriptor) {\n\t\tObject.defineProperty(what, propName, descriptor);\n\t},\n\n\t// used for overwriting a single property.\n\t// this should be used for patching other objects\n\t// the super plugin overwrites this\n\t_overwrite: function (what, oldProps, propName, val) {\n\t\tObject.defineProperty(what, propName, {value: val, configurable: true, enumerable: true, writable: true});\n\t},\n\t// Set `defaults` as the merger of the parent `defaults` and this\n\t// object's `defaults`. If you overwrite this method, make sure to\n\t// include option merging logic.\n\t/**\n\t * @function can-construct.setup setup\n\t * @parent can-construct.static\n\t *\n\t * @description Perform initialization logic for a constructor function.\n\t *\n\t * @signature `Construct.setup(base, fullName, staticProps, protoProps)`\n\t *\n\t * A static `setup` method provides inheritable setup functionality\n\t * for a Constructor function. The following example\n\t * creates a Group constructor function.  Any constructor\n\t * functions that inherit from Group will be added to\n\t * `Group.childGroups`.\n\t *\n\t * ```js\n\t * Group = Construct.extend({\n\t *   setup: function(Construct, fullName, staticProps, protoProps){\n\t *     this.childGroups = [];\n\t *     if(Construct !== Construct){\n\t *       this.childGroups.push(Construct)\n\t *     }\n\t *     Construct.setup.apply(this, arguments)\n\t *   }\n\t * },{})\n\t * var Flock = Group.extend(...)\n\t * Group.childGroups[0] //-> Flock\n\t * ```\n\t * @param {constructor} base The base constructor that is being inherited from.\n\t * @param {String} fullName The name of the new constructor.\n\t * @param {Object} staticProps The static properties of the new constructor.\n\t * @param {Object} protoProps The prototype properties of the new constructor.\n\t *\n\t * @body\n\t * The static `setup` method is called immediately after a constructor\n\t * function is created and\n\t * set to inherit from its base constructor. It is useful for setting up\n\t * additional inheritance work.\n\t * Do not confuse this with the prototype `[can-construct::setup]` method.\n\t *\n\t * ## Example\n\t *\n\t * This `Parent` class adds a reference to its base class to itself, and\n\t * so do all the classes that inherit from it.\n\t *\n\t * ```js\n\t * Parent = Construct.extend({\n\t *   setup : function(base, fullName, staticProps, protoProps){\n\t *     this.base = base;\n\t *\n\t *     // call base functionality\n\t *     Construct.setup.apply(this, arguments)\n\t *   }\n\t * },{});\n\t *\n\t * Parent.base; // Construct\n\t *\n\t * Child = Parent({});\n\t *\n\t * Child.base; // Parent\n\t * ```\n\t */\n\tsetup: function (base) {\n\t\tvar defaults = base.defaults ? canReflect.serialize(base.defaults) : {};\n\t\tthis.defaults = canReflect.assignDeepMap(defaults,this.defaults);\n\t},\n\t// Create's a new `class` instance without initializing by setting the\n\t// `initializing` flag.\n\tinstance: function () {\n\t\t// Prevents running `init`.\n\t\tinitializing = 1;\n\t\tvar inst = new this();\n\t\t// Allow running `init`.\n\t\tinitializing = 0;\n\t\treturn inst;\n\t},\n\t// Extends classes.\n\t/**\n\t * @function can-construct.extend extend\n\t * @parent can-construct.static\n\t *\n\t * @signature `Construct.extend([name,] [staticProperties,] instanceProperties)`\n\t *\n\t * Extends `Construct`, or constructor functions derived from `Construct`,\n\t * to create a new constructor function. Example:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   sayHi: function(){\n\t *     console.log(\"hi\")\n\t *   }\n\t * });\n\t *\n\t * var animal = new Animal()\n\t * animal.sayHi();\n\t * ```\n\t *\n\t * @param {String} [name] Adds a name to the constructor function so\n\t * it is nicely labeled in the developer tools. The following:\n\t *\n\t *     Construct.extend(\"ConstructorName\",{})\n\t *\n\t * returns a constructur function that will show up as `ConstructorName`\n\t * in the developer tools.\n\t * It also sets \"ConstructorName\" as [can-construct.shortName shortName].\n\t *\n\t * @param {Object} [staticProperties] Properties that are added the constructor\n\t * function directly. For example:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   findAll: function(){\n\t *     return can.ajax({url: \"/animals\"})\n\t *   }\n\t * },{}); // need to pass an empty instanceProperties object\n\t *\n\t * Animal.findAll().then(function(json){ ... })\n\t * ```\n\t *\n\t * The [can-construct.setup static setup] method can be used to\n\t * specify inheritable behavior when a Constructor function is created.\n\t *\n\t * @param {Object} instanceProperties Properties that belong to\n\t * instances made with the constructor. These properties are added to the\n\t * constructor's `prototype` object. Example:\n\t *\n\t *     var Animal = Construct.extend({\n\t *\t\t  findAll: function() {\n\t *\t\t\treturn can.ajax({url: \"/animals\"});\n\t *\t\t  }\n\t *     },{\n\t *       init: function(name) {\n\t *         this.name = name;\n\t *       },\n\t *       sayHi: function() {\n\t *         console.log(this.name,\" says hai!\");\n\t *       }\n\t *     })\n\t *     var pony = new Animal(\"Gertrude\");\n\t *     pony.sayHi(); // \"Gertrude says hai!\"\n\t *\n\t * The [can-construct::init init] and [can-construct::setup setup] properties\n\t * are used for initialization.\n\t *\n\t * @return {function} The constructor function.\n\t *\n\t * ```js\n\t *\tvar Animal = Construct.extend(...);\n\t *\tvar pony = new Animal(); // Animal is a constructor function\n\t * ```\n\t * @body\n\t * ## Inheritance\n\t * Creating \"subclasses\" with `Construct` is simple. All you need to do is call the base constructor\n\t * with the new function's static and instance properties. For example, we want our `Snake` to\n\t * be an `Animal`, but there are some differences:\n\t *\n\t *\n\t *     var Snake = Animal.extend({\n\t *         legs: 0\n\t *     }, {\n\t *         init: function() {\n\t *             Animal.prototype.init.call(this, 'ssssss');\n\t *         },\n\t *         slither: function() {\n\t *             console.log('slithering...');\n\t *         }\n\t *     });\n\t *\n\t *     var baslisk = new Snake();\n\t *     baslisk.speak();   // \"ssssss\"\n\t *     baslisk.slither(); // \"slithering...\"\n\t *     baslisk instanceof Snake;  // true\n\t *     baslisk instanceof Animal; // true\n\t *\n\t *\n\t * ## Static properties and inheritance\n\t *\n\t * If you pass all three arguments to Construct, the second one will be attached directy to the\n\t * constructor, allowing you to imitate static properties and functions. You can access these\n\t * properties through the `[can-construct::constructor this.constructor]` property.\n\t *\n\t * Static properties can get overridden through inheritance just like instance properties. In the example below,\n\t * we override both the legs static property as well as the the init function for each instance:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *     legs: 4\n\t * }, {\n\t *     init: function(sound) {\n\t *         this.sound = sound;\n\t *     },\n\t *     speak: function() {\n\t *         console.log(this.sound);\n\t *     }\n\t * });\n\t *\n\t * var Snake = Animal.extend({\n\t *     legs: 0\n\t * }, {\n\t *     init: function() {\n\t *         this.sound = 'ssssss';\n\t *     },\n\t *     slither: function() {\n\t *         console.log('slithering...');\n\t *     }\n\t * });\n\t *\n\t * Animal.legs; // 4\n\t * Snake.legs; // 0\n\t * var dog = new Animal('woof');\n\t * var blackMamba = new Snake();\n\t * dog.speak(); // 'woof'\n\t * blackMamba.speak(); // 'ssssss'\n\t * ```\n\t *\n\t * ## Alternative value for a new instance\n\t *\n\t * Sometimes you may want to return some custom value instead of a new object when creating an instance of your class.\n\t * For example, you want your class to act as a singleton, or check whether an item with the given id was already\n\t * created and return an existing one from your cache store (e.g. using [can-connect/constructor/store/store]).\n\t *\n\t * To achieve this you can return [can-construct.ReturnValue] from `setup` method of your class.\n\t *\n\t * Lets say you have `myStore` to cache all newly created instances. And if an item already exists you want to merge\n\t * the new data into the existing instance and return the updated instance.\n\t *\n\t * ```\n\t * var myStore = {};\n\t *\n\t * var Item = Construct.extend({\n\t *     setup: function(params){\n\t *         if (myStore[params.id]){\n\t *             var item = myStore[params.id];\n\t *\n\t *             // Merge new data to the existing instance:\n\t *             Object.assign(item, params);\n\t *\n\t *             // Return the updated item:\n\t *             return new Construct.ReturnValue( item );\n\t *         } else {\n\t *             // Save to cache store:\n\t *             myStore[this.id] = this;\n\t *\n\t *             return [params];\n\t *         }\n\t *     },\n\t *     init: function(params){\n\t *         Object.assign(this, params);\n\t *     }\n\t * });\n\t *\n\t * var item_1  = new Item( {id: 1, name: \"One\"} );\n\t * var item_1a = new Item( {id: 1, name: \"OnePlus\"} )\n\t * ```\n\t */\n\textend: function (name, staticProperties, instanceProperties) {\n\t\tvar shortName = name,\n\t\t\tklass = staticProperties,\n\t\t\tproto = instanceProperties;\n\n\t\t// Figure out what was passed and normalize it.\n\t\tif (typeof shortName !== 'string') {\n\t\t\tproto = klass;\n\t\t\tklass = shortName;\n\t\t\tshortName = null;\n\t\t}\n\t\tif (!proto) {\n\t\t\tproto = klass;\n\t\t\tklass = null;\n\t\t}\n\t\tproto = proto || {};\n\t\tvar _super_class = this,\n\t\t\t_super = this.prototype,\n\t\t\tConstructor, prototype;\n\t\t// Instantiate a base class (but only create the instance,\n\t\t// don't run the init constructor).\n\t\tprototype = this.instance();\n\t\t// Copy the properties over onto the new prototype.\n\t\tConstruct._inherit(proto, _super, prototype);\n\n\t\tif(shortName) {\n\n\t\t} else if(klass && klass.shortName) {\n\t\t\tshortName = klass.shortName;\n\t\t} else if(this.shortName) {\n\t\t\tshortName = this.shortName;\n\t\t}\n\t\t// We want constructor.name to be the same as shortName, within\n\t\t// the bounds of what the JS VM will allow (meaning no non-word characters).\n\t\t// new Function() is significantly faster than eval() here.\n\n\t\t// Strip semicolons\n\t\t//!steal-remove-start\n\t\t// wrapping this var will cause \"used out of scope.\" when linting\n\t\tvar constructorName = shortName ? shortName.replace(constructorNameRegex, '_') : 'Constructor';\n\t\tif(true) {\n\t\t\tif(reservedWords[constructorName]) {\n\t\t\t\tconstructorName = CanString.capitalize(constructorName);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// The dummy class constructor.\n\t\tfunction init() {\n\t\t\t/* jshint validthis: true */\n\t\t\t// All construction is actually done in the init method.\n\t\t\tif (!initializing) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tif(!this || (this.constructor !== Constructor) &&\n\t\t\t\t\t// We are being called without `new` or we are extending.\n\t\t\t\t\targuments.length && Constructor.constructorExtends) {\n\t\t\t\t\t\tdev.warn('can/construct/construct.js: extending a Construct without calling extend');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\treturn (!this || this.constructor !== Constructor) &&\n\t\t\t\t// We are being called without `new` or we are extending.\n\t\t\t\targuments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) :\n\t\t\t\t// We are being called with `new`.\n\t\t\t\tConstructor.newInstance.apply(Constructor, arguments);\n\t\t\t}\n\t\t}\n\t\tConstructor = typeof namedCtor === \"function\" ?\n\t\t\tnamedCtor( constructorName, init ) :\n\t\t\tfunction() { return init.apply(this, arguments); };\n\n\t\t// Copy old stuff onto class (can probably be merged w/ inherit)\n\t\tfor (var propName in _super_class) {\n\t\t\tif (_super_class.hasOwnProperty(propName)) {\n\t\t\t\tConstructor[propName] = _super_class[propName];\n\t\t\t}\n\t\t}\n\t\t// Copy new static properties on class.\n\t\tConstruct._inherit(klass, _super_class, Constructor);\n\n\t\t// Set things that shouldn't be overwritten.\n\t\tcanReflect.assignMap(Constructor, {\n\t\t\tconstructor: Constructor,\n\t\t\tprototype: prototype\n\t\t\t/**\n\t\t\t * @property {String} can-construct.shortName shortName\n\t\t\t * @parent can-construct.static\n\t\t\t *\n\t\t\t * If you pass a name when creating a Construct, the `shortName` property will be set to the\n\t\t\t * name.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var MyConstructor = Construct.extend(\"MyConstructor\",{},{});\n\t\t\t * MyConstructor.shortName // \"MyConstructor\"\n\t\t\t * ```\n\t\t\t */\n\t\t});\n\n\t\tif (shortName !== undefined) {\n\t\t\tif (Object.getOwnPropertyDescriptor) {\n\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(Constructor, 'name');\n\t\t\t\tif (!desc || desc.configurable) {\n\t\t\t\t\tObject.defineProperty(\n\t\t\t\t\t\tConstructor,\n\t\t\t\t\t\t'name',\n\t\t\t\t\t\t{ writable: true, value: shortName, configurable: true }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tConstructor.shortName = shortName;\n\t\t}\n\t\t// Make sure our prototype looks nice.\n\t\tdefineNonEnumerable(Constructor.prototype, \"constructor\", Constructor);\n\t\t// Call the class `setup` and `init`\n\t\tvar t = [_super_class].concat(Array.prototype.slice.call(arguments)),\n\t\t\targs = Constructor.setup.apply(Constructor, t);\n\t\tif (Constructor.init) {\n\t\t\tConstructor.init.apply(Constructor, args || t);\n\t\t}\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\treturn Constructor; //\n\t\t/**\n\t\t * @property {Object} can-construct.prototype.constructor constructor\n\t\t * @parent can-construct.prototype\n\t\t *\n\t\t * A reference to the constructor function that created the instance. This allows you to access\n\t\t * the constructor's static properties from an instance.\n\t\t *\n\t\t * @body\n\t\t * ## Example\n\t\t *\n\t\t * This Construct has a static counter that counts how many instances have been created:\n\t\t *\n\t\t * ```js\n\t\t * var Counter = Construct.extend({\n\t\t *     count: 0\n\t\t * }, {\n\t\t *     init: function() {\n\t\t *         this.constructor.count++;\n\t\t *     }\n\t\t * });\n\t\t *\n\t\t * var childCounter = new Counter();\n\t\t * console.log(childCounter.constructor.count); // 1\n\t\t * console.log(Counter.count); // 1\n\t\t * ```\n\t\t */\n\t},\n\t/**\n\t * @function can-construct.ReturnValue ReturnValue\n\t * @parent can-construct.static\n\t *\n\t * Use to overwrite the return value of new Construct(...).\n\t *\n\t * @signature `new Construct.ReturnValue( value )`\n\t *\n\t *   This constructor function can be used for creating a return value of the `setup` method.\n\t *   [can-construct] will check if the return value is an instance of `Construct.ReturnValue`.\n\t *   If it is then its `value` will be used as the new instance.\n\t *\n\t *   @param {Object} value A value to be used for a new instance instead of a new object.\n\t *\n\t *   ```js\n\t *   var Student = function( name, school ){\n\t *       this.name = name;\n\t *       this.school = school;\n\t *   }\n\t *\n\t *   var Person = Construct.extend({\n\t *       setup: function( options ){\n\t *           if (options.school){\n\t *               return new Constructor.ReturnValue( new Student( options.name, options.school ) );\n\t *           } else {\n\t *               return [options];\n\t *           }\n\t *       }\n\t *   });\n\t *\n\t *   var myPerson = new Person( {name: \"Ilya\", school: \"PetrSU\"} );\n\t *\n\t *   myPerson instanceof Student // => true\n\t *   ```\n   */\n\tReturnValue: function(value){\n\t\tthis.value = value;\n\t}\n});\n/**\n * @function can-construct.prototype.setup setup\n * @parent can-construct.prototype\n *\n * @signature `construct.setup(...args)`\n *\n * A setup function for the instantiation of a constructor function.\n *\n * @param {*} args The arguments passed to the constructor.\n *\n * @return {Array|undefined|can-construct.ReturnValue} If an array is returned, the array's items are passed as\n * arguments to [can-construct::init init]. If a [can-construct.ReturnValue] instance is returned, the ReturnValue\n * instance's value will be returned as the result of calling new Construct(). The following example always makes\n * sure that init is called with a jQuery wrapped element:\n *\n * ```js\n * \tWidgetFactory = Construct.extend({\n * \t\t\tsetup: function(element){\n * \t\t\t\t\treturn [$(element)]\n * \t\t\t}\n * \t});\n *\n * \tMyWidget = WidgetFactory.extend({\n * \t\t\tinit: function($el){\n * \t\t\t\t\t$el.html(\"My Widget!!\")\n * \t\t\t}\n * \t});\n *  ```\n *\n * Otherwise, the arguments to the\n * constructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n *\n * @body\n *\n * ## Deciding between `setup` and `init`\n *\n *\n * Usually, you should use [can-construct::init init] to do your constructor function's initialization.\n * You should, instead, use `setup` when:\n *\n *   - there is initialization code that you want to run before the inheriting constructor's\n *     `init` method is called.\n *   - there is initialization code that should run whether or not inheriting constructors\n *     call their base's `init` methods.\n *   - you want to modify the arguments that will get passed to `init`.\n *\n */\ndefineNonEnumerable(Construct.prototype, \"setup\", function () {});\n/**\n * @function can-construct.prototype.init init\n * @parent can-construct.prototype\n *\n * @description Called when a new instance of a Construct is created.\n *\n * @signature `construct.init(...args)`\n * @param {*} args the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n *\n * @body\n * If a prototype `init` method is provided, `init` is called when a new Construct is created---\n * after [can-construct::setup]. The `init` method is where the bulk of your initialization code\n * should go. A common thing to do in `init` is save the arguments passed into the constructor.\n *\n * ## Examples\n *\n * First, we'll make a Person constructor that has a first and last name:\n *\n * ```js\n * var Person = Construct.extend({\n *     init: function(first, last) {\n *         this.first = first;\n *         this.last  = last;\n *     }\n * });\n *\n * var justin = new Person(\"Justin\", \"Meyer\");\n * justin.first; // \"Justin\"\n * justin.last; // \"Meyer\"\n * ```\n *\n * Then, we'll extend Person into Programmer, and add a favorite language:\n *\n * ```js\n * var Programmer = Person.extend({\n *     init: function(first, last, language) {\n *         // call base's init\n *         Person.prototype.init.apply(this, arguments);\n *\n *         // other initialization code\n *         this.language = language;\n *     },\n *     bio: function() {\n *         return \"Hi! I'm \" + this.first + \" \" + this.last +\n *             \" and I write \" + this.language + \".\";\n *     }\n * });\n *\n * var brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\n * brian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n * ```\n *\n * ## Modified Arguments\n *\n * [can-construct::setup] is able to modify the arguments passed to `init`.\n * If you aren't receiving the arguments you passed to `new Construct(args)`,\n * check that they aren't being changed by `setup` along\n * the inheritance chain.\n */\ndefineNonEnumerable(Construct.prototype, \"init\", function () {});\n\nmodule.exports = namespace.Construct = Construct;\n\n\n//# sourceURL=webpack:///./node_modules/can-construct/can-construct.js?");

/***/ }),

/***/ "./node_modules/can-control/can-control.js":
/*!*************************************************!*\
  !*** ./node_modules/can-control/can-control.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # can/control/control.js\n//\n// Create organized, memory-leak free, rapidly performing, stateful\n// controls with declarative eventing binding. Used when creating UI\n// controls with behaviors, bound to elements on the page.\n// ## helpers\n\nvar Construct = __webpack_require__(/*! can-construct */ \"./node_modules/can-construct/can-construct.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar observeReader = __webpack_require__(/*! can-stache-key */ \"./node_modules/can-stache-key/can-stache-key.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar canEvent = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\n\nvar string = __webpack_require__(/*! can-string */ \"./node_modules/can-string/can-string.js\");\nvar get = __webpack_require__(/*! can-key/get/get */ \"./node_modules/can-key/get/get.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar controlsSymbol = canSymbol.for(\"can.controls\");\n\n\nvar processors;\n\n\n// ### bind\n// this helper binds to one element and returns a function that unbinds from that element.\nvar bind = function (el, ev, callback, queue) {\n\n    canEvent.on.call(el, ev, callback, queue);\n\n\treturn function () {\n        canEvent.off.call(el, ev, callback, queue);\n\t};\n},\n\tslice = [].slice,\n\tparamReplacer = /\\{([^\\}]+)\\}/g,\n\n\t// ### delegate\n\t//\n\t// this helper binds to elements based on a selector and returns a\n\t// function that unbinds.\n\tdelegate = function (el, selector, ev, callback) {\n        canEvent.on.call(el, ev, selector, callback);\n\n\t\treturn function () {\n            canEvent.off.call(el, ev, selector, callback);\n\t\t};\n\t},\n\n\t// ### binder\n\t//\n\t// Calls bind or unbind depending if there is a selector.\n\tbinder = function (el, ev, callback, selector) {\n\t\treturn selector ?\n\t\t\tdelegate(el, selector.trim(), ev, callback) :\n\t\t\tbind(el, ev, callback);\n\t},\n\n\tbasicProcessor;\n\nvar Control = Construct.extend(\"Control\",\n\t// ## *static functions*\n\t/**\n\t * @static\n\t */\n\t{\n\t\t// ## can.Control.setup\n\t\t//\n\t\t// This function pre-processes which methods are event listeners and which are methods of\n\t\t// the control. It has a mechanism to allow controllers to inherit default values from super\n\t\t// classes, like `can.Construct`, and will cache functions that are action functions (see `_isAction`)\n\t\t// or functions with an underscored name.\n\t\tsetup: function () {\n\t\t\tConstruct.setup.apply(this, arguments);\n\n\t\t\tif (Control) {\n\t\t\t\tvar control = this,\n\t\t\t\t\tfuncName;\n\n\t\t\t\tcontrol.actions = {};\n\t\t\t\tfor (funcName in control.prototype) {\n\t\t\t\t\tif (control._isAction(funcName)) {\n\t\t\t\t\t\tcontrol.actions[funcName] = control._action(funcName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// ## can.Control._shifter\n\t\t//\n\t\t// Moves `this` to the first argument, wraps it with `jQuery` if it's\n\t\t// an element.\n\t\t_shifter: function (context, name) {\n\t\t\tvar method = typeof name === \"string\" ? context[name] : name;\n\n\t\t\tif (typeof method !== \"function\") {\n\t\t\t\tmethod = context[method];\n\t\t\t}\n            var Control = this;\n\t\t\tfunction controlMethod() {\n\t\t\t\tvar wrapped = Control.wrapElement(this);\n\t\t\t\tcontext.called = name;\n\t\t\t\treturn method.apply(context, [wrapped].concat(slice.call(arguments, 0)));\n\t\t\t}\n      //!steal-remove-start\n      if(true) {\n\t      Object.defineProperty(controlMethod, \"name\", {\n\t      \tvalue: canReflect.getName(this) + \"[\"+name+\"]\",\n\t      });\n\t     }\n      //!steal-remove-end\n      return controlMethod;\n\t\t},\n\n\t\t// ## can.Control._isAction\n\t\t//\n\t\t// Return `true` if `methodName` refers to an action. An action is a `methodName` value that\n\t\t// is not the constructor, and is either a function or string that refers to a function, or is\n\t\t// defined in `special`, `processors`. Detects whether `methodName` is also a valid method name.\n\t\t_isAction: function (methodName) {\n\t\t\tvar val = this.prototype[methodName],\n\t\t\t\ttype = typeof val;\n\n\t\t\treturn (methodName !== 'constructor') &&\n\t\t\t(type === \"function\" || (type === \"string\" && (typeof this.prototype[val] === \"function\") )) &&\n\t\t\t!! (Control.isSpecial(methodName) || processors[methodName] || /[^\\w]/.test(methodName));\n\t\t},\n\t\t// ## can.Control._action\n\t\t//\n\t\t// Takes a method name and the options passed to a control and tries to return the data\n\t\t// necessary to pass to a processor (something that binds things).\n\t\t//\n\t\t// For performance reasons, `_action` is called twice:\n\t\t// * It's called when the Control class is created. for templated method names (e.g., `{window} foo`), it returns null. For non-templated method names it returns the event binding data. That data is added to `this.actions`.\n\t\t// * It is called wehn a control instance is created, but only for templated actions.\n\t\t_action: function(methodName, options, controlInstance) {\n\t\t\tvar readyCompute,\n                unableToBind;\n\n\t\t\t// If we don't have options (a `control` instance), we'll run this later. If we have\n\t\t\t// options, run `can.sub` to replace the action template `{}` with values from the `options`\n\t\t\t// or `window`. If a `{}` template resolves to an object, `convertedName` will be an array.\n\t\t\t// In that case, the event name we want will be the last item in that array.\n\t\t\tparamReplacer.lastIndex = 0;\n\t\t\tif (options || !paramReplacer.test(methodName)) {\n                var controlActionData = function() {\n\t\t\t\t\tvar delegate;\n\n\t\t\t\t\t// Set the delegate target and get the name of the event we're listening to.\n\t\t\t\t\tvar name = methodName.replace(paramReplacer, function(matched, key) {\n\t\t\t\t\t\tvar value, parent;\n\n\t\t\t\t\t\t// If listening directly to a delegate target, set it\n\t\t\t\t\t\tif (this._isDelegate(options, key)) {\n\t\t\t\t\t\t\tdelegate = this._getDelegate(options, key);\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If key contains part of the lookup path, remove it.\n\t\t\t\t\t\t// This is needed for bindings like {viewModel.foo} in can-component's Control.\n\t\t\t\t\t\tkey = this._removeDelegateFromKey(key);\n\n\t\t\t\t\t\t// set the parent (where the key will be read from)\n\t\t\t\t\t\tparent = this._lookup(options)[0];\n\n\t\t\t\t\t\tvalue = observeReader.read(parent, observeReader.reads(key), {\n\t\t\t\t\t\t\t// if we find a compute, we should bind on that and not read it\n\t\t\t\t\t\t\treadCompute: false\n\t\t\t\t\t\t}).value;\n\n\t\t\t\t\t\t// If `value` is undefined try to get the value from the window.\n\t\t\t\t\t\tif (value === undefined && typeof window !== 'undefined') {\n\t\t\t\t\t\t\tvalue = get(window, key);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if the parent is not an observable and we don't have a value, show a warning\n\t\t\t\t\t\t// in this situation, it is not possible for the event handler to be triggered\n\t\t\t\t\t\tif (!parent || !(canReflect.isObservableLike(parent) && canReflect.isMapLike(parent)) && !value) {\n                            unableToBind = true;\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If `value` is a string we just return it, otherwise we set it as a delegate target.\n\t\t\t\t\t\tif (typeof value === \"string\") {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelegate = value;\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\t// removing spaces that get added when converting\n\t\t\t\t\t// `{element} click` -> ` click`\n\t\t\t\t\tname = name.trim();\n\n\t\t\t\t\t// Get the name of the `event` we're listening to.\n\t\t\t\t\tvar parts = name.split(/\\s+/g),\n\t\t\t\t\t\tevent = parts.pop();\n\n\t\t\t\t\t// Return everything needed to handle the event we're listening to.\n\t\t\t\t\treturn {\n\t\t\t\t\t\tprocessor: this.processors[event] || basicProcessor,\n\t\t\t\t\t\tparts: [name, parts.join(\" \"), event],\n\t\t\t\t\t\tdelegate: delegate || undefined\n\t\t\t\t\t};\n\t\t\t\t};\n\n        //!steal-remove-start\n        if(true) {\n\t\t    \tObject.defineProperty(controlActionData, \"name\", {\n\t\t      \tvalue: canReflect.getName(controlInstance || this.prototype) + \"[\"+methodName+\"].actionData\",\n\t\t      });\n\t      }\n        //!steal-remove-end\n\n\t\t\t\treadyCompute = new Observation(controlActionData, this);\n\n\n\t\t\t\tif (controlInstance) {\n\t\t\t\t\t// Create a handler function that we'll use to handle the `change` event on the `readyCompute`.\n\t\t\t\t\tvar handler = function(actionData) {\n\t\t\t\t\t\t// unbinds the old binding\n\t\t\t\t\t\tif(controlInstance._bindings.control[methodName]) {\n\t\t\t\t\t\t\tcontrolInstance._bindings.control[methodName](controlInstance.element);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// binds the new\n\t\t\t\t\t\tcontrolInstance._bindings.control[methodName] = actionData.processor(\n\t\t\t\t\t\t\tactionData.delegate || controlInstance.element,\n\t\t\t\t\t\t\tactionData.parts[2], actionData.parts[1], methodName, controlInstance);\n\t\t\t\t\t};\n\n          //!steal-remove-start\n          if(true) {\n          \tObject.defineProperty(handler, \"name\", {\n            \tvalue: canReflect.getName(controlInstance) + \"[\"+methodName+\"].handler\",\n            });\n          }\n\t\t\t\t\t//!steal-remove-end\n\n\n\t\t\t\t\tcanReflect.onValue(readyCompute, handler, \"mutate\");\n          //!steal-remove-start\n          if(true) {\n\t          if(unableToBind) {\n\t          \tdev.log('can-control: No property found for handling ' + methodName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tcontrolInstance._bindings.readyComputes[methodName] = {\n\t\t\t\t\t\tcompute: readyCompute,\n\t\t\t\t\t\thandler: handler\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn readyCompute.get();\n\t\t\t}\n\t\t},\n\t\t// the lookup path - where templated keys will be looked up\n\t\t_lookup: function (options) {\n\t\t\treturn [options, window];\n\t\t},\n\t\t// strip strings that represent delegates from the key\n\t\t_removeDelegateFromKey: function (key) {\n\t\t\treturn key;\n\t\t},\n\t\t// return whether the key is a delegate\n\t\t_isDelegate: function(options, key) {\n\t\t\treturn key === 'element';\n\t\t},\n\t\t// return the delegate object for a given key\n\t\t_getDelegate: function(options, key) {\n\t\t\treturn undefined;\n\t\t},\n\t\t// ## can.Control.processors\n\t\t//\n\t\t// An object of `{eventName : function}` pairs that Control uses to\n\t\t// hook up events automatically.\n\t\tprocessors: {},\n\t\t// ## can.Control.defaults\n\t\t// A object of name-value pairs that act as default values for a control instance\n\t\tdefaults: {},\n        // should be used to overwrite to make nodeLists on this\n        convertElement: function(element) {\n            element = typeof element === \"string\" ?\n\t\t\t\t\t\t\tdocument.querySelector(element) : element;\n\n\t\t\t\t\t\treturn this.wrapElement(element);\n        },\n        wrapElement: function(el){\n            return el;\n        },\n        unwrapElement: function(el){\n            return el;\n        },\n        // should be overwritten to look in jquery special events\n        isSpecial: function(eventName){\n            return eventName === \"inserted\" || eventName === \"removed\";\n        }\n\t}, {\n\t\t// ## *prototype functions*\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\t// ## setup\n\t\t//\n\t\t// Setup is where most of the Control's magic happens. It performs several pre-initialization steps:\n\t\t// - Sets `this.element`\n\t\t// - Adds the Control's name to the element's className\n\t\t// - Saves the Control in `$.data`\n\t\t// - Merges Options\n\t\t// - Binds event handlers using `delegate`\n\t\t// The final step is to return pass the element and prepareed options, to be used in `init`.\n\t\tsetup: function (element, options) {\n\n\t\t\tvar cls = this.constructor,\n\t\t\t\tpluginname = cls.pluginName || cls.shortName,\n\t\t\t\tarr;\n\n\t\t\tif (!element) {\n\t\t\t\tthrow new Error('Creating an instance of a named control without passing an element');\n\t\t\t}\n\t\t\t// Retrieve the raw element, then set the plugin name as a class there.\n            this.element = cls.convertElement(element);\n\n\t\t\tif (pluginname && pluginname !== 'Control' && this.element.classList) {\n                this.element.classList.add(pluginname);\n\t\t\t}\n\n\t\t\t// Set up the 'controls' data on the element. If it does not exist, initialize\n\t\t\t// it to an empty array.\n\t\t\tarr = this.element[controlsSymbol];\n\t\t\tif (!arr) {\n\t\t\t\tarr = [];\n\t\t\t\tthis.element[controlsSymbol] = arr;\n\t\t\t}\n\t\t\tarr.push(this);\n\n\t\t\t// The `this.options` property is an Object that contains configuration data\n\t\t\t// passed to a control when it is created (`new can.Control(element, options)`)\n\t\t\t//\n\t\t\t// The `options` argument passed when creating the control is merged with `can.Control.defaults`\n\t\t\t// in [can.Control.prototype.setup setup].\n\t\t\t//\n\t\t\t// If no `options` value is used during creation, the value in `defaults` is used instead\n\t\t\tif (canReflect.isObservableLike(options) && canReflect.isMapLike(options)) {\n\t\t\t\tfor (var prop in cls.defaults) {\n\t\t\t\t\tif (!options.hasOwnProperty(prop)) {\n\t\t\t\t\t\tobserveReader.set(options, prop, cls.defaults[prop]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.options = options;\n\t\t\t} else {\n\t\t\t\tthis.options = assign( assign({}, cls.defaults), options);\n\t\t\t}\n\n\t\t\tthis.on();\n\n\t\t\treturn [this.element, this.options];\n\t\t},\n\t\t// ## on\n\t\t//\n\t\t// This binds an event handler for an event to a selector under the scope of `this.element`\n\t\t// If no options are specified, all events are rebound to their respective elements. The actions,\n\t\t// which were cached in `setup`, are used and all elements are bound using `delegate` from `this.element`.\n\t\ton: function (el, selector, eventName, func) {\n\t\t\tif (!el) {\n\t\t\t\tthis.off();\n\n\t\t\t\tvar cls = this.constructor,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tactions = cls.actions,\n\t\t\t\t\telement = this.constructor.unwrapElement(this.element),\n\t\t\t\t\tdestroyCB = Control._shifter(this, \"destroy\"),\n\t\t\t\t\tfuncName, ready;\n\n\t\t\t\tfor (funcName in actions) {\n\t\t\t\t\t// Only push if we have the action and no option is `undefined`\n\t\t\t\t\tif ( actions.hasOwnProperty(funcName) ) {\n\t\t\t\t\t\tready = actions[funcName] || cls._action(funcName, this.options, this);\n\t\t\t\t\t\tif( ready ) {\n\t\t\t\t\t\t\tbindings.control[funcName]  = ready.processor(ready.delegate || element,\n\t\t\t\t\t\t\t\tready.parts[2], ready.parts[1], funcName, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set up the ability to `destroy` the control later.\n\t\t\t\tvar removalDisposal = domMutate.onNodeDisconnected(element, function () {\n\t\t\t\t\tvar doc = element.ownerDocument;\n\t\t\t\t\tvar ownerNode = doc.contains ? doc : doc.documentElement;\n\t\t\t\t\tif (!ownerNode || ownerNode.contains(element) === false) {\n\t\t\t\t\t\t// if the teardown is happening while the dom queue is flushing,\n\t\t\t\t\t\t// there may have been a rebinding of _action handlers queued\n\t\t\t\t\t\t// in the mutate queue already, so do the teardown later.\n\t\t\t\t\t\tif(queues.domQueue.isFlushing) {\n\t\t\t\t\t\t\tqueues.mutateQueue.enqueue(destroyCB);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdestroyCB();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbindings.user.push(function () {\n\t\t\t\t\tif (removalDisposal) {\n\t\t\t\t\t\tremovalDisposal();\n\t\t\t\t\t\tremovalDisposal = undefined;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn bindings.user.length;\n\t\t\t}\n\n\t\t\t// if `el` is a string, use that as `selector` and re-set it to this control's element...\n\t\t\tif (typeof el === 'string') {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = el;\n\t\t\t\tel = this.element;\n\t\t\t}\n\n\t\t\t// ...otherwise, set `selector` to null\n\t\t\tif (func === undefined) {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = null;\n\t\t\t}\n\n\t\t\tif (typeof func === 'string') {\n\t\t\t\tfunc = Control._shifter(this, func);\n\t\t\t}\n\n\t\t\tthis._bindings.user.push(binder(el, eventName, func, selector));\n\n\t\t\treturn this._bindings.user.length;\n\t\t},\n\t\t// ## off\n\t\t//\n\t\t// Unbinds all event handlers on the controller.\n\t\t// This should _only_ be called in combination with .on()\n\t\toff: function () {\n\t\t\tvar el = this.constructor.unwrapElement(this.element),\n\t\t\t\tbindings = this._bindings;\n\t\t\tif( bindings ) {\n\t\t\t\t(bindings.user || []).forEach(function (value) {\n\t\t\t\t\tvalue(el);\n\t\t\t\t});\n\t\t\t\tcanReflect.eachKey(bindings.control || {}, function (value) {\n\t\t\t\t\tvalue(el);\n\t\t\t\t});\n\t\t\t\tcanReflect.eachKey(bindings.readyComputes || {}, function(value) {\n\t\t\t\t\tcanReflect.offValue(value.compute, value.handler, \"mutate\");\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Adds bindings.\n\t\t\tthis._bindings = {user: [], control: {}, readyComputes: {}};\n\t\t},\n\t\t// ## destroy\n\t\t//\n\t\t// Prepares a `control` for garbage collection.\n\t\t// First checks if it has already been removed. Then, removes all the bindings, data, and\n\t\t// the element from the Control instance.\n\t\tdestroy: function () {\n\t\t\tif (this.element === null) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tdev.warn(\"can-control: Control already destroyed\");\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar Class = this.constructor,\n\t\t\t\tpluginName = Class.pluginName || (Class.shortName && string.underscore(Class.shortName)),\n\t\t\t\tcontrols;\n\n\t\t\tthis.off();\n\n\t\t\tif (pluginName && pluginName !== 'can_control' && this.element.classList) {\n                this.element.classList.remove(pluginName);\n\t\t\t}\n\n\t\t\tcontrols = this.element[controlsSymbol];\n\t\t\tif (controls) {\n\t\t\t\tcontrols.splice(controls.indexOf(this), 1);\n\t\t\t}\n\n\t\t\t//canEvent.dispatch.call(this, \"destroyed\");\n\n\t\t\tthis.element = null;\n\t\t}\n\t});\n\n// ## Processors\n//\n// Processors do the binding. This basic processor binds events. Each returns a function that unbinds\n// when called.\nprocessors = Control.processors;\nbasicProcessor = function (el, event, selector, methodName, control) {\n\treturn binder(el, event, Control._shifter(control, methodName), selector);\n};\n\n// Set common events to be processed as a `basicProcessor`\n[\"beforeremove\", \"change\", \"click\", \"contextmenu\", \"dblclick\", \"keydown\", \"keyup\",\n\t\"keypress\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\",\n\t\"mouseup\", \"reset\", \"resize\", \"scroll\", \"select\", \"submit\", \"focusin\",\n\t\"focusout\", \"mouseenter\", \"mouseleave\",\n\t\"touchstart\", \"touchmove\", \"touchcancel\", \"touchend\", \"touchleave\",\n\t\"inserted\",\"removed\",\n\t\"dragstart\", \"dragenter\", \"dragover\", \"dragleave\", \"drag\", \"drop\", \"dragend\"\n].forEach(function (v) {\n\tprocessors[v] = basicProcessor;\n});\n\nmodule.exports = namespace.Control = Control;\n\n\n//# sourceURL=webpack:///./node_modules/can-control/can-control.js?");

/***/ }),

/***/ "./node_modules/can-data-types/maybe-boolean/maybe-boolean.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-data-types/maybe-boolean/maybe-boolean.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nfunction toBoolean(val) {\n\tif(val == null) {\n\t\treturn val;\n\t}\n\tif (val === 'false' || val === '0' || !val) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nmodule.exports = canReflect.assignSymbols(toBoolean,{\n\t\"can.new\": toBoolean,\n\t\"can.getSchema\": function(){\n\t\treturn {\n\t\t\ttype: \"Or\",\n\t\t\tvalues: [true, false, undefined, null]\n\t\t};\n\t},\n    \"can.getName\": function(){\n        return \"MaybeBoolean\";\n    },\n\t\"can.isMember\": function(value) {\n\t\treturn value == null || typeof value === \"boolean\";\n\t}\n});\n\n\n//# sourceURL=webpack:///./node_modules/can-data-types/maybe-boolean/maybe-boolean.js?");

/***/ }),

/***/ "./node_modules/can-data-types/maybe-date/maybe-date.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-data-types/maybe-date/maybe-date.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nfunction toDate(str) {\n\tvar type = typeof str;\n\tif (type === 'string') {\n\t\tstr = Date.parse(str);\n\t\treturn isNaN(str) ? null : new Date(str);\n\t} else if (type === 'number') {\n\t\treturn new Date(str);\n\t} else {\n\t\treturn str;\n\t}\n}\n\nfunction DateStringSet(dateStr){\n\tthis.setValue = dateStr;\n\tvar date = toDate(dateStr);\n\tthis.value = date == null ? date : date.getTime();\n}\nDateStringSet.prototype.valueOf = function(){\n\treturn this.value;\n};\ncanReflect.assignSymbols(DateStringSet.prototype,{\n\t\"can.serialize\": function(){\n\t\treturn this.setValue;\n\t}\n});\n\nmodule.exports = canReflect.assignSymbols(toDate,{\n\t\"can.new\": toDate,\n\t\"can.getSchema\": function(){\n\t\treturn {\n\t\t\ttype: \"Or\",\n\t\t\tvalues: [Date, undefined, null]\n\t\t};\n\t},\n\t\"can.ComparisonSetType\": DateStringSet,\n    \"can.getName\": function(){\n        return \"MaybeDate\";\n    },\n\t\"can.isMember\": function(value) {\n\t\treturn value == null || (value instanceof Date);\n\t}\n});\n\n\n//# sourceURL=webpack:///./node_modules/can-data-types/maybe-date/maybe-date.js?");

/***/ }),

/***/ "./node_modules/can-data-types/maybe-number/maybe-number.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-data-types/maybe-number/maybe-number.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nfunction toNumber(val) {\n\tif (val == null) {\n\t\treturn val;\n\t}\n\treturn +(val);\n}\n\nmodule.exports = canReflect.assignSymbols(toNumber,{\n\t\"can.new\": toNumber,\n\t\"can.getSchema\": function(){\n\t\treturn {\n\t\t\ttype: \"Or\",\n\t\t\tvalues: [Number, undefined, null]\n\t\t};\n\t},\n    \"can.getName\": function(){\n        return \"MaybeNumber\";\n    },\n\t\"can.isMember\": function(value) {\n\t\treturn value == null || typeof value === \"number\";\n\t}\n});\n\n\n//# sourceURL=webpack:///./node_modules/can-data-types/maybe-number/maybe-number.js?");

/***/ }),

/***/ "./node_modules/can-data-types/maybe-string/maybe-string.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-data-types/maybe-string/maybe-string.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nfunction toString(val) {\n\tif (val == null) {\n\t\treturn val;\n\t}\n\treturn '' + val;\n}\n\nmodule.exports = canReflect.assignSymbols(toString,{\n\t\"can.new\": toString,\n\t\"can.getSchema\": function(){\n\t\treturn {\n\t\t\ttype: \"Or\",\n\t\t\tvalues: [String, undefined, null]\n\t\t};\n\t},\n    \"can.getName\": function(){\n        return \"MaybeString\";\n    },\n\t\"can.isMember\": function(value) {\n\t\treturn value == null || typeof value === \"string\";\n\t}\n});\n\n\n//# sourceURL=webpack:///./node_modules/can-data-types/maybe-string/maybe-string.js?");

/***/ }),

/***/ "./node_modules/can-debug/can-debug.js":
/*!*********************************************!*\
  !*** ./node_modules/can-debug/can-debug.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar globals = __webpack_require__(/*! can-globals */ \"./node_modules/can-globals/can-globals.js\");\nvar proxyNamespace = __webpack_require__(/*! ./src/proxy-namespace */ \"./node_modules/can-debug/src/proxy-namespace.js\");\nvar temporarilyBind = __webpack_require__(/*! ./src/temporarily-bind */ \"./node_modules/can-debug/src/temporarily-bind.js\");\n\nvar getGraph = __webpack_require__(/*! ./src/get-graph/get-graph */ \"./node_modules/can-debug/src/get-graph/get-graph.js\");\nvar formatGraph = __webpack_require__(/*! ./src/format-graph/format-graph */ \"./node_modules/can-debug/src/format-graph/format-graph.js\");\nvar logWhatIChange = __webpack_require__(/*! ./src/what-i-change/what-i-change */ \"./node_modules/can-debug/src/what-i-change/what-i-change.js\");\nvar logWhatChangesMe = __webpack_require__(/*! ./src/what-changes-me/what-changes-me */ \"./node_modules/can-debug/src/what-changes-me/what-changes-me.js\");\nvar getWhatIChange = __webpack_require__(/*! ./src/get-what-i-change/get-what-i-change */ \"./node_modules/can-debug/src/get-what-i-change/get-what-i-change.js\");\nvar getWhatChangesMe = __webpack_require__(/*! ./src/get-what-changes-me/get-what-changes-me */ \"./node_modules/can-debug/src/get-what-changes-me/get-what-changes-me.js\");\n\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canQueues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar mergeDeep = __webpack_require__(/*! can-diff/merge-deep/merge-deep */ \"./node_modules/can-diff/merge-deep/merge-deep.js\");\n\nvar global = globals.getKeyValue(\"global\");\n\nvar devtoolsRegistrationComplete = false;\nfunction registerWithDevtools() {\n\tif (devtoolsRegistrationComplete) {\n\t\treturn;\n\t}\n\n\tvar devtoolsGlobalName =  \"__CANJS_DEVTOOLS__\";\n\tvar devtoolsCanModules = {\n\t\tObservation: Observation,\n\t\tReflect: canReflect,\n\t\tSymbol: canSymbol,\n\t\tformatGraph: namespace.debug.formatGraph,\n\t\tgetGraph: namespace.debug.getGraph,\n\t\tmergeDeep: mergeDeep,\n\t\tqueues: canQueues\n\t};\n\n\tif (global[devtoolsGlobalName]) {\n\t\tglobal[devtoolsGlobalName].register(devtoolsCanModules);\n\t} else {\n\t\tObject.defineProperty(global, devtoolsGlobalName, {\n\t\t\tset: function(devtoolsGlobal) {\n\t\t\t\tObject.defineProperty(global, devtoolsGlobalName, {\n\t\t\t\t\tvalue: devtoolsGlobal\n\t\t\t\t});\n\n\t\t\t\tdevtoolsGlobal.register(devtoolsCanModules);\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\t}\n\n\tdevtoolsRegistrationComplete = true;\n}\n\nmodule.exports = function() {\n\tnamespace.debug = {\n\t\tformatGraph: temporarilyBind(formatGraph),\n\t\tgetGraph: temporarilyBind(getGraph),\n\t\tgetWhatIChange: temporarilyBind(getWhatIChange),\n\t\tgetWhatChangesMe: temporarilyBind(getWhatChangesMe),\n\t\tlogWhatIChange: temporarilyBind(logWhatIChange),\n\t\tlogWhatChangesMe: temporarilyBind(logWhatChangesMe)\n\t};\n\n\tregisterWithDevtools();\n\n\tglobal.can = typeof Proxy !== \"undefined\" ? proxyNamespace(namespace) : namespace;\n\n\treturn namespace.debug;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/can-debug.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/format-graph/format-graph.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-debug/src/format-graph/format-graph.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canAssign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\n// Converts the graph into a data structure that vis.js requires to draw the graph\nmodule.exports = function formatGraph(graph) {\n\t// { [node]: Number }\n\tvar nodeIdMap = new Map();\n\tgraph.nodes.forEach(function(node, index) {\n\t\tnodeIdMap.set(node, index + 1);\n\t});\n\n\t// collects nodes in the shape of { id: Number, label: String }\n\tvar nodesDataSet = graph.nodes.map(function(node) {\n\t\treturn {\n\t\t\tshape: \"box\",\n\t\t\tid: nodeIdMap.get(node),\n\t\t\tlabel:\n\t\t\t\tcanReflect.getName(node.obj) +\n\t\t\t\t(node.key ? \".\" + node.key : \"\")\n\t\t};\n\t});\n\n\tvar getArrowData = function getArrowData(meta) {\n\t\tvar regular = { arrows: \"to\" };\n\t\tvar withDashes = { arrows: \"to\", dashes: true };\n\n\t\tvar map = {\n\t\t\tderive: regular,\n\t\t\tmutate: withDashes\n\t\t};\n\n\t\treturn map[meta.kind];\n\t};\n\n\t// collect edges in the shape of { from: Id, to: Id }\n\tvar visited = new Map();\n\tvar arrowsDataSet = [];\n\tgraph.nodes.forEach(function(node) {\n\t\tvar visit = function(node) {\n\t\t\tif (!visited.has(node)) {\n\t\t\t\tvisited.set(node, true);\n\t\t\t\tvar arrows = graph.arrows.get(node);\n\t\t\t\tvar headId = nodeIdMap.get(node);\n\n\t\t\t\tarrows.forEach(function(neighbor) {\n\t\t\t\t\tvar tailId = nodeIdMap.get(neighbor);\n\t\t\t\t\tvar meta = graph.arrowsMeta.get(node).get(neighbor);\n\n\t\t\t\t\tarrowsDataSet.push(\n\t\t\t\t\t\tcanAssign(\n\t\t\t\t\t\t\t{ from: headId, to: tailId },\n\t\t\t\t\t\t\tgetArrowData(meta)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tvisit(neighbor);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tvisit(node);\n\t});\n\t\n\treturn {\n\t\tnodes: nodesDataSet,\n\t\tedges: arrowsDataSet\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/format-graph/format-graph.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/get-data/get-data.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-debug/src/get-data/get-data.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar labelCycles = __webpack_require__(/*! ../label-cycles/label-cycles */ \"./node_modules/can-debug/src/label-cycles/label-cycles.js\");\n\nvar isDisconnected = function isDisconnected(data) {\n\treturn (\n\t\t!data.derive.length &&\n\t\t!data.mutations.length &&\n\t\t!data.twoWay.length\n\t);\n};\n\n// Returns a deeply nested object from the graph\nmodule.exports = function getDebugData(inputGraph, direction) {\n\tvar visited = new Map();\n\n\tvar graph = labelCycles(\n\t\tdirection === \"whatChangesMe\" ? inputGraph.reverse() : inputGraph\n\t);\n\n\tvar visit = function visit(node) {\n\t\tvar data = { node: node, derive: [], mutations: [], twoWay: [] };\n\n\t\tvisited.set(node, true);\n\n\t\tgraph.getNeighbors(node).forEach(function(adj) {\n\t\t\tvar meta = graph.getArrowMeta(node, adj);\n\n\t\t\tif (!visited.has(adj)) {\n\t\t\t\tswitch (meta.kind) {\n\t\t\t\t\tcase \"twoWay\":\n\t\t\t\t\t\tdata.twoWay.push(visit(adj));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"derive\":\n\t\t\t\t\t\tdata.derive.push(visit(adj));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"mutate\":\n\t\t\t\t\t\tdata.mutations.push(visit(adj));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"Unknow meta.kind value: \", meta.kind);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn data;\n\t};\n\n\t// discard data if there are no arrows registered, this happens when\n\t// [direction] is passed in and no arrow metadada matches its value\n\tvar result = visit(graph.nodes[0]);\n\treturn isDisconnected(result) ? null : result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/get-data/get-data.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/get-graph/get-graph.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-debug/src/get-graph/get-graph.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Graph = __webpack_require__(/*! ../graph/graph */ \"./node_modules/can-debug/src/graph/graph.js\");\nvar makeNode = __webpack_require__(/*! ./make-node */ \"./node_modules/can-debug/src/get-graph/make-node.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar mutateDeps = __webpack_require__(/*! can-reflect-dependencies */ \"./node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\n\n// Returns a directed graph of the dependencies of obj (key is optional)\n//\n// Signature:\n//\tgetDirectedGraph(obj)\n//\tgetDirectedGraph(obj, key)\nmodule.exports = function getGraph(obj, key) {\n\tvar order = 0;\n\tvar graph = new Graph();\n\tvar gotKey = arguments.length === 2;\n\n\tvar addArrow = function addArrow(direction, parent, child, meta) {\n\t\tswitch (direction) {\n\t\t\tcase \"whatIChange\":\n\t\t\t\tgraph.addArrow(parent, child, meta); break;\n\t\t\tcase \"whatChangesMe\":\n\t\t\t\tgraph.addArrow(child, parent, meta); break;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unknown direction value: \", meta.direction);\n\t\t}\n\t};\n\n\t// keyDependencies :: Map<obj, Set<key>>\n\tvar visitKeyDependencies = function visitKeyDependencies(source, meta, cb) {\n\t\tcanReflect.eachKey(source.keyDependencies || {}, function(keys, obj) {\n\t\t\tcanReflect.each(keys, function(key) {\n\t\t\t\tcb(obj, meta, key);\n\t\t\t});\n\t\t});\n\t};\n\n\t// valueDependencies :: Set<obj>\n\tvar visitValueDependencies = function visitValueDependencies(source, meta, cb) {\n\t\tcanReflect.eachIndex(source.valueDependencies || [], function(obj) {\n\t\t\tcb(obj, meta);\n\t\t});\n\t};\n\n\tvar visit = function visit(obj, meta, key) {\n\t\tvar gotKey = arguments.length === 3;\n\n\t\tvar node = graph.findNode(function(node) {\n\t\t\treturn gotKey ?\n\t\t\t\tnode.obj === obj && node.key === key :\n\t\t\t\tnode.obj === obj;\n\t\t});\n\n\t\t// if there is a node already in the graph, add the arrow and prevent\n\t\t// infinite calls to `visit` by returning early\n\t\tif (node) {\n\t\t\tif (meta.parent) {\n\t\t\t\taddArrow(meta.direction, meta.parent, node, {\n\t\t\t\t\tkind: meta.kind,\n\t\t\t\t\tdirection: meta.direction\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn graph;\n\t\t}\n\n\t\t// create and add a node to the graph\n\t\torder += 1;\n\t\tnode = gotKey ? makeNode(obj, key) : makeNode(obj);\n\t\tnode.order = order;\n\t\tgraph.addNode(node);\n\n\t\t// if there is a known parent node, add the arrow in the given direction\n\t\tif (meta.parent) {\n\t\t\taddArrow(meta.direction, meta.parent, node, {\n\t\t\t\tkind: meta.kind,\n\t\t\t\tdirection: meta.direction\n\t\t\t});\n\t\t}\n\n\t\t// get the dependencies of the new node and recursively visit those\n\t\tvar nextMeta;\n\t\tvar data = gotKey ?\n\t\t\tmutateDeps.getDependencyDataOf(obj, key) :\n\t\t\tmutateDeps.getDependencyDataOf(obj);\n\n\t\tif (data && data.whatIChange) {\n\t\t\tnextMeta = { direction: \"whatIChange\", parent: node };\n\n\t\t\t// kind :: derive | mutate\n\t\t\tcanReflect.eachKey(data.whatIChange, function(dependencyRecord, kind) {\n\t\t\t\tnextMeta.kind = kind;\n\t\t\t\tvisitKeyDependencies(dependencyRecord, nextMeta, visit);\n\t\t\t\tvisitValueDependencies(dependencyRecord, nextMeta, visit);\n\t\t\t});\n\t\t}\n\n\t\tif (data && data.whatChangesMe) {\n\t\t\tnextMeta = { direction: \"whatChangesMe\", parent: node };\n\n\t\t\t// kind :: derive | mutate\n\t\t\tcanReflect.eachKey(data.whatChangesMe, function(dependencyRecord, kind) {\n\t\t\t\tnextMeta.kind = kind;\n\t\t\t\tvisitKeyDependencies(dependencyRecord, nextMeta, visit);\n\t\t\t\tvisitValueDependencies(dependencyRecord, nextMeta, visit);\n\t\t\t});\n\t\t}\n\n\t\treturn graph;\n\t};\n\n\treturn gotKey ? visit(obj, {}, key) : visit(obj, {});\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/get-graph/get-graph.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/get-graph/make-node.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-debug/src/get-graph/make-node.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nmodule.exports = function makeNode(obj, key) {\n\tvar gotKey = arguments.length === 2;\n\n\tvar node = {\n\t\tobj: obj,\n\t\tname: canReflect.getName(obj),\n\t\tvalue: gotKey ? canReflect.getKeyValue(obj, key) : canReflect.getValue(obj)\n\t};\n\n\tif (gotKey) {\n\t\tnode.key = key;\n\t}\n\n\treturn node;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/get-graph/make-node.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/get-what-changes-me/get-what-changes-me.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/can-debug/src/get-what-changes-me/get-what-changes-me.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar getData = __webpack_require__(/*! ../get-data/get-data */ \"./node_modules/can-debug/src/get-data/get-data.js\");\nvar getGraph = __webpack_require__(/*! ../get-graph/get-graph */ \"./node_modules/can-debug/src/get-graph/get-graph.js\");\n\nmodule.exports = function getWhatChangesMe(obj, key) {\n\tvar gotKey = arguments.length === 2;\n\n\treturn getData(\n\t\tgotKey ? getGraph(obj, key) : getGraph(obj),\n\t\t\"whatChangesMe\"\n\t);\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/get-what-changes-me/get-what-changes-me.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/get-what-i-change/get-what-i-change.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-debug/src/get-what-i-change/get-what-i-change.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar getData = __webpack_require__(/*! ../get-data/get-data */ \"./node_modules/can-debug/src/get-data/get-data.js\");\nvar getGraph = __webpack_require__(/*! ../get-graph/get-graph */ \"./node_modules/can-debug/src/get-graph/get-graph.js\");\n\nmodule.exports = function getWhatChangesMe(obj, key) {\n\tvar gotKey = arguments.length === 2;\n\n\treturn getData(\n\t\tgotKey ? getGraph(obj, key) : getGraph(obj),\n\t\t\"whatIChange\"\n\t);\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/get-what-i-change/get-what-i-change.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/graph/graph.js":
/*!***************************************************!*\
  !*** ./node_modules/can-debug/src/graph/graph.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canAssign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\nfunction Graph() {\n\tthis.nodes = [];\n\tthis.arrows = new Map();\n\tthis.arrowsMeta = new Map();\n}\n\n// Adds the node, but it does not check if the node exists, callers will have\n// to check that through [findNode]\nGraph.prototype.addNode = function addNode(node) {\n\tthis.nodes.push(node);\n\tthis.arrows.set(node, new Set());\n};\n\n// Adds an arrow from head to tail with optional metadata\n// The method does not check whether head and tail are already\n// nodes in the graph, this should be done by the caller.\nGraph.prototype.addArrow = function addArrow(head, tail, meta) {\n\tvar graph = this;\n\n\tgraph.arrows.get(head).add(tail);\n\n\t// optional\n\tif (meta) {\n\t\taddArrowMeta(graph, head, tail, meta);\n\t}\n};\n\n// Tests whether there is an arrow from head to tail\nGraph.prototype.hasArrow = function hasArrow(head, tail) {\n\treturn this.getNeighbors(head).has(tail);\n};\n\n// Returns the metadata associated to the head -> tail arrow\nGraph.prototype.getArrowMeta = function getArrowMeta(head, tail) {\n\treturn this.arrowsMeta.get(head) && this.arrowsMeta.get(head).get(tail);\n};\n\n// Sets metadata about the arrow from head to tail\n// Merges the passed object into existing metadata\nGraph.prototype.setArrowMeta = function setArrowMeta(head, tail, meta) {\n\taddArrowMeta(this, head, tail, meta);\n};\n\n// Returns a Set of all nodes 'y' such that there is an arrow\n// from the node 'x' to the node 'y'.\nGraph.prototype.getNeighbors = function getNeighbors(node) {\n\treturn this.arrows.get(node);\n};\n\n// Returns the first node that satisfies the provided testing function.\n// The Graph is traversed using depth first search\nGraph.prototype.findNode = function findNode(cb) {\n\tvar found = null;\n\tvar graph = this;\n\tvar i, node;\n\n\tfor (i=0; i<graph.nodes.length; i++) {\n\t\tnode = graph.nodes[i];\n\t\tif (cb(node)) {\n\t\t\tfound = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n};\n\nGraph.prototype.bfs = function bfs(visit) {\n\tvar graph = this;\n\n\tvar node = graph.nodes[0];\n\tvar queue = [node];\n\tvar visited = new Map();\n\tvisited.set(node, true);\n\n\twhile (queue.length) {\n\t\tnode = queue.shift();\n\n\t\tvisit(node);\n\n\t\tgraph.arrows.get(node).forEach(function(adj) {\n\t\t\tif (!visited.has(adj)) {\n\t\t\t\tqueue.push(adj);\n\t\t\t\tvisited.set(adj, true);\n\t\t\t}\n\t\t});\n\t}\n};\n\nGraph.prototype.dfs = function dfs(visit) {\n\tvar graph = this;\n\n\tvar node = graph.nodes[0];\n\tvar stack = [node];\n\tvar visited = new Map();\n\n\twhile (stack.length) {\n\t\tnode = stack.pop();\n\n\t\tvisit(node);\n\n\t\tif (!visited.has(node)) {\n\t\t\tvisited.set(node, true);\n\t\t\tgraph.arrows.get(node).forEach(function(adj) {\n\t\t\t\tstack.push(adj);\n\t\t\t});\n\t\t}\n\t}\n};\n\n// Returns a new graph where the arrows point to the opposite direction, that is:\n// For each arrow (u, v) in [this], there will be a (v, u) in the returned graph\n// This is also called Transpose or Converse a graph\nGraph.prototype.reverse = function reverse() {\n\tvar graph = this;\n\tvar reversed = new Graph();\n\n\t// copy over the nodes\n\tgraph.nodes.forEach(reversed.addNode.bind(reversed));\n\n\tgraph.nodes.forEach(function(node) {\n\t\tgraph.getNeighbors(node).forEach(function(adj) {\n\t\t\t// add the arrow in the opposite direction, copy over metadata\n\t\t\tvar meta = graph.getArrowMeta(node, adj);\n\t\t\treversed.addArrow(adj, node, meta);\n\t\t});\n\t});\n\n\treturn reversed;\n};\n\n// Helpers\nfunction addArrowMeta(graph, head, tail, meta) {\n\tvar entry = graph.arrowsMeta.get(head);\n\n\tif (entry) {\n\t\tvar arrowMeta = entry.get(tail);\n\t\tif (!arrowMeta) {\n\t\t\tarrowMeta = {};\n\t\t}\n\t\tentry.set(tail, canAssign(arrowMeta, meta));\n\t} else {\n\t\tentry = new Map();\n\t\tentry.set(tail, meta);\n\t\tgraph.arrowsMeta.set(head, entry);\n\t}\n}\n\nmodule.exports = Graph;\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/graph/graph.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/label-cycles/label-cycles.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-debug/src/label-cycles/label-cycles.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Graph = __webpack_require__(/*! ../graph/graph */ \"./node_modules/can-debug/src/graph/graph.js\");\n\n// Returns a new graph with all the arrows not involved in a circuit\nmodule.exports = function labelCycles(graph) {\n\tvar visited = new Map();\n\tvar result = new Graph();\n\n\t// copy over all nodes\n\tgraph.nodes.forEach(function(node) {\n\t\tresult.addNode(node);\n\t});\n\n\tvar visit = function visit(node) {\n\t\tvisited.set(node, true);\n\n\t\tgraph.getNeighbors(node).forEach(function(adj) {\n\t\t\t// back arrow found\n\t\t\tif (visited.has(adj)) {\n\t\t\t\t// if isTwoWay is false it means the cycle involves more than 2 nodes,\n\t\t\t\t// e.g: A -> B -> C -> A\n\t\t\t\t// what to do in these cases? (currently ignoring these)\n\t\t\t\tvar isTwoWay = graph.hasArrow(node, adj);\n\n\t\t\t\tif (isTwoWay) {\n\t\t\t\t\tresult.addArrow(adj, node, { kind: \"twoWay\" });\n\t\t\t\t}\n\t\t\t// copy over arrows not involved in a cycle\n\t\t\t} else {\n\t\t\t\tresult.addArrow(node, adj, graph.getArrowMeta(node, adj));\n\t\t\t\tvisit(adj);\n\t\t\t}\n\t\t});\n\t};\n\n\tvisit(graph.nodes[0]);\n\treturn result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/label-cycles/label-cycles.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/log-data/log-data.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-debug/src/log-data/log-data.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar quoteString = function quoteString(x) {\n\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n};\n\nmodule.exports = function log(data) {\n\tvar node = data.node;\n\tvar nameParts = [node.name, \"key\" in node ? \".\" + node.key : \"\"];\n\n\tconsole.group(nameParts.join(\"\"));\n\tconsole.log(\"value  \", quoteString(node.value));\n\tconsole.log(\"object \", node.obj);\n\n\tif (data.derive.length) {\n\t\tconsole.group(\"DERIVED FROM\");\n\t\tcanReflect.eachIndex(data.derive, log);\n\t\tconsole.groupEnd();\n\t}\n\n\tif (data.mutations.length) {\n\t\tconsole.group(\"MUTATED BY\");\n\t\tcanReflect.eachIndex(data.mutations, log);\n\t\tconsole.groupEnd();\n\t}\n\n\tif (data.twoWay.length) {\n\t\tconsole.group(\"TWO WAY\");\n\t\tcanReflect.eachIndex(data.twoWay, log);\n\t\tconsole.groupEnd();\n\t}\n\n\tconsole.groupEnd();\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/log-data/log-data.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/proxy-namespace.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-debug/src/proxy-namespace.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar warned = false;\n\nmodule.exports = function proxyNamespace(namespace) {\n\treturn new Proxy(namespace, {\n\t\tget: function get(target, name) {\n\t\t\tif (!warned) {\n\t\t\t\tconsole.warn(\"Warning: use of 'can' global should be for debugging purposes only.\");\n\t\t\t\twarned = true;\n\t\t\t}\n\t\t\treturn target[name];\n\t\t}\n\t});\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/proxy-namespace.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/temporarily-bind.js":
/*!********************************************************!*\
  !*** ./node_modules/can-debug/src/temporarily-bind.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar onValueSymbol = canSymbol.for(\"can.onValue\");\nvar offValueSymbol = canSymbol.for(\"can.offValue\");\nvar onKeyValueSymbol = canSymbol.for(\"can.onKeyValue\");\nvar offKeyValueSymbol = canSymbol.for(\"can.offKeyValue\");\n\nvar noop = function noop() {};\n\nfunction isFunction(value) {\n\treturn typeof value === \"function\";\n}\n\nfunction withKey(obj, key, fn) {\n\tvar result;\n\n\tif (isFunction(obj[onKeyValueSymbol])) {\n\t\tcanReflect.onKeyValue(obj, key, noop);\n\t}\n\n\tresult = fn(obj, key);\n\n\tif (isFunction(obj[offKeyValueSymbol])) {\n\t\tcanReflect.offKeyValue(obj, key, noop);\n\t}\n\n\treturn result;\n}\n\nfunction withoutKey(obj, fn) {\n\tvar result;\n\n\tif (isFunction(obj[onValueSymbol])) {\n\t\tcanReflect.onValue(obj, noop);\n\t}\n\n\tresult = fn(obj);\n\n\tif (isFunction(obj[offValueSymbol])) {\n\t\tcanReflect.offValue(obj, noop);\n\t}\n\n\treturn result;\n}\n\n// Takes a function with signature `fn(obj, [key])`\n// Makes sure that the argument is bound before calling \n// the function and unbinds it after the call is done.\nmodule.exports = function temporarilyBind(fn) {\n\treturn function(obj, key) {\n\t\tvar gotKey = arguments.length === 2;\n\t\treturn gotKey ? withKey(obj, key, fn) : withoutKey(obj, fn);\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/temporarily-bind.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/what-changes-me/what-changes-me.js":
/*!***********************************************************************!*\
  !*** ./node_modules/can-debug/src/what-changes-me/what-changes-me.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar log = __webpack_require__(/*! ../log-data/log-data */ \"./node_modules/can-debug/src/log-data/log-data.js\");\nvar getData = __webpack_require__(/*! ../get-data/get-data */ \"./node_modules/can-debug/src/get-data/get-data.js\");\nvar getGraph = __webpack_require__(/*! ../get-graph/get-graph */ \"./node_modules/can-debug/src/get-graph/get-graph.js\");\n\n// key :: string | number | null | undefined\nmodule.exports = function logWhatChangesMe(obj, key) {\n\tvar gotKey = arguments.length === 2;\n\n\tvar data = getData(\n\t\tgotKey ? getGraph(obj, key) : getGraph(obj),\n\t\t\"whatChangesMe\"\n\t);\n\n\tif (data) {\n\t\tlog(data);\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/what-changes-me/what-changes-me.js?");

/***/ }),

/***/ "./node_modules/can-debug/src/what-i-change/what-i-change.js":
/*!*******************************************************************!*\
  !*** ./node_modules/can-debug/src/what-i-change/what-i-change.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar log = __webpack_require__(/*! ../log-data/log-data */ \"./node_modules/can-debug/src/log-data/log-data.js\");\nvar getData = __webpack_require__(/*! ../get-data/get-data */ \"./node_modules/can-debug/src/get-data/get-data.js\");\nvar getGraph = __webpack_require__(/*! ../get-graph/get-graph */ \"./node_modules/can-debug/src/get-graph/get-graph.js\");\n\n// key :: string | number | null | undefined\nmodule.exports = function logWhatIChange(obj, key) {\n\tvar gotKey = arguments.length === 2;\n\n\tvar data = getData(\n\t\tgotKey ? getGraph(obj, key) : getGraph(obj),\n\t\t\"whatIChange\"\n\t);\n\n\tif (data) {\n\t\tlog(data);\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-debug/src/what-i-change/what-i-change.js?");

/***/ }),

/***/ "./node_modules/can-deep-observable/can-deep-observable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-deep-observable/can-deep-observable.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const ObservableArray = __webpack_require__(/*! can-observable-array */ \"./node_modules/can-observable-array/dist/can-observable-array.js\");\nconst ObservableObject = __webpack_require__(/*! can-observable-object */ \"./node_modules/can-observable-object/dist/can-observable-object.js\");\nconst namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nconst canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nconst type = __webpack_require__(/*! can-type */ \"./node_modules/can-type/can-type.js\");\n\nclass DeepObservableObject extends ObservableObject {\n\tstatic get propertyDefaults() {\n\t\treturn type.maybeConvert(DeepObservable);\n\t}\n}\n\nclass DeepObservableArray extends ObservableArray {\n\tstatic get items() {\n\t\treturn type.maybeConvert(DeepObservable);\n\t}\n}\n\nfunction isPlainArray(array) {\n\treturn Array.isArray(array) && array.constructor === Array;\n}\n\nfunction DeepObservable() {}\n\ncanReflect.assignSymbols(DeepObservable, {\n\t\"can.new\": function(value) {\n\t\tif(isPlainArray(value)) {\n\t\t\treturn new DeepObservableArray(value);\n\t\t}\n\t\telse if(canReflect.isPlainObject(value)) {\n\t\t\treturn new DeepObservableObject(value);\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n});\n\nmodule.exports = namespace.DeepObservable = type.maybeConvert(DeepObservable);\n\n\n//# sourceURL=webpack:///./node_modules/can-deep-observable/can-deep-observable.js?");

/***/ }),

/***/ "./node_modules/can-define-backup/can-define-backup.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-define-backup/can-define-backup.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n//allows you to backup and restore a map instance\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\nvar diffDeep = __webpack_require__(/*! can-diff/deep/deep */ \"./node_modules/can-diff/deep/deep.js\");\nvar diffMap = __webpack_require__(/*! can-diff/map/map */ \"./node_modules/can-diff/map/map.js\");\n\nvar flatProps = function (a, cur) {\n\tvar obj = {};\n\tfor (var prop in a) {\n\t\tif (typeof a[prop] !== 'object' || a[prop] === null || a[prop] instanceof Date) {\n\t\t\tobj[prop] = a[prop];\n\t\t} else {\n\t\t\tobj[prop] = cur[prop];//cur.attr(prop);\n\t\t}\n\t}\n\treturn obj;\n};\n\nvar assignNonEnumerable = function(base, props) {\n\tfor(var prop in props) {\n\t\tObject.defineProperty(base, prop, {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: props[prop]\n\t\t});\n\t}\n};\n\nvar observables = new WeakMap();\n\nfunction getBackup(map) {\n\tvar obs = observables.get(map);\n\tif(!obs) {\n\t\tobs = new SimpleObservable();\n\t\tobservables.set(map, obs);\n\t}\n\treturn obs;\n}\n\nfunction defineBackup(Map) {\n\tassignNonEnumerable(Map.prototype, {\n\n\t\tbackup: function () {\n\t\t\tvar store = getBackup(this);\n\t\t\tcanReflect.setValue(store, this.serialize());\n\t\t\treturn this;\n\t\t},\n\n\t\tisDirty: function (checkAssociations) {\n\t\t\tvar store = getBackup(this);\n\t\t\tvar backupStore = canReflect.getValue(store);\n\t\t\tif(!backupStore){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentValue = this.serialize();\n\t\t\tvar patches;\n\t\t\tif(!! checkAssociations) {\n\t\t\t\tpatches = diffDeep(currentValue, backupStore);\n\t\t\t} else {\n\t\t\t\tpatches = diffMap(currentValue, backupStore).filter(function(patch){\n\t\t\t\t\t// only keep those that are not a set of deep object\n\t\t\t\t\tif(patch.type !== \"set\") {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// check values .. if both objects ... we are not dirty ...\n\t\t\t\t\t\tvar curVal = currentValue[patch.key],\n\t\t\t\t\t\t\tbackupVal = backupStore[patch.key];\n\t\t\t\t\t\tvar twoObjectsCompared = curVal && backupVal && typeof curVal === \"object\" && typeof backupVal === \"object\";\n\t\t\t\t\t\treturn !twoObjectsCompared;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn patches.length;\n\t\t},\n\n\t\trestore: function (restoreAssociations) {\n\t\t\tvar store = getBackup(this);\n\t\t\tvar curVal = canReflect.getValue(store);\n\t\t\tvar props = restoreAssociations ? curVal : flatProps(curVal, this);\n\t\t\tif (this.isDirty(restoreAssociations)) {\n\t\t\t\tfor(var prop in props) {\n\t\t\t\t\tthis[prop] = props[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t});\n\n\treturn Map;\n}\n\nmodule.exports = exports = defineBackup;\n\n\n//# sourceURL=webpack:///./node_modules/can-define-backup/can-define-backup.js?");

/***/ }),

/***/ "./node_modules/can-define-connected-singleton/can-define-connected-singleton.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/can-define-connected-singleton/can-define-connected-singleton.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar reflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar DefineMap = __webpack_require__(/*! can-define/map/map */ \"./node_modules/can-define/map/map.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar zoneStorage = __webpack_require__(/*! ./util/zone-storage */ \"./node_modules/can-define-connected-singleton/util/zone-storage.js\");\nvar helpers = __webpack_require__(/*! ./util/helpers */ \"./node_modules/can-define-connected-singleton/util/helpers.js\");\n\nvar defaults = {\n\tstoragePrefix: 'can-define-connected-singleton',\n\tcurrentPropertyName: 'current',\n\tsavingPropertyName: 'saving',\n\tfetchMethodName: 'get',\n\tcreateMethodName: 'save',\n\tdestroyMethodName: 'destroy',\n};\n\nfunction isDefineMapConstructor(Obj) {\n\treturn Obj && (Obj.prototype instanceof DefineMap);\n}\n\n// wrap the createMethod so it updates .current, .currentPromise & .saving during the course of a singleton model being persisted\nfunction wrapCreateMethod(Ctor, options) {\n\tvar baseCreate = Ctor.prototype[options.createMethodName];\n\n\tCtor.prototype[options.createMethodName] = function wrappedCreate() {\n\t\tvar ret = baseCreate.apply(this, arguments);\n\n\t\t// set Ctor.saving & Ctor.currentPromise\n\t\tzoneStorage.setItem(options.storageKeys.savingProperty, this);\n\t\tCtor.dispatch(options.savingPropertyName, [this]);\n\t\tzoneStorage.setItem(options.storageKeys.currentPropertyPromise, ret);\n\t\tCtor.dispatch(options.currentPropertyPromiseName, [ret]);\n\n\t\tret.then(\n\t\t\t(instance) => {\n\t\t\t\t// clear Ctor.saving, set Ctor.current\n\t\t\t\tzoneStorage.setItem(options.storageKeys.savingProperty, undefined);\n\t\t\t\tCtor.dispatch(options.savingPropertyName, [undefined]);\n\t\t\t\tzoneStorage.setItem(options.storageKeys.currentProperty, instance);\n\t\t\t\tCtor.dispatch(options.currentPropertyName, [instance]);\n\t\t\t},\n\t\t\t() => {\n\t\t\t\t// clear saving\n\t\t\t\tzoneStorage.setItem(options.storageKeys.savingProperty, undefined);\n\t\t\t\tCtor.dispatch(options.savingPropertyName, [undefined]);\n\t\t\t}\n\t\t);\n\n\t\treturn ret;\n\t};\n}\n\n// wrap the destroyMethod so it updates .current & .currentPromise during the course of a singleton model being removed from persistence\nfunction wrapDestroyMethod(Ctor, options) {\n\tvar baseDestroy = Ctor.prototype[options.destroyMethodName];\n\n\tCtor.prototype[options.destroyMethodName] = function wrappedDestroy() {\n\t\tvar ret = baseDestroy.apply(this, arguments);\n\n\t\t// return modified promise to ensure that storedPromise check runs before consumer of returned promise\n\t\treturn ret.then((value) => {\n\t\t\t// clear current, reject currentPromise\n\t\t\tzoneStorage.setItem(options.storageKeys.currentProperty, undefined);\n\t\t\tCtor.dispatch(options.currentPropertyName, [undefined]);\n\n\t\t\t// avoid setting promise a second time if can/session behavior callback handler has already set it to a rejected promise\n\t\t\tconst storedPromise = zoneStorage.getItem(options.storageKeys.currentPropertyPromise);\n\t\t\tstoredPromise.then(\n\t\t\t\t() => {\n\t\t\t\t\tvar promise = Promise.reject(undefined);\n\t\t\t\t\tzoneStorage.setItem(options.storageKeys.currentPropertyPromise, promise);\n\t\t\t\t\tCtor.dispatch(options.currentPropertyPromiseName, [promise]);\n\t\t\t\t},\n\t\t\t\t() => {} // promise is already rejected by can/session destroyedInstance callback\n\t\t\t);\n\n\t\t\treturn value;\n\t\t});\n\t};\n}\n\nfunction checkForExistingKeys(options) {\n\tif (zoneStorage.getItem(options.storageKeys.currentProperty) ||\n\t\tzoneStorage.getItem(options.storageKeys.currentPropertyPromise) ||\n\t\tzoneStorage.getItem(options.storageKeys.savingProperty)) {\n\t\tconsole.warn('can-define-connected-singleton: Removing existing values from zone storage. You are likely configuring a singleton twice.');\n\t\tzoneStorage.removeItem(options.storageKeys.currentProperty);\n\t\tzoneStorage.removeItem(options.storageKeys.currentPropertyPromise);\n\t\tzoneStorage.removeItem(options.storageKeys.savingProperty);\n\t}\n}\n\n// get stored current & promise values, initializing them if they're not yet set\nfunction getCurrentAndPromise(Ctor, options) {\n\tvar current = zoneStorage.getItem(options.storageKeys.currentProperty);\n\tvar promise = zoneStorage.getItem(options.storageKeys.currentPropertyPromise);\n\n\tif (promise == null) {\n\t\tpromise = Ctor[options.fetchMethodName]();\n\t\tzoneStorage.setItem(options.storageKeys.currentPropertyPromise, promise);\n\t\tCtor.dispatch(options.currentPropertyPromiseName, [promise]);\n\n\t\tpromise.then(function (value) {\n\t\t\tzoneStorage.setItem(options.storageKeys.currentProperty, value);\n\t\t\tCtor.dispatch(options.currentPropertyName, [value]);\n\t\t})\n\t\t.catch(function () {\n\t\t\tzoneStorage.setItem(options.storageKeys.currentProperty, null);\n\t\t\tCtor.dispatch(options.currentPropertyName, [null]);\n\t\t});\n\t}\n\n\treturn {\n\t\tcurrent: current,\n\t\tpromise: promise\n\t};\n}\n\n\nfunction makeSingleton(Ctor, input_options){\n\tvar helpURL = 'https://canjs.com/doc/can-define-connected-singleton';\n\n\tif(!isDefineMapConstructor(Ctor)) {\n\t\tthrow new Error('The singleton decorator/mixin can only be used for DefineMaps: ' + helpURL);\n\t}\n\n\tvar savingPropertyName = input_options.savingPropertyName;\n\tvar currentPropertyName = input_options.currentPropertyName;\n\tvar currentPropertyPromiseName = currentPropertyName + 'Promise';\n\tvar currentPropertyKey = input_options.storagePrefix + '-' + Ctor.name + '-' + currentPropertyName;\n\tvar storageKeys = {\n\t\tsavingProperty: input_options.storagePrefix + '-' + Ctor.name + '-' + savingPropertyName,\n\t\tcurrentProperty: currentPropertyKey,\n\t\tcurrentPropertyPromise: currentPropertyKey + '-promise'\n\t};\n\tvar options = Object.assign({}, input_options, {\n\t\tcurrentPropertyPromiseName, storageKeys\n\t});\n\n\tcheckForExistingKeys(options);\n\n\tObject.defineProperty(Ctor, options.currentPropertyPromiseName, {\n\t\tget: function () {\n\t\t\tObservationRecorder.add(Ctor, options.currentPropertyPromiseName);\n\t\t\treturn getCurrentAndPromise(Ctor, options).promise;\n\t\t}\n\t});\n\n\tObject.defineProperty(Ctor, options.currentPropertyName, {\n\t\tget: function () {\n\t\t\tObservationRecorder.add(Ctor, options.currentPropertyName);\n\t\t\treturn getCurrentAndPromise(Ctor, options).current;\n\t\t},\n\t\t// The \"current\" property is not typically set via this setter, typically it will be set by the destroyMethod & createMethod wrappers, and getCurrentAndPromise. This setter is used when a user of this module wishes to force a state.\n\t\tset: function(instance) {\n\t\t\tif (!(instance instanceof Ctor) && instance !== undefined) {\n\t\t\t\tthrow new TypeError('Attempted to set singleton to an unexpected type. Expected an instance of the constructor \"' + reflect.getName(Ctor) + '\"');\n\t\t\t}\n\n\t\t\tlet promise = instance ?\n\t\t\t\tPromise.resolve(instance) :\n\t\t\t\tPromise.reject(undefined);\n\n\t\t\tzoneStorage.setItem(options.storageKeys.currentProperty, instance);\n\t\t\tCtor.dispatch(options.currentPropertyName, [instance]);\n\t\t\tzoneStorage.setItem(options.storageKeys.currentPropertyPromise, promise);\n\t\t\tCtor.dispatch(options.currentPropertyPromiseName, [promise]);\n\t\t}\n\t});\n\n\tObject.defineProperty(Ctor, options.savingPropertyName, {\n\t\tget: function () {\n\t\t\tObservationRecorder.add(Ctor, options.savingPropertyName);\n\t\t\treturn zoneStorage.getItem(options.storageKeys.savingProperty);\n\t\t}\n\t});\n\n\twrapCreateMethod(Ctor, options);\n\twrapDestroyMethod(Ctor, options);\n\n\treturn Ctor;\n}\n\nfunction singleton(Obj) {\n\tvar opts = helpers.assign({}, defaults);\n\n\t// @singleton\n\tif(isDefineMapConstructor(Obj)) {\n\t\treturn makeSingleton(Obj, opts);\n\t}\n\n\t// @singleton(options)\n\treturn function(Ctor) {\n\t\treturn makeSingleton(Ctor, helpers.assign(opts, Obj));\n\t};\n}\n\nmodule.exports = singleton;\n\n\n//# sourceURL=webpack:///./node_modules/can-define-connected-singleton/can-define-connected-singleton.js?");

/***/ }),

/***/ "./node_modules/can-define-connected-singleton/util/helpers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-define-connected-singleton/util/helpers.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var assign = function(obj) {\n\tvar to = Object(obj);\n\n\tfor (var i = 1, l = arguments.length; i < l ; i++) {\n\t\tvar next = arguments[i];\n\n\t\tif (next != null) {\n\t\t\tfor (var key in next) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(next, key)) {\n\t\t\t\t\tto[key] = next[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n}\n\n\nmodule.exports = {\n\tassign: assign\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-define-connected-singleton/util/helpers.js?");

/***/ }),

/***/ "./node_modules/can-define-connected-singleton/util/zone-storage.js":
/*!**************************************************************************!*\
  !*** ./node_modules/can-define-connected-singleton/util/zone-storage.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n\tdata: {},\n\n\tgetStore: function () {\n\t\tif (window.doneSsr) {\n\t\t\tvar CanZone = window.CanZone || undefined;\n\t\t\treturn typeof CanZone === 'undefined' ? this.data : CanZone.current.data;\n\t\t}\n\t\treturn this.data;\n\t},\n\n\tsetItem: function (prop, value) {\n\t\tvar store = this.getStore();\n\t\tstore[prop] = value;\n\t},\n\n\tgetItem: function (prop) {\n\t\tvar store = this.getStore();\n\t\treturn store[prop];\n\t},\n\n\tremoveItem: function (prop) {\n\t\tvar store = this.getStore();\n\t\tdelete store[prop];\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-define-connected-singleton/util/zone-storage.js?");

/***/ }),

/***/ "./node_modules/can-define-lazy-value/define-lazy-value.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-define-lazy-value/define-lazy-value.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-define-lazy-value\n * @parent can-js-utilities\n * @collection can-infrastructure\n * @package ./package.json\n * @signature `defineLazyValue(obj, prop, fn, writable)`\n *\n * Use Object.defineProperty to define properties whose values will be created lazily when they are first read.\n *\n * ```js\n * var _id = 1;\n * function getId() {\n *     return _id++;\n * }\n *\n * function MyObj(name) {\n *     this.name = name;\n * }\n *\n * defineLazyValue(MyObj.prototype, 'id', getId);\n *\n * var obj1 = new MyObj('obj1');\n * var obj2 = new MyObj('obj2');\n *\n * console.log( obj2 ); // -> { name: \"obj2\" }\n * console.log( obj1 ); // -> { name: \"obj1\" }\n *\n * // the first `id` read will get id `1`\n * console( obj2.id ); // -> 1\n * console( obj1.id ); // -> 2\n *\n * console.log( obj2 ); // -> { name: \"obj2\", id: 1 }\n * console.log( obj1 ); // -> { name: \"obj1\", id: 2 }\n *\n * ```\n *\n * @param {Object} object The object to add the property to.\n * @param {String} prop   The name of the property.\n * @param {Function} fn   A function to get the value the property should be set to.\n * @param {boolean} writable   Whether the field should be writable (false by default).\n */\nmodule.exports = function defineLazyValue(obj, prop, initializer, writable) {\n\tObject.defineProperty(obj, prop, {\n\t\tconfigurable: true,\n\t\tget: function() {\n\t\t\t// make the property writable\n\t\t\tObject.defineProperty(this, prop, {\n\t\t\t\tvalue: undefined,\n\t\t\t\twritable: true\n\t\t\t});\n\n\t\t\t// get the value from the initializer function\n\t\t\tvar value = initializer.call(this, obj, prop);\n\n\t\t\t// redefine the property to the value property\n\t\t\t// and reset the writable flag\n\t\t\tObject.defineProperty(this, prop, {\n\t\t\t\tvalue: value,\n\t\t\t\twritable: !!writable\n\t\t\t});\n\n\t\t\t// return the value\n\t\t\treturn value;\n\t\t},\n\t\tset: function(value){\n\t\t\tObject.defineProperty(this, prop, {\n\t\t\t\tvalue: value,\n\t\t\t\twritable: !!writable\n\t\t\t});\n\n\t\t\treturn value;\n\t\t}\n\t});\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-define-lazy-value/define-lazy-value.js?");

/***/ }),

/***/ "./node_modules/can-define-realtime-rest-model/can-define-realtime-rest-model.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/can-define-realtime-rest-model/can-define-realtime-rest-model.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var connect = __webpack_require__(/*! can-connect */ \"./node_modules/can-connect/can-connect.js\");\n\nvar constructor = __webpack_require__(/*! can-connect/constructor/constructor */ \"./node_modules/can-connect/constructor/constructor.js\");\nvar canMap = __webpack_require__(/*! can-connect/can/map/map */ \"./node_modules/can-connect/can/map/map.js\");\nvar constructorStore = __webpack_require__(/*! can-connect/constructor/store/store */ \"./node_modules/can-connect/constructor/store/store.js\");\nvar dataCallbacks = __webpack_require__(/*! can-connect/data/callbacks/callbacks */ \"./node_modules/can-connect/data/callbacks/callbacks.js\");\nvar dataParse = __webpack_require__(/*! can-connect/data/parse/parse */ \"./node_modules/can-connect/data/parse/parse.js\");\nvar dataUrl = __webpack_require__(/*! can-connect/data/url/url */ \"./node_modules/can-connect/data/url/url.js\");\nvar DefineList = __webpack_require__(/*! can-define/list/list */ \"./node_modules/can-define/list/list.js\");\nvar DefineMap = __webpack_require__(/*! can-define/map/map */ \"./node_modules/can-define/map/map.js\");\nvar realTime = __webpack_require__(/*! can-connect/real-time/real-time */ \"./node_modules/can-connect/real-time/real-time.js\");\nvar callbacksOnce = __webpack_require__(/*! can-connect/constructor/callbacks-once/callbacks-once */ \"./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nfunction defineRealtimeRestModel(optionsOrUrl) {\n\n\t// If optionsOrUrl is a string, make options = {url: optionsOrUrl}\n\tvar options = (typeof optionsOrUrl === \"string\") ? {url: optionsOrUrl} : optionsOrUrl;\n\n\t// If options.Map or .List arenâ€™t provided, define them\n\tif (typeof options.Map === \"undefined\") {\n\t\toptions.Map = DefineMap.extend({seal: false}, {});\n\t}\n\tif (typeof options.List === \"undefined\") {\n\t\toptions.List = options.Map.List || DefineList.extend({\"#\": options.Map});\n\t}\n\n\tvar behaviors = [\n\t\tconstructor,\n\t\tcanMap,\n\t\tconstructorStore,\n\t\tdataCallbacks,\n\t\tdataParse,\n\t\tdataUrl,\n\t\trealTime,\n\t\tcallbacksOnce\n\t];\n\n\treturn connect(behaviors,options);\n}\n\nmodule.exports = namespace.defineRealtimeRestModel = defineRealtimeRestModel;\n\n\n//# sourceURL=webpack:///./node_modules/can-define-realtime-rest-model/can-define-realtime-rest-model.js?");

/***/ }),

/***/ "./node_modules/can-define-rest-model/can-define-rest-model.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-define-rest-model/can-define-rest-model.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var constructor = __webpack_require__(/*! can-connect/constructor/constructor */ \"./node_modules/can-connect/constructor/constructor.js\");\nvar canMap = __webpack_require__(/*! can-connect/can/map/map */ \"./node_modules/can-connect/can/map/map.js\");\nvar dataParse = __webpack_require__(/*! can-connect/data/parse/parse */ \"./node_modules/can-connect/data/parse/parse.js\");\nvar dataUrl = __webpack_require__(/*! can-connect/data/url/url */ \"./node_modules/can-connect/data/url/url.js\");\nvar DefineList = __webpack_require__(/*! can-define/list/list */ \"./node_modules/can-define/list/list.js\");\nvar DefineMap = __webpack_require__(/*! can-define/map/map */ \"./node_modules/can-define/map/map.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar base = __webpack_require__(/*! can-connect/base/base */ \"./node_modules/can-connect/base/base.js\");\n\nfunction defineRestModel(optionsOrUrl) {\n\n\t// If optionsOrUrl is a string, make options = {url: optionsOrUrl}\n\tvar options = (typeof optionsOrUrl === \"string\") ? {url: optionsOrUrl} : optionsOrUrl;\n\n\t// If options.Map or .List arenâ€™t provided, define them\n\tif (typeof options.Map === \"undefined\") {\n\t\toptions.Map = DefineMap.extend({seal: false}, {});\n\t}\n\tif (typeof options.List === \"undefined\") {\n\t\toptions.List = options.Map.List || DefineList.extend({\"#\": options.Map});\n\t}\n\n\tvar connection = [base,dataUrl, dataParse, constructor, canMap].reduce(function(prev, behavior){\n\t\treturn behavior(prev);\n\t}, options);\n\tconnection.init();\n\treturn connection;\n}\n\nmodule.exports = namespace.defineRestModel = defineRestModel;\n\n\n//# sourceURL=webpack:///./node_modules/can-define-rest-model/can-define-rest-model.js?");

/***/ }),

/***/ "./node_modules/can-define-stream-kefir/can-define-stream-kefir.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-define-stream-kefir/can-define-stream-kefir.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canDefineStream = __webpack_require__(/*! can-define-stream */ \"./node_modules/can-define-stream/can-define-stream.js\");\nvar canStreamKefir = __webpack_require__(/*! can-stream-kefir */ \"./node_modules/can-stream-kefir/can-stream-kefir.js\");\n\nmodule.exports = namespace.defineStreamKefir = canDefineStream(canStreamKefir);\n\n\n//# sourceURL=webpack:///./node_modules/can-define-stream-kefir/can-define-stream-kefir.js?");

/***/ }),

/***/ "./node_modules/can-define-stream/can-define-stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-define-stream/can-define-stream.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar define = __webpack_require__(/*! can-define */ \"./node_modules/can-define/can-define.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nmodule.exports = function(canStream) {\n\treturn function(DefineMapType) {\n\t\t[\"toStream\",\"toStreamFromProperty\",\"toStreamFromEvent\"] .forEach(function(name){\n\t\t\tDefineMapType.prototype[name] = function(){\n\t\t\t\treturn canStream[name].apply(canStream, [this].concat( [].slice.call(arguments) ));\n\t\t\t};\n\t\t});\n\n\t\tDefineMapType.prototype.stream = DefineMapType.prototype.toStream;\n\n\t\t// figure out how to rebuild definitions.\n\t\tvar definitions = DefineMapType.prototype._define.definitions,\n\t\t\tdataInitializers = DefineMapType.prototype._define.dataInitializers,\n\t\t\tcomputedInitializers = DefineMapType.prototype._define.computedInitializers;\n\n\t\tcanReflect.eachKey(definitions, function(definition, property) {\n\t\t\tvar streamDefinition = definition.stream;\n\t\t\tif(streamDefinition) {\n\t\t\t\tvar newDefinition = assign({\n\t\t\t\t\tdefault: function() {\n\t\t\t\t\t\treturn canStream.toCompute(streamDefinition, this);\n\t\t\t\t\t}\n\t\t\t\t}, define.types.compute);\n\t\t\t\tdefine.property(\n\t\t\t\t\tDefineMapType.prototype,\n\t\t\t\t\tproperty,\n\t\t\t\t\tnewDefinition,\n\t\t\t\t\tdataInitializers,\n\t\t\t\t\tcomputedInitializers\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-define-stream/can-define-stream.js?");

/***/ }),

/***/ "./node_modules/can-define-validate-validatejs/can-define-validate-validatejs.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/can-define-validate-validatejs/can-define-validate-validatejs.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar validate = __webpack_require__(/*! can-validate-validatejs */ \"./node_modules/can-define-validate-validatejs/node_modules/can-validate-validatejs/can-validate-validatejs.js\");\nvar define = __webpack_require__(/*! can-define */ \"./node_modules/can-define/can-define.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar formatErrors = __webpack_require__(/*! can-validate */ \"./node_modules/can-validate/can-validate.js\").formatErrors;\n\nvar getMapConstraints = function(Map) {\n\tvar constraints = {};\n\tcanReflect.eachKey(Map.prototype._define.definitions, function(prop, key) {\n\t\tif (prop.validate && canReflect.size(prop.validate)!== 0) {\n\t\t\tconstraints[key] = prop.validate;\n\t\t}\n\t});\n\treturn constraints;\n};\n\nvar validateMap = function(Map, validator) {\n\tvar mapDefinition = Map.prototype._define;\n\n\tMap.prototype.testSet = function() {\n\t\tvar values = {};\n\t\tvar useNewObject = false;\n\t\tif (arguments.length) {\n\t\t\t// Check if testing many values or just one\n\t\t\tif (typeof arguments[0] === \"object\" && Boolean(arguments[0])) {\n\t\t\t\tvalues = arguments[0];\n\t\t\t\tuseNewObject = Boolean(arguments[1]);\n\t\t\t}\n\n\t\t\t// Check if testing single value\n\t\t\tif (typeof arguments[0] === \"string\") {\n\t\t\t\tvalues[arguments[0]] = arguments[1];\n\t\t\t}\n\n\t\t\t// Merge values with existing map or with a new map\n\t\t\tif (useNewObject) {\n\t\t\t\tvalues = new Map(values);\n\t\t\t} else {\n\t\t\t\tvar mapClone = this.serialize();\n\t\t\t\tassign(mapClone, values);\n\t\t\t\tvalues = mapClone;\n\t\t\t}\n\t\t\treturn validator(values);\n\t\t} else {\n\t\t\treturn this.errors();\n\t\t}\n\t};\n\n\tMap.prototype.errors = function() {\n\t\tvar _errors = this._errors;\n\t\tvar errors;\n\t\tif (arguments.length) {\n\t\t\tvar errorsObj = formatErrors(_errors, \"errors-object\");\n\t\t\terrors = [];\n\n\t\t\tcanReflect.eachIndex(arguments, function(key) {\n\t\t\t\t[].push.apply(errors, errorsObj ? errorsObj[key] : []);\n\t\t\t});\n\t\t\terrors = errors.length > 0 ? errors : undefined;\n\t\t} else {\n\t\t\terrors = _errors;\n\t\t}\n\t\treturn errors;\n\t};\n\n\tdefine.property(\n\t\tMap.prototype,\n\t\t\"_errors\",\n\t\t{\n\t\t\tget: function() {\n\t\t\t\tvar errors = validator(this);\n\t\t\t\treturn errors;\n\t\t\t}\n\t\t},\n\t\tmapDefinition.dataInitializers,\n\t\tmapDefinition.computedInitializers\n\t);\n};\n\nvar decorator = function(Map) {\n\tvar constraints = getMapConstraints(Map);\n\tvar validator = validate.many(constraints);\n\n\tvalidateMap(Map, function(map) {\n\t\tvar errors = validator(map);\n\t\treturn formatErrors(errors, \"errors\");\n\t});\n};\n\ndecorator.validatejs = validate.validatejs;\n\nmodule.exports = decorator;\n\n\n//# sourceURL=webpack:///./node_modules/can-define-validate-validatejs/can-define-validate-validatejs.js?");

/***/ }),

/***/ "./node_modules/can-define-validate-validatejs/node_modules/can-validate-validatejs/can-validate-validatejs.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/can-define-validate-validatejs/node_modules/can-validate-validatejs/can-validate-validatejs.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar validatejs = __webpack_require__(/*! validate.js */ \"./node_modules/validate.js/validate.js\");\n\nvar makeValidator = function(constraints) {\n\treturn function(value) {\n\t\t// Returns an array or undefined\n\t\treturn validatejs.single(value, constraints);\n\t};\n};\n\nmakeValidator.many = function(constraints) {\n\treturn function(values) {\n\t\tvar rawErrors = validatejs(values, constraints, {\n\t\t\tformat: \"detailed\",\n\t\t\tfullMessages: false\n\t\t});\n\t\tvar errors;\n\n\t\tif (rawErrors) {\n\t\t\terrors = [];\n\t\t\tcanReflect.eachIndex(rawErrors, function(error) {\n\t\t\t\terrors.push({\n\t\t\t\t\tmessage: error.options.message || error.error,\n\t\t\t\t\trelated: [error.attribute]\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn errors;\n\t};\n};\n\nmakeValidator.validatejs = validatejs;\n\nmodule.exports = makeValidator;\n\n\n//# sourceURL=webpack:///./node_modules/can-define-validate-validatejs/node_modules/can-validate-validatejs/can-validate-validatejs.js?");

/***/ }),

/***/ "./node_modules/can-define/can-define.js":
/*!***********************************************!*\
  !*** ./node_modules/can-define/can-define.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\"format cjs\";\n\nvar ns = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar AsyncObservable = __webpack_require__(/*! can-simple-observable/async/async */ \"./node_modules/can-simple-observable/async/async.js\");\nvar SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ \"./node_modules/can-simple-observable/settable/settable.js\");\nvar ResolverObservable = __webpack_require__(/*! can-simple-observable/resolver/resolver */ \"./node_modules/can-simple-observable/resolver/resolver.js\");\n\nvar eventQueue = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ \"./node_modules/can-event-queue/type/type.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar canLogDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\nvar stringToAny = __webpack_require__(/*! can-string-to-any */ \"./node_modules/can-string-to-any/can-string-to-any.js\");\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"./node_modules/can-define-lazy-value/define-lazy-value.js\");\n\nvar MaybeBoolean = __webpack_require__(/*! can-data-types/maybe-boolean/maybe-boolean */ \"./node_modules/can-data-types/maybe-boolean/maybe-boolean.js\"),\n    MaybeDate = __webpack_require__(/*! can-data-types/maybe-date/maybe-date */ \"./node_modules/can-data-types/maybe-date/maybe-date.js\"),\n    MaybeNumber = __webpack_require__(/*! can-data-types/maybe-number/maybe-number */ \"./node_modules/can-data-types/maybe-number/maybe-number.js\"),\n    MaybeString = __webpack_require__(/*! can-data-types/maybe-string/maybe-string */ \"./node_modules/can-data-types/maybe-string/maybe-string.js\");\n\nvar newSymbol = canSymbol.for(\"can.new\"),\n\tserializeSymbol = canSymbol.for(\"can.serialize\"),\n\tinSetupSymbol = canSymbol.for(\"can.initializing\");\n\nvar eventsProto, define,\n\tmake, makeDefinition, getDefinitionsAndMethods, getDefinitionOrMethod;\n\n// UTILITIES\nfunction isDefineType(func){\n\treturn func && (func.canDefineType === true || func[newSymbol] );\n}\n\nvar peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));\n\nvar Object_defineNamedPrototypeProperty = Object.defineProperty;\n//!steal-remove-start\nif(true) {\n\tObject_defineNamedPrototypeProperty = function(obj, prop, definition) {\n\t\tif (definition.get) {\n\t\t\tObject.defineProperty(definition.get, \"name\", {\n\t\t\t\tvalue: \"get \"+canReflect.getName(obj) + \".\"+prop,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t\tif (definition.set) {\n\t\t\tObject.defineProperty(definition.set, \"name\", {\n\t\t\t\tvalue:  \"set \"+canReflect.getName(obj) + \".\"+prop,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t\treturn Object.defineProperty(obj, prop, definition);\n\t};\n}\n//!steal-remove-end\n\n\nfunction defineConfigurableAndNotEnumerable(obj, prop, value) {\n\tObject.defineProperty(obj, prop, {\n\t\tconfigurable: true,\n\t\tenumerable: false,\n\t\twritable: true,\n\t\tvalue: value\n\t});\n}\n\nfunction eachPropertyDescriptor(map, cb){\n\tfor(var prop in map) {\n\t\tif(map.hasOwnProperty(prop)) {\n\t\t\tcb.call(map, prop, Object.getOwnPropertyDescriptor(map,prop));\n\t\t}\n\t}\n}\n\nfunction getEveryPropertyAndSymbol(obj) {\n\tvar props = Object.getOwnPropertyNames(obj);\n\tvar symbols = (\"getOwnPropertySymbols\" in Object) ?\n\t  Object.getOwnPropertySymbols(obj) : [];\n\treturn props.concat(symbols);\n}\n\nfunction cleanUpDefinition(prop, definition, shouldWarn, typePrototype){\n\t// cleanup `value` -> `default`\n\tif(definition.value !== undefined && ( typeof definition.value !== \"function\" || definition.value.length === 0) ){\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif(shouldWarn) {\n\t\t\t\tcanLogDev.warn(\n\t\t\t\t\t\"can-define: Change the 'value' definition for \" + canReflect.getName(typePrototype)+\".\"+prop + \" to 'default'.\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tdefinition.default = definition.value;\n\t\tdelete definition.value;\n\t}\n\t// cleanup `Value` -> `DEFAULT`\n\tif(definition.Value !== undefined  ){\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif(shouldWarn) {\n\t\t\t\tcanLogDev.warn(\n\t\t\t\t\t\"can-define: Change the 'Value' definition for \" + canReflect.getName(typePrototype)+\".\"+prop + \" to 'Default'.\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t\tdefinition.Default = definition.Value;\n\t\tdelete definition.Value;\n\t}\n}\n\nfunction isValueResolver(definition) {\n\t// there's a function and it has one argument\n\treturn typeof definition.value === \"function\" && definition.value.length;\n}\n\nmodule.exports = define = ns.define = function(typePrototype, defines, baseDefine) {\n\t// default property definitions on _data\n\tvar prop,\n\t\tdataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null),\n\t\t// computed property definitions on _computed\n\t\tcomputedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);\n\n\tvar result = getDefinitionsAndMethods(defines, baseDefine, typePrototype);\n\tresult.dataInitializers = dataInitializers;\n\tresult.computedInitializers = computedInitializers;\n\n\n\t// Goes through each property definition and creates\n\t// a `getter` and `setter` function for `Object.defineProperty`.\n\tcanReflect.eachKey(result.definitions, function(definition, property){\n\t\tdefine.property(typePrototype, property, definition, dataInitializers, computedInitializers, result.defaultDefinition);\n\t});\n\n\t// Places a `_data` on the prototype that when first called replaces itself\n\t// with a `_data` object local to the instance.  It also defines getters\n\t// for any value that has a default value.\n\tif(typePrototype.hasOwnProperty(\"_data\")) {\n\t\tfor (prop in dataInitializers) {\n\t\t\tdefineLazyValue(typePrototype._data, prop, dataInitializers[prop].bind(typePrototype), true);\n\t\t}\n\t} else {\n\t\tdefineLazyValue(typePrototype, \"_data\", function() {\n\t\t\tvar map = this;\n\t\t\tvar data = {};\n\t\t\tfor (var prop in dataInitializers) {\n\t\t\t\tdefineLazyValue(data, prop, dataInitializers[prop].bind(map), true);\n\t\t\t}\n\t\t\treturn data;\n\t\t});\n\t}\n\n\t// Places a `_computed` on the prototype that when first called replaces itself\n\t// with a `_computed` object local to the instance.  It also defines getters\n\t// that will create the property's compute when read.\n\tif(typePrototype.hasOwnProperty(\"_computed\")) {\n\t\tfor (prop in computedInitializers) {\n\t\t\tdefineLazyValue(typePrototype._computed, prop, computedInitializers[prop].bind(typePrototype));\n\t\t}\n\t} else {\n\t\tdefineLazyValue(typePrototype, \"_computed\", function() {\n\t\t\tvar map = this;\n\t\t\tvar data = Object.create(null);\n\t\t\tfor (var prop in computedInitializers) {\n\t\t\t\tdefineLazyValue(data, prop, computedInitializers[prop].bind(map));\n\t\t\t}\n\t\t\treturn data;\n\t\t});\n\t}\n\n\t// Add necessary event methods to this object.\n\tgetEveryPropertyAndSymbol(eventsProto).forEach(function(prop){\n\t\tObject.defineProperty(typePrototype, prop, {\n\t\t\tenumerable: false,\n\t\t\tvalue: eventsProto[prop],\n\t\t\tconfigurable: true,\n\t\t\twritable: true\n\t\t});\n\t});\n\t// also add any symbols\n\t// add so instance defs can be dynamically added\n\tObject.defineProperty(typePrototype,\"_define\",{\n\t\tenumerable: false,\n\t\tvalue: result,\n\t\tconfigurable: true,\n\t\twritable: true\n\t});\n\n\t// Places Symbol.iterator or @@iterator on the prototype\n\t// so that this can be iterated with for/of and canReflect.eachIndex\n\tvar iteratorSymbol = canSymbol.iterator || canSymbol.for(\"iterator\");\n\tif(!typePrototype[iteratorSymbol]) {\n\t\tdefineConfigurableAndNotEnumerable(typePrototype, iteratorSymbol, function(){\n\t\t\treturn new define.Iterator(this);\n\t\t});\n\t}\n\n\treturn result;\n};\n\nvar onlyType = function(obj){\n\tfor(var prop in obj) {\n\t\tif(prop !== \"type\") {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\ndefine.extensions = function () {};\n\n// typePrototype - the prototype of the type we are defining `prop` on.\n// `definition` - the user provided definition\ndefine.property = function(typePrototype, prop, definition, dataInitializers, computedInitializers, defaultDefinition) {\n\tvar propertyDefinition = define.extensions.apply(this, arguments);\n\n\tif (propertyDefinition) {\n\t\tdefinition = makeDefinition(prop, propertyDefinition, defaultDefinition || {}, typePrototype);\n\t}\n\n\tvar type = definition.type;\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tvar hasZeroArgGetter = definition.get && definition.get.length === 0;\n\t\tvar noSetter = !definition.set;\n\t\tvar defaultInDefinition = ( \"default\" in definition || \"Default\" in definition );\n\t\tvar typeInDefinition = (definition.type && defaultDefinition && definition.type !== defaultDefinition.type) ||\n\t\t\t(definition.Type && defaultDefinition && definition.Type !== defaultDefinition.Type);\n\n\t\tif(hasZeroArgGetter && noSetter && defaultInDefinition) {\n\t\t\tvar defaultOrDefault = \"default\" in definition ? \"default\" : \"Default\";\n\t\t\t\tcanLogDev.warn(\"can-define: \" + defaultOrDefault + \" value for property \" +\n\t\t\t\t\t\tcanReflect.getName(typePrototype)+\".\"+ prop +\n\t\t\t\t\t\t\" ignored, as its definition has a zero-argument getter\");\n\t\t}\n\n\t\tif(hasZeroArgGetter && noSetter && typeInDefinition) {\n\t\t\tvar typeOrType = definition.type ? \"type\" : \"Type\";\n\t\t\tcanLogDev.warn(\"can-define: \" + typeOrType + \" value for property \" +\n\t\t\t\t\tcanReflect.getName(typePrototype)+\".\"+ prop +\n\t\t\t\t\t\" ignored, as its definition has a zero-argument getter\");\n\t\t}\n\n\t\tif (type && canReflect.isConstructorLike(type) && !isDefineType(type)) {\n\t\t\tcanLogDev.warn(\n\t\t\t\t\"can-define: the definition for \" + canReflect.getName(typePrototype) + \".\"+\n                prop +\n\t\t\t\t\" uses a constructor for \\\"type\\\". Did you mean \\\"Type\\\"?\"\n\t\t\t);\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// Special case definitions that have only `type: \"*\"`.\n\tif (type && onlyType(definition) && type === define.types[\"*\"]) {\n\t\tObject_defineNamedPrototypeProperty(typePrototype, prop, {\n\t\t\tget: make.get.data(prop),\n\t\t\tset: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t\treturn;\n\t}\n\tdefinition.type = type;\n\n\t// Where the value is stored.  If there is a `get` the source of the value\n\t// will be a compute in `this._computed[prop]`.  If not, the source of the\n\t// value will be in `this._data[prop]`.\n\tvar dataProperty = definition.get || isValueResolver(definition) ? \"computed\" : \"data\",\n\n\t\t// simple functions that all read/get/set to the right place.\n\t\t// - reader - reads the value but does not observe.\n\t\t// - getter - reads the value and notifies observers.\n\t\t// - setter - sets the value.\n\t\treader = make.read[dataProperty](prop),\n\t\tgetter = make.get[dataProperty](prop),\n\t\tsetter = make.set[dataProperty](prop),\n\t\tgetInitialValue;\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tif (definition.get) {\n\t\t\tObject.defineProperty(definition.get, \"name\", {\n\t\t\t\tvalue: canReflect.getName(typePrototype) + \"'s \" + prop + \" getter\",\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t\tif (definition.set) {\n\t\t\tObject.defineProperty(definition.set, \"name\", {\n\t\t\t\tvalue: canReflect.getName(typePrototype) + \"'s \" + prop + \" setter\",\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t\tif(isValueResolver(definition)) {\n\t\t\tObject.defineProperty(definition.value, \"name\", {\n\t\t\t\tvalue: canReflect.getName(typePrototype) + \"'s \" + prop + \" value\",\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// Determine the type converter\n\tvar typeConvert = function(val) {\n\t\treturn val;\n\t};\n\n\tif (definition.Type) {\n\t\ttypeConvert = make.set.Type(prop, definition.Type, typeConvert);\n\t}\n\tif (type) {\n\t\ttypeConvert = make.set.type(prop, type, typeConvert);\n\t}\n\n\t// make a setter that's going to fire of events\n\tvar eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));\n\tif(isValueResolver(definition)) {\n\t\tcomputedInitializers[prop] = make.valueResolver(prop, definition, typeConvert);\n\t}\n\t// Determine a function that will provide the initial property value.\n\telse if ((definition.default !== undefined || definition.Default !== undefined)) {\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\t// If value is an object or array, give a warning\n\t\t\tif (definition.default !== null && typeof definition.default === 'object') {\n\t\t\t\tcanLogDev.warn(\"can-define: The default value for \" + canReflect.getName(typePrototype)+\".\"+prop + \" is set to an object. This will be shared by all instances of the DefineMap. Use a function that returns the object instead.\");\n\t\t\t}\n\t\t\t// If value is a constructor, give a warning\n\t\t\tif (definition.default && canReflect.isConstructorLike(definition.default)) {\n\t\t\t\tcanLogDev.warn(\"can-define: The \\\"default\\\" for \" + canReflect.getName(typePrototype)+\".\"+prop + \" is set to a constructor. Did you mean \\\"Default\\\" instead?\");\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tgetInitialValue = ObservationRecorder.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));\n\t}\n\n\t// If property has a getter, create the compute that stores its data.\n\tif (definition.get) {\n\t\tcomputedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);\n\t}\n\t// If the property isn't a getter, but has an initial value, setup a\n\t// default value on `this._data[prop]`.\n\telse if (getInitialValue) {\n\t\tdataInitializers[prop] = getInitialValue;\n\t}\n\n\n\t// Define setter behavior.\n\n\t// If there's a `get` and `set`, make the setter get the `lastSetValue` on the\n\t// `get`'s compute.\n\tif (definition.get && definition.set) {\n\t\t// the compute will set off events, so we can use the basic setter\n\t\tsetter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);\n\n        // If there's zero-arg `get`, warn on all sets in dev mode\n        if (definition.get.length === 0 ) {\n            //!steal-remove-start\n            if(true) {\n                canLogDev.warn(\"can-define: Set value for property \" +\n                    canReflect.getName(typePrototype)+\".\"+ prop +\n                    \" ignored, as its definition has a zero-argument getter\");\n            }\n            //!steal-remove-end\n        }\n\t}\n\t// If there's a `set` and no `get`,\n\telse if (definition.set) {\n\t\t// Add `set` functionality to the eventSetter.\n\t\tsetter = make.set.setter(prop, definition.set, reader, eventsSetter, false);\n\t}\n\t// If there's neither `set` or `get` or `value` (resolver)\n\telse if (dataProperty === \"data\") {\n\t\t// make a set that produces events.\n\t\tsetter = eventsSetter;\n\t}\n\t// If there's zero-arg `get` but not `set`, warn on all sets in dev mode\n\telse if (definition.get && definition.get.length < 1) {\n\t\tsetter = function() {\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tcanLogDev.warn(\"can-define: Set value for property \" +\n\t\t\t\t\tcanReflect.getName(typePrototype)+\".\"+ prop +\n\t\t\t\t\t\" ignored, as its definition has a zero-argument getter and no setter\");\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t};\n\t}\n\n\t// Add type behavior to the setter.\n\tif (type) {\n\t\tsetter = make.set.type(prop, type, setter);\n\t}\n\tif (definition.Type) {\n\t\tsetter = make.set.Type(prop, definition.Type, setter);\n\t}\n\n\t// Define the property.\n\tObject_defineNamedPrototypeProperty(typePrototype, prop, {\n\t\tget: getter,\n\t\tset: setter,\n\t\tenumerable: \"serialize\" in definition ? !!definition.serialize : !definition.get,\n\t\tconfigurable: true\n\t});\n};\ndefine.makeDefineInstanceKey = function(constructor) {\n\tconstructor[canSymbol.for(\"can.defineInstanceKey\")] = function(property, value) {\n\t\tvar defineResult = this.prototype._define;\n\t\tif(typeof value === \"object\") {\n\t\t\t// change `value` to default.\n\t\t\tcleanUpDefinition(property, value, false, this);\n\t\t}\n\t\tvar definition = getDefinitionOrMethod(property, value, defineResult.defaultDefinition, this);\n\t\tif(definition && typeof definition === \"object\") {\n\t\t\tdefine.property(constructor.prototype, property, definition, defineResult.dataInitializers, defineResult.computedInitializers, defineResult.defaultDefinition);\n\t\t\tdefineResult.definitions[property] = definition;\n\t\t} else {\n\t\t\tdefineResult.methods[property] = definition;\n\t\t}\n\n\t\tthis.prototype.dispatch({\n\t\t\taction: \"can.keys\",\n\t\t\ttype: \"can.keys\", // TODO: Remove in 6.0\n\t\t\ttarget: this.prototype\n\t\t});\n\t};\n};\n\n// Makes a simple constructor function.\ndefine.Constructor = function(defines, sealed) {\n\tvar constructor = function DefineConstructor(props) {\n\t\tObject.defineProperty(this, inSetupSymbol, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: true,\n\t\t\twritable: true\n\t\t});\n\t\tdefine.setup.call(this, props, sealed);\n\t\tthis[inSetupSymbol] = false;\n\t};\n\tvar result = define(constructor.prototype, defines);\n\taddTypeEvents(constructor);\n\tdefine.makeDefineInstanceKey(constructor, result);\n\treturn constructor;\n};\n\n// A bunch of helper functions that are used to create various behaviors.\nmake = {\n\n\tcomputeObj: function(map, prop, observable) {\n\t\tvar computeObj = {\n\t\t\toldValue: undefined,\n\t\t\tcompute: observable,\n\t\t\tcount: 0,\n\t\t\thandler: function(newVal) {\n\t\t\t\tvar oldValue = computeObj.oldValue;\n\t\t\t\tcomputeObj.oldValue = newVal;\n\n\t\t\t\tmap.dispatch({\n\t\t\t\t\taction: \"set\",\n\t\t\t\t\tkey: \"prop\",\n\t\t\t\t\ttarget: map,\n\t\t\t\t\tvalue: newVal,\n\t\t\t\t\toldValue: oldValue,\n\t\t\t\t\ttype: prop, // TODO: Remove in 6.0\n\t\t\t\t}, [newVal, oldValue]);\n\t\t\t}\n\t\t};\n\t\treturn computeObj;\n\t},\n\tvalueResolver: function(prop, definition, typeConvert) {\n\t\tvar getDefault = make.get.defaultValue(prop, definition, typeConvert);\n\t\treturn function(){\n\t\t\tvar map = this;\n\t\t\tvar defaultValue = getDefault.call(this);\n\t\t\tvar computeObj = make.computeObj(map, prop, new ResolverObservable(definition.value, map, defaultValue));\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tObject.defineProperty(computeObj.handler, \"name\", {\n\t\t\t\t\tvalue: canReflect.getName(definition.value).replace('value', 'event emitter')\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\treturn computeObj;\n\t\t};\n\t},\n\t// Returns a function that creates the `_computed` prop.\n\tcompute: function(prop, get, defaultValueFn) {\n\n\t\treturn function() {\n\t\t\tvar map = this,\n\t\t\t\tdefaultValue = defaultValueFn && defaultValueFn.call(this),\n\t\t\t\tobservable, computeObj;\n\n\t\t\tif(get.length === 0) {\n\t\t\t\tobservable = new Observation(get, map);\n\t\t\t} else if(get.length === 1) {\n\t\t\t\tobservable = new SettableObservable(get, map, defaultValue);\n\t\t\t} else {\n\t\t\t\tobservable = new AsyncObservable(get, map, defaultValue);\n\t\t\t}\n\n\t\t\tcomputeObj = make.computeObj(map, prop, observable);\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tObject.defineProperty(computeObj.handler, \"name\", {\n\t\t\t\t\tvalue: canReflect.getName(get).replace('getter', 'event emitter')\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn computeObj;\n\t\t};\n\t},\n\t// Set related helpers.\n\tset: {\n\t\tdata: function(prop) {\n\t\t\treturn function(newVal) {\n\t\t\t\tthis._data[prop] = newVal;\n\t\t\t};\n\t\t},\n\t\tcomputed: function(prop) {\n\t\t\treturn function(val) {\n\t\t\t\tcanReflect.setValue( this._computed[prop].compute, val );\n\t\t\t};\n\t\t},\n\t\tevents: function(prop, getCurrent, setData, eventType) {\n\t\t\treturn function(newVal) {\n\t\t\t\tif (this[inSetupSymbol]) {\n\t\t\t\t\tsetData.call(this, newVal);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar current = getCurrent.call(this);\n\t\t\t\t\tif (newVal === current) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar dispatched;\n\t\t\t\t\tsetData.call(this, newVal);\n\n\t\t\t\t\t\tdispatched = {\n\t\t\t\t\t\t\tpatches: [{type: \"set\", key: prop, value: newVal}],\n\t\t\t\t\t\t\ttarget: this,\n\t\t\t\t\t\t\taction: \"set\",\n\t\t\t\t\t\t\tvalue: newVal,\n\t\t\t\t\t\t\toldValue: current,\n\t\t\t\t\t\t\tkey: prop,\n\t\t\t\t\t\t\ttype: prop // TODO: Remove in 6.0\n\t\t\t\t\t\t};\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif(true) {\n\t\t\t\t\t\tvar lastItem, lastFn;\n\t\t\t\t\t\tdispatched.reasonLog = [ canReflect.getName(this) + \"'s\", prop, \"changed to\", newVal, \"from\", current ];\n\n\t\t\t\t\t\t// If there are observations currently recording, this isn't a good time to\n\t\t\t\t\t\t//   mutate values: it's likely a cycle, and even if it doesn't cycle infinitely,\n\t\t\t\t\t\t//   it will likely cause unnecessary recomputation of derived values.  Warn the user.\n\t\t\t\t\t\tif(ObservationRecorder.isRecording() && queues.stack().length && !this[inSetupSymbol]) {\n\t\t\t\t\t\t\tlastItem = queues.stack()[queues.stack().length - 1];\n\t\t\t\t\t\t\tlastFn = lastItem.context instanceof Observation ? lastItem.context.func : lastItem.fn;\n\t\t\t\t\t\t\tvar mutationWarning = \"can-define: The \" + prop + \" property on \" +\n\t\t\t\t\t\t\t\tcanReflect.getName(this) +\n\t\t\t\t\t\t\t\t\" is being set in \" +\n\t\t\t\t\t\t\t\t(canReflect.getName(lastFn) || canReflect.getName(lastItem.fn)) +\n\t\t\t\t\t\t\t\t\". This can cause infinite loops and performance issues. \" +\n\t\t\t\t\t\t\t\t\"Use the value() behavior for \" +\n\t\t\t\t\t\t\t\tprop +\n\t\t\t\t\t\t\t\t\" instead, and listen to other properties and observables with listenTo(). https://canjs.com/doc/can-define.types.value.html\";\n\t\t\t\t\t\t\tcanLogDev.warn(mutationWarning);\n\t\t\t\t\t\t\tqueues.logStack();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tthis.dispatch(dispatched, [newVal, current]);\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\tsetter: function(prop, setter, getCurrent, setEvents, hasGetter) {\n\t\t\treturn function(value) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tvar asyncTimer;\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\tvar self = this;\n\n\t\t\t\t// call the setter, if returned value is undefined,\n\t\t\t\t// this means the setter is async so we\n\t\t\t\t// do not call update property and return right away\n\n\t\t\t\tqueues.batch.start();\n\t\t\t\tvar setterCalled = false,\n\t\t\t\t\tcurrent = getCurrent.call(this),\n\t\t\t\t\tsetValue = setter.call(this, value, function(value) {\n\t\t\t\t\t\tsetEvents.call(self, value);\n\n\t\t\t\t\t\tsetterCalled = true;\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif(true) {\n\t\t\t\t\t\t\tclearTimeout(asyncTimer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t}, current);\n\n\t\t\t\tif (setterCalled) {\n\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t} else {\n\t\t\t\t\tif (hasGetter) {\n\t\t\t\t\t\t// we got a return value\n\t\t\t\t\t\tif (setValue !== undefined) {\n\t\t\t\t\t\t\t// if the current `set` value is returned, don't set\n\t\t\t\t\t\t\t// because current might be the `lastSetVal` of the internal compute.\n\t\t\t\t\t\t\tif (current !== setValue) {\n\t\t\t\t\t\t\t\tsetEvents.call(this, setValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// this is a side effect, it didn't take a value\n\t\t\t\t\t\t// so use the original set value\n\t\t\t\t\t\telse if (setter.length === 0) {\n\t\t\t\t\t\t\tsetEvents.call(this, value);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// it took a value\n\t\t\t\t\t\telse if (setter.length === 1) {\n\t\t\t\t\t\t\t// if we have a getter, and undefined was returned,\n\t\t\t\t\t\t\t// we should assume this is setting the getters properties\n\t\t\t\t\t\t\t// and we shouldn't do anything.\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// we are expecting something\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\tif(true) {\n\t\t\t\t\t\t\t\tasyncTimer = setTimeout(function() {\n\t\t\t\t\t\t\t\t\tcanLogDev.warn('can-define: Setter \"' + canReflect.getName(self)+\".\"+prop + '\" did not return a value or call the setter callback.');\n\t\t\t\t\t\t\t\t}, canLogDev.warnTimeout);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we got a return value\n\t\t\t\t\t\tif (setValue !== undefined) {\n\t\t\t\t\t\t\t// if the current `set` value is returned, don't set\n\t\t\t\t\t\t\t// because current might be the `lastSetVal` of the internal compute.\n\t\t\t\t\t\t\tsetEvents.call(this, setValue);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// this is a side effect, it didn't take a value\n\t\t\t\t\t\t// so use the original set value\n\t\t\t\t\t\telse if (setter.length === 0) {\n\t\t\t\t\t\t\tsetEvents.call(this, value);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// it took a value\n\t\t\t\t\t\telse if (setter.length === 1) {\n\t\t\t\t\t\t\t// if we don't have a getter, we should probably be setting the\n\t\t\t\t\t\t\t// value to undefined\n\t\t\t\t\t\t\tsetEvents.call(this, undefined);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// we are expecting something\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\tif(true) {\n\t\t\t\t\t\t\t\tasyncTimer = setTimeout(function() {\n\t\t\t\t\t\t\t\t\tcanLogDev.warn('can/map/setter.js: Setter \"' + canReflect.getName(self)+\".\"+prop + '\" did not return a value or call the setter callback.');\n\t\t\t\t\t\t\t\t}, canLogDev.warnTimeout);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\ttype: function(prop, type, set) {\n\t\t\tfunction setter(newValue) {\n\t\t\t\treturn set.call(this, type.call(this, newValue, prop));\n\t\t\t}\n\t\t\tif(isDefineType(type)) {\n\t\t\t\t// TODO: remove this `canDefineType` check in a future release.\n\t\t\t\tif(type.canDefineType) {\n\t\t\t\t\treturn setter;\n\t\t\t\t} else {\n\t\t\t\t\treturn function setter(newValue){\n\t\t\t\t\t\treturn set.call(this, canReflect.convert(newValue, type));\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If type is a nested object: `type: {foo: \"string\", bar: \"number\"}`\n\t\t\tif (typeof type === \"object\") {\n\t\t\t\treturn make.set.Type(prop, type, set);\n\t\t\t} else {\n\t\t\t\treturn setter;\n\t\t\t}\n\t\t},\n\t\tType: function(prop, Type, set) {\n\t\t\t// `type`: {foo: \"string\"}\n\t\t\tif(Array.isArray(Type) && define.DefineList) {\n\t\t\t\tType = define.DefineList.extend({\n\t\t\t\t\t\"#\": Type[0]\n\t\t\t\t});\n\t\t\t} else if (typeof Type === \"object\") {\n\t\t\t\tif(define.DefineMap) {\n\t\t\t\t\tType = define.DefineMap.extend(Type);\n\t\t\t\t} else {\n\t\t\t\t\tType = define.Constructor(Type);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function(newValue) {\n\t\t\t\tif (newValue instanceof Type || newValue == null) {\n\t\t\t\t\treturn set.call(this, newValue);\n\t\t\t\t} else {\n\t\t\t\t\treturn set.call(this, new Type(newValue));\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\t// Helpes that indicate what the event type should be.  These probably aren't needed.\n\teventType: {\n\t\tdata: function(prop) {\n\t\t\treturn function(newVal, oldVal) {\n\t\t\t\treturn oldVal !== undefined || this._data.hasOwnProperty(prop) ? \"set\" : \"add\";\n\t\t\t};\n\t\t},\n\t\tcomputed: function() {\n\t\t\treturn function() {\n\t\t\t\treturn \"set\";\n\t\t\t};\n\t\t}\n\t},\n\t// Helpers that read the data in a non-observable way.\n\tread: {\n\t\tdata: function(prop) {\n\t\t\treturn function() {\n\t\t\t\treturn this._data[prop];\n\t\t\t};\n\t\t},\n\t\tcomputed: function(prop) {\n\t\t\t// might want to protect this\n\t\t\treturn function() {\n\t\t\t\treturn canReflect.getValue( this._computed[prop].compute );\n\t\t\t};\n\t\t},\n\t\tlastSet: function(prop) {\n\t\t\treturn function() {\n\t\t\t\tvar observable = this._computed[prop].compute;\n\t\t\t\tif(observable.lastSetValue) {\n\t\t\t\t\treturn canReflect.getValue(observable.lastSetValue);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\t// Helpers that read the data in an observable way.\n\tget: {\n\t\t// uses the default value\n\t\tdefaultValue: function(prop, definition, typeConvert, callSetter) {\n\t\t\treturn function() {\n\t\t\t\tvar value = definition.default;\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tif (typeof value === \"function\") {\n\t\t\t\t\t\tvalue = value.call(this);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = typeConvert.call(this, value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar Default = definition.Default;\n\t\t\t\t\tif (Default) {\n\t\t\t\t\t\tvalue = typeConvert.call(this,new Default());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(definition.set) {\n\t\t\t\t\t// TODO: there's almost certainly a faster way of making this happen\n\t\t\t\t\t// But this is maintainable.\n\n\t\t\t\t\tvar VALUE;\n\t\t\t\t\tvar sync = true;\n\n\t\t\t\t\tvar setter = make.set.setter(prop, definition.set, function(){}, function(value){\n\t\t\t\t\t\tif(sync) {\n\t\t\t\t\t\t\tVALUE = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallSetter.call(this, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, definition.get);\n\n\t\t\t\t\tsetter.call(this,value);\n\t\t\t\t\tsync= false;\n\n\t\t\t\t\t// VALUE will be undefined if the callback is never called.\n\t\t\t\t\treturn VALUE;\n\n\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t};\n\t\t},\n\t\tdata: function(prop) {\n\t\t\treturn function() {\n\t\t\t\tif (!this[inSetupSymbol]) {\n\t\t\t\t\tObservationRecorder.add(this, prop);\n\t\t\t\t}\n\n\t\t\t\treturn this._data[prop];\n\t\t\t};\n\t\t},\n\t\tcomputed: function(prop) {\n\t\t\treturn function(val) {\n\t\t\t\tvar compute = this._computed[prop].compute;\n\t\t\t\tif (ObservationRecorder.isRecording()) {\n\t\t\t\t\tObservationRecorder.add(this, prop);\n\t\t\t\t\tif (!canReflect.isBound(compute)) {\n\t\t\t\t\t\tObservation.temporarilyBind(compute);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn peek(compute);\n\t\t\t};\n\t\t}\n\t}\n};\n\ndefine.behaviors = [\"get\", \"set\", \"value\", \"Value\", \"type\", \"Type\", \"serialize\"];\n\n// This cleans up a particular behavior and adds it to the definition\nvar addBehaviorToDefinition = function(definition, behavior, value) {\n\tif(behavior === \"enumerable\") {\n\t\t// treat enumerable like serialize\n\t\tdefinition.serialize = !!value;\n\t}\n\telse if(behavior === \"type\") {\n\t\tvar behaviorDef = value;\n\t\tif(typeof behaviorDef === \"string\") {\n\t\t\tbehaviorDef = define.types[behaviorDef];\n\t\t\tif(typeof behaviorDef === \"object\" && !isDefineType(behaviorDef)) {\n\t\t\t\tassign(definition, behaviorDef);\n\t\t\t\tbehaviorDef = behaviorDef[behavior];\n\t\t\t}\n\t\t}\n\t\tif (typeof behaviorDef !== 'undefined') {\n\t\t\tdefinition[behavior] = behaviorDef;\n\t\t}\n\t}\n\telse {\n\t\tdefinition[behavior] = value;\n\t}\n};\n\n// This is called by `define.property` AND `getDefinitionOrMethod` (which is called by `define`)\n// Currently, this is adding default behavior\n// copying `type` over, and even cleaning up the final definition object\nmakeDefinition = function(prop, def, defaultDefinition, typePrototype) {\n\n\tvar definition = {};\n\n\tcanReflect.eachKey(def, function(value, behavior) {\n\t\taddBehaviorToDefinition(definition, behavior, value);\n\t});\n\t// only add default if it doesn't exist\n\tcanReflect.eachKey(defaultDefinition, function(value, prop){\n\t\tif(definition[prop] === undefined) {\n\t\t\tif(prop !== \"type\" && prop !== \"Type\") {\n\t\t\t\tdefinition[prop] = value;\n\t\t\t}\n\t\t}\n\t});\n\n\t// normalize Type that implements can.new\n\tif(def.Type) {\n\t\tvar value = def.Type;\n\n\t\tvar serialize = value[serializeSymbol];\n\t\tif(serialize) {\n\t\t\tdefinition.serialize = function(val){\n\t\t\t\treturn serialize.call(val);\n\t\t\t};\n\t\t}\n\t\tif(value[newSymbol]) {\n\t\t\tdefinition.type = value;\n\t\t\tdelete definition.Type;\n\t\t}\n\t}\n\n\t// We only want to add a defaultDefinition if def.type is not a string\n\t// if def.type is a string it is handled in addDefinition\n\tif(typeof def.type !== 'string') {\n\t\t// if there's no type definition, take it from the defaultDefinition\n\t\tif(!definition.type && !definition.Type) {\n            var defaultsCopy = canReflect.assignMap({},defaultDefinition);\n            definition = canReflect.assignMap(defaultsCopy, definition);\n\t\t}\n\n\t\tif( canReflect.size(definition) === 0 ) {\n\t\t\tdefinition.type = define.types[\"*\"];\n\t\t}\n\t}\n\tcleanUpDefinition(prop, definition, true, typePrototype);\n\treturn definition;\n};\n\n// called by `can.defineInstanceKey` and `getDefinitionsAndMethods`\n// returns the value or the definition object.\n// calls makeDefinition\n// This is dealing with a string value\ngetDefinitionOrMethod = function(prop, value, defaultDefinition, typePrototype){\n\t// Clean up the value to make it a definition-like object\n\tvar definition;\n\tif(typeof value === \"string\") {\n\t\tdefinition = {type: value};\n\t}\n    // copies a `Type`'s methods over\n\telse if(value && (value[serializeSymbol] || value[newSymbol]) ) {\n\t\tdefinition = { Type: value };\n\t}\n\telse if(typeof value === \"function\") {\n\t\tif(canReflect.isConstructorLike(value)) {\n\t\t\tdefinition = {Type: value};\n\t\t}\n\t\t// or leaves as a function\n\t} else if( Array.isArray(value) ) {\n\t\tdefinition = {Type: value};\n\t} else if( canReflect.isPlainObject(value) ){\n\t\tdefinition = value;\n\t}\n\n\tif(definition) {\n\t\treturn makeDefinition(prop, definition, defaultDefinition, typePrototype);\n\t}\n\telse {\n\t\treturn value;\n\t}\n};\n// called by can.define\ngetDefinitionsAndMethods = function(defines, baseDefines, typePrototype) {\n\t// make it so the definitions include base definitions on the proto\n\tvar definitions = Object.create(baseDefines ? baseDefines.definitions : null);\n\tvar methods = {};\n\t// first lets get a default if it exists\n\tvar defaults = defines[\"*\"],\n\t\tdefaultDefinition;\n\tif(defaults) {\n\t\tdelete defines[\"*\"];\n\t\tdefaultDefinition = getDefinitionOrMethod(\"*\", defaults, {});\n\t} else {\n\t\tdefaultDefinition = Object.create(null);\n\t}\n\n\teachPropertyDescriptor(defines, function( prop, propertyDescriptor ) {\n\n\t\tvar value;\n\t\tif(propertyDescriptor.get || propertyDescriptor.set) {\n\t\t\tvalue = {get: propertyDescriptor.get, set: propertyDescriptor.set};\n\t\t} else {\n\t\t\tvalue = propertyDescriptor.value;\n\t\t}\n\n\t\tif(prop === \"constructor\") {\n\t\t\tmethods[prop] = value;\n\t\t\treturn;\n\t\t} else {\n\t\t\tvar result = getDefinitionOrMethod(prop, value, defaultDefinition, typePrototype);\n\t\t\tif(result && typeof result === \"object\" && canReflect.size(result) > 0) {\n\t\t\t\tdefinitions[prop] = result;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Removed adding raw values that are not functions\n\t\t\t\tif (typeof result === 'function') {\n\t\t\t\t\tmethods[prop] = result;\n\t\t\t\t}\n\t\t\t\t//!steal-remove-start\n\t\t\t\telse if (typeof result !== 'undefined') {\n\t\t\t\t\tif(true) {\n                    \t// Ex: {prop: 0}\n\t\t\t\t\t\tcanLogDev.error(canReflect.getName(typePrototype)+\".\"+prop + \" does not match a supported propDefinition. See: https://canjs.com/doc/can-define.types.propDefinition.html\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t}\n\t\t}\n\t});\n\tif(defaults) {\n\t\t// we should move this property off the prototype.\n\t\tdefineConfigurableAndNotEnumerable(defines,\"*\", defaults);\n\t}\n\treturn {definitions: definitions, methods: methods, defaultDefinition: defaultDefinition};\n};\n\neventsProto = eventQueue({});\n\nfunction setupComputed(instance, eventName) {\n\tvar computedBinding = instance._computed && instance._computed[eventName];\n\tif (computedBinding && computedBinding.compute) {\n\t\tif (!computedBinding.count) {\n\t\t\tcomputedBinding.count = 1;\n\t\t\tcanReflect.onValue(computedBinding.compute, computedBinding.handler, \"notify\");\n\t\t\tcomputedBinding.oldValue = peek(computedBinding.compute);\n\t\t} else {\n\t\t\tcomputedBinding.count++;\n\t\t}\n\n\t}\n}\nfunction teardownComputed(instance, eventName){\n\tvar computedBinding = instance._computed && instance._computed[eventName];\n\tif (computedBinding) {\n\t\tif (computedBinding.count === 1) {\n\t\t\tcomputedBinding.count = 0;\n\t\t\tcanReflect.offValue(computedBinding.compute, computedBinding.handler,\"notify\");\n\t\t} else {\n\t\t\tcomputedBinding.count--;\n\t\t}\n\t}\n}\n\nvar canMetaSymbol = canSymbol.for(\"can.meta\");\nassign(eventsProto, {\n\t_eventSetup: function() {},\n\t_eventTeardown: function() {},\n\taddEventListener: function(eventName, handler, queue) {\n\t\tsetupComputed(this, eventName);\n\t\treturn eventQueue.addEventListener.apply(this, arguments);\n\t},\n\n\t// ### unbind\n\t// Stops listening to an event.\n\t// If this is the last listener of a computed property,\n\t// stop forwarding events of the computed property to this map.\n\tremoveEventListener: function(eventName, handler) {\n\t\tteardownComputed(this, eventName);\n\t\treturn eventQueue.removeEventListener.apply(this, arguments);\n\n\t}\n});\neventsProto.on = eventsProto.bind = eventsProto.addEventListener;\neventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;\n\n\nvar onKeyValueSymbol = canSymbol.for(\"can.onKeyValue\");\nvar offKeyValueSymbol = canSymbol.for(\"can.offKeyValue\");\n\ncanReflect.assignSymbols(eventsProto,{\n\t\"can.onKeyValue\": function(key){\n\t\tsetupComputed(this, key);\n\t\treturn eventQueue[onKeyValueSymbol].apply(this, arguments);\n\t},\n\t\"can.offKeyValue\": function(key){\n\t\tteardownComputed(this, key);\n\t\treturn eventQueue[offKeyValueSymbol].apply(this, arguments);\n\t}\n});\n\ndelete eventsProto.one;\n\ndefine.setup = function(props, sealed) {\n\tObject.defineProperty(this,\"constructor\", {value: this.constructor, enumerable: false, writable: false});\n\tObject.defineProperty(this,canMetaSymbol, {value: Object.create(null), enumerable: false, writable: false});\n\n\t/* jshint -W030 */\n\n\tvar definitions = this._define.definitions;\n\tvar instanceDefinitions = Object.create(null);\n\tvar map = this;\n\tcanReflect.eachKey(props, function(value, prop){\n\t\tif(definitions[prop] !== undefined) {\n\t\t\tmap[prop] = value;\n\t\t} else {\n\t\t\tdefine.expando(map, prop, value);\n\t\t}\n\t});\n\tif(canReflect.size(instanceDefinitions) > 0) {\n\t\tdefineConfigurableAndNotEnumerable(this, \"_instanceDefinitions\", instanceDefinitions);\n\t}\n\t// only seal in dev mode for performance reasons.\n\t//!steal-remove-start\n\tif(true) {\n\t\tthis._data;\n\t\tthis._computed;\n\t\tif(sealed !== false) {\n\t\t\tObject.seal(this);\n\t\t}\n\t}\n\t//!steal-remove-end\n};\n\n\nvar returnFirstArg = function(arg){\n\treturn arg;\n};\n\ndefine.expando = function(map, prop, value) {\n\tif(define._specialKeys[prop]) {\n\t\t// ignores _data and _computed\n\t\treturn true;\n\t}\n\t// first check if it's already a constructor define\n\tvar constructorDefines = map._define.definitions;\n\tif(constructorDefines && constructorDefines[prop]) {\n\t\treturn;\n\t}\n\t// next if it's already on this instances\n\tvar instanceDefines = map._instanceDefinitions;\n\tif(!instanceDefines) {\n\t\tif(Object.isSealed(map)) {\n\t\t\treturn;\n\t\t}\n\t\tObject.defineProperty(map, \"_instanceDefinitions\", {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tvalue: {}\n\t\t});\n\t\tinstanceDefines = map._instanceDefinitions;\n\t}\n\tif(!instanceDefines[prop]) {\n\t\tvar defaultDefinition = map._define.defaultDefinition || {type: define.types.observable};\n\t\tdefine.property(map, prop, defaultDefinition, {},{});\n\t\t// possibly convert value to List or DefineMap\n\t\tif(defaultDefinition.type) {\n\t\t\tmap._data[prop] = define.make.set.type(prop, defaultDefinition.type, returnFirstArg).call(map, value);\n\t\t} else if (defaultDefinition.Type && canReflect.isConstructorLike(defaultDefinition.Type)) {\n\t\t\tmap._data[prop] = define.make.set.Type(prop, defaultDefinition.Type, returnFirstArg).call(map, value);\n\t\t} else {\n\t\t\tmap._data[prop] = define.types.observable(value);\n\t\t}\n\n\t\tinstanceDefines[prop] = defaultDefinition;\n\t\tif(!map[inSetupSymbol]) {\n\t\t\tqueues.batch.start();\n\t\t\tmap.dispatch({\n\t\t\t\taction: \"can.keys\",\n\t\t\t\ttarget: map,\n\t\t\t\ttype: \"can.keys\" // TODO: Remove in 6.0\n\t\t\t});\n\t\t\tif(Object.prototype.hasOwnProperty.call(map._data, prop)) {\n\t\t\t\tmap.dispatch({\n\t\t\t\t\taction: \"add\",\n\t\t\t\t\ttarget: map,\n\t\t\t\t\tvalue:  map._data[prop],\n\t\t\t\t\toldValue: undefined,\n\t\t\t\t\tkey: prop,\n\t\t\t\t\ttype: prop, // TODO: Remove in 6.0\n\t\t\t\t\tpatches: [{type: \"add\", key: prop, value: map._data[prop]}],\n\t\t\t\t},[map._data[prop], undefined]);\n\t\t\t} else {\n\t\t\t\tmap.dispatch({\n\t\t\t\t\ttype: \"set\",\n\t\t\t\t\ttarget: map,\n\t\t\t\t\tpatches: [{type: \"add\", key: prop, value: map._data[prop]}],\n\t\t\t\t},[map._data[prop], undefined]);\n\t\t\t}\n\t\t\tqueues.batch.stop();\n\t\t}\n\t\treturn true;\n\t}\n};\ndefine.replaceWith = defineLazyValue;\ndefine.eventsProto = eventsProto;\ndefine.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;\ndefine.make = make;\ndefine.getDefinitionOrMethod = getDefinitionOrMethod;\ndefine._specialKeys = {_data: true, _computed: true};\nvar simpleGetterSetters = {};\ndefine.makeSimpleGetterSetter = function(prop){\n\tif(simpleGetterSetters[prop] === undefined) {\n\n\t\tvar setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop) );\n\n\t\tsimpleGetterSetters[prop] = {\n\t\t\tget: make.get.data(prop),\n\t\t\tset: function(newVal){\n\t\t\t\treturn setter.call(this, define.types.observable(newVal));\n\t\t\t},\n\t\t\tenumerable: true,\n            configurable: true\n\t\t};\n\t}\n\treturn simpleGetterSetters[prop];\n};\n\ndefine.Iterator = function(obj){\n\tthis.obj = obj;\n\tthis.definitions = Object.keys(obj._define.definitions);\n\tthis.instanceDefinitions = obj._instanceDefinitions ?\n\t\tObject.keys(obj._instanceDefinitions) :\n\t\tObject.keys(obj);\n\tthis.hasGet = typeof obj.get === \"function\";\n};\n\ndefine.Iterator.prototype.next = function(){\n\tvar key;\n\tif(this.definitions.length) {\n\t\tkey = this.definitions.shift();\n\n\t\t// Getters should not be enumerable\n\t\tvar def = this.obj._define.definitions[key];\n\t\tif(def.get) {\n\t\t\treturn this.next();\n\t\t}\n\t} else if(this.instanceDefinitions.length) {\n\t\tkey = this.instanceDefinitions.shift();\n\t} else {\n\t\treturn {\n\t\t\tvalue: undefined,\n\t\t\tdone: true\n\t\t};\n\t}\n\n\treturn {\n\t\tvalue: [\n\t\t\tkey,\n\t\t\tthis.hasGet ? this.obj.get(key) : this.obj[key]\n\t\t],\n\t\tdone: false\n\t};\n};\n\n\n\nfunction isObservableValue(obj){\n\treturn canReflect.isValueLike(obj) && canReflect.isObservableLike(obj);\n}\n\ndefine.types = {\n\t// To be made into a type ... this is both lazy {time: '123-456'}\n\t'date': MaybeDate,\n\t'number': MaybeNumber,\n\t'boolean': MaybeBoolean,\n\t'observable': function(newVal) {\n\t\t\tif(Array.isArray(newVal) && define.DefineList) {\n\t\t\t\t\tnewVal = new define.DefineList(newVal);\n\t\t\t}\n\t\t\telse if(canReflect.isPlainObject(newVal) &&  define.DefineMap) {\n\t\t\t\t\tnewVal = new define.DefineMap(newVal);\n\t\t\t}\n\t\t\treturn newVal;\n\t},\n\t'stringOrObservable': function(newVal) {\n\t\tif(Array.isArray(newVal)) {\n\t\t\treturn new define.DefaultList(newVal);\n\t\t}\n\t\telse if(canReflect.isPlainObject(newVal)) {\n\t\t\treturn new define.DefaultMap(newVal);\n\t\t}\n\t\telse {\n\t\t\treturn canReflect.convert( newVal, define.types.string);\n\t\t}\n\t},\n\t/**\n\t * Implements HTML-style boolean logic for attribute strings, where\n\t * any string, including \"\", is truthy.\n\t */\n\t'htmlbool': function(val) {\n\t\tif (val === '') {\n\t\t\treturn true;\n\t\t}\n\t\treturn !!stringToAny(val);\n\t},\n\t'*': function(val) {\n\t\treturn val;\n\t},\n\t'any': function(val) {\n\t\treturn val;\n\t},\n\t'string': MaybeString,\n\n\t'compute': {\n\t\tset: function(newValue, setVal, setErr, oldValue) {\n\t\t\tif (isObservableValue(newValue) ) {\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t\tif (isObservableValue(oldValue)) {\n\t\t\t\tcanReflect.setValue(oldValue,newValue);\n\t\t\t\treturn oldValue;\n\t\t\t}\n\t\t\treturn newValue;\n\t\t},\n\t\tget: function(value) {\n\t\t\treturn isObservableValue(value) ? canReflect.getValue(value) : value;\n\t\t}\n\t}\n};\n\ndefine.updateSchemaKeys = function(schema, definitions) {\n\tfor(var prop in definitions) {\n\t\tvar definition = definitions[prop];\n\t\tif(definition.serialize !== false ) {\n\t\t\tif(definition.Type) {\n\t\t\t\tschema.keys[prop] = definition.Type;\n\t\t\t} else if(definition.type) {\n\t\t\t\tschema.keys[prop] = definition.type;\n\t\t\t} else {\n\t\t\t\tschema.keys[prop] = function(val){ return val; };\n\t\t\t}\n\t\t\t // some unknown type\n\t\t\tif(definitions[prop].identity === true) {\n\t\t\t\tschema.identity.push(prop);\n\t\t\t}\n\t\t}\n\t}\n\treturn schema;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-define/can-define.js?");

/***/ }),

/***/ "./node_modules/can-define/define-helpers/define-helpers.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-define/define-helpers/define-helpers.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar define = __webpack_require__(/*! can-define */ \"./node_modules/can-define/can-define.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar ensureMeta = __webpack_require__(/*! ../ensure-meta */ \"./node_modules/can-define/ensure-meta.js\");\n\nvar defineHelpers = {\n\t// returns `true` if the value was defined and set\n\tdefineExpando: define.expando,\n\treflectSerialize: function(unwrapped){\n\t\tvar constructorDefinitions = this._define.definitions;\n\t\tvar defaultDefinition = this._define.defaultDefinition;\n\t\tthis.forEach(function(val, name){\n\t\t\tvar propDef = constructorDefinitions[name];\n\n\t\t\tif(propDef && typeof propDef.serialize === \"function\") {\n\t\t\t\tval = propDef.serialize.call(this, val, name);\n\t\t\t}\n\t\t\telse if(defaultDefinition && typeof defaultDefinition.serialize === \"function\") {\n\t\t\t\tval =  defaultDefinition.serialize.call(this, val, name);\n\t\t\t} else {\n\t\t\t\tval = canReflect.serialize(val);\n\t\t\t}\n\t\t\tif(val !== undefined) {\n\t\t\t\tunwrapped[name] = val;\n\t\t\t}\n\t\t}, this);\n\t\treturn unwrapped;\n\t},\n\treflectUnwrap: function(unwrapped){\n\t\tthis.forEach(function(value, key){\n\t\t\tif(value !== undefined) {\n\t\t\t\tunwrapped[key] = canReflect.unwrap(value);\n\t\t\t}\n\t\t});\n\t\treturn unwrapped;\n\t},\n\tlog: function(key) {\n\t\tvar instance = this;\n\n\t\tvar quoteString = function quoteString(x) {\n\t\t\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n\t\t};\n\n\t\tvar meta = ensureMeta(instance);\n\t\tvar allowed = meta.allowedLogKeysSet || new Set();\n\t\tmeta.allowedLogKeysSet = allowed;\n\n\t\tif (key) {\n\t\t\tallowed.add(key);\n\t\t}\n\n\t\tmeta._log = function(event, data) {\n\t\t\tvar type = event.type;\n\n\t\t\tif (\n\t\t\t\ttype === \"can.onPatches\" || (key && !allowed.has(type)) ||\n\t\t\t\ttype === \"can.keys\" || (key && !allowed.has(type))\n\t\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (type === \"add\" || type === \"remove\") {\n\t\t\t\tdev.log(\n\t\t\t\t\tcanReflect.getName(instance),\n\t\t\t\t\t\"\\n how   \", quoteString(type),\n\t\t\t\t\t\"\\n what  \", quoteString(data[0]),\n\t\t\t\t\t\"\\n index \", quoteString(data[1])\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// log `length` and `propertyName` events\n\t\t\t\tdev.log(\n\t\t\t\t\tcanReflect.getName(instance),\n\t\t\t\t\t\"\\n key \", quoteString(type),\n\t\t\t\t\t\"\\n is  \", quoteString(data[0]),\n\t\t\t\t\t\"\\n was \", quoteString(data[1])\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t},\n\tdeleteKey: function(prop){\n\t\tvar instanceDefines = this._instanceDefinitions;\n\t\tif(instanceDefines && Object.prototype.hasOwnProperty.call(instanceDefines, prop) && !Object.isSealed(this)) {\n\t\t\tdelete instanceDefines[prop];\n\t\t\tqueues.batch.start();\n\t\t\tthis.dispatch({\n\t\t\t\taction: \"can.keys\",\n\t\t\t\ttype: \"can.keys\", // TODO: Remove in 6.0\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t\tvar oldValue = this._data[prop];\n\t\t\tif(oldValue !== undefined) {\n\t\t\t\tdelete this._data[prop];\n\t\t\t\t//delete this[prop];\n\t\t\t\tthis.dispatch({\n\t\t\t\t\taction: \"delete\",\n\t\t\t\t\tkey: prop,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t\toldValue: oldValue,\n\t\t\t\t\ttype: prop, // TODO: Remove in 6.0\n\t\t\t\t\ttarget: this,\n\t\t\t\t\tpatches: [{type: \"delete\", key: prop}],\n\t\t\t\t},[undefined,oldValue]);\n\t\t\t}\n\t\t\tqueues.batch.stop();\n\t\t} else {\n\t\t\tthis.set(prop, undefined);\n\t\t}\n\t\treturn this;\n\t}\n};\nmodule.exports = defineHelpers;\n\n\n//# sourceURL=webpack:///./node_modules/can-define/define-helpers/define-helpers.js?");

/***/ }),

/***/ "./node_modules/can-define/ensure-meta.js":
/*!************************************************!*\
  !*** ./node_modules/can-define/ensure-meta.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\n// Ensure the \"obj\" passed as an argument has an object on @@can.meta\nmodule.exports = function ensureMeta(obj) {\n\tvar metaSymbol = canSymbol.for(\"can.meta\");\n\tvar meta = obj[metaSymbol];\n\n\tif (!meta) {\n\t\tmeta = {};\n\t\tcanReflect.setKeyValue(obj, metaSymbol, meta);\n\t}\n\n\treturn meta;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-define/ensure-meta.js?");

/***/ }),

/***/ "./node_modules/can-define/list/list.js":
/*!**********************************************!*\
  !*** ./node_modules/can-define/list/list.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Construct = __webpack_require__(/*! can-construct */ \"./node_modules/can-construct/can-construct.js\");\nvar define = __webpack_require__(/*! can-define */ \"./node_modules/can-define/can-define.js\");\nvar make = define.make;\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ \"./node_modules/can-event-queue/type/type.js\");\n\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar canLog = __webpack_require__(/*! can-log */ \"./node_modules/can-log/can-log.js\");\nvar canLogDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar defineHelpers = __webpack_require__(/*! ../define-helpers/define-helpers */ \"./node_modules/can-define/define-helpers/define-helpers.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar diff = __webpack_require__(/*! can-diff/list/list */ \"./node_modules/can-diff/list/list.js\");\nvar ns = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar singleReference = __webpack_require__(/*! can-single-reference */ \"./node_modules/can-single-reference/can-single-reference.js\");\n\nvar splice = [].splice;\nvar runningNative = false;\n\nvar identity = function(x) {\n\treturn x;\n};\n\n// symbols aren't enumerable ... we'd need a version of Object that treats them that way\nvar localOnPatchesSymbol = \"can.patches\";\n\nvar makeFilterCallback = function(props) {\n\treturn function(item) {\n\t\tfor (var prop in props) {\n\t\t\tif (item[prop] !== props[prop]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n};\n\nvar onKeyValue = define.eventsProto[canSymbol.for(\"can.onKeyValue\")];\nvar offKeyValue = define.eventsProto[canSymbol.for(\"can.offKeyValue\")];\nvar getSchemaSymbol = canSymbol.for(\"can.getSchema\");\nvar inSetupSymbol = canSymbol.for(\"can.initializing\");\n\nfunction getSchema() {\n\tvar definitions = this.prototype._define.definitions;\n\tvar schema = {\n\t\ttype: \"list\",\n\t\tkeys: {}\n\t};\n\tschema = define.updateSchemaKeys(schema, definitions);\n\tif(schema.keys[\"#\"]) {\n\t\tschema.values = definitions[\"#\"].Type;\n\t\tdelete schema.keys[\"#\"];\n\t}\n\n\treturn schema;\n}\n\n/** @add can-define/list/list */\nvar DefineList = Construct.extend(\"DefineList\",\n\t/** @static */\n\t{\n\t\tsetup: function(base) {\n\t\t\tif (DefineList) {\n\t\t\t\taddTypeEvents(this);\n\t\t\t\tvar prototype = this.prototype;\n\t\t\t\tvar result = define(prototype, prototype, base.prototype._define);\n\t\t\t\tdefine.makeDefineInstanceKey(this, result);\n\n\t\t\t\tvar itemsDefinition = result.definitions[\"#\"] || result.defaultDefinition;\n\n\t\t\t\tif (itemsDefinition) {\n\t\t\t\t\tif (itemsDefinition.Type) {\n\t\t\t\t\t\tthis.prototype.__type = make.set.Type(\"*\", itemsDefinition.Type, identity);\n\t\t\t\t\t} else if (itemsDefinition.type) {\n\t\t\t\t\t\tthis.prototype.__type = make.set.type(\"*\", itemsDefinition.type, identity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis[getSchemaSymbol] = getSchema;\n\t\t\t}\n\t\t}\n\t},\n\t/** @prototype */\n\t{\n\t\t// setup for only dynamic DefineMap instances\n\t\tsetup: function(items) {\n\t\t\tif (!this._define) {\n\t\t\t\tObject.defineProperty(this, \"_define\", {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tdefinitions: {\n\t\t\t\t\t\t\tlength: { type: \"number\" },\n\t\t\t\t\t\t\t_length: { type: \"number\" }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tObject.defineProperty(this, \"_data\", {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: {}\n\t\t\t\t});\n\t\t\t}\n\t\t\tdefine.setup.call(this, {}, false);\n\t\t\tObject.defineProperty(this, \"_length\", {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: 0\n\t\t\t});\n\t\t\tif (items) {\n\t\t\t\tthis.splice.apply(this, [ 0, 0 ].concat(canReflect.toArray(items)));\n\t\t\t}\n\t\t},\n\t\t__type: define.types.observable,\n\t\t_triggerChange: function(attr, how, newVal, oldVal) {\n\n\t\t\tvar index = +attr;\n\t\t\t// `batchTrigger` direct add and remove events...\n\n\t\t\t// Make sure this is not nested and not an expando\n\t\t\tif ( !isNaN(index)) {\n\t\t\t\tvar itemsDefinition = this._define.definitions[\"#\"];\n\t\t\t\tvar patches, dispatched;\n\t\t\t\tif (how === 'add') {\n\t\t\t\t\tif (itemsDefinition && typeof itemsDefinition.added === 'function') {\n\t\t\t\t\t\tObservationRecorder.ignore(itemsDefinition.added).call(this, newVal, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tpatches = [{type: \"splice\", insert: newVal, index: index, deleteCount: 0}];\n\t\t\t\t\tdispatched = {\n\t\t\t\t\t\ttype: how,\n\t\t\t\t\t\taction: \"splice\",\n\t\t\t\t\t\tinsert: newVal,\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\tdeleteCount: 0,\n\t\t\t\t\t\tpatches: patches\n\t\t\t\t\t};\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif(true) {\n\t\t\t\t\t\tdispatched.reasonLog = [ canReflect.getName(this), \"added\", newVal, \"at\", index ];\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tthis.dispatch(dispatched, [ newVal, index ]);\n\n\t\t\t\t} else if (how === 'remove') {\n\t\t\t\t\tif (itemsDefinition && typeof itemsDefinition.removed === 'function') {\n\t\t\t\t\t\tObservationRecorder.ignore(itemsDefinition.removed).call(this, oldVal, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tpatches = [{type: \"splice\", index: index, deleteCount: oldVal.length}];\n\t\t\t\t\tdispatched = {\n\t\t\t\t\t\ttype: how,\n\t\t\t\t\t\tpatches: patches,\n\t\t\t\t\t\taction: \"splice\",\n\t\t\t\t\t\tindex: index, deleteCount: oldVal.length,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t};\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif(true) {\n\t\t\t\t\t\tdispatched.reasonLog = [ canReflect.getName(this), \"remove\", oldVal, \"at\", index ];\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tthis.dispatch(dispatched, [ oldVal, index ]);\n\n\t\t\t\t} else {\n\t\t\t\t\tthis.dispatch(how, [ newVal, index ]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.dispatch({\n\t\t\t\t\ttype: \"\" + attr,\n\t\t\t\t\ttarget: this\n\t\t\t\t}, [ newVal, oldVal ]);\n\t\t\t}\n\t\t},\n\t\tget: function(index) {\n\t\t\tif (arguments.length) {\n\t\t\t\tif(isNaN(index)) {\n\t\t\t\t\tObservationRecorder.add(this, index);\n\t\t\t\t} else {\n\t\t\t\t\tObservationRecorder.add(this, \"length\");\n\t\t\t\t}\n\t\t\t\treturn this[index];\n\t\t\t} else {\n\t\t\t\treturn canReflect.unwrap(this, Map);\n\t\t\t}\n\t\t},\n\t\tset: function(prop, value) {\n\t\t\t// if we are setting a single value\n\t\t\tif (typeof prop !== \"object\") {\n\t\t\t\t// We want change events to notify using integers if we're\n\t\t\t\t// setting an integer index. Note that <float> % 1 !== 0;\n\t\t\t\tprop = isNaN(+prop) || (prop % 1) ? prop : +prop;\n\t\t\t\tif (typeof prop === \"number\") {\n\t\t\t\t\t// Check to see if we're doing a .attr() on an out of\n\t\t\t\t\t// bounds index property.\n\t\t\t\t\tif (typeof prop === \"number\" &&\n\t\t\t\t\t\tprop > this._length - 1) {\n\t\t\t\t\t\tvar newArr = new Array((prop + 1) - this._length);\n\t\t\t\t\t\tnewArr[newArr.length - 1] = value;\n\t\t\t\t\t\tthis.push.apply(this, newArr);\n\t\t\t\t\t\treturn newArr;\n\t\t\t\t\t}\n\t\t\t\t\tthis.splice(prop, 1, value);\n\t\t\t\t} else {\n\t\t\t\t\tvar defined = defineHelpers.defineExpando(this, prop, value);\n\t\t\t\t\tif (!defined) {\n\t\t\t\t\t\tthis[prop] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// otherwise we are setting multiple\n\t\t\telse {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tcanLogDev.warn('can-define/list/list.prototype.set is deprecated; please use can-define/list/list.prototype.assign or can-define/list/list.prototype.update instead');\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\t//we are deprecating this in #245\n\t\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tthis.replace(prop);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanReflect.assignList(this, prop);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcanReflect.assignMap(this, prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tassign: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.assignList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.assignMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tupdate: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.updateList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.updateMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tassignDeep: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.assignDeepList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.assignDeepMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tupdateDeep: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.updateDeepList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.updateDeepMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t_items: function() {\n\t\t\tvar arr = [];\n\t\t\tthis._each(function(item) {\n\t\t\t\tarr.push(item);\n\t\t\t});\n\t\t\treturn arr;\n\t\t},\n\t\t_each: function(callback) {\n\t\t\tfor (var i = 0, len = this._length; i < len; i++) {\n\t\t\t\tcallback(this[i], i);\n\t\t\t}\n\t\t},\n\t\tsplice: function(index, howMany) {\n\t\t\tvar args = canReflect.toArray(arguments),\n\t\t\t\tadded = [],\n\t\t\t\ti, len, listIndex,\n\t\t\t\tallSame = args.length > 2,\n\t\t\t\toldLength = this._length;\n\n\t\t\tindex = index || 0;\n\n\t\t\t// converting the arguments to the right type\n\t\t\tfor (i = 0, len = args.length - 2; i < len; i++) {\n\t\t\t\tlistIndex = i + 2;\n\t\t\t\targs[listIndex] = this.__type(args[listIndex], listIndex);\n\t\t\t\tadded.push(args[listIndex]);\n\n\t\t\t\t// Now lets check if anything will change\n\t\t\t\tif (this[i + index] !== args[listIndex]) {\n\t\t\t\t\tallSame = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if nothing has changed, then return\n\t\t\tif (allSame && this._length <= added.length) {\n\t\t\t\treturn added;\n\t\t\t}\n\n\t\t\t// default howMany if not provided\n\t\t\tif (howMany === undefined) {\n\t\t\t\thowMany = args[1] = this._length - index;\n\t\t\t}\n\n\t\t\trunningNative = true;\n\t\t\tvar removed = splice.apply(this, args);\n\t\t\trunningNative = false;\n\n\t\t\tqueues.batch.start();\n\t\t\tif (howMany > 0) {\n\t\t\t\t// tears down bubbling\n\t\t\t\tthis._triggerChange(\"\" + index, \"remove\", undefined, removed);\n\t\t\t}\n\t\t\tif (args.length > 2) {\n\t\t\t\tthis._triggerChange(\"\" + index, \"add\", added, removed);\n\t\t\t}\n\n\t\t\tthis.dispatch('length', [ this._length, oldLength ]);\n\n\t\t\tqueues.batch.stop();\n\t\t\treturn removed;\n\t\t},\n\n\t\t/**\n\t\t */\n\t\tserialize: function() {\n\t\t\treturn canReflect.serialize(this, Map);\n\t\t}\n\t}\n);\n\nfor(var prop in define.eventsProto) {\n\tObject.defineProperty(DefineList.prototype, prop, {\n\t\tenumerable:false,\n\t\tvalue: define.eventsProto[prop],\n\t\twritable: true\n\t});\n}\n\nvar eventsProtoSymbols = (\"getOwnPropertySymbols\" in Object) ?\n  Object.getOwnPropertySymbols(define.eventsProto) :\n  [canSymbol.for(\"can.onKeyValue\"), canSymbol.for(\"can.offKeyValue\")];\n\neventsProtoSymbols.forEach(function(sym) {\n  Object.defineProperty(DefineList.prototype, sym, {\n  \tconfigurable: true,\n    enumerable:false,\n    value: define.eventsProto[sym],\n    writable: true\n  });\n});\n\n// Converts to an `array` of arguments.\nvar getArgs = function(args) {\n\treturn args[0] && Array.isArray(args[0]) ?\n\t\targs[0] :\n\t\tcanReflect.toArray(args);\n};\n// Create `push`, `pop`, `shift`, and `unshift`\ncanReflect.eachKey({\n\tpush: \"length\",\n\tunshift: 0\n},\n\t// Adds a method\n\t// `name` - The method name.\n\t// `where` - Where items in the `array` should be added.\n\tfunction(where, name) {\n\t\tvar orig = [][name];\n\t\tDefineList.prototype[name] = function() {\n\t\t\t// Get the items being added.\n\t\t\tvar args = [],\n\t\t\t\t// Where we are going to add items.\n\t\t\t\tlen = where ? this._length : 0,\n\t\t\t\ti = arguments.length,\n\t\t\t\tres, val;\n\n\t\t\t// Go through and convert anything to a `map` that needs to be converted.\n\t\t\twhile (i--) {\n\t\t\t\tval = arguments[i];\n\t\t\t\targs[i] = this.__type(val, i);\n\t\t\t}\n\n\t\t\t// Call the original method.\n\t\t\trunningNative = true;\n\t\t\tres = orig.apply(this, args);\n\t\t\trunningNative = false;\n\n\t\t\tif (!this.comparator || args.length) {\n\t\t\t\tqueues.batch.start();\n\t\t\t\tthis._triggerChange(\"\" + len, \"add\", args, undefined);\n\t\t\t\tthis.dispatch('length', [ this._length, len ]);\n\t\t\t\tqueues.batch.stop();\n\t\t\t}\n\n\t\t\treturn res;\n\t\t};\n\t});\n\ncanReflect.eachKey({\n\tpop: \"length\",\n\tshift: 0\n},\n\t// Creates a `remove` type method\n\tfunction(where, name) {\n\t\tvar orig = [][name];\n\t\tDefineList.prototype[name] = function() {\n\t\t\tif (!this._length) {\n\t\t\t\t// For shift and pop, we just return undefined without\n\t\t\t\t// triggering events.\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tvar args = getArgs(arguments),\n\t\t\t\tlen = where && this._length ? this._length - 1 : 0,\n\t\t\t\toldLength = this._length ? this._length : 0,\n\t\t\t\tres;\n\n\t\t\t// Call the original method.\n\t\t\trunningNative = true;\n\t\t\tres = orig.apply(this, args);\n\t\t\trunningNative = false;\n\n\t\t\t// Create a change where the args are\n\t\t\t// `len` - Where these items were removed.\n\t\t\t// `remove` - Items removed.\n\t\t\t// `undefined` - The new values (there are none).\n\t\t\t// `res` - The old, removed values (should these be unbound).\n\t\t\tqueues.batch.start();\n\t\t\tthis._triggerChange(\"\" + len, \"remove\", undefined, [ res ]);\n\t\t\tthis.dispatch('length', [ this._length, oldLength ]);\n\t\t\tqueues.batch.stop();\n\n\t\t\treturn res;\n\t\t};\n\t});\n\ncanReflect.eachKey({\n\t\"map\": 3,\n\t\"filter\": 3,\n\t\"reduce\": 4,\n\t\"reduceRight\": 4,\n\t\"every\": 3,\n\t\"some\": 3\n},\nfunction a(fnLength, fnName) {\n\tDefineList.prototype[fnName] = function() {\n\t\tvar self = this;\n\t\tvar args = [].slice.call(arguments, 0);\n\t\tvar callback = args[0];\n\t\tvar thisArg = args[fnLength - 1] || self;\n\n\t\tif (typeof callback === \"object\") {\n\t\t\tcallback = makeFilterCallback(callback);\n\t\t}\n\n\t\targs[0] = function() {\n\t\t\tvar cbArgs = [].slice.call(arguments, 0);\n\t\t\t// use .get(index) to ensure observation added.\n\t\t\t// the arguments are (item, index) or (result, item, index)\n\t\t\tcbArgs[fnLength - 3] = self.get(cbArgs[fnLength - 2]);\n\t\t\treturn callback.apply(thisArg, cbArgs);\n\t\t};\n\t\tvar ret = Array.prototype[fnName].apply(this, args);\n\n\t\tif(fnName === \"map\") {\n\t\t\treturn new DefineList(ret);\n\t\t}\n\t\telse if(fnName === \"filter\") {\n\t\t\treturn new self.constructor(ret);\n\t\t} else {\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\nassign(DefineList.prototype, {\n\tincludes: (function(){\n\t\tvar arrayIncludes =  Array.prototype.includes;\n\t\tif(arrayIncludes){\n\t\t\treturn function includes() {\n\t\t\t\treturn arrayIncludes.apply(this, arguments);\n\t\t\t};\n\t\t} else {\n\t\t\treturn function includes() {\n\t\t\t\tthrow new Error(\"DefineList.prototype.includes must have Array.prototype.includes available. Please add a polyfill to this environment.\");\n\t\t\t};\n\t\t}\n\t})(),\n\tindexOf: function(item, fromIndex) {\n\t\tfor (var i = fromIndex || 0, len = this.length; i < len; i++) {\n\t\t\tif (this.get(i) === item) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\tlastIndexOf: function(item, fromIndex) {\n\t\tfromIndex = typeof fromIndex === \"undefined\" ? this.length - 1: fromIndex;\n\t\tfor (var i = fromIndex; i >= 0; i--) {\n\t\t\tif (this.get(i) === item) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\tjoin: function() {\n\t\tObservationRecorder.add(this, \"length\");\n\t\treturn [].join.apply(this, arguments);\n\t},\n\treverse: function() {\n\t\t// this shouldn't be observable\n\t\tvar list = [].reverse.call(this._items());\n\t\treturn this.replace(list);\n\t},\n\tslice: function() {\n\t\t// tells computes to listen on length for changes.\n\t\tObservationRecorder.add(this, \"length\");\n\t\tvar temp = Array.prototype.slice.apply(this, arguments);\n\t\treturn new this.constructor(temp);\n\t},\n\tconcat: function() {\n\t\tvar args = [];\n\t\t// Go through each of the passed `arguments` and\n\t\t// see if it is list-like, an array, or something else\n\t\tcanReflect.eachIndex(arguments, function(arg) {\n\t\t\tif (canReflect.isListLike(arg)) {\n\t\t\t\t// If it is list-like we want convert to a JS array then\n\t\t\t\t// pass each item of the array to this.__type\n\t\t\t\tvar arr = Array.isArray(arg) ? arg : canReflect.toArray(arg);\n\t\t\t\tarr.forEach(function(innerArg) {\n\t\t\t\t\targs.push(this.__type(innerArg));\n\t\t\t\t}, this);\n\t\t\t} else {\n\t\t\t\t// If it is a Map, Object, or some primitive\n\t\t\t\t// just pass arg to this.__type\n\t\t\t\targs.push(this.__type(arg));\n\t\t\t}\n\t\t}, this);\n\n\t\t// We will want to make `this` list into a JS array\n\t\t// as well (We know it should be list-like), then\n\t\t// concat with our passed in args, then pass it to\n\t\t// list constructor to make it back into a list\n\t\treturn new this.constructor(Array.prototype.concat.apply(canReflect.toArray(this), args));\n\t},\n\tforEach: function(cb, thisarg) {\n\t\tvar item;\n\t\tfor (var i = 0, len = this.length; i < len; i++) {\n\t\t\titem = this.get(i);\n\t\t\tif (cb.call(thisarg || item, item, i, this) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\treplace: function(newList) {\n\t\tvar patches = diff(this, newList);\n\n\t\tqueues.batch.start();\n\t\tfor (var i = 0, len = patches.length; i < len; i++) {\n\t\t\tthis.splice.apply(this, [\n\t\t\t\tpatches[i].index,\n\t\t\t\tpatches[i].deleteCount\n\t\t\t].concat(patches[i].insert));\n\t\t}\n\t\tqueues.batch.stop();\n\n\t\treturn this;\n\t},\n\tsort: function(compareFunction) {\n\t\tvar sorting = Array.prototype.slice.call(this);\n\t\tArray.prototype.sort.call(sorting, compareFunction);\n\t\tthis.splice.apply(this, [0,sorting.length].concat(sorting) );\n\t\treturn this;\n\t}\n});\n\n// Add necessary event methods to this object.\nfor (var prop in define.eventsProto) {\n\tDefineList[prop] = define.eventsProto[prop];\n\tObject.defineProperty(DefineList.prototype, prop, {\n\t\tenumerable: false,\n\t\tvalue: define.eventsProto[prop],\n\t\twritable: true\n\t});\n}\n\nObject.defineProperty(DefineList.prototype, \"length\", {\n\tget: function() {\n\t\tif (!this[inSetupSymbol]) {\n\t\t\tObservationRecorder.add(this, \"length\");\n\t\t}\n\t\treturn this._length;\n\t},\n\tset: function(newVal) {\n\t\tif (runningNative) {\n\t\t\tthis._length = newVal;\n\t\t\treturn;\n\t\t}\n\n\t\t// Don't set _length if:\n\t\t//  - null or undefined\n\t\t//  - a string that doesn't convert to number\n\t\t//  - already the length being set\n\t\tif (newVal == null || isNaN(+newVal) || newVal === this._length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (newVal > this._length - 1) {\n\t\t\tvar newArr = new Array(newVal - this._length);\n\t\t\tthis.push.apply(this, newArr);\n\t\t}\n\t\telse {\n\t\t\tthis.splice(newVal);\n\t\t}\n\t},\n\tenumerable: true\n});\n\nDefineList.prototype.attr = function(prop, value) {\n\tcanLog.warn(\"DefineMap::attr shouldn't be called\");\n\tif (arguments.length === 0) {\n\t\treturn this.get();\n\t} else if (prop && typeof prop === \"object\") {\n\t\treturn this.set.apply(this, arguments);\n\t} else if (arguments.length === 1) {\n\t\treturn this.get(prop);\n\t} else {\n\t\treturn this.set(prop, value);\n\t}\n};\nDefineList.prototype.item = function(index, value) {\n\tif (arguments.length === 1) {\n\t\treturn this.get(index);\n\t} else {\n\t\treturn this.set(index, value);\n\t}\n};\nDefineList.prototype.items = function() {\n\tcanLog.warn(\"DefineList::get should should be used instead of DefineList::items\");\n\treturn this.get();\n};\n\nvar defineListProto = {\n\t// type\n\t\"can.isMoreListLikeThanMapLike\": true,\n\t\"can.isMapLike\": true,\n\t\"can.isListLike\": true,\n\t\"can.isValueLike\": false,\n\t// get/set\n\t\"can.getKeyValue\": DefineList.prototype.get,\n\t\"can.setKeyValue\": DefineList.prototype.set,\n\n\t// Called for every reference to a property in a template\n\t// if a key is a numerical index then translate to length event\n\t\"can.onKeyValue\": function(key, handler, queue) {\n\t\tvar translationHandler;\n\t\tif (isNaN(key)) {\n\t\t\treturn onKeyValue.apply(this, arguments);\n\t\t}\n\t\telse {\n\t\t\ttranslationHandler = function() {\n\t\t\t\thandler(this[key]);\n\t\t\t};\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tObject.defineProperty(translationHandler, \"name\", {\n\t\t\t\t\tvalue: \"translationHandler(\" + key + \")::\" + canReflect.getName(this) + \".onKeyValue('length',\" + canReflect.getName(handler) + \")\",\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tsingleReference.set(handler, this, translationHandler, key);\n\t\t\treturn onKeyValue.call(this, 'length',  translationHandler, queue);\n\t\t}\n\t},\n\t// Called when a property reference is removed\n\t\"can.offKeyValue\": function(key, handler, queue) {\n\t\tvar translationHandler;\n\t\tif ( isNaN(key)) {\n\t\t\treturn offKeyValue.apply(this, arguments);\n\t\t}\n\t\telse {\n\t\t\ttranslationHandler = singleReference.getAndDelete(handler, this, key);\n\t\t\treturn offKeyValue.call(this, 'length',  translationHandler, queue);\n\t\t}\n\t},\n\n\t\"can.deleteKeyValue\": function(prop) {\n\t\t// convert string key to number index if key can be an integer:\n\t\t//   isNaN if prop isn't a numeric representation\n\t\t//   (prop % 1) if numeric representation is a float\n\t\t//   In both of the above cases, leave as string.\n\t\tprop = isNaN(+prop) || (prop % 1) ? prop : +prop;\n\t\tif(typeof prop === \"number\") {\n\t\t\tthis.splice(prop, 1);\n\t\t} else if(prop === \"length\" || prop === \"_length\") {\n\t\t\treturn; // length must not be deleted\n\t\t} else {\n\t\t\tthis.set(prop, undefined);\n\t\t}\n\t\treturn this;\n\t},\n\t// shape get/set\n\t\"can.assignDeep\": function(source){\n\t\tqueues.batch.start();\n\t\tcanReflect.assignList(this, source);\n\t\tqueues.batch.stop();\n\t},\n\t\"can.updateDeep\": function(source){\n\t\tqueues.batch.start();\n\t\tthis.replace(source);\n\t\tqueues.batch.stop();\n\t},\n\n\t// observability\n\t\"can.keyHasDependencies\": function(key) {\n\t\treturn !!(this._computed && this._computed[key] && this._computed[key].compute);\n\t},\n\t\"can.getKeyDependencies\": function(key) {\n\t\tvar ret;\n\t\tif(this._computed && this._computed[key] && this._computed[key].compute) {\n\t\t\tret = {};\n\t\t\tret.valueDependencies = new Set();\n\t\t\tret.valueDependencies.add(this._computed[key].compute);\n\t\t}\n\t\treturn ret;\n\t},\n\t/*\"can.onKeysAdded\": function(handler,queue) {\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](\"add\", handler,queue);\n\t},\n\t\"can.onKeysRemoved\": function(handler,queue) {\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](\"remove\", handler,queue);\n\t},*/\n\t\"can.splice\": function(index, deleteCount, insert){\n\t\tthis.splice.apply(this, [index, deleteCount].concat(insert));\n\t},\n\t\"can.onPatches\": function(handler,queue){\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](localOnPatchesSymbol, handler,queue);\n\t},\n\t\"can.offPatches\": function(handler,queue) {\n\t\tthis[canSymbol.for(\"can.offKeyValue\")](localOnPatchesSymbol, handler,queue);\n\t}\n};\n\n//!steal-remove-start\nif(true) {\n\tdefineListProto[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"[]\";\n\t};\n}\n//!steal-remove-end\n\ncanReflect.assignSymbols(DefineList.prototype, defineListProto);\n\ncanReflect.setKeyValue(DefineList.prototype, canSymbol.iterator, function() {\n\tvar index = -1;\n\tif(typeof this.length !== \"number\") {\n\t\tthis.length = 0;\n\t}\n\treturn {\n\t\tnext: function() {\n\t\t\tindex++;\n\t\t\treturn {\n\t\t\t\tvalue: this[index],\n\t\t\t\tdone: index >= this.length\n\t\t\t};\n\t\t}.bind(this)\n\t};\n});\n\n//!steal-remove-start\nif(true) {\n\t// call `list.log()` to log all event changes\n\t// pass `key` to only log the matching event, e.g: `list.log(\"add\")`\n\tDefineList.prototype.log = defineHelpers.log;\n}\n//!steal-remove-end\n\ndefine.DefineList = DefineList;\n\nmodule.exports = ns.DefineList = DefineList;\n\n\n//# sourceURL=webpack:///./node_modules/can-define/list/list.js?");

/***/ }),

/***/ "./node_modules/can-define/map/map.js":
/*!********************************************!*\
  !*** ./node_modules/can-define/map/map.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Construct = __webpack_require__(/*! can-construct */ \"./node_modules/can-construct/can-construct.js\");\nvar define = __webpack_require__(/*! can-define */ \"./node_modules/can-define/can-define.js\");\nvar defineHelpers = __webpack_require__(/*! ../define-helpers/define-helpers */ \"./node_modules/can-define/define-helpers/define-helpers.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar ns = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canLog = __webpack_require__(/*! can-log */ \"./node_modules/can-log/can-log.js\");\nvar canLogDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ \"./node_modules/can-event-queue/type/type.js\");\n\nvar keysForDefinition = function(definitions) {\n\tvar keys = [];\n\tfor(var prop in definitions) {\n\t\tvar definition = definitions[prop];\n\t\tif(typeof definition !== \"object\" || (\"serialize\" in definition ? !!definition.serialize : !definition.get)) {\n\t\t\tkeys.push(prop);\n\t\t}\n\t}\n\treturn keys;\n};\n\nfunction assign(source) {\n\tqueues.batch.start();\n\tcanReflect.assignMap(this, source || {});\n\tqueues.batch.stop();\n}\nfunction update(source) {\n\tqueues.batch.start();\n\tcanReflect.updateMap(this, source || {});\n\tqueues.batch.stop();\n}\nfunction assignDeep(source){\n\tqueues.batch.start();\n\t// TODO: we should probably just throw an error instead of cleaning\n\tcanReflect.assignDeepMap(this, source || {});\n\tqueues.batch.stop();\n}\nfunction updateDeep(source){\n\tqueues.batch.start();\n\t// TODO: we should probably just throw an error instead of cleaning\n\tcanReflect.updateDeepMap(this, source || {});\n\tqueues.batch.stop();\n}\nfunction setKeyValue(key, value) {\n\tvar defined = defineHelpers.defineExpando(this, key, value);\n\tif(!defined) {\n\t\tthis[key] = value;\n\t}\n}\nfunction getKeyValue(key) {\n\tvar value = this[key];\n\tif(value !== undefined || key in this || Object.isSealed(this)) {\n\t\treturn value;\n\t} else {\n\t\tObservationRecorder.add(this, key);\n\t\treturn this[key];\n\t}\n}\n\nvar getSchemaSymbol = canSymbol.for(\"can.getSchema\");\n\nfunction getSchema() {\n\tvar def = this.prototype._define;\n\tvar definitions = def ? def.definitions : {};\n\tvar schema = {\n\t\ttype: \"map\",\n\t\tidentity: [],\n\t\tkeys: {}\n\t};\n\treturn define.updateSchemaKeys(schema, definitions);\n}\n\nvar sealedSetup = function(props){\n\tdefine.setup.call(\n\t\tthis,\n\t\tprops || {},\n\t\tthis.constructor.seal\n\t);\n};\n\n\nvar DefineMap = Construct.extend(\"DefineMap\",{\n\tsetup: function(base){\n\t\tvar key,\n\t\t\tprototype = this.prototype;\n\t\tif(DefineMap) {\n\t\t\t// we have already created\n\t\t\tvar result = define(prototype, prototype, base.prototype._define);\n\t\t\t\tdefine.makeDefineInstanceKey(this, result);\n\n\t\t\taddTypeEvents(this);\n\t\t\tfor(key in DefineMap.prototype) {\n\t\t\t\tdefine.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);\n\t\t\t}\n\t\t\t// If someone provided their own setup, we call that.\n\t\t\tif(prototype.setup === DefineMap.prototype.setup) {\n\t\t\t\tdefine.defineConfigurableAndNotEnumerable(prototype, \"setup\", sealedSetup);\n\t\t\t}\n\n\t\t\tvar _computedGetter = Object.getOwnPropertyDescriptor(prototype, \"_computed\").get;\n\t\t\tObject.defineProperty(prototype, \"_computed\", {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tget: function(){\n\t\t\t\t\tif(this === prototype) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn _computedGetter.call(this, arguments);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tfor(key in prototype) {\n\t\t\t\tdefine.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);\n\t\t\t}\n\t\t}\n\t\tdefine.defineConfigurableAndNotEnumerable(prototype, \"constructor\", this);\n\t\tthis[getSchemaSymbol] = getSchema;\n\t}\n},{\n\t// setup for only dynamic DefineMap instances\n\tsetup: function(props, sealed){\n\t\tif(!this._define) {\n\t\t\tObject.defineProperty(this,\"_define\",{\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: {\n\t\t\t\t\tdefinitions: {}\n\t\t\t\t}\n\t\t\t});\n\t\t\tObject.defineProperty(this,\"_data\",{\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: {}\n\t\t\t});\n\t\t}\n\t\tdefine.setup.call(\n\t\t\tthis,\n\t\t\tprops || {},\n\t\t\tsealed === true\n\t\t);\n\t},\n\tget: function(prop){\n\t\tif(prop) {\n\t\t\treturn getKeyValue.call(this, prop);\n\t\t} else {\n\t\t\treturn canReflect.unwrap(this, Map);\n\t\t}\n\t},\n\tset: function(prop, value){\n\t\tif(typeof prop === \"object\") {\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tcanLogDev.warn('can-define/map/map.prototype.set is deprecated; please use can-define/map/map.prototype.assign or can-define/map/map.prototype.update instead');\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tif(value === true) {\n\t\t\t\tupdateDeep.call(this, prop);\n\t\t\t} else {\n\t\t\t\tassignDeep.call(this, prop);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsetKeyValue.call(this, prop, value);\n\t\t}\n\n\t\treturn this;\n\t},\n\tassignDeep: function(prop) {\n\t\tassignDeep.call(this, prop);\n\t\treturn this;\n\t},\n\tupdateDeep: function(prop) {\n\t\tupdateDeep.call(this, prop);\n\t\treturn this;\n\t},\n\tassign: function(prop) {\n\t\tassign.call(this, prop);\n\t\treturn this;\n\t},\n\tupdate: function(prop) {\n\t\tupdate.call(this, prop);\n\t\treturn this;\n\t},\n\tserialize: function () {\n\t\treturn canReflect.serialize(this, Map);\n\t},\n\tdeleteKey: defineHelpers.deleteKey,\n\tforEach: (function(){\n\n\t\tvar forEach = function(list, cb, thisarg){\n\t\t\treturn canReflect.eachKey(list, cb, thisarg);\n\t\t},\n\t\t\tnoObserve = ObservationRecorder.ignore(forEach);\n\n\t\treturn function(cb, thisarg, observe) {\n\t\t\treturn observe === false ? noObserve(this, cb, thisarg) : forEach(this, cb, thisarg);\n\t\t};\n\n\t})(),\n\t\"*\": {\n\t\ttype: define.types.observable\n\t}\n});\n\nvar defineMapProto = {\n\t// -type-\n\t\"can.isMapLike\": true,\n\t\"can.isListLike\":  false,\n\t\"can.isValueLike\": false,\n\n\t// -get/set-\n\t\"can.getKeyValue\": getKeyValue,\n\t\"can.setKeyValue\": setKeyValue,\n\t\"can.deleteKeyValue\": defineHelpers.deleteKey,\n\n\t// -shape\n\t\"can.getOwnKeys\": function() {\n\t\tvar keys = canReflect.getOwnEnumerableKeys(this);\n\t\tif(this._computed) {\n\t\t\tvar computedKeys = canReflect.getOwnKeys(this._computed);\n\n\t\t\tvar key;\n\t\t\tfor (var i=0; i<computedKeys.length; i++) {\n\t\t\t\tkey = computedKeys[i];\n\t\t\t\tif (keys.indexOf(key) < 0) {\n\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t},\n\t\"can.getOwnEnumerableKeys\": function(){\n\t\tObservationRecorder.add(this, 'can.keys');\n\t\tObservationRecorder.add(Object.getPrototypeOf(this), 'can.keys');\n\t\treturn keysForDefinition(this._define.definitions).concat(keysForDefinition(this._instanceDefinitions) );\n\t},\n\t\"can.hasOwnKey\": function(key) {\n\t\treturn Object.hasOwnProperty.call(this._define.definitions, key) ||\n\t\t\t( this._instanceDefinitions !== undefined && Object.hasOwnProperty.call(this._instanceDefinitions, key) );\n\t},\n\t\"can.hasKey\": function(key) {\n\t\treturn (key in this._define.definitions) || (this._instanceDefinitions !== undefined && key in this._instanceDefinitions);\n\t},\n\n\t// -shape get/set-\n\t\"can.assignDeep\": assignDeep,\n\t\"can.updateDeep\": updateDeep,\n\t\"can.unwrap\": defineHelpers.reflectUnwrap,\n\t\"can.serialize\": defineHelpers.reflectSerialize,\n\n\t// observable\n\t\"can.keyHasDependencies\": function(key) {\n\t\treturn !!(this._computed && this._computed[key] && this._computed[key].compute);\n\t},\n\t\"can.getKeyDependencies\": function(key) {\n\t\tvar ret;\n\t\tif(this._computed && this._computed[key] && this._computed[key].compute) {\n\t\t\tret = {};\n\t\t\tret.valueDependencies = new Set();\n\t\t\tret.valueDependencies.add(this._computed[key].compute);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n//!steal-remove-start\nif(true) {\n\tdefineMapProto[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"{}\";\n\t};\n}\n//!steal-remove-end\n\ncanReflect.assignSymbols(DefineMap.prototype, defineMapProto);\n\ncanReflect.setKeyValue(DefineMap.prototype, canSymbol.iterator, function() {\n\treturn new define.Iterator(this);\n});\n\n// Add necessary event methods to this object.\nfor(var prop in define.eventsProto) {\n\tDefineMap[prop] = define.eventsProto[prop];\n\tObject.defineProperty(DefineMap.prototype, prop, {\n\t\tenumerable:false,\n\t\tvalue: define.eventsProto[prop],\n\t\twritable: true\n\t});\n}\nfunction getSymbolsForIE(obj){\n\treturn Object.getOwnPropertyNames(obj).filter(function(name){\n\t\treturn name.indexOf(\"@@symbol\") === 0;\n\t});\n}\n// Copy symbols over, but they aren't supported in IE\nvar eventsProtoSymbols = (\"getOwnPropertySymbols\" in Object) ?\n  Object.getOwnPropertySymbols(define.eventsProto) :\n  getSymbolsForIE(define.eventsProto);\n\neventsProtoSymbols.forEach(function(sym) {\n  Object.defineProperty(DefineMap.prototype, sym, {\n  \tconfigurable: true,\n    enumerable:false,\n    value: define.eventsProto[sym],\n    writable: true\n  });\n});\n\n\n//!steal-remove-start\nif(true) {\n\t// call `map.log()` to log all event changes\n\t// pass `key` to only log the matching property, e.g: `map.log(\"foo\")`\n\tdefine.defineConfigurableAndNotEnumerable(DefineMap.prototype, \"log\", defineHelpers.log);\n}\n//!steal-remove-end\n\n// tells `can-define` to use this\ndefine.DefineMap = DefineMap;\n\nObject.defineProperty(DefineMap.prototype, \"toObject\", {\n\tenumerable: false,\n\twritable: true,\n\tvalue: function(){\n\t\tcanLog.warn(\"Use DefineMap::get instead of DefineMap::toObject\");\n\t\treturn this.get();\n\t}\n});\n\nmodule.exports = ns.DefineMap = DefineMap;\n\n\n//# sourceURL=webpack:///./node_modules/can-define/map/map.js?");

/***/ }),

/***/ "./node_modules/can-deparam/can-deparam.js":
/*!*************************************************!*\
  !*** ./node_modules/can-deparam/can-deparam.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\n/**\n * @module {function} can-deparam can-deparam\n * @parent can-routing\n * @collection can-infrastructure\n * @package ./package.json\n * @description Deserialize a query string into an array or object.\n * @signature `deparam(params)`\n *\n * @param {String} params A form-urlencoded string of key-value pairs.\n * @param {function} [valueDeserializer] A function that decodes the string values. For example, using\n * [can-string-to-any] will convert `\"null\"` to `null` like:\n *\n *   ```js\n *   import stringToAny from \"can-string-to-any\";\n *   deparam(\"value=null\", stringToAny) //-> {value: null}\n *   ```\n * @return {Object} The params formatted into an object\n *\n * Takes a string of name value pairs and returns a Object literal that represents those params.\n *\n * ```js\n * var deparam = require(\"can-deparam\");\n *\n * console.log(JSON.stringify(deparam(\"?foo=bar&number=1234\"))); // -> '{\"foo\" : \"bar\", \"number\": 1234}'\n * console.log(JSON.stringify(deparam(\"#foo[]=bar&foo[]=baz\"))); // -> '{\"foo\" : [\"bar\", \"baz\"]}'\n * console.log(JSON.stringify(deparam(\"foo=bar%20%26%20baz\"))); // -> '{\"foo\" : \"bar & baz\"}'\n * ```\n * @body\n *\n * ## Try it\n *\n * Use this JS Bin to play around with this package:\n *\n * <a class=\"jsbin-embed\" href=\"https://jsbin.com/mobimok/3/embed?js,console\">can-deparam on jsbin.com</a>\n * <script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n */\nvar digitTest = /^\\d+$/,\n\tkeyBreaker = /([^\\[\\]]+)|(\\[\\])/g,\n\tparamTest = /([^?#]*)(#.*)?$/,\n\tentityRegex = /%([^0-9a-f][0-9a-f]|[0-9a-f][^0-9a-f]|[^0-9a-f][^0-9a-f])/i,\n\tstartChars = {\"#\": true,\"?\": true},\n\tprep = function (str) {\n\t\tif (startChars[str.charAt(0)] === true) {\n\t\t\tstr = str.substr(1);\n\t\t}\n\t\tstr = str.replace(/\\+/g, ' ');\n\n\t\ttry {\n\t\t\treturn decodeURIComponent(str);\n\t\t}\n\t\tcatch (e) {\n\t\t\treturn decodeURIComponent(str.replace(entityRegex, function(match, hex) {\n\t\t\t\treturn '%25' + hex;\n\t\t\t}));\n\t\t}\n\t};\n\nfunction isArrayLikeName(name) {\n\treturn digitTest.test(name) || name === '[]';\n}\n\n\nfunction idenity(value){ return value; }\n\nmodule.exports = namespace.deparam = function (params, valueDeserializer) {\n\tvalueDeserializer = valueDeserializer || idenity;\n\tvar data = {}, pairs, lastPart;\n\tif (params && paramTest.test(params)) {\n\t\tpairs = params.split('&');\n\t\tpairs.forEach(function (pair) {\n\t\t\tvar parts = pair.split('='),\n\t\t\t\tkey = prep(parts.shift()),\n\t\t\t\tvalue = prep(parts.join('=')),\n\t\t\t\tcurrent = data;\n\t\t\tif (key) {\n\t\t\t\tparts = key.match(keyBreaker);\n\t\t\t\tfor (var j = 0, l = parts.length - 1; j < l; j++) {\n\t\t\t\t\tvar currentName = parts[j],\n\t\t\t\t\t\tnextName = parts[j + 1],\n\t\t\t\t\t\tcurrentIsArray = isArrayLikeName(currentName) && current instanceof Array;\n\t\t\t\t\tif (!current[currentName]) {\n\t\t\t\t\t\tif(currentIsArray) {\n\t\t\t\t\t\t\tcurrent.push( isArrayLikeName(nextName) ? [] : {} );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If what we are pointing to looks like an `array`\n\t\t\t\t\t\t\tcurrent[currentName] = isArrayLikeName(nextName) ? [] : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif(currentIsArray) {\n\t\t\t\t\t\tcurrent = current[current.length - 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent = current[currentName];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tlastPart = parts.pop();\n\t\t\t\tif ( isArrayLikeName(lastPart) ) {\n\t\t\t\t\tcurrent.push(valueDeserializer(value));\n\t\t\t\t} else {\n\t\t\t\t\tcurrent[lastPart] = valueDeserializer(value);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\treturn data;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-deparam/can-deparam.js?");

/***/ }),

/***/ "./node_modules/can-diff/assign-deep-except-identity/assign-deep-except-identity.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/can-diff/assign-deep-except-identity/assign-deep-except-identity.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nmodule.exports = function assignExceptIdentity(obj, data, schema) {\n    if(!schema) {\n        schema = canReflect.getSchema(obj);\n    }\n    if(!schema) {\n        throw new Error(\"can-diff/update-except-id is unable to update without a schema.\");\n    }\n    // copy the keys onto data\n    schema.identity.forEach(function(key){\n        var id = canReflect.getKeyValue(obj, key);\n        if(id!== undefined) {\n            canReflect.setKeyValue(data, key, id );\n        }\n    });\n\n    canReflect.assignDeep(obj, data);\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-diff/assign-deep-except-identity/assign-deep-except-identity.js?");

/***/ }),

/***/ "./node_modules/can-diff/can-diff.js":
/*!*******************************************!*\
  !*** ./node_modules/can-diff/can-diff.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar deep = __webpack_require__(/*! ./deep/deep */ \"./node_modules/can-diff/deep/deep.js\"),\n    list = __webpack_require__(/*! ./list/list */ \"./node_modules/can-diff/list/list.js\"),\n    map = __webpack_require__(/*! ./map/map */ \"./node_modules/can-diff/map/map.js\"),\n    mergeDeep = __webpack_require__(/*! ./merge-deep/merge-deep */ \"./node_modules/can-diff/merge-deep/merge-deep.js\"),\n    Patcher = __webpack_require__(/*! ./patcher/patcher */ \"./node_modules/can-diff/patcher/patcher.js\"),\n    namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar diff = {\n    deep: deep,\n    list: list,\n    map: map,\n    mergeDeep: mergeDeep,\n    Patcher: Patcher\n};\n\nmodule.exports = namespace.diff = diff;\n\n\n//# sourceURL=webpack:///./node_modules/can-diff/can-diff.js?");

/***/ }),

/***/ "./node_modules/can-diff/deep/deep.js":
/*!********************************************!*\
  !*** ./node_modules/can-diff/deep/deep.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar diffMap = __webpack_require__(/*! ../map/map */ \"./node_modules/can-diff/map/map.js\"),\n    diffList = __webpack_require__(/*! ../list/list */ \"./node_modules/can-diff/list/list.js\"),\n    canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nfunction shouldCheckSet(patch, destVal, sourceVal) {\n    return patch.type === \"set\" && destVal && sourceVal &&\n        typeof destVal === \"object\" &&\n        typeof sourceVal === \"object\";\n}\n\nfunction makeIdentityFromMapSchema(typeSchema) {\n    if(typeSchema.identity && typeSchema.identity.length) {\n        return function identityCheck(a, b) {\n            var aId = canReflect.getIdentity(a, typeSchema),\n                bId = canReflect.getIdentity(b, typeSchema);\n            return aId === bId;\n        };\n    }\n}\n\nfunction makeDiffListIdentityComparison(oldList, newList, parentKey, nestedPatches) {\n    var listSchema = canReflect.getSchema(oldList),\n        typeSchema,\n        identityCheckFromSchema,\n        oldListLength = canReflect.size( oldList );\n    if(listSchema != null) {\n        if(listSchema.values != null) {\n            typeSchema = canReflect.getSchema(listSchema.values);\n        }\n    }\n    if(typeSchema == null && oldListLength > 0) {\n        typeSchema = canReflect.getSchema( canReflect.getKeyValue(oldList, 0) );\n    }\n    if(typeSchema) {\n        identityCheckFromSchema = makeIdentityFromMapSchema(typeSchema);\n    }\n\n\n    return function(a, b, aIndex) {\n        if(canReflect.isPrimitive(a)) {\n            return a === b;\n        }\n        if(canReflect.isPrimitive(b)) {\n            return a === b;\n        }\n        if(identityCheckFromSchema) {\n            if(identityCheckFromSchema(a, b)) {\n                var patches = diffDeep(a, b, parentKey ? parentKey+\".\"+aIndex : \"\"+aIndex);\n                nestedPatches.push.apply(nestedPatches, patches);\n                return true;\n            }\n        }\n        return diffDeep(a, b).length === 0;\n    };\n}\n\nfunction diffDeep(dest, source, parentKey){\n\n    if (dest && canReflect.isMoreListLikeThanMapLike(dest)) {\n        var nestedPatches = [],\n            diffingIdentity = makeDiffListIdentityComparison(dest, source, parentKey, nestedPatches);\n\n        var primaryPatches = diffList(dest, source, diffingIdentity).map(function(patch){\n            if(parentKey) {\n                patch.key = parentKey;\n            }\n            return patch;\n        });\n\n\t\treturn nestedPatches.concat(primaryPatches);\n\t} else {\n        parentKey = parentKey ? parentKey+\".\": \"\";\n\t\tvar patches = diffMap(dest, source);\n        // any sets we are going to recurse within\n        var finalPatches = [];\n        patches.forEach(function(patch){\n            var key = patch.key;\n\n            patch.key = parentKey + patch.key;\n            var destVal = dest && canReflect.getKeyValue(dest, key),\n                sourceVal = source && canReflect.getKeyValue(source, key);\n            if(shouldCheckSet(patch, destVal, sourceVal)) {\n\n                var deepPatches = diffDeep(destVal, sourceVal, patch.key);\n                finalPatches.push.apply(finalPatches, deepPatches);\n            } else {\n                finalPatches.push(patch);\n            }\n        });\n        return finalPatches;\n\t}\n}\n\nmodule.exports = diffDeep;\n\n\n//# sourceURL=webpack:///./node_modules/can-diff/deep/deep.js?");

/***/ }),

/***/ "./node_modules/can-diff/index-by-identity/index-by-identity.js":
/*!**********************************************************************!*\
  !*** ./node_modules/can-diff/index-by-identity/index-by-identity.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nmodule.exports = function(items, item, schema){\n    var length = canReflect.size(items);\n    if(!schema && length > 0) {\n        schema = canReflect.getSchema( items[0] );\n    }\n    if(!schema) {\n        schema = canReflect.getSchema( item );\n    }\n    if(!schema) {\n        throw new Error(\"No schema to use to get identity.\");\n    }\n\n\tvar id = canReflect.getIdentity(item, schema);\n\n\tfor(var i = 0; i < length; i++) {\n\t\tvar connId = canReflect.getIdentity(items[i], schema);\n        // this was ==\n\t\tif( id === connId) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-diff/index-by-identity/index-by-identity.js?");

/***/ }),

/***/ "./node_modules/can-diff/list/list.js":
/*!********************************************!*\
  !*** ./node_modules/can-diff/list/list.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar slice = [].slice;\n// a b c\n// a b c d\n// [[2,0, d]]\n\n\nfunction defaultIdentity(a, b){\n    return a === b;\n}\n\nfunction makeIdentityFromMapSchema(typeSchema) {\n    if(typeSchema.identity && typeSchema.identity.length) {\n        return function identityCheck(a, b) {\n            var aId = canReflect.getIdentity(a, typeSchema),\n                bId = canReflect.getIdentity(b, typeSchema);\n            return aId === bId;\n        };\n    } else {\n        return defaultIdentity;\n    }\n}\n\nfunction makeIdentityFromListSchema(listSchema) {\n    return listSchema.values != null ?\n        makeIdentityFromMapSchema( canReflect.getSchema(listSchema.values) ) :\n        defaultIdentity;\n}\n\nfunction makeIdentity(oldList, oldListLength) {\n    var listSchema = canReflect.getSchema(oldList),\n        typeSchema;\n    if(listSchema != null) {\n        if(listSchema.values != null) {\n            typeSchema = canReflect.getSchema(listSchema.values);\n        } else {\n            return defaultIdentity;\n        }\n    }\n    if(typeSchema == null && oldListLength > 0) {\n        typeSchema = canReflect.getSchema( canReflect.getKeyValue(oldList, 0) );\n    }\n    if(typeSchema) {\n        return makeIdentityFromMapSchema(typeSchema);\n    } else {\n        return defaultIdentity;\n    }\n}\n\n\n\nfunction reverseDiff(oldDiffStopIndex, newDiffStopIndex, oldList, newList, identity) {\n\tvar oldIndex = oldList.length - 1,\n\t\tnewIndex =  newList.length - 1;\n\n\twhile( oldIndex > oldDiffStopIndex && newIndex > newDiffStopIndex) {\n\t\tvar oldItem = oldList[oldIndex],\n\t\t\tnewItem = newList[newIndex];\n\n\t\tif( identity( oldItem, newItem, oldIndex ) ) {\n\t\t\toldIndex--;\n\t\t\tnewIndex--;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t// use newIndex because it reflects any deletions\n\t\t\treturn [{\n                type: \"splice\",\n\t\t\t\tindex: newDiffStopIndex,\n\t\t\t \tdeleteCount: (oldIndex-oldDiffStopIndex+1),\n\t\t\t \tinsert: slice.call(newList, newDiffStopIndex,newIndex+1)\n\t\t\t}];\n\t\t}\n\t}\n\t// if we've reached of either the new or old list\n\t// we simply return\n\treturn [{\n        type: \"splice\",\n\t\tindex: newDiffStopIndex,\n\t\tdeleteCount: (oldIndex-oldDiffStopIndex+1),\n\t\tinsert: slice.call(newList, newDiffStopIndex,newIndex+1)\n\t}];\n\n}\n\n/**\n * @module {function} can-diff/list/list\n * @parent can-diff\n *\n * @description Return a difference of two lists.\n *\n * @signature `diffList( oldList, newList, [identity] )`\n *\n * Compares two lists and produces a sequence of patches that can be applied to make `oldList` take\n * the shape of `newList`.\n *\n * ```js\n * var diffList = require(\"can-diff/list/list\");\n *\n * console.log(diff([1], [1, 2])); // -> [{type: \"splice\", index: 1, deleteCount: 0, insert: [2]}]\n * console.log(diff([1, 2], [1])); // -> [{type: \"splice\", index: 1, deleteCount: 1, insert: []}]\n *\n * // with an optional identity function:\n * diffList(\n *     [{id:1},{id:2}],\n *     [{id:1},{id:3}],\n *     (a,b) => a.id === b.id\n * ); // -> [{type: \"splice\", index: 1, deleteCount: 1, insert: [{id:3}]}]\n * ```\n *\n * The patch algorithm is linear with respect to the length of the lists and therefore does not produce a\n * [perfect edit distance](https://en.wikipedia.org/wiki/Edit_distance) (which would be at least quadratic).\n *\n * It is designed to work with most common list change scenarios, when items are inserted or removed\n * to a list (as opposed to moved with in the last).\n *\n * For example, it is able to produce the following patches:\n *\n * ```js\n * diffList(\n *     [\"a\",\"b\",\"c\",\"d\"],\n *     [\"a\",\"b\",\"X\",\"Y\",\"c\",\"d\"]\n * ); // -> [{type: \"splice\", index: 2, deleteCount: 0, insert: [\"X\",\"Y\"]}]\n * ```\n *\n * @param  {ArrayLike} oldList The source array or list to diff from.\n * @param  {ArrayLike} newList The array or list to diff to.\n * @param  {function|can-reflect.getSchema} schemaOrIdentity An optional identity function or a schema with\n * an identity property for comparing elements.  If a `schemaOrIdentity` is not provided, the schema of\n * the `oldList` will be used.  If a schema can not be found, items a default identity function will be created\n * that checks if the two values are strictly equal `===`.\n * @return {Array} An array of [can-symbol/types/Patch] objects representing the differences\n *\n * Returns the difference between two ArrayLike objects (that have nonnegative\n * integer keys and the `length` property) as an array of patch objects.\n *\n * A patch object returned by this function has the following properties:\n * - **type**: the type of patch (`\"splice\"`).\n * - **index**:  the index of newList where the patch begins\n * - **deleteCount**: the number of items deleted from that index in newList\n * - **insert**: an Array of items newly inserted at that index in newList\n *\n * Patches should be applied in the order they are returned.\n */\n\nmodule.exports = function(oldList, newList, schemaOrIdentity){\n    var oldIndex = 0,\n\t\tnewIndex =  0,\n\t\toldLength = canReflect.size( oldList ),\n\t\tnewLength = canReflect.size( newList ),\n\t\tpatches = [];\n\n    var schemaType = typeof schemaOrIdentity,\n        identity;\n    if(schemaType === \"function\") {\n        identity = schemaOrIdentity;\n    } else if(schemaOrIdentity != null) {\n        if(schemaOrIdentity.type === \"map\") {\n            identity = makeIdentityFromMapSchema(schemaOrIdentity);\n        } else {\n            identity = makeIdentityFromListSchema(schemaOrIdentity);\n        }\n    } else {\n        identity = makeIdentity(oldList, oldLength);\n    }\n\n\n\n\twhile(oldIndex < oldLength && newIndex < newLength) {\n\t\tvar oldItem = oldList[oldIndex],\n\t\t\tnewItem = newList[newIndex];\n\n\t\tif( identity( oldItem, newItem, oldIndex ) ) {\n\t\t\toldIndex++;\n\t\t\tnewIndex++;\n\t\t\tcontinue;\n\t\t}\n\t\t// look for single insert, does the next newList item equal the current oldList.\n\t\t// 1 2 3\n\t\t// 1 2 4 3\n\t\tif(  newIndex+1 < newLength && identity( oldItem, newList[newIndex+1], oldIndex ) ) {\n\t\t\tpatches.push({index: newIndex, deleteCount: 0, insert: [ newList[newIndex] ], type: \"splice\"});\n\t\t\toldIndex++;\n\t\t\tnewIndex += 2;\n\t\t\tcontinue;\n\t\t}\n\t\t// look for single removal, does the next item in the oldList equal the current newList item.\n\t\t// 1 2 3\n\t\t// 1 3\n\t\telse if( oldIndex+1 < oldLength  && identity( oldList[oldIndex+1], newItem, oldIndex+1 ) ) {\n\t\t\tpatches.push({index: newIndex, deleteCount: 1, insert: [], type: \"splice\"});\n\t\t\toldIndex += 2;\n\t\t\tnewIndex++;\n\t\t\tcontinue;\n\t\t}\n\t\t// just clean up the rest and exit\n\t\t// 1 2 3\n\t\t// 1 2 5 6 7\n\t\telse {\n\t\t\t// iterate backwards to `newIndex`\n\t\t\t// \"a\", \"b\", \"c\", \"d\", \"e\"\n\t\t\t// \"a\", \"x\", \"y\", \"z\", \"e\"\n\t\t\t// -> {}\n\t\t\tpatches.push.apply(patches, reverseDiff(oldIndex, newIndex , oldList, newList, identity) );\n\n\n\t\t\treturn patches;\n\t\t}\n\t}\n\tif( (newIndex === newLength) && (oldIndex === oldLength) ) {\n\t\treturn patches;\n\t}\n\t// a b\n\t// a b c d e\n\tpatches.push(\n\t\t\t\t{type: \"splice\", index: newIndex,\n\t\t\t\t deleteCount: oldLength-oldIndex,\n\t\t\t\t insert: slice.call(newList, newIndex) } );\n\n\treturn patches;\n};\n\n\n\n\n// a b c\n// a d e b c\n\n\n//# sourceURL=webpack:///./node_modules/can-diff/list/list.js?");

/***/ }),

/***/ "./node_modules/can-diff/map/map.js":
/*!******************************************!*\
  !*** ./node_modules/can-diff/map/map.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nfunction defaultIdentity(a, b){\n\treturn a === b;\n}\n\n\n/**\n * @module {function} can-diff/map/map\n * @parent can-diff\n *\n * @description Return a difference of two maps or objects.\n *\n * @signature `diffMap(oldObject, newObject)`\n *\n * Find the differences between two objects, based on properties and values.\n *\n * ```js\n * var diffObject = require(\"can-diff/map/map\");\n *\n * diffMap({a: 1, b: 2}, {b: 3, c: 4})) // ->\n *   [{key: \"a\", type: \"remove\"},\n *    {key: \"b\", type: \"set\": value: 3},\n *    {key: \"c\", type: \"add\", \"value\": 4}]\n * ```\n *\n * @param {Object} oldObject The object to diff from.\n * @param {Object} newObject The object to diff to.\n * @return {Array} An array of object-[can-symbol/types/Patch patch] objects\n *\n * The object-patch object format has the following keys:\n * - **type**:  the type of operation on this property: add, remove, or set\n * - **key**:   the mutated property on the new object\n * - **value**: the new value (if type is \"add\" or \"set\")\n *\n */\nmodule.exports = function(oldObject, newObject){\n\tvar oldObjectClone,\n\t\tpatches = [];\n\n\t// clone oldObject so properties can be deleted\n\toldObjectClone = canReflect.assignMap({}, oldObject);\n\n    canReflect.eachKey(newObject, function(value, newProp){\n        // look for added properties\n        if (!oldObject || !oldObject.hasOwnProperty(newProp)) {\n            patches.push({\n                key: newProp,\n                type: 'add',\n                value: value\n            });\n        // look for changed properties\n        } else if (newObject[newProp] !== oldObject[newProp]) {\n            patches.push({\n                key: newProp,\n                type: 'set',\n                value: value\n            });\n        }\n\n        // delete properties found in newObject\n        // so we can find removed properties\n        delete oldObjectClone[newProp];\n    });\n\n\t// loop over removed properties\n\tfor (var oldProp in oldObjectClone) {\n\t\tpatches.push({\n\t\t\tkey: oldProp,\n\t\t\ttype: 'delete'\n\t\t});\n\t}\n\n\treturn patches;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-diff/map/map.js?");

/***/ }),

/***/ "./node_modules/can-diff/merge-deep/merge-deep.js":
/*!********************************************************!*\
  !*** ./node_modules/can-diff/merge-deep/merge-deep.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar diffList = __webpack_require__(/*! ../list/list */ \"./node_modules/can-diff/list/list.js\");\n\nfunction smartMerge(instance, props) {\n\n\tprops = canReflect.serialize(props);\n\n\tif (canReflect.isMoreListLikeThanMapLike(instance)) {\n\t\tmergeList(instance, props);\n\t} else {\n\t\tmergeMap(instance, props);\n\t}\n\treturn instance;\n}\n\n// date is expected to be mutable here\nfunction mergeMap(instance, data) {\n\n\t// for each key in\n\tcanReflect.eachKey(instance, function(value, prop) {\n\t\tif(!canReflect.hasKey(data, prop)) {\n\t\t\tcanReflect.deleteKeyValue(instance, prop);\n\t\t\treturn;\n\t\t}\n\t\tvar newValue = canReflect.getKeyValue(data, prop);\n\t\tcanReflect.deleteKeyValue(data, prop);\n\n\t\t// cases:\n\t\t// a. list\n\t\t// b. map\n\t\t// c. primitive\n\n\t\t// if the data is typed, we would just replace it\n\t\tif (canReflect.isPrimitive(value)) {\n\t\t\tcanReflect.setKeyValue(instance, prop, newValue);\n\t\t\treturn;\n\t\t}\n\n\n\t\tvar newValueIsList = Array.isArray(newValue),\n\t\t\tcurrentValueIsList = canReflect.isMoreListLikeThanMapLike(value);\n\n\t\tif (currentValueIsList && newValueIsList) {\n\n\t\t\tmergeList(value, newValue);\n\n\t\t} else if (!newValueIsList && !currentValueIsList && canReflect.isMapLike(value) && canReflect.isPlainObject(newValue)) {\n\n\t\t\t// TODO: the `TYPE` should probably be infered from the `_define` property definition.\n\t\t\tvar schema = canReflect.getSchema(value);\n\t\t\tif (schema && schema.identity && schema.identity.length) {\n\t\t\t\tvar id = canReflect.getIdentity(value, schema);\n\t\t\t\tif (id != null && id === canReflect.getIdentity(newValue, schema)) {\n\t\t\t\t\tmergeMap(value, newValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcanReflect.setKeyValue(instance, prop, canReflect.new(value.constructor, newValue));\n\t\t} else {\n\t\t\tcanReflect.setKeyValue(instance, prop, newValue);\n\t\t}\n\t});\n\tcanReflect.eachKey(data, function(value, prop) {\n\t\tcanReflect.setKeyValue(instance, prop, value);\n\t});\n}\n\nfunction mergeList(list, data) {\n\tvar ItemType, itemSchema;\n\tvar listSchema = canReflect.getSchema(list);\n\tif (listSchema) {\n\t\tItemType = listSchema.values;\n\t}\n\n\tif (ItemType) {\n\t\titemSchema = canReflect.getSchema(ItemType);\n\t}\n\tif (!itemSchema && canReflect.size(list) > 0) {\n\t\titemSchema = canReflect.getSchema(canReflect.getKeyValue(list, 0));\n\t}\n\n\tvar identity;\n\tif(itemSchema && itemSchema.identity && itemSchema.identity.length) {\n\t\tidentity = function(a, b) {\n\t\t   var aId = canReflect.getIdentity(a, itemSchema),\n\t\t\t   bId = canReflect.getIdentity(b, itemSchema);\n\t\t   var eq = aId === bId;\n\t\t   if (eq) {\n\t\t\t   // If id is the same we merge data in. Case #2\n\t\t\t   mergeMap(a, b);\n\t\t   }\n\t\t   return eq;\n\t   };\n   } else {\n\t   identity = function(a, b) {\n\t\t  var eq = a === b;\n\t\t  if (eq) {\n\t\t\t  // If id is the same we merge data in. Case #2\n\t\t\t  if(! canReflect.isPrimitive(a) ) {\n\t\t\t\t   mergeMap(a, b);\n\t\t\t  }\n\n\t\t  }\n\t\t  return eq;\n\t  }\n   }\n\n\n\tvar patches = diffList(list, data, identity);\n\n\n\n\tvar hydrate = ItemType ? canReflect.new.bind(canReflect, ItemType) : function(v) {\n\t\treturn v;\n\t};\n\n\n\t// If there are no patches then data contains only updates for all of the existing items, and we just leave.\n\tif (!patches.length) {\n\t\treturn list;\n\t}\n\n\t// Apply patches (add new, remove) #3. For any insertion use a hydrator.\n\tpatches.forEach(function(patch) {\n\t\tapplyPatch(list, patch, hydrate);\n\t});\n}\n\nfunction applyPatch(list, patch, makeInstance) {\n\t// Splice signature compared to patch:\n\t//   array.splice(start, deleteCount, item1, item2, ...)\n\t//   patch = {index: 1, deleteCount: 0, insert: [1.5]}\n\tvar insert = makeInstance && patch.insert.map(function(val){\n\t\treturn makeInstance(val);\n\t}) || patch.insert;\n\n\tvar args = [patch.index, patch.deleteCount].concat(insert);\n\tlist.splice.apply(list, args);\n\n\treturn list;\n}\n\nsmartMerge.applyPatch = applyPatch;\n\nmodule.exports = smartMerge;\n\n\n//# sourceURL=webpack:///./node_modules/can-diff/merge-deep/merge-deep.js?");

/***/ }),

/***/ "./node_modules/can-diff/patch-sort/patch-sort.js":
/*!********************************************************!*\
  !*** ./node_modules/can-diff/patch-sort/patch-sort.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nmodule.exports = function(patches) {\n\t//!steal-remove-start\n\tif(true) {\n\t\tvar deletes =[],\n\t\t\tinserts = [],\n\t\t\tmoves = [];\n\t\tpatches.forEach(function(patch){\n\t\t\tif (patch.type === \"move\") {\n\t\t\t\tmoves.push(patch);\n\t\t\t} else {\n\t\t\t\tif (patch.deleteCount) {\n\t\t\t\t\tdeletes.push(patch)\n\t\t\t\t}\n\t\t\t\tif (patch.insert && patch.insert.length) {\n\t\t\t\t\tinserts.push(inserts);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tif(deletes.length + inserts.length > 2) {\n\t\t\tconsole.error(\"unable to group patches\",patches);\n\t\t\tthrow new Error(\"unable to group patches\");\n\t\t}\n\t\tif(moves.length &&(deletes.length || inserts.length)) {\n\t\t\tconsole.error(\"unable to sort a move with a delete or insert\");\n\t\t\tthrow new Error(\"unable to sort a move with a delete or insert\");\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\n\tvar splitPatches = [];\n\tpatches.forEach(function(patch){\n\t\tif (patch.type === \"move\") {\n\t\t\tsplitPatches.push( {patch: patch, kind: \"move\"} );\n\t\t} else {\n\t\t\tif (patch.deleteCount) {\n\t\t\t\tsplitPatches.push({\n\t\t\t\t\ttype: \"splice\",\n\t\t\t\t\tindex: patch.index,\n\t\t\t\t\tdeleteCount: patch.deleteCount,\n\t\t\t\t\tinsert: [],\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (patch.insert && patch.insert.length) {\n\t\t\t\tsplitPatches.push({\n\t\t\t\t\ttype: \"splice\",\n\t\t\t\t\tindex: patch.index,\n\t\t\t\t\tdeleteCount: 0,\n\t\t\t\t\tinsert: patch.insert\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\tif(patches.length !== 2) {\n\t\treturn patches;\n\t}\n\tvar first = splitPatches[0],\n\t\tsecond = splitPatches[1];\n\t// if insert before a delete\n\tif(first.insert && first.insert.length && second.deleteCount) {\n\t\t// lets swap the order.\n\t\tvar insert = first,\n\t\t\tremove = second;\n\t\tif(insert.index < remove.index) {\n\t\t\tremove.index = remove.index - insert.insert.length;\n\t\t} else if(insert.index > remove.index) {\n\t\t\tinsert.index = insert.index - remove.deleteCount;\n\t\t} else {\n\t\t\tthrow \"indexes the same!\"\n\t\t}\n\t\treturn [remove, insert];\n\t}\n\treturn patches;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-diff/patch-sort/patch-sort.js?");

/***/ }),

/***/ "./node_modules/can-diff/patcher/patcher.js":
/*!**************************************************!*\
  !*** ./node_modules/can-diff/patcher/patcher.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"./node_modules/can-key-tree/can-key-tree.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar diff = __webpack_require__(/*! ../list/list */ \"./node_modules/can-diff/list/list.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar onValueSymbol = canSymbol.for(\"can.onValue\"),\n\toffValueSymbol = canSymbol.for(\"can.offValue\");\nvar onPatchesSymbol = canSymbol.for(\"can.onPatches\");\nvar offPatchesSymbol = canSymbol.for(\"can.offPatches\");\n\n// Patcher takes a observable that might wrap a list type.\n// When the observable changes, it will diff, and emit patches,\n// and if the list emits patches, it will emit those too.\n// It is expected that only `domUI` handlers are registered.\n/*\nvar observable = new SimpleObservable( new DefineList([ \"a\", \"b\", \"c\" ]) )\nvar patcher = new Patcher(observable)\ncanReflect.onPatches( patcher,function(patches){\n  console.log(patches) // a patch removing c, then a\n})\nvar newList = new DefineList([\"a\",\"b\"]);\nobservable.set(newList);\nnewList.unshift(\"X\");\n[\n    {type: \"splice\", index: 2, deleteCount: 1}\n]\nvar patches2 = [\n    {type: \"splice\", index: 0, deleteCount: 0, inserted: [\"X\"]}\n]\n */\nvar Patcher = function(observableOrList, priority) {\n\t// stores listeners for this patcher\n\tthis.handlers = new KeyTree([Object, Array], {\n\t\t// call setup when the first handler is bound\n\t\tonFirst: this.setup.bind(this),\n\t\t// call teardown when the last handler is removed\n\t\tonEmpty: this.teardown.bind(this)\n\t});\n\n\t// save this value observable or patch emitter (list)\n\tthis.observableOrList = observableOrList;\n\t// if we were passed an observable value that we need to read its array for changes\n\tthis.isObservableValue = canReflect.isValueLike(this.observableOrList) || canReflect.isObservableLike(this.observableOrList);\n\tif(this.isObservableValue) {\n\t    this.priority = canReflect.getPriority(observableOrList);\n\t} else {\n\t    this.priority = priority || 0;\n\t}\n\tthis.onList = this.onList.bind(this);\n\tthis.onPatchesNotify = this.onPatchesNotify.bind(this);\n\t// needs to be unique so the derive queue doesn't only add one.\n\tthis.onPatchesDerive = this.onPatchesDerive.bind(this);\n\n\t// stores patches that have happened between notification and\n\t// when we queue the  `onPatches` handlers in the `domUI` queue\n\tthis.patches = [];\n\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tObject.defineProperty(this.onList, \"name\", {\n\t\t\tvalue: \"live.list new list::\"+canReflect.getName(observableOrList),\n\t\t});\n\t\tObject.defineProperty(this.onPatchesNotify, \"name\", {\n\t\t\tvalue: \"live.list notify::\"+canReflect.getName(observableOrList),\n\t\t});\n\t\tObject.defineProperty(this.onPatchesDerive, \"name\", {\n\t\t\tvalue: \"live.list derive::\"+canReflect.getName(observableOrList),\n\t\t});\n\t}\n\t//!steal-remove-end\n};\n\n\nPatcher.prototype = {\n\tconstructor: Patcher,\n\tsetup: function() {\n\t\tif (this.observableOrList[onValueSymbol]) {\n\t\t\t// if we have an observable value, listen to when it changes to get a\n\t\t\t// new list.\n\t\t\tcanReflect.onValue(this.observableOrList, this.onList, \"notify\");\n\t\t\t// listen on the current value (which shoudl be a list) if there is one\n\t\t\tthis.setupList(canReflect.getValue(this.observableOrList));\n\t\t} else {\n\t\t\tthis.setupList(this.observableOrList);\n\t\t}\n\t},\n\tteardown: function() {\n\t\tif (this.observableOrList[offValueSymbol]) {\n\t\t\tcanReflect.offValue(this.observableOrList, this.onList, \"notify\");\n\t\t}\n\t\tif (this.currentList && this.currentList[offPatchesSymbol]) {\n\t\t\tthis.currentList[offPatchesSymbol](this.onPatchesNotify, \"notify\");\n\t\t}\n\t},\n\t// listen to the list for patches\n\tsetupList: function(list) {\n\t\tthis.currentList = list;\n\t\tif (list && list[onPatchesSymbol]) {\n\t\t\t// If observable, set up bindings on list changes\n\t\t\tlist[onPatchesSymbol](this.onPatchesNotify, \"notify\");\n\t\t}\n\t},\n\t// when the list changes, teardown the old list bindings\n\t// and setup the new list\n\tonList: function onList(newList) {\n\t\tvar current = this.currentList || [];\n\t\tnewList = newList || [];\n\t\tif (current[offPatchesSymbol]) {\n\t\t\tcurrent[offPatchesSymbol](this.onPatchesNotify, \"notify\");\n\t\t}\n\t\tvar patches = diff(current, newList);\n\t\tthis.currentList = newList;\n\t\tthis.onPatchesNotify(patches);\n\t\tif (newList[onPatchesSymbol]) {\n\t\t\t// If observable, set up bindings on list changes\n\t\t\tnewList[onPatchesSymbol](this.onPatchesNotify, \"notify\");\n\t\t}\n\t},\n\t// This is when we get notified of patches on the underlying list.\n\t// Save the patches and queue up a `derive` task that will\n\t// call `domUI` updates.\n\tonPatchesNotify: function onPatchesNotify(patches) {\n\t\t// we are going to collect all patches\n\t\tthis.patches.push.apply(this.patches, patches);\n\t\t// TODO: share priority\n\t\tqueues.deriveQueue.enqueue(this.onPatchesDerive, this, [], {\n\t\t\tpriority: this.priority\n\t\t});\n\t},\n\t// Let handlers (which should only be registered in `domUI`) know about patches\n\t// that they can apply.\n\tonPatchesDerive: function onPatchesDerive() {\n\t\tvar patches = this.patches;\n\t\tthis.patches = [];\n\t\tqueues.enqueueByQueue(this.handlers.getNode([]), this.currentList, [patches, this.currentList], null,[\"Apply patches\", patches]);\n\t}\n};\n\ncanReflect.assignSymbols(Patcher.prototype, {\n\t\"can.onPatches\": function(handler, queue) {\n\t\tthis.handlers.add([queue || \"mutate\", handler]);\n\t},\n\t\"can.offPatches\": function(handler, queue) {\n\t\tthis.handlers.delete([queue || \"mutate\", handler]);\n\t}\n});\n\nmodule.exports = Patcher;\n\n\n//# sourceURL=webpack:///./node_modules/can-diff/patcher/patcher.js?");

/***/ }),

/***/ "./node_modules/can-diff/update-deep-except-identity/update-deep-except-identity.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/can-diff/update-deep-except-identity/update-deep-except-identity.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nmodule.exports = function updateExceptIdentity(obj, data, schema) {\n    if(!schema) {\n        schema = canReflect.getSchema(obj);\n    }\n    if(!schema) {\n        throw new Error(\"can-diff/update-except-id is unable to update without a schema.\");\n    }\n    // copy the keys onto data\n    schema.identity.forEach(function(key){\n        var id = canReflect.getKeyValue(obj, key);\n        if(id!== undefined) {\n            canReflect.setKeyValue(data, key, id );\n        }\n    });\n\n    canReflect.updateDeep(obj, data);\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-diff/update-deep-except-identity/update-deep-except-identity.js?");

/***/ }),

/***/ "./node_modules/can-dom-data/can-dom-data.js":
/*!***************************************************!*\
  !*** ./node_modules/can-dom-data/can-dom-data.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar isEmptyObject = function(obj){\n\t/* jshint -W098 */\n\tfor(var prop in obj) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\nvar data = new WeakMap();\n\n// delete this node's `data`\n// returns true if the node was deleted.\nvar deleteNode = function(node) {\n\tvar nodeDeleted = false;\n\tif (data.has(node)) {\n\t\tnodeDeleted = true;\n\t\tdata.delete(node);\n\t}\n\treturn nodeDeleted;\n};\n\nvar setData = function(node, name, value) {\n\tvar store = data.get(node);\n\tif (store === undefined) {\n\t\tstore = {};\n\t\tdata.set(node, store);\n\t}\n\tif (name !== undefined) {\n\t\tstore[name] = value;\n\t}\n\treturn store;\n};\n\n/*\n * Core of domData that does not depend on mutationDocument\n * This is separated in order to prevent circular dependencies\n */\nvar domData = {\n\t_data: data,\n\n\tget: function(node, key) {\n\t\tvar store = data.get(node);\n\t\treturn key === undefined ? store : store && store[key];\n\t},\n\n\tset: setData,\n\n\tclean: function(node, prop) {\n\t\tvar itemData = data.get(node);\n\t\tif (itemData && itemData[prop]) {\n\t\t\tdelete itemData[prop];\n\t\t}\n\t\tif (isEmptyObject(itemData)) {\n\t\t\tdeleteNode(node);\n\t\t}\n\t},\n\n\tdelete: deleteNode\n};\n\nif (namespace.domData) {\n\tthrow new Error(\"You can't have two versions of can-dom-data, check your dependencies\");\n} else {\n\tmodule.exports = namespace.domData = domData;\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-data/can-dom-data.js?");

/***/ }),

/***/ "./node_modules/can-dom-events/can-dom-events.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-dom-events/can-dom-events.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar util = __webpack_require__(/*! ./helpers/util */ \"./node_modules/can-dom-events/helpers/util.js\");\nvar makeEventRegistry = __webpack_require__(/*! ./helpers/make-event-registry */ \"./node_modules/can-dom-events/helpers/make-event-registry.js\");\nvar makeDelegateEventTree = __webpack_require__(/*! ./helpers/-make-delegate-event-tree */ \"./node_modules/can-dom-events/helpers/-make-delegate-event-tree.js\");\n\n\nvar domEvents = {\n\t_eventRegistry: makeEventRegistry(),\n\n\t/**\n\t* @function can-dom-events.addEvent addEvent\n\t* @parent can-dom-events.static\n\t*\n\t* Add a custom event to the global event registry.\n\t*\n\t* @signature `addEvent( event [, eventType ] )`\n\t*\n\t* ```js\n\t* var removeReturnEvent = domEvents.addEvent(enterEvent, \"return\");\n\t* ```\n\t*\n\t* @param {can-dom-events/EventDefinition} event The custom event definition.\n\t* @param {String} eventType The event type to associated with the custom event.\n\t* @return {function} The callback to remove the custom event from the registry.\n\t*/\n\taddEvent: function(event, eventType) {\n\t\treturn this._eventRegistry.add(event, eventType);\n\t},\n\n\t/**\n\t* @function can-dom-events.addEventListener addEventListener\n\t*\n\t* Add an event listener for eventType to the target.\n\t*\n\t* @signature `addEventListener( target, eventType, ...eventArgs )`\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} target The object to which to add the listener.\n\t* @param {String} eventType The event type with which to register.\n\t* @param {*} eventArgs The arguments which configure the associated event's behavior. This is usually a\n\t* function event handler.\n\t*/\n\taddEventListener: function(target, eventType) {\n\t\tvar hasCustomEvent = domEvents._eventRegistry.has(eventType);\n\t\tif (hasCustomEvent) {\n\t\t\tvar event = domEvents._eventRegistry.get(eventType);\n\t\t\treturn event.addEventListener.apply(domEvents, arguments);\n\t\t}\n\n\t\tvar eventArgs = Array.prototype.slice.call(arguments, 1);\n\t\treturn target.addEventListener.apply(target, eventArgs);\n\t},\n\n\t/**\n\t* @function can-dom-events.removeEventListener removeEventListener\n\t*\n\t* Remove an event listener for eventType from the target.\n\t*\n\t* @signature `removeEventListener( target, eventType, ...eventArgs )`\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} target The object from which to remove the listener.\n\t* @param {String} eventType The event type with which to unregister.\n\t* @param {*} eventArgs The arguments which configure the associated event's behavior. This is usually a\n\t* function event handler.\n\t*/\n\tremoveEventListener: function(target, eventType) {\n\t\tvar hasCustomEvent = domEvents._eventRegistry.has(eventType);\n\t\tif (hasCustomEvent) {\n\t\t\tvar event = domEvents._eventRegistry.get(eventType);\n\t\t\treturn event.removeEventListener.apply(domEvents, arguments);\n\t\t}\n\n\t\tvar eventArgs = Array.prototype.slice.call(arguments, 1);\n\t\treturn target.removeEventListener.apply(target, eventArgs);\n\t},\n\n\t/**\n\t* @function can-dom-events.addDelegateListener addDelegateListener\n\t*\n\t* Attach a handler for an event for all elements that match the selector,\n\t* now or in the future, based on a root element.\n\t*\n\t* @signature `addDelegateListener( target, eventType, selector, handler )`\n\t*\n\t* ```js\n\t* // Prevents all anchor elements from changing the page\n\t* domEvents.addDelegateListener(document.body,\"click\", \"a\", function(event){\n\t*   event.preventDefault();\n\t* })\n\t* ```\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} root The html element to listen to events that match selector within.\n\t* @param {String} eventType The event name to listen to.\n\t* @param {String} selector A selector to filter the elements that trigger the event.\n\t* @param {function} handler A function to execute at the time the event is triggered.\n\t*/\n\taddDelegateListener: function(root, eventType, selector, handler) {\n\t\tdomEvents._eventTree.add([root, eventType, selector, handler]);\n\t},\n\t/**\n\t* @function can-dom-events.removeDelegateListener removeDelegateListener\n\t*\n\t* Remove a handler for an event for all elements that match the selector.\n\t*\n\t* @signature `removeDelegateListener( target, eventType, selector, handler )`\n\t*\n\t* ```js\n\t* // Prevents all anchor elements from changing the page\n\t* function handler(event) {\n\t*   event.preventDefault();\n\t* }\n\t* domEvents.addDelegateListener(document.body,\"click\", \"a\", handler);\n\t*\n\t* domEvents.removeDelegateListener(document.body,\"click\", \"a\", handler);\n\t* ```\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} root The html element to listen to events that match selector within.\n\t* @param {String} eventType The event name to listen to.\n\t* @param {String} selector A selector to filter the elements that trigger the event.\n\t* @param {function} handler A function that was previously passed to `addDelegateListener`.\n\t*/\n\tremoveDelegateListener: function(target, eventType, selector, handler) {\n\t\tdomEvents._eventTree.delete([target, eventType, selector, handler]);\n\t},\n\n\t/**\n\t* @function can-dom-events.dispatch dispatch\n\t*\n\t* Create and dispatch a configured event on the target.\n\t*\n\t* @signature `dispatch( target, eventData [, bubbles ][, cancelable ] )`\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} target The object on which to dispatch the event.\n\t* @param {Object | String} eventData The data to be assigned to the event. If it is a string, that will be the event type.\n\t* @param {Boolean} bubbles Whether the event should bubble; defaults to true.\n\t* @param {Boolean} cancelable Whether the event can be cancelled; defaults to false.\n\t* @return {Boolean} notCancelled Whether the event dispatched without being cancelled.\n\t*/\n\tdispatch: function(target, eventData, bubbles, cancelable) {\n\t\tvar event = util.createEvent(target, eventData, bubbles, cancelable);\n\t\tvar enableForDispatch = util.forceEnabledForDispatch(target, event);\n\t\tif(enableForDispatch) {\n\t\t\ttarget.disabled = false;\n\t\t}\n\n\t\tvar ret = target.dispatchEvent(event);\n\t\tif(enableForDispatch) {\n\t\t\ttarget.disabled = true;\n\t\t}\n\n\t\treturn ret;\n\t}\n};\n\ndomEvents._eventTree = makeDelegateEventTree(domEvents);\n\n\n\n\n\nmodule.exports = namespace.domEvents = domEvents;\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-events/can-dom-events.js?");

/***/ }),

/***/ "./node_modules/can-dom-events/helpers/-make-delegate-event-tree.js":
/*!**************************************************************************!*\
  !*** ./node_modules/can-dom-events/helpers/-make-delegate-event-tree.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"./node_modules/can-key-tree/can-key-tree.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\n// Some events do not bubble, so delegating them requires registering the handler in the\n// capturing phase.\n// http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\nvar useCapture = function(eventType) {\n\treturn eventType === 'focus' || eventType === 'blur';\n};\n\nfunction makeDelegator (domEvents) {\n\tvar Delegator = function Delegator (parentKey){\n\t\tthis.element = parentKey; // HTMLElement\n\t\tthis.events = {}; // {[eventType: string]: Array<(event) -> void>}\n\t\tthis.delegated = {}; // {[eventType: string]: (event) -> void}\n\t};\n\n\tcanReflect.assignSymbols( Delegator.prototype, {\n\t\t\"can.setKeyValue\": function(eventType, handlersBySelector){\n\t\t\tvar handler = this.delegated[eventType] = function(ev){\n\t\t\t\tvar cur = ev.target;\n\t\t\t\tvar propagate = true;\n\t\t\t\tvar origStopPropagation = ev.stopPropagation;\n\t\t\t\tev.stopPropagation = function() {\n\t\t\t\t\torigStopPropagation.apply(this, arguments);\n\t\t\t\t\tpropagate = false;\n\t\t\t\t};\n\t\t\t\tvar origStopImmediatePropagation = ev.stopImmediatePropagation;\n\t\t\t\tev.stopImmediatePropagation = function() {\n\t\t\t\t\torigStopImmediatePropagation.apply(this, arguments);\n\t\t\t\t\tpropagate = false;\n\t\t\t\t};\n\t\t\t\tdo {\n\t\t\t\t\t// document does not implement `.matches` but documentElement does\n\t\t\t\t\tvar el = cur === document ? document.documentElement : cur;\n\t\t\t\t\tvar matches = el.matches || el.msMatchesSelector;\n\n\t\t\t\t\tcanReflect.each(handlersBySelector, function(handlers, selector){\n\t\t\t\t\t\t// Text and comment nodes may be included in mutation event targets\n\t\t\t\t\t\t//  but will never match selectors (and do not implement matches)\n\t\t\t\t\t\tif (matches && matches.call(el, selector)) {\n\t\t\t\t\t\t\thandlers.forEach(function(handler){\n\t\t\t\t\t\t\t\thandler.call(el, ev);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t// since `el` points to `documentElement` when `cur` === document,\n\t\t\t\t\t// we need to continue using `cur` as the loop pointer, otherwhise\n\t\t\t\t\t// it will never end as documentElement.parentNode === document\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t} while ((cur && cur !== ev.currentTarget) && propagate);\n\t\t\t};\n\t\t\tthis.events[eventType] = handlersBySelector;\n\t\t\tdomEvents.addEventListener(this.element, eventType, handler, useCapture(eventType));\n\t\t},\n\t\t\"can.getKeyValue\": function(eventType) {\n\t\t\treturn this.events[eventType];\n\t\t},\n\t\t\"can.deleteKeyValue\": function(eventType) {\n\t\t\tdomEvents.removeEventListener(this.element, eventType, this.delegated[eventType], useCapture(eventType));\n\t\t\tdelete this.delegated[eventType];\n\t\t\tdelete this.events[eventType];\n\t\t},\n\t\t\"can.getOwnEnumerableKeys\": function() {\n\t\t\treturn Object.keys(this.events);\n\t\t}\n\t});\n\n\treturn Delegator;\n}\n\nmodule.exports = function makeDelegateEventTree (domEvents) {\n\tvar Delegator = makeDelegator(domEvents);\n\treturn new KeyTree([Map, Delegator, Object, Array]);\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-events/helpers/-make-delegate-event-tree.js?");

/***/ }),

/***/ "./node_modules/can-dom-events/helpers/add-jquery-events.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-dom-events/helpers/add-jquery-events.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar domEvents = __webpack_require__(/*! ../can-dom-events */ \"./node_modules/can-dom-events/can-dom-events.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\n/**\n * @function can-dom-events/helpers/add-jquery-events ./helpers/add-jquery-events\n * @parent can-dom-events.helpers\n * @description Add jQueryâ€™s special events to the global registry.\n * @signature `addJQueryEvents(jQuery)`\n * @param {jQuery} jQuery Your instance of jQuery.\n * @return {function} The callback to remove the jQuery events from the registry.\n *\n * @body\n *\n * ```js\n * const $ = require(\"jquery\");\n * const addJQueryEvents = require(\"can-dom-events/helpers/add-jquery-events\");\n * const domEvents = require(\"can-dom-events\");\n * // Require another module that registers itself with jQuery.event.special,\n * // e.g. jQuery++ registers events such as draginit, dragmove, etc.\n *\n * const removeJQueryEvents = addJQueryEvents($);\n *\n * // Listen for an event in code; this might also be accomplished through a\n * // can-stache-binding such as <li on:draginit=\"listener()\">\n * domEvents.addEventListener(listItemElement, \"draginit\", function listener() {\n *   // Will fire after a jQuery draginit event has been fired\n * });\n *\n * // Some other code that fires a jQuery event; this will probably be in the\n * // package youâ€™re usingâ€¦\n * $(listItemElement).trigger(\"draginit\");\n *\n * // Later in your codeâ€¦ ready to stop listening for those jQuery events? Call\n * // the function returned by addJQueryEvents()\n * removeJQueryEvents();\n * ```\n */\nmodule.exports = namespace.addJQueryEvents = function addJQueryEvents(jQuery) {\n\tvar jQueryEvents = jQuery.event.special;\n\tvar removeEvents = [];\n\n\tfor (var eventType in jQueryEvents) {\n\t\tif (!domEvents._eventRegistry.has(eventType)) {\n\t\t\tvar eventDefinition = {\n\t\t\t\tdefaultEventType: eventType,\n\t\t\t\taddEventListener: function (target, eventType, handler) {\n\t\t\t\t\t$(target).on(eventType, handler);\n\t\t\t\t},\n\t\t\t\tremoveEventListener: function (target, eventType, handler) {\n\t\t\t\t\t$(target).off(eventType, handler);\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar removeEvent = domEvents.addEvent(eventDefinition);\n\t\t\tremoveEvents.push(removeEvent);\n\t\t}\n\t}\n\n\treturn function removeJQueryEvents() {\n\t\tremoveEvents.forEach(function(removeEvent) {\n\t\t\tremoveEvent();\n\t\t});\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-events/helpers/add-jquery-events.js?");

/***/ }),

/***/ "./node_modules/can-dom-events/helpers/make-event-registry.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-dom-events/helpers/make-event-registry.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction EventRegistry () {\n\tthis._registry = {};\n}\n\n/**\n * @module can-dom-events/helpers/make-event-registry\n * @parent can-dom-events.helpers\n * @description Create an event registry.\n * @signature `makeEventRegistry()`\n *   @return {can-dom-events/EventRegistry}\n * @hide\n * \n * @body\n *\n * ```js\n * var makeEventRegistry = require('can-dom-events/helpers/make-event-registry');\n * var registry = makeEventRegistry();\n *\n * var radioChange = require('can-events-dom-radiochange');\n * var removeRadioChange = registry.add(radioChange);\n *\n * registry.has('radiochange'); // => true\n * registry.get('radiochange'); // => radioChange\n *\n * removeRadioChange();\n * ```\n */\nmodule.exports = function makeEventRegistry () {\n\treturn new EventRegistry();\n};\n\n/**\n * @function make-event-registry.has eventRegistry.has\n *\n * Check whether an event type has already been registered.\n *\n * @signature `eventRegistry.has( eventType )`\n * @parent can-dom-events/EventRegistry\n * @param {String} eventType The event type for which to check.\n * @return {Boolean} Whether the event type is registered.\n*/\nEventRegistry.prototype.has = function (eventType) {\n\treturn !!this._registry[eventType];\n};\n\n/**\n * @function make-event-registry.get eventRegistry.get\n *\n * Retrieve an event type which has already been registered.\n *\n * @signature `eventRegistry.get( eventType )`\n * @parent can-dom-events/EventRegistry\n * @param {String} eventType The event type for which to retrieve.\n * @return {EventDefinition} The registered event definition, or undefined if unregistered.\n*/\nEventRegistry.prototype.get = function (eventType) {\n\treturn this._registry[eventType];\n};\n\n/**\n * @function make-event-registry.add eventRegistry.add\n *\n * Add an event to the registry.\n *\n * @signature `eventRegistry.add( event [, eventType ] )`\n * @parent can-dom-events/EventRegistry\n * @param {EventDefinition} event The event definition to register.\n * @param {String} eventType The event type with which to register the event.\n * @return {function} The callback to remove the event from the registry.\n*/\nEventRegistry.prototype.add = function (event, eventType) {\n\tif (!event) {\n\t\tthrow new Error('An EventDefinition must be provided');\n\t}\n\tif (typeof event.addEventListener !== 'function') {\n\t\tthrow new TypeError('EventDefinition addEventListener must be a function');\n\t}\n\tif (typeof event.removeEventListener !== 'function') {\n\t\tthrow new TypeError('EventDefinition removeEventListener must be a function');\n\t}\n\n\teventType = eventType || event.defaultEventType;\n\tif (typeof eventType !== 'string') {\n\t\tthrow new TypeError('Event type must be a string, not ' + eventType);\n\t}\n\n\tif (this.has(eventType)) {\n\t\tthrow new Error('Event \"' + eventType + '\" is already registered');\n\t}\n\n\tthis._registry[eventType] = event;\n\tvar self = this;\n\treturn function remove () {\n\t\tself._registry[eventType] = undefined;\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-events/helpers/make-event-registry.js?");

/***/ }),

/***/ "./node_modules/can-dom-events/helpers/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-dom-events/helpers/util.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getCurrentDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\nvar isBrowserWindow = __webpack_require__(/*! can-globals/is-browser-window/is-browser-window */ \"./node_modules/can-globals/is-browser-window/is-browser-window.js\");\n\nfunction getTargetDocument (target) {\n\treturn target.ownerDocument || getCurrentDocument();\n}\n\nfunction createEvent (target, eventData, bubbles, cancelable) {\n\tvar doc = getTargetDocument(target);\n\tvar event = doc.createEvent('HTMLEvents');\n\tvar eventType;\n\tif (typeof eventData === 'string') {\n\t\teventType = eventData;\n\t} else {\n\t\teventType = eventData.type;\n\t\tfor (var prop in eventData) {\n\t\t\tif (event[prop] === undefined) {\n\t\t\t\tevent[prop] = eventData[prop];\n\t\t\t}\n\t\t}\n\t}\n\tif (bubbles === undefined) {\n\t\tbubbles = true;\n\t}\n\tevent.initEvent(eventType, bubbles, cancelable);\n\treturn event;\n}\n\n// We do not account for all EventTarget classes,\n// only EventTarget DOM nodes, fragments, and the window.\nfunction isDomEventTarget (obj) {\n\tif (!(obj && obj.nodeName)) {\n\t\treturn obj === window;\n\t}\n\tvar nodeType = obj.nodeType;\n\treturn (\n\t\tnodeType === 1 || // Node.ELEMENT_NODE\n\t\tnodeType === 9 || // Node.DOCUMENT_NODE\n\t\tnodeType === 11 // Node.DOCUMENT_FRAGMENT_NODE\n\t);\n}\n\nfunction addDomContext (context, args) {\n\tif (isDomEventTarget(context)) {\n\t\targs = Array.prototype.slice.call(args, 0);\n\t\targs.unshift(context);\n\t}\n\treturn args;\n}\n\nfunction removeDomContext (context, args) {\n\tif (!isDomEventTarget(context)) {\n\t\targs = Array.prototype.slice.call(args, 0);\n\t\tcontext = args.shift();\n\t}\n\treturn {\n\t\tcontext: context,\n\t\targs: args\n\t};\n}\n\nvar fixSyntheticEventsOnDisabled = false;\n// In FireFox, dispatching a synthetic event on a disabled element throws an error.\n// Other browsers, like IE 10 do not dispatch synthetic events on disabled elements at all.\n// This determines if we have to work around that when dispatching events.\n// https://bugzilla.mozilla.org/show_bug.cgi?id=329509\n(function() {\n\tif(!isBrowserWindow()) {\n\t\treturn;\n\t}\n\n\tvar testEventName = 'fix_synthetic_events_on_disabled_test';\n\tvar input = document.createElement(\"input\");\n\tinput.disabled = true;\n\tvar timer = setTimeout(function() {\n\t\tfixSyntheticEventsOnDisabled = true;\n\t}, 50);\n\tvar onTest = function onTest (){\n\t\tclearTimeout(timer);\n\t\tinput.removeEventListener(testEventName, onTest);\n\t};\n\tinput.addEventListener(testEventName, onTest);\n\ttry {\n\t\tvar event = document.create('HTMLEvents');\n\t\tevent.initEvent(testEventName, false);\n\t\tinput.dispatchEvent(event);\n\t} catch(e) {\n\t\tonTest();\n\t\tfixSyntheticEventsOnDisabled = true;\n\t}\n})();\n\nfunction isDispatchingOnDisabled(element, event) {\n\tvar eventType = event.type;\n\tvar isInsertedOrRemoved = eventType === 'inserted' || eventType === 'removed';\n\tvar isDisabled = !!element.disabled;\n\treturn isInsertedOrRemoved && isDisabled;\n}\n\nfunction forceEnabledForDispatch (element, event) {\n\treturn fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(element, event);\n}\n\nmodule.exports = {\n\tcreateEvent: createEvent,\n\taddDomContext: addDomContext,\n\tremoveDomContext: removeDomContext,\n\tisDomEventTarget: isDomEventTarget,\n\tgetTargetDocument: getTargetDocument,\n\tforceEnabledForDispatch: forceEnabledForDispatch\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-events/helpers/util.js?");

/***/ }),

/***/ "./node_modules/can-dom-mutate/-is-connected.js":
/*!******************************************************!*\
  !*** ./node_modules/can-dom-mutate/-is-connected.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var globals = __webpack_require__(/*! can-globals */ \"./node_modules/can-globals/can-globals.js\");\nvar util = __webpack_require__(/*! ./-util */ \"./node_modules/can-dom-mutate/-util.js\");\nvar contains = util.contains;\nvar mutate = {};\nvar isConnected;\nfunction getIsConnectedFromNode(node) {\n\treturn node.isConnected;\n}\nfunction getIsConnectedFromDocument(node) {\n\tvar doc = node.ownerDocument;\n\t// if node *is* the document, ownerDocument is null\n\t// However, CanSimpleDom implements this incorrectly, and a document's ownerDocument is itself,\n\t//   so make both checks\n\treturn doc === null || doc === node || contains(doc, node);\n}\n\nfunction setIsConnected(doc) {\n\tif(doc) {\n\t\tvar node = doc.createTextNode(\"\");\n\t\tisConnected = 'isConnected' in node.constructor.prototype ?\n\t\t\tgetIsConnectedFromNode :\n\t\t\tgetIsConnectedFromDocument;\n\t\tif(mutate) {\n\t\t\tmutate.isConnected = isConnected;\n\t\t}\n\t} else {\n\t\tmutate.isConnected = getIsConnectedFromNode;\n\t}\n}\nsetIsConnected(globals.getKeyValue(\"document\"));\nglobals.onKeyValue(\"document\", setIsConnected);\n\nmodule.exports = mutate;\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-mutate/-is-connected.js?");

/***/ }),

/***/ "./node_modules/can-dom-mutate/-util.js":
/*!**********************************************!*\
  !*** ./node_modules/can-dom-mutate/-util.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\n\nfunction eliminate(array, item) {\n\tvar index = array.indexOf(item);\n\tif (index >= 0) {\n\t\tarray.splice(index, 1);\n\t}\n}\nfunction wasNotInSet(item, set) {\n\tvar inSet = set.has(item);\n\tif(inSet === false) {\n\t\tset.add(item);\n\t}\n\treturn !inSet;\n}\n\n\nfunction contains(parent, child){\n\tif(child && child.nodeType === Node.TEXT_NODE) {\n\t\treturn contains(parent, child.parentNode);\n\t}\n\tif(parent.contains) {\n\t\treturn parent.contains(child);\n\t}\n\tif(parent.nodeType === Node.DOCUMENT_NODE && parent.documentElement) {\n\t\treturn contains(parent.documentElement, child);\n\t} else {\n\t\tchild = child.parentNode;\n\t\tif(child === parent) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nfunction isDocumentElement (node) {\n\treturn getDocument().documentElement === node;\n}\n\nfunction isFragment (node) {\n\treturn !!(node && node.nodeType === 11);\n}\n\nfunction isElementNode (node) {\n\treturn !!(node && node.nodeType === 1);\n}\n\nfunction getChildren (parentNode) {\n\tvar nodes = [];\n\tvar node = parentNode.firstChild;\n\twhile (node) {\n\t\tnodes.push(node);\n\t\tnode = node.nextSibling;\n\t}\n\treturn nodes;\n}\n\nfunction getParents (node) {\n\tvar nodes;\n\tif (isFragment(node)) {\n\t\tnodes = getChildren(node);\n\t} else {\n\t\tnodes = [node];\n\t}\n\treturn nodes;\n}\n\n\nfunction getNodesLegacyB(node) {\n\tvar skip, tmp;\n\n\tvar depth = 0;\n\n\tvar items = isFragment(node) ? [] : [node];\n\tif(node.firstChild == null) {\n\t\treturn items;\n\t}\n\n\t// Always start with the initial element.\n\tdo {\n\t\tif ( !skip && (tmp = node.firstChild) ) {\n\t\t\tdepth++;\n\t\t\titems.push(tmp);\n\t\t} else if ( tmp = node.nextSibling ) {\n\t\t\tskip = false;\n\t\t\titems.push(tmp);\n\t\t} else {\n\t\t\t// Skipped or no first child and no next sibling, so traverse upwards,\n\t\t\ttmp = node.parentNode;\n\t\t\t// and decrement the depth.\n\t\t\tdepth--;\n\t\t\t// Enable skipping, so that in the next loop iteration, the children of\n\t\t\t// the now-current node (parent node) aren't processed again.\n\t\t\tskip = true;\n\t\t}\n\n\t\t// Instead of setting node explicitly in each conditional block, use the\n\t\t// tmp var and set it here.\n\t\tnode = tmp;\n\n\t\t// Stop if depth comes back to 0 (or goes below zero, in conditions where\n\t\t// the passed node has neither children nore next siblings).\n\t} while ( depth > 0 );\n\n\treturn items;\n}\n\n// IE11 requires a filter parameter for createTreeWalker\n// it also must be an object with an `acceptNode` property\nfunction treeWalkerFilterFunction() {\n\treturn NodeFilter.FILTER_ACCEPT;\n}\nvar treeWalkerFilter = treeWalkerFilterFunction;\ntreeWalkerFilter.acceptNode = treeWalkerFilterFunction;\n\nfunction getNodesWithTreeWalker(rootNode) {\n\tvar result = isFragment(rootNode) ? [] : [rootNode];\n\n\t// IE11 throws if createTreeWalker is called on a non-ElementNode\n\tvar walker = isElementNode(rootNode) && getDocument().createTreeWalker(\n\t\trootNode,\n\t\tNodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n\t\ttreeWalkerFilter,\n\t\tfalse\n\t);\n\n\tvar node;\n\twhile(node = walker && walker.nextNode()) {\n\t\tresult.push(node);\n\t}\n\treturn result;\n}\n\nfunction getAllNodes (node) {\n\tif( getDocument().createTreeWalker !== undefined ) {\n\t\treturn getNodesWithTreeWalker(node);\n\t} else {\n\t\treturn getNodesLegacyB(node);\n\t}\n}\n\nfunction subscription (fn) {\n\treturn function _subscription () {\n\t\tvar disposal = fn.apply(this, arguments);\n\t\tvar isDisposed = false;\n\t\treturn function _disposal () {\n\t\t\tif (isDisposed) {\n\t\t\t\tvar fnName = fn.name || fn.displayName || 'an anonymous function';\n\t\t\t\tvar message = 'Disposal function returned by ' + fnName + ' called more than once.';\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t\tdisposal.apply(this, arguments);\n\t\t\tisDisposed = true;\n\t\t};\n\t};\n}\n\nmodule.exports = {\n\teliminate: eliminate,\n\tgetDocument: getDocument,\n\tisDocumentElement: isDocumentElement,\n\tisFragment: isFragment,\n\tgetParents: getParents,\n\tgetAllNodes: getAllNodes,\n\tgetChildren: getChildren,\n\tsubscription: subscription,\n\twasNotInSet: wasNotInSet,\n\tcontains: contains\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-mutate/-util.js?");

/***/ }),

/***/ "./node_modules/can-dom-mutate/can-dom-mutate.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-dom-mutate/can-dom-mutate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals */ \"./node_modules/can-globals/can-globals.js\");\nvar getRoot = __webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\nvar getMutationObserver = __webpack_require__(/*! can-globals/mutation-observer/mutation-observer */ \"./node_modules/can-globals/mutation-observer/mutation-observer.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar DOCUMENT = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\n\nvar util = __webpack_require__(/*! ./-util */ \"./node_modules/can-dom-mutate/-util.js\");\nvar eliminate = util.eliminate;\nvar subscription = util.subscription;\nvar isDocumentElement = util.isDocumentElement;\nvar getAllNodes = util.getAllNodes;\n\nvar domMutate,\n\tdispatchNodeInserted,\n\tdispatchNodeConnected,\n\tdispatchGlobalConnected,\n\tdispatchNodeRemoved,\n\tdispatchNodeDisconnected,\n\tdispatchGlobalDisconnected,\n\tdispatchAttributeChange,\n\tdispatchGlobalAttributeChange;\n\nvar dataStore = new WeakMap();\nvar isConnected = __webpack_require__(/*! ./-is-connected */ \"./node_modules/can-dom-mutate/-is-connected.js\");\n\nvar queue;\n\nfunction getRelatedData(node, key) {\n\tvar data = dataStore.get(node);\n\tif (data) {\n\t\treturn data[key];\n\t}\n}\n\nfunction setRelatedData(node, key, targetListenersMap) {\n\tvar data = dataStore.get(node);\n\tif (!data) {\n\t\tdata = {};\n\t\tdataStore.set(node, data);\n\t}\n\tdata[key] = targetListenersMap;\n}\n\nfunction deleteRelatedData(node, key) {\n\tvar data = dataStore.get(node);\n\treturn delete data[key];\n}\n\nfunction toMutationEvent(node, mutation) {\n\treturn {target: node, sourceMutation: mutation};\n}\n\nfunction getDocumentListeners (target, key) {\n\t// TODO: it's odd these functions read DOCUMENT() instead of\n\t// target.ownerDocument.  To change to ownerDocument, we might need a \"is document\"\n\t// check.\n\tvar doc = DOCUMENT();\n\tvar data = getRelatedData(doc, key);\n\tif (data) {\n\t\treturn data.listeners;\n\t}\n}\n\nfunction getTargetListeners (target, key) {\n\tvar doc = DOCUMENT();\n\tvar targetListenersMap = getRelatedData(doc, key);\n\tif (!targetListenersMap) {\n\t\treturn;\n\t}\n\n\treturn targetListenersMap.get(target);\n}\n\nfunction addTargetListener (target, key, listener) {\n\tvar doc = DOCUMENT();\n\tvar targetListenersMap = getRelatedData(doc, key);\n\tif (!targetListenersMap) {\n\t\ttargetListenersMap = new WeakMap();\n\t\tsetRelatedData(doc, key, targetListenersMap);\n\t}\n\tvar targetListeners = targetListenersMap.get(target);\n\tif (!targetListeners) {\n\t\ttargetListeners = [];\n\t\ttargetListenersMap.set(target, targetListeners);\n\t}\n\ttargetListeners.push(listener);\n}\n\nfunction removeTargetListener (target, key, listener) {\n\tvar doc = DOCUMENT();\n\tvar targetListenersMap = getRelatedData(doc, key);\n\tif (!targetListenersMap) {\n\t\treturn;\n\t}\n\tvar targetListeners = targetListenersMap.get(target);\n\tif (!targetListeners) {\n\t\treturn;\n\t}\n\teliminate(targetListeners, listener);\n\tif (targetListeners.length === 0) {\n\t\ttargetListenersMap['delete'](target);\n\t\tif (targetListenersMap.size === 0) {\n\t\t\tdeleteRelatedData(doc, key);\n\t\t}\n\t}\n}\n\nvar promise = Promise.resolve();\nfunction nextTick(handler) {\n\tpromise.then(handler);\n}\n\n//var recordsAndCallbacks = null;\n\nfunction flushCallbacks(callbacks, arg){\n\tvar callbacksCount = callbacks.length;\n\tvar safeCallbacks = callbacks.slice(0);\n\tfor(var c = 0; c < callbacksCount; c++){\n\t\tsafeCallbacks[c](arg);\n\t}\n}\n\nfunction dispatch(getListeners, targetKey) {\n\n\treturn function dispatchEvents(event) {\n\t\tvar targetListeners = getListeners(event.target, targetKey);\n\n\t\tif (targetListeners) {\n\t\t\tflushCallbacks(targetListeners, event);\n\t\t}\n\t};\n}\n\nvar count = 0;\n\nfunction observeMutations(target, observerKey, config, handler) {\n\n\tvar observerData = getRelatedData(target, observerKey);\n\tif (!observerData) {\n\t\tobserverData = {\n\t\t\tobservingCount: 0\n\t\t};\n\t\tsetRelatedData(target, observerKey, observerData);\n\t}\n\n\tvar setupObserver = function () {\n\t\t// disconnect the old one\n\t\tif (observerData.observer) {\n\t\t\tobserverData.observer.disconnect();\n\t\t\tobserverData.observer = null;\n\t\t}\n\n\t\tvar MutationObserver = getMutationObserver();\n\t\tif (MutationObserver) {\n\t\t\tvar Node = getRoot().Node;\n\t\t\tvar isRealNode = !!(Node && target instanceof Node);\n\t\t\tif (isRealNode) {\n\t\t\t\tvar targetObserver = new MutationObserver(handler);\n\t\t\t\ttargetObserver.id = count++;\n\t\t\t\ttargetObserver.observe(target, config);\n\t\t\t\tobserverData.observer = targetObserver;\n\t\t\t}\n\t\t}\n\t};\n\n\tif (observerData.observingCount === 0) {\n\t\tglobals.onKeyValue('MutationObserver', setupObserver);\n\t\tsetupObserver();\n\t}\n\n\tobserverData.observingCount++;\n\treturn function stopObservingMutations() {\n\t\tvar observerData = getRelatedData(target, observerKey);\n\t\tif (observerData) {\n\t\t\tobserverData.observingCount--;\n\t\t\tif (observerData.observingCount <= 0) {\n\t\t\t\tif (observerData.observer) {\n\t\t\t\t\tobserverData.observer.disconnect();\n\t\t\t\t}\n\t\t\t\tdeleteRelatedData(target, observerKey);\n\t\t\t\tglobals.offKeyValue('MutationObserver', setupObserver);\n\t\t\t}\n\t\t}\n\t};\n}\n\nvar treeMutationConfig = {\n\tsubtree: true,\n\tchildList: true\n};\n\nvar attributeMutationConfig = {\n\tattributes: true,\n\tattributeOldValue: true\n};\n\nfunction addNodeListener(listenerKey, observerKey, isAttributes) {\n\treturn subscription(function _addNodeListener(target, listener) {\n\t\t// DocumentFragment\n\t\tif(target.nodeType === 11) {\n\t\t\t// This returns a noop without actually doing anything.\n\t\t\t// We should probably warn about passing a DocumentFragment here,\n\t\t\t// but since can-stache does so currently we are ignoring until that is\n\t\t\t// fixed.\n\t\t\treturn Function.prototype;\n\t\t}\n\n\t\tvar stopObserving;\n\t\tif (isAttributes) {\n\t\t\tstopObserving = observeMutations(target, observerKey, attributeMutationConfig, queue.enqueueAndFlushMutations);\n\t\t} else {\n\t\t\tstopObserving = observeMutations(DOCUMENT(), observerKey, treeMutationConfig, queue.enqueueAndFlushMutations);\n\t\t}\n\n\t\taddTargetListener(target, listenerKey, listener);\n\t\treturn function removeNodeListener() {\n\t\t\tif(stopObserving) {\n\t\t\t\tstopObserving();\n\t\t\t}\n\n\t\t\tremoveTargetListener(target, listenerKey, listener);\n\t\t};\n\t});\n}\n\nfunction addGlobalListener(globalDataKey, addNodeListener) {\n\treturn subscription(function addGlobalGroupListener(documentElement, listener) {\n\t\tif (!isDocumentElement(documentElement)) {\n\t\t\tthrow new Error('Global mutation listeners must pass a documentElement');\n\t\t}\n\n\t\tvar doc = DOCUMENT();\n\t\tvar documentData = getRelatedData(doc, globalDataKey);\n\t\tif (!documentData) {\n\t\t\tdocumentData = {listeners: []};\n\t\t\tsetRelatedData(doc, globalDataKey, documentData);\n\t\t}\n\n\t\tvar listeners = documentData.listeners;\n\t\tif (listeners.length === 0) {\n\t\t\t// We need at least on listener for mutation events to propagate\n\t\t\tdocumentData.removeListener = addNodeListener(doc, function () {});\n\t\t}\n\n\t\tlisteners.push(listener);\n\n\t\treturn function removeGlobalGroupListener() {\n\t\t\tvar documentData = getRelatedData(doc, globalDataKey);\n\t\t\tif (!documentData) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar listeners = documentData.listeners;\n\t\t\teliminate(listeners, listener);\n\t\t\tif (listeners.length === 0) {\n\t\t\t\tdocumentData.removeListener();\n\t\t\t\tdeleteRelatedData(doc, globalDataKey);\n\t\t\t}\n\t\t};\n\t});\n}\n\n\n\nvar domMutationPrefix = 'domMutation';\n\n// target listener keys\nvar connectedDataKey = domMutationPrefix + 'ConnectedData';\nvar disconnectedDataKey = domMutationPrefix + 'DisconnectedData';\nvar insertedDataKey = domMutationPrefix + 'InsertedData';\nvar removedDataKey = domMutationPrefix + 'RemovedData';\nvar attributeChangeDataKey = domMutationPrefix + 'AttributeChangeData';\n\n// document listener keys\nvar documentConnectedDataKey = domMutationPrefix + 'DocumentConnectedData';\nvar documentDisconnectedDataKey = domMutationPrefix + 'DocumentDisconnectedData';\nvar documentAttributeChangeDataKey = domMutationPrefix + 'DocumentAttributeChangeData';\n\n// observer keys\nvar treeDataKey = domMutationPrefix + 'TreeData';\nvar attributeDataKey = domMutationPrefix + 'AttributeData';\n\ndispatchNodeInserted = dispatch(getTargetListeners, insertedDataKey);\ndispatchNodeConnected = dispatch(getTargetListeners, connectedDataKey);\ndispatchGlobalConnected = dispatch(getDocumentListeners, documentConnectedDataKey);\n\ndispatchNodeRemoved = dispatch(getTargetListeners, removedDataKey);\ndispatchNodeDisconnected = dispatch(getTargetListeners, disconnectedDataKey);\ndispatchGlobalDisconnected = dispatch(getDocumentListeners, documentDisconnectedDataKey);\n\ndispatchAttributeChange = dispatch(getTargetListeners, attributeChangeDataKey);\ndispatchGlobalAttributeChange = dispatch(getDocumentListeners, documentAttributeChangeDataKey);\n\n// node listeners\nvar addNodeConnectedListener = addNodeListener(connectedDataKey, treeDataKey);\nvar addNodeDisconnectedListener = addNodeListener(disconnectedDataKey, treeDataKey);\nvar addNodeInsertedListener = addNodeListener(insertedDataKey, treeDataKey);\nvar addNodeRemovedListener = addNodeListener(removedDataKey, treeDataKey);\nvar addNodeAttributeChangeListener = addNodeListener(attributeChangeDataKey, attributeDataKey, true);\n\n// global listeners\nvar addConnectedListener = addGlobalListener(\n\tdocumentConnectedDataKey,\n\taddNodeConnectedListener\n);\nvar addDisconnectedListener = addGlobalListener(\n\tdocumentDisconnectedDataKey,\n\taddNodeDisconnectedListener\n);\nvar addAttributeChangeListener = addGlobalListener(\n\tdocumentAttributeChangeDataKey,\n\taddNodeAttributeChangeListener\n);\n\n// ==========================================\nfunction dispatchTreeMutation(mutation, processedState) {\n\t// was the mutation connected\n\tvar wasConnected = mutation.isConnected === true || mutation.isConnected === undefined;\n\n\t// there are\n\t// - the global connected\n\t// - individual connected\n\t// - individual inserted\n\tvar removedCount = mutation.removedNodes.length;\n\tfor (var r = 0; r < removedCount; r++) {\n\t\t// get what already isn't in `removed`\n\n\t\t// see if \"removed\"\n\t\t// if wasConnected .. dispatch disconnected\n\t\tvar removedNodes = getAllNodes(mutation.removedNodes[r]);\n\t\tremovedNodes.forEach(function(node){\n\t\t\tvar event = toMutationEvent(node, mutation);\n\n\t\t\tif( util.wasNotInSet(node, processedState.removed) ) {\n\t\t\t\tdispatchNodeRemoved( event );\n\t\t\t}\n\t\t\tif(wasConnected && util.wasNotInSet(node, processedState.disconnected) ) {\n\t\t\t\tdispatchNodeDisconnected( event );\n\t\t\t\tdispatchGlobalDisconnected( event );\n\t\t\t}\n\t\t});\n\t}\n\n\tvar addedCount = mutation.addedNodes.length;\n\tfor (var a = 0; a < addedCount; a++) {\n\t\tvar insertedNodes = getAllNodes(mutation.addedNodes[a]);\n\t\tinsertedNodes.forEach(function(node){\n\t\t\tvar event = toMutationEvent(node, mutation);\n\n\t\t\tif(util.wasNotInSet(node, processedState.inserted)) {\n\t\t\t\tdispatchNodeInserted( event );\n\t\t\t}\n\t\t\tif(wasConnected && util.wasNotInSet(node, processedState.connected) ) {\n\t\t\t\tdispatchNodeConnected( event );\n\t\t\t\tdispatchGlobalConnected( event );\n\t\t\t}\n\t\t});\n\t}\n\t// run mutation\n}\n\n\nvar FLUSHING_MUTATIONS = [];\nvar IS_FLUSHING = false;\n\nvar IS_FLUSH_PENDING = false;\nvar ENQUEUED_MUTATIONS = [];\n\nqueue = {\n\t// This is used to dispatch mutations immediately.\n\t// This is usually called by the result of a mutation observer.\n\tenqueueAndFlushMutations: function(mutations) {\n\t\tif(IS_FLUSH_PENDING) {\n\t\t\tFLUSHING_MUTATIONS.push.apply(FLUSHING_MUTATIONS, ENQUEUED_MUTATIONS);\n\t\t\tIS_FLUSH_PENDING = false;\n\t\t\tENQUEUED_MUTATIONS = [];\n\t\t}\n\n\t\tFLUSHING_MUTATIONS.push.apply(FLUSHING_MUTATIONS, mutations);\n\t\tif(IS_FLUSHING) {\n\t\t\treturn;\n\t\t}\n\n\t\tIS_FLUSHING = true;\n\n\t\tvar index = 0;\n\n\t\tvar processedState = {\n\t\t\tconnected: new Set(),\n\t\t\tdisconnected: new Set(),\n\t\t\tinserted: new Set(),\n\t\t\tremoved: new Set()\n\t\t};\n\n\t\twhile(index < FLUSHING_MUTATIONS.length) {\n\t\t\tvar mutation = FLUSHING_MUTATIONS[index];\n\t\t\t// process mutation\n\t\t\tif(mutation.type === \"childList\") {\n\t\t\t\tdispatchTreeMutation(mutation, processedState);\n\t\t\t} else if(mutation.type === \"attributes\") {\n\t\t\t\tdispatchAttributeChange(mutation);\n\t\t\t}\n\t\t\tindex++;\n\n\t\t}\n\t\tFLUSHING_MUTATIONS = [];\n\t\tIS_FLUSHING = false;\n\t},\n\t// called to dipatch later unless we are already dispatching.\n\tenqueueMutationsAndFlushAsync: function(mutations){\n\t\tENQUEUED_MUTATIONS.push.apply(ENQUEUED_MUTATIONS, mutations);\n\n\t\t// if there are currently dispatching mutations, this should happen sometime after\n\t\tif(!IS_FLUSH_PENDING) {\n\t\t\tIS_FLUSH_PENDING = true;\n\t\t\tnextTick(function(){\n\t\t\t\tif(IS_FLUSH_PENDING) {\n\t\t\t\t\tIS_FLUSH_PENDING = false;\n\t\t\t\t\tvar pending = ENQUEUED_MUTATIONS;\n\t\t\t\t\tENQUEUED_MUTATIONS = [];\n\t\t\t\t\tqueue.enqueueAndFlushMutations(pending);\n\t\t\t\t} else {\n\t\t\t\t\t// Someone called enqueueAndFlushMutations before this finished.\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n};\n\n\n// ==========================================\n\n\ndomMutate = {\n\t/**\n\t* @function can-dom-mutate.dispatchNodeInsertion dispatchNodeInsertion\n\t* @hide\n\t*\n\t* Dispatch an insertion mutation on the given node.\n\t*\n\t* @signature `dispatchNodeInsertion( node [, callback ] )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to dispatch an insertion mutation.\n\t*/\n\tdispatchNodeInsertion: function (node, target) {\n\t\tqueue.enqueueMutationsAndFlushAsync(\n\t\t\t[{\n\t\t\t\ttype: \"childList\",\n\t\t\t\ttarget: target,\n\t\t\t\taddedNodes: [node],\n\t\t\t\tisConnected: isConnected.isConnected(target),\n\t\t\t\tremovedNodes: []\n\t\t\t}]\n\t\t);\n\t\t/*\n\t\tvar nodes = new Set();\n\t\tutil.addToSet( getAllNodes(node), nodes);\n\t\tvar events = toMutationEvents( canReflect.toArray(nodes) );\n\t\t// this is basically an array of every single child of node including node\n\t\tdispatchInsertion(events, callback, dispatchConnected, flushAsync);*/\n\t},\n\n\t/**\n\t* @function can-dom-mutate.dispatchNodeRemoval dispatchNodeRemoval\n\t* @hide\n\t*\n\t* Dispatch a removal mutation on the given node.\n\t*\n\t* @signature `dispatchNodeRemoval( node [, callback ] )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to dispatch a removal mutation.\n\t* @param {function} callback The optional callback called after the mutation is dispatched.\n\t*/\n\tdispatchNodeRemoval: function (node, target) {\n\t\tqueue.enqueueMutationsAndFlushAsync(\n\t\t\t[{\n\t\t\t\ttype: \"childList\",\n\t\t\t\ttarget: target,\n\t\t\t\taddedNodes: [],\n\t\t\t\tremovedNodes: [node],\n\t\t\t\tisConnected: isConnected.isConnected(target)\n\t\t\t}]\n\t\t);\n\t\t/*\n\t\tvar nodes = new Set();\n\t\tutil.addToSet( getAllNodes(node), nodes);\n\t\tvar events = toMutationEvents( canReflect.toArray(nodes) );\n\t\tdispatchRemoval(events, callback, dispatchConnected, flushAsync);*/\n\t},\n\n\t/**\n\t* @function can-dom-mutate.dispatchNodeAttributeChange dispatchNodeAttributeChange\n\t* @parent can-dom-mutate.static\n\t* @hide\n\t*\n\t* Dispatch an attribute change mutation on the given node.\n\t*\n\t* @signature `dispatchNodeAttributeChange( node, attributeName, oldValue [, callback ] )`\n\t*\n\t* ```\n\t* input.setAttribute(\"value\", \"newValue\")\n\t* domMutate.dispatchNodeAttributeChange(input, \"value\",\"oldValue\")\n\t* ```\n\t*\n\t*\n\t* @param {Node} target The node on which to dispatch an attribute change mutation.\n\t* @param {String} attributeName The attribute name whose value has changed.\n\t* @param {String} oldValue The attribute value before the change.\n\t*/\n\tdispatchNodeAttributeChange: function (target, attributeName, oldValue) {\n\t\tqueue.enqueueMutationsAndFlushAsync(\n\t\t\t[{\n\t\t\t\ttype: \"attributes\",\n\t\t\t\ttarget: target,\n\t\t\t\tattributeName: attributeName,\n\t\t\t\toldValue: oldValue\n\t\t\t}]\n\t\t);\n\t},\n\n\t/**\n\t* @function can-dom-mutate.onNodeConnected onNodeConnected\n\t*\n\t* Listen for insertion mutations on the given node.\n\t*\n\t* @signature `onNodeConnected( node, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to listen for insertion mutations.\n\t* @param {function} callback The callback called when an insertion mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonNodeConnected: addNodeConnectedListener,\n\tonNodeInsertion: function(){\n\t\t// TODO: remove in prod\n\t\tconsole.warn(\"can-dom-mutate: Use onNodeConnected instead of onNodeInsertion\");\n\t\treturn addNodeConnectedListener.apply(this, arguments);\n\t},\n\t/**\n\t* @function can-dom-mutate.onNodeDisconnected onNodeDisconnected\n\t*\n\t* Listen for removal mutations on the given node.\n\t*\n\t* @signature `onNodeDisconnected( node, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to listen for removal mutations.\n\t* @param {function} callback The callback called when a removal mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonNodeDisconnected: addNodeDisconnectedListener,\n\tonNodeRemoval: function(){\n\t\t// TODO: remove in prod\n\t\tconsole.warn(\"can-dom-mutate: Use onNodeDisconnected instead of onNodeRemoval\");\n\t\treturn addNodeDisconnectedListener.apply(this, arguments);\n\t},\n\t/**\n\t* @function can-dom-mutate.onNodeAttributeChange onNodeAttributeChange\n\t*\n\t* Listen for attribute change mutations on the given node.\n\t*\n\t* @signature `onNodeAttributeChange( node, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to listen for attribute change mutations.\n\t* @param {function} callback The callback called when an attribute change mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonNodeAttributeChange: addNodeAttributeChangeListener,\n\n\t/**\n\t* @function can-dom-mutate.onDisconnected onDisconnected\n\t*\n\t* Listen for removal mutations on any node within the documentElement.\n\t*\n\t* @signature `onDisconnected( documentElement, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} documentElement The documentElement on which to listen for removal mutations.\n\t* @param {function} callback The callback called when a removal mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonDisconnected: addDisconnectedListener,\n\tonRemoval: function(){\n\t\t// TODO: remove in prod\n\t\tconsole.warn(\"can-dom-mutate: Use onDisconnected instead of onRemoval\");\n\t\treturn addDisconnectedListener.apply(this, arguments);\n\t},\n\t/**\n\t* @function can-dom-mutate.onConnected onConnected\n\t*\n\t* Listen for insertion mutations on any node within the documentElement.\n\t*\n\t* @signature `onConnected( documentElement, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} documentElement The documentElement on which to listen for removal mutations.\n\t* @param {function} callback The callback called when a insertion mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonConnected: addConnectedListener,\n\tonInsertion: function(){\n\t\t// TODO: remove in prod\n\t\tconsole.warn(\"can-dom-mutate: Use onConnected instead of onInsertion\");\n\t\treturn addConnectedListener.apply(this, arguments);\n\t},\n\t/**\n\t* @function can-dom-mutate.onAttributeChange onAttributeChange\n\t*\n\t* Listen for attribute change mutations on any node within the documentElement.\n\t*\n\t* @signature `onAttributeChange( documentElement, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} documentElement The documentElement on which to listen for removal mutations.\n\t* @param {function} callback The callback called when an attribute change mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonAttributeChange: addAttributeChangeListener,\n\n\tflushRecords: function(doc){\n\t\tdoc = doc || DOCUMENT();\n\t\tvar data = dataStore.get(doc),\n\t\t\trecords = [];\n\t\tif(data) {\n\t\t\tif(data.domMutationTreeData && data.domMutationTreeData.observer) {\n\t\t\t\trecords = data.domMutationTreeData.observer.takeRecords();\n\t\t\t}\n\t\t}\n\t\tqueue.enqueueAndFlushMutations(records);\n\t},\n\tonNodeInserted: addNodeInsertedListener,\n\tonNodeRemoved: addNodeRemovedListener\n};\n\n//!steal-remove-start\nif(true) {\n\tdomMutate.dataStore = dataStore;\n}\n//!steal-remove-end\n\nmodule.exports = namespace.domMutate = domMutate;\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-mutate/can-dom-mutate.js?");

/***/ }),

/***/ "./node_modules/can-dom-mutate/dom-events.js":
/*!***************************************************!*\
  !*** ./node_modules/can-dom-mutate/dom-events.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar domMutateEvents = __webpack_require__(/*! ./events/events */ \"./node_modules/can-dom-mutate/events/events.js\");\n\n// backwards compatibility\nmodule.exports = namespace.domMutateDomEvents = domMutateEvents;\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-mutate/dom-events.js?");

/***/ }),

/***/ "./node_modules/can-dom-mutate/events/events.js":
/*!******************************************************!*\
  !*** ./node_modules/can-dom-mutate/events/events.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar domMutate = __webpack_require__(/*! ../can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\n/**\n * @module {{}} can-dom-mutate/events/events\n * @parent can-dom-mutate/modules\n * \n * @description This adds attributes, inserted and removed attributes to the DOM.\n * @signature `domMutateEvents`\n * \n * `can-dom-mutate/events/events` Exports an object that allows to listen ```attributes```, ```inserted``` and ```removed``` events \n *  in the DOM using [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n * \n * ```js\n * import domMutateEvents from \"can-dom-mutate/events/events\";\n * import domEvents from \"can-dom-events\";\n *\n * domMutateEvents //->\n * {\n *   attributes: {defaultEventType, addEventListener(), removeEventListener()},\n *   inserted: {defaultEventType, addEventListener(), removeEventListener},\n *   removed: {defaultEventType, addEventListener(), removeEventListener()},\n * }\n *\n * // listen to inserted change within an element:\n * // add inserted event to registry\n * domEvents.addEvent(domMutateEvents.inserted);\n * domEvent.addEventListener(document.querySelector(\"#foo\"), \"inserted\", handler () => {})\n * ```\n */\n\nfunction makeMutationEvent (defaultEventType, subscription, bubbles) {\n\tvar elementSubscriptions = new Map();\n\treturn {\n\t\t_subscriptions: elementSubscriptions,\n\t\tdefaultEventType: defaultEventType,\n\t\taddEventListener: function (target, eventType, handler) {\n\t\t\tvar dispatch = this.dispatch;\n\t\t\tvar data = elementSubscriptions.get(target);\n\t\t\tif (!data) {\n\t\t\t\tdata = {\n\t\t\t\t\tremoveListener: null,\n\t\t\t\t\tlisteners: new Set()\n\t\t\t\t};\n\t\t\t\telementSubscriptions.set(target, data);\n\t\t\t}\n\n\t\t\tif (data.listeners.size === 0) {\n\t\t\t\tdata.removeListener = subscription(target, function (mutation) {\n\t\t\t\t\tvar eventData = {type: eventType};\n\t\t\t\t\tfor (var key in mutation) {\n\t\t\t\t\t\teventData[key] = mutation[key];\n\t\t\t\t\t}\n\n\t\t\t\t\tdispatch(target, eventData, bubbles !== false);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tdata.listeners.add(handler);\n\t\t\ttarget.addEventListener(eventType, handler);\n\t\t},\n\t\tremoveEventListener: function (target, eventType, handler) {\n\t\t\ttarget.removeEventListener(eventType, handler);\n\t\t\tvar data = elementSubscriptions.get(target);\n\t\t\tif (data) {\n\t\t\t\tdata.listeners['delete'](handler);\n\t\t\t\tif (data.listeners.size === 0) {\n\t\t\t\t\tdata.removeListener();\n\t\t\t\t\telementSubscriptions['delete'](target);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t};\n}\n\nmodule.exports = namespace.domMutateDomEvents = {\n\tattributes: makeMutationEvent('attributes', domMutate.onNodeAttributeChange),\n\tinserted: makeMutationEvent('inserted', domMutate.onNodeConnected, false),\n\tremoved: makeMutationEvent('removed', domMutate.onNodeDisconnected)\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-mutate/events/events.js?");

/***/ }),

/***/ "./node_modules/can-dom-mutate/node.js":
/*!*********************************************!*\
  !*** ./node_modules/can-dom-mutate/node.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar node = __webpack_require__(/*! ./node/node */ \"./node_modules/can-dom-mutate/node/node.js\");\n\n// backwards compatibility\nmodule.exports = namespace.node = node;\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-mutate/node.js?");

/***/ }),

/***/ "./node_modules/can-dom-mutate/node/node.js":
/*!**************************************************!*\
  !*** ./node_modules/can-dom-mutate/node/node.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals */ \"./node_modules/can-globals/can-globals.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar domMutate = __webpack_require__(/*! ../can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar util = __webpack_require__(/*! ../-util */ \"./node_modules/can-dom-mutate/-util.js\");\n\nvar getParents = util.getParents;\nvar contains = util.contains;\nvar isConnected = __webpack_require__(/*! ../-is-connected */ \"./node_modules/can-dom-mutate/-is-connected.js\");\n\n\nvar compat = {\n\treplaceChild: function (newChild, oldChild) {\n\t\tvar newChildren = getParents(newChild);\n\t\tvar result = this.replaceChild(newChild, oldChild);\n\t\tdomMutate.dispatchNodeRemoval(oldChild, this);\n\t\tfor (var i = 0; i < newChildren.length; i++) {\n\t\t\tdomMutate.dispatchNodeInsertion(newChildren[i], this);\n\t\t}\n\t\treturn result;\n\t},\n\tsetAttribute: function (name, value) {\n\t\tvar oldAttributeValue = this.getAttribute(name);\n\t\tvar result = this.setAttribute(name, value);\n\t\tvar newAttributeValue = this.getAttribute(name);\n\t\tif (oldAttributeValue !== newAttributeValue) {\n\t\t\tdomMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);\n\t\t}\n\t\treturn result;\n\t},\n\tsetAttributeNS: function (namespace, name, value) {\n\t\tvar oldAttributeValue = this.getAttribute(name);\n\t\tvar result = this.setAttributeNS(namespace, name, value);\n\t\tvar newAttributeValue = this.getAttribute(name);\n\t\tif (oldAttributeValue !== newAttributeValue) {\n\t\t\tdomMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);\n\t\t}\n\t\treturn result;\n\t},\n\tremoveAttribute: function (name) {\n\t\tvar oldAttributeValue = this.getAttribute(name);\n\t\tvar result = this.removeAttribute(name);\n\t\tif (oldAttributeValue) {\n\t\t\tdomMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);\n\t\t}\n\t\treturn result;\n\t}\n};\n\nvar compatData = [\n\t['appendChild', 'Insertion'],\n\t['insertBefore', 'Insertion'],\n\t['removeChild', 'Removal']\n];\ncompatData.forEach(function (pair) {\n\tvar nodeMethod = pair[0];\n\tvar dispatchMethod = 'dispatchNode' + pair[1];\n\tcompat[nodeMethod] = function (node) {\n\t\tvar nodes = getParents(node);\n\t\tvar result = this[nodeMethod].apply(this, arguments);\n\t\tfor (var i = 0; i < nodes.length; i++) {\n\t\t\tdomMutate[dispatchMethod](nodes[i], this);\n\t\t}\n\t\treturn result;\n\t};\n});\n\nvar normal = {};\nvar nodeMethods = ['appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'setAttributeNS', 'removeAttribute'];\nnodeMethods.forEach(function (methodName) {\n\tnormal[methodName] = function () {\n\t\tif(isConnected.isConnected(this)) {\n\t\t\treturn this[methodName].apply(this, arguments);\n\t\t} else {\n\t\t\treturn compat[methodName].apply(this, arguments);\n\t\t}\n\t};\n});\n\n/**\n* @module {{}} can-dom-mutate/node node\n* @parent can-dom-mutate/modules\n*\n* Append, insert, and remove DOM nodes. Also, change node attributes.\n* This allows mutations to be dispatched in environments where MutationObserver is not supported.\n* @signature `mutateNode`\n*\n* Exports an `Object` with methods that shouhld be used to mutate HTML.\n*\n* ```js\n* var mutateNode = require('can-dom-mutate/node');\n* var el = document.createElement('div');\n*\n* mutateNode.appendChild.call(document.body, el);\n*\n* ```\n*/\nvar mutate = {};\n\n/**\n* @function can-dom-mutate/node.appendChild appendChild\n* @parent can-dom-mutate/node\n*\n* Append a node to an element, effectively `Node.prototype.appendChild`.\n*\n* @signature `mutate.appendChild.call(parent, child)`\n*\n* @param {Node} parent The parent into which the child is inserted.\n* @param {Node} child The child which will be inserted into the parent.\n* @return {Node} The appended child.\n*/\n\n/**\n* @function can-dom-mutate/node.insertBefore insertBefore\n* @parent can-dom-mutate/node\n*\n* Insert a node before a given reference node in an element, effectively `Node.prototype.insertBefore`.\n*\n* @signature `mutate.insertBefore.call(parent, child, reference)`\n* @param {Node} parent The parent into which the child is inserted.\n* @param {Node} child The child which will be inserted into the parent.\n* @param {Node} reference The reference which the child will be placed before.\n* @return {Node} The inserted child.\n*/\n\n/**\n* @function can-dom-mutate/node.removeChild removeChild\n* @parent can-dom-mutate/node\n*\n* Remove a node from an element, effectively `Node.prototype.removeChild`.\n*\n* @signature `mutate.removeChild.call(parent, child)`\n*\n* @param {Node} parent The parent from which the child is removed.\n* @param {Node} child The child which will be removed from the parent.\n* @return {Node} The removed child.\n*/\n\n/**\n* @function can-dom-mutate/node.replaceChild replaceChild\n* @parent can-dom-mutate/node\n*\n* Insert a node before a given reference node in an element, effectively `Node.prototype.replaceChild`.\n*\n* @signature `mutate.replaceChild.call(parent, newChild, oldChild)`\n*\n* @param {Node} parent The parent into which the newChild is inserted.\n* @param {Node} newChild The child which is inserted into the parent.\n* @param {Node} oldChild The child which is removed from the parent.\n* @return {Node} The replaced child.\n*/\n\n/**\n* @function can-dom-mutate/node.setAttribute setAttribute\n* @parent can-dom-mutate/node\n*\n* Set an attribute value on an element, effectively `Element.prototype.setAttribute`.\n*\n* @signature `mutate.setAttribute.call(element, name, value)`\n*\n* @param {Element} element The element on which to set the attribute.\n* @param {String} name The name of the attribute to set.\n* @param {String} value The value to set on the attribute.\n*/\n\n/**\n* @function can-dom-mutate/node.removeAttribute removeAttribute\n* @parent can-dom-mutate/node\n*\n* Removes an attribute from an element, effectively `Element.prototype.removeAttribute`.\n*\n* @signature `mutate.removeAttribute.call(element, name, value)`\n*\n* @param {Element} element The element from which to remove the attribute.\n* @param {String} name The name of the attribute to remove.\n*/\n\nfunction setMutateStrategy(observer) {\n\tvar strategy = observer ? normal : compat;\n\n\tfor (var key in strategy) {\n\t\tmutate[key] = strategy[key];\n\t}\n}\n\nvar mutationObserverKey = 'MutationObserver';\nsetMutateStrategy(globals.getKeyValue(mutationObserverKey));\nglobals.onKeyValue(mutationObserverKey, setMutateStrategy);\n\nmodule.exports = namespace.domMutateNode = domMutate.node = mutate;\n\n\n//# sourceURL=webpack:///./node_modules/can-dom-mutate/node/node.js?");

/***/ }),

/***/ "./node_modules/can-event-dom-enter/can-event-dom-enter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-event-dom-enter/can-event-dom-enter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar baseEventType = 'keyup';\n\nfunction isEnterEvent (event) {\n\tvar hasEnterKey = event.key === 'Enter';\n\tvar hasEnterCode = event.keyCode === 13;\n\treturn hasEnterKey || hasEnterCode;\n}\n\n/**\n * @module {events} can-event-dom-enter\n * @parent can-dom-utilities\n * @collection can-infrastructure\n * @group can-event-dom-enter.modules modules\n * @package ./package.json\n *\n * Watch for when enter keys are pressed on a DomEventTarget.\n *\n * ```js\n * var domEvents = require('can-dom-events');\n * var enterEvent = require('can-event-dom-enter');\n *\n * domEvents.addEvent(enterEvent);\n *\n * var input = document.createElement('input');\n * function enterEventHandler() {\n * \tconsole.log('enter key pressed');\n * }\n *\n * domEvents.addEventHandler(input, 'enter', enterEventHandler);\n * domEvents.dispatch(input, {\n *   type: 'keyup',\n *   keyCode: keyCode\n * });\n * ```\n */\nvar enterEvent = {\n\tdefaultEventType: 'enter',\n\n\taddEventListener: function (target, eventType, handler) {\n\t\tvar keyHandler = function (event) {\n\t\t\tif (isEnterEvent(event)) {\n\t\t\t\treturn handler.apply(this, arguments);\n\t\t\t}\n\t\t};\n\n\t\tvar handlerMap = enterEvent._eventTypeHandlerMap[eventType];\n\t\tif (!handlerMap) {\n\t\t\thandlerMap = enterEvent._eventTypeHandlerMap[eventType] = new Map();\n\t\t}\n\n\t\thandlerMap.set(handler, keyHandler);\n\t\tthis.addEventListener(target, baseEventType, keyHandler);\n\t},\n\n\tremoveEventListener: function (target, eventType, handler) {\n\t\tvar handlerMap = enterEvent._eventTypeHandlerMap[eventType];\n\t\tif (handlerMap) {\n\t\t\tvar keyHandler = handlerMap.get(handler);\n\t\t\tif (keyHandler) {\n\t\t\t\thandlerMap.delete(handler);\n\t\t\t\tif (handlerMap.size === 0) {\n\t\t\t\t\tdelete enterEvent._eventTypeHandlerMap[eventType];\n\t\t\t\t}\n\t\t\t\tthis.removeEventListener(target, baseEventType, keyHandler);\n\t\t\t}\n\t\t}\n\t},\n\n\t// {[eventType: string]: WeakMap<OriginalHandler, KeyEventHandler>}\n\t_eventTypeHandlerMap: {}\n};\n\nmodule.exports = namespace.domEventEnter = enterEvent;\n\n\n//# sourceURL=webpack:///./node_modules/can-event-dom-enter/can-event-dom-enter.js?");

/***/ }),

/***/ "./node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nfunction getRoot () {\n\treturn getDocument().documentElement;\n}\n\nfunction findParentForm (el) {\n\twhile (el) {\n\t\tif (el.nodeName === 'FORM') {\n\t\t\tbreak;\n\t\t}\n\t\tel = el.parentNode;\n\t}\n\treturn el;\n}\n\nfunction shouldReceiveEventFromRadio (source, dest) {\n\t// Must have the same name attribute and parent form\n\tvar name = source.getAttribute('name');\n\treturn (\n\t\tname &&\n\t\tname === dest.getAttribute('name') &&\n\t\tfindParentForm(source) === findParentForm(dest)\n\t);\n}\n\nfunction isRadioInput (el) {\n\treturn el.nodeName === 'INPUT' && el.type === 'radio';\n}\n\n\nfunction attachRootListener (domEvents, eventTypeTargets) {\n\tvar root = getRoot();\n\tvar newListener = function (event) {\n\t\tvar target = event.target;\n\t\tif (!isRadioInput(target)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var eventType in eventTypeTargets) {\n\t\t\tvar newEvent = {type: eventType};\n\t\t\tvar listeningNodes = eventTypeTargets[eventType];\n\t\t\tlisteningNodes.forEach(function (el) {\n\t\t\t\tif (shouldReceiveEventFromRadio(target, el)) {\n\t\t\t\t\tdomEvents.dispatch(el, newEvent, false);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\tdomEvents.addEventListener(root, 'change', newListener);\n\treturn newListener;\n}\n\nfunction detachRootListener (domEvents, listener) {\n\tvar root = getRoot();\n\tdomEvents.removeEventListener(root, 'change', listener);\n}\n\n/**\n * @module {events} can-event-dom-radiochange\n * @parent can-dom-utilities\n * @collection can-infrastructure\n * @package ./package.json\n *\n * A custom event for listening to changes of inputs with type \"radio\",\n * which fires when a conflicting radio input changes. A \"conflicting\"\n * radio button has the same \"name\" attribute and exists within in the\n * same form, or lack thereof. This event coordinates state bound to\n * whether a radio is checked. The \"change\" event does not fire for deselected\n * radios. By using this event instead, deselected radios receive notification.\n *\n * ```js\n * var domEvents = require('can-dom-events');\n * var radioChange = require('can-event-dom-radiochange');\n * domEvents.addEvent(radioChange);\n *\n * var target = document.createElement('input');\n *\n * function handler () {\n * \tconsole.log('radiochange event fired');\n * }\n *\n * domEvents.addEventListener(target, 'radiochange', handler);\n * domEvents.removeEventListener(target, 'radiochange', handler);\n * ```\n */\nvar radioChangeEvent = {\n\tdefaultEventType: 'radiochange',\n\n\taddEventListener: function (target, eventType, handler) {\n\t\tif (!isRadioInput(target)) {\n\t\t\tthrow new Error('Listeners for ' + eventType + ' must be radio inputs');\n\t\t}\n\n\t\tvar eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;\n\t\tif (!eventTypeTrackedRadios) {\n\t\t\teventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios = {};\n\t\t\tif (!radioChangeEvent._rootListener) {\n\t\t\t\tradioChangeEvent._rootListener = attachRootListener(this, eventTypeTrackedRadios);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tvar trackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType];\n\t\tif (!trackedRadios) {\n\t\t\ttrackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType] = new Set();\n\t\t}\n\n\t\ttrackedRadios.add(target);\n\t\ttarget.addEventListener(eventType, handler);\n\t},\n\n\tremoveEventListener: function (target, eventType, handler) {\n\t\ttarget.removeEventListener(eventType, handler);\n\n\t\tvar eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;\n\t\tif (!eventTypeTrackedRadios) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar trackedRadios = eventTypeTrackedRadios[eventType];\n\t\tif (!trackedRadios) {\n\t\t\treturn;\n\t\t}\n\t\n\t\ttrackedRadios.delete(target);\n\t\tif (trackedRadios.size === 0) {\n\t\t\tdelete eventTypeTrackedRadios[eventType];\n\t\t\tfor (var key in eventTypeTrackedRadios) {\n\t\t\t\tif (eventTypeTrackedRadios.hasOwnProperty(key)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\t\t\t\t\t\t\n\t\t\t}\n\t\t\tdelete radioChangeEvent._eventTypeTrackedRadios;\n\t\t\tdetachRootListener(this, radioChangeEvent._rootListener);\n\t\t\tdelete radioChangeEvent._rootListener;\n\t\t}\n\t}\n};\n\nmodule.exports = namespace.domEventRadioChange = radioChangeEvent;\n\n\n//# sourceURL=webpack:///./node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js?");

/***/ }),

/***/ "./node_modules/can-event-queue/dependency-record/merge.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-event-queue/dependency-record/merge.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar mergeValueDependencies = function mergeValueDependencies(obj, source) {\n\tvar sourceValueDeps = source.valueDependencies;\n\n\tif (sourceValueDeps) {\n\t\tvar destValueDeps = obj.valueDependencies;\n\n\t\t// make sure there is a valueDependencies Set\n\t\t// in the [obj] dependency record\n\t\tif (!destValueDeps) {\n\t\t\tdestValueDeps = new Set();\n\t\t\tobj.valueDependencies = destValueDeps;\n\t\t}\n\n\t\tcanReflect.eachIndex(sourceValueDeps, function(dep) {\n\t\t\tdestValueDeps.add(dep);\n\t\t});\n\t}\n};\n\nvar mergeKeyDependencies = function mergeKeyDependencies(obj, source) {\n\tvar sourcekeyDeps = source.keyDependencies;\n\n\tif (sourcekeyDeps) {\n\t\tvar destKeyDeps = obj.keyDependencies;\n\n\t\t// make sure there is a keyDependencies Map\n\t\t// in the [obj] dependency record\n\t\tif (!destKeyDeps) {\n\t\t\tdestKeyDeps = new Map();\n\t\t\tobj.keyDependencies = destKeyDeps;\n\t\t}\n\n\t\tcanReflect.eachKey(sourcekeyDeps, function(keys, obj) {\n\t\t\tvar entry = destKeyDeps.get(obj);\n\n\t\t\tif (!entry) {\n\t\t\t\tentry = new Set();\n\t\t\t\tdestKeyDeps.set(obj, entry);\n\t\t\t}\n\n\t\t\tcanReflect.eachIndex(keys, function(key) {\n\t\t\t\tentry.add(key);\n\t\t\t});\n\t\t});\n\t}\n};\n\n// Merges the key and value dependencies of the source object into the\n// destination object\nmodule.exports = function mergeDependencyRecords(object, source) {\n\tmergeKeyDependencies(object, source);\n\tmergeValueDependencies(object, source);\n\treturn object;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-event-queue/dependency-record/merge.js?");

/***/ }),

/***/ "./node_modules/can-event-queue/map/map.js":
/*!*************************************************!*\
  !*** ./node_modules/can-event-queue/map/map.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-event-queue/map/map\n * @parent can-event-queue\n * @templateRender true\n *\n * @description Mixin methods and symbols to make this object or prototype object\n * behave like a key-value observable.\n *\n * @signature `mixinMapBindings( obj )`\n *\n * Adds symbols and methods that make `obj` or instances having `obj` on their prototype\n * behave like key-value observables.\n *\n * When `mixinMapBindings` is called on an `obj` like:\n *\n * ```js\n * var mixinMapBindings = require(\"can-event-queue/map/map\");\n *\n * var observable = mixinValueBindings({});\n *\n * observable.on(\"prop\",function(ev, newVal, oldVal){\n *   console.log(newVal);\n * });\n *\n * observable[canSymbol.for(\"can.dispatch\")](\"prop\",[2,1]);\n * // Logs: 2\n * ```\n *\n * `mixinMapBindings` adds the following properties and symbols to the object:\n *\n * {{#each (getChildren [can-event-queue/map/map])}}\n * - [{{name}}] - {{description}}{{/each}}\n *\n * Furthermore, `mixinMapBindings` looks for the following symbols on the object's `.constructor`\n * property:\n *\n * - `@can.dispatchInstanceBoundChange` - Called when the bind status of an instance changes.\n * - `@can.dispatchInstanceOnPatches` - Called if [can-event-queue/map/map.dispatch] is called with `event.patches` as an array of\n *   patches.\n */\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"./node_modules/can-key-tree/can-key-tree.js\");\n\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"./node_modules/can-dom-events/can-dom-events.js\");\nvar isDomEventTarget = __webpack_require__(/*! can-dom-events/helpers/util */ \"./node_modules/can-dom-events/helpers/util.js\").isDomEventTarget;\n\nvar mergeDependencyRecords = __webpack_require__(/*! ../dependency-record/merge */ \"./node_modules/can-event-queue/dependency-record/merge.js\");\n\nvar metaSymbol = canSymbol.for(\"can.meta\"),\n\tdispatchBoundChangeSymbol = canSymbol.for(\"can.dispatchInstanceBoundChange\"),\n\tdispatchInstanceOnPatchesSymbol = canSymbol.for(\"can.dispatchInstanceOnPatches\"),\n\tonKeyValueSymbol = canSymbol.for(\"can.onKeyValue\"),\n\toffKeyValueSymbol = canSymbol.for(\"can.offKeyValue\"),\n\tonEventSymbol = canSymbol.for(\"can.onEvent\"),\n\toffEventSymbol = canSymbol.for(\"can.offEvent\"),\n\tonValueSymbol = canSymbol.for(\"can.onValue\"),\n\toffValueSymbol = canSymbol.for(\"can.offValue\"),\n\tinSetupSymbol = canSymbol.for(\"can.initializing\");\n\nvar legacyMapBindings;\n\nfunction addHandlers(obj, meta) {\n\tif (!meta.handlers) {\n\t\t// Handlers are organized by:\n\t\t// event name - the type of event bound to\n\t\t// binding type - \"event\" for things that expect an event object (legacy), \"onKeyValue\" for reflective bindings.\n\t\t// queue name - mutate, queue, etc\n\t\t// handlers - the handlers.\n\t\tmeta.handlers = new KeyTree([Object, Object, Object, Array], {\n\t\t\tonFirst: function() {\n\t\t\t\tif (obj._eventSetup !== undefined) {\n\t\t\t\t\tobj._eventSetup();\n\t\t\t\t}\n\t\t\t\tvar constructor = obj.constructor;\n\t\t\t\tif(constructor[dispatchBoundChangeSymbol] !== undefined && obj instanceof constructor) {\n\t\t\t\t\tconstructor[dispatchBoundChangeSymbol](obj, true);\n\t\t\t\t}\n\t\t\t\t//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [true]);\n\t\t\t},\n\t\t\tonEmpty: function() {\n\t\t\t\tif (obj._eventTeardown !== undefined) {\n\t\t\t\t\tobj._eventTeardown();\n\t\t\t\t}\n\t\t\t\tvar constructor = obj.constructor;\n\t\t\t\tif(constructor[dispatchBoundChangeSymbol] !== undefined && obj instanceof constructor) {\n\t\t\t\t\tconstructor[dispatchBoundChangeSymbol](obj, false);\n\t\t\t\t}\n\t\t\t\t//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [false]);\n\t\t\t}\n\t\t});\n\t}\n\n\tif (!meta.listenHandlers) {\n\t\t// context, eventName (might be undefined), queue, handlers\n\t\tmeta.listenHandlers = new KeyTree([Map, Map, Object, Array]);\n\t}\n}\n\n\n// getHandlers returns a KeyTree used for event handling.\n// `handlers` will be on the `can.meta` symbol on the object.\n// Ensure the \"obj\" passed as an argument has an object on @@can.meta\nvar ensureMeta = function ensureMeta(obj) {\n\tvar meta = obj[metaSymbol];\n\n\tif (!meta) {\n\t\tmeta = {};\n\t\tcanReflect.setKeyValue(obj, metaSymbol, meta);\n\t}\n\taddHandlers(obj, meta);\n\n\treturn meta;\n};\n\nfunction stopListeningArgumentsToKeys(bindTarget, event, handler, queueName) {\n\tif(arguments.length && canReflect.isPrimitive(bindTarget)) {\n\t\tqueueName = handler;\n\t\thandler = event;\n\t\tevent = bindTarget;\n\t\tbindTarget = this.context;\n\t}\n\tif(typeof event === \"function\") {\n\t\tqueueName = handler;\n\t\thandler = event;\n\t\tevent = undefined;\n\t}\n\tif(typeof handler === \"string\") {\n\t\tqueueName = handler;\n\t\thandler = undefined;\n\t}\n\tvar keys = [];\n\tif(bindTarget) {\n\t\tkeys.push(bindTarget);\n\t\tif(event || handler || queueName) {\n\t\t\tkeys.push(event);\n\t\t\tif(queueName || handler) {\n\t\t\t\tkeys.push(queueName || this.defaultQueue);\n\t\t\t\tif(handler) {\n\t\t\t\t\tkeys.push(handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn keys;\n}\n\n\n// These are the properties we are going to add to objects\nvar props = {\n\t/**\n\t * @function can-event-queue/map/map.dispatch dispatch\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Dispatch event and key binding handlers.\n\t *\n\t * @signature `obj.dispatch(event, [args])`\n\t *\n\t * Dispatches registered [can-event-queue/map/map.addEventListener] and\n\t * [can-event-queue/map/map.can.onKeyValue] value binding handlers.\n\t *\n\t * The following shows dispatching the `property` event and\n\t * `keyValue` handlers:\n\t *\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * obj.addEventListener(\"property\", function(event, newVal){\n\t *   event.type //-> \"property\"\n\t *   newVal     //-> 5\n\t * });\n\t *\n\t * canReflect.onKeyValue(\"property\", function(newVal){\n\t *   newVal     //-> 5\n\t * })\n\t *\n\t * obj.dispatch(\"property\", [5]);\n\t * ```\n\t *\n\t * > NOTE: Event handlers have an additional `event` argument.\n\t *\n\t * @param {String|Object} event The event to dispatch. If a string is passed,\n\t *   it will be used as the `type` of the event that will be dispatched and dispatch matching\n\t *   [can-event-queue/map/map.can.onKeyValue] bindings:\n\t *\n\t *   ```js\n\t *   obs.dispatch(\"key\")\n\t *   ```\n\t *\n\t *   If `event` is an object, it __MUST__ have a `type` property. The If a string is passed,\n\t *   it will be used as the `type` of the event that will be dispatched and dispatch matching\n\t *   [can-event-queue/map/map.can.onKeyValue] bindings:\n\t *\n\t *   ```js\n\t *   obs.dispatch({type: \"key\"})\n\t *   ```\n\t *\n\t *   The `event` object can also have the following properties and values:\n\t *   - __reasonLog__ `{Array}` - The reason this event happened. This will be passed to\n\t *     [can-queues.enqueueByQueue] for debugging purposes.\n\t *   - __makeMeta__ `{function}` - Details about the handler being called. This will be passed to\n\t *     [can-queues.enqueueByQueue] for debugging purposes.\n\t *   - __patches__ `{Array<Patch>}` - The patch objects this event represents.  The `.patches` value will be\n\t *     passed to the object's `.constructor`'s `@can.dispatchInstanceOnPatches` method.\n\t *\n\t * @param {Array} [args] Additional arguments to pass to event handlers.\n\t * @return {Object} event The resulting event object.\n\t */\n\tdispatch: function(event, args) {\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif (arguments.length > 4) {\n\t\t\t\tcanDev.warn('Arguments to dispatch should be an array, not multiple arguments.');\n\t\t\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\t\t}\n\n\t\t\tif (args && !Array.isArray(args)) {\n\t\t\t\tcanDev.warn('Arguments to dispatch should be an array.');\n\t\t\t\targs = [args];\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// Don't send events if initalizing.\n\t\tif (this.__inSetup !== true && this[inSetupSymbol] !== true) {\n\t\t\tif (typeof event === 'string') {\n\t\t\t\tevent = {\n\t\t\t\t\ttype: event\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar meta = ensureMeta(this);\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tif (!event.reasonLog) {\n\t\t\t\t\tevent.reasonLog = [canReflect.getName(this), \"dispatched\", '\"' + event.type + '\"', \"with\"].concat(args);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof meta._log === \"function\") {\n\t\t\t\tmeta._log.call(this, event, args);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar handlers = meta.handlers;\n\t\t\tvar handlersByType = event.type !== undefined && handlers.getNode([event.type]);\n\t\t\tvar dispatchConstructorPatches = event.patches && this.constructor[dispatchInstanceOnPatchesSymbol];\n\t\t\tvar patchesNode = event.patches !== undefined && handlers.getNode([\"can.patches\",\"onKeyValue\"]);\n\t\t\tvar keysNode = event.keyChanged !== undefined && handlers.getNode([\"can.keys\",\"onKeyValue\"]);\n\t\t\tvar batch = dispatchConstructorPatches || handlersByType || patchesNode || keysNode;\n\t\t\tif ( batch ) {\n\t\t\t\tqueues.batch.start();\n\t\t\t}\n\t\t\tif(handlersByType) {\n\t\t\t\tif (handlersByType.onKeyValue) {\n\t\t\t\t\tqueues.enqueueByQueue(handlersByType.onKeyValue, this, args, event.makeMeta, event.reasonLog);\n\t\t\t\t}\n\t\t\t\tif (handlersByType.event) {\n\t\t\t\t\tevent.batchNum = queues.batch.number();\n\t\t\t\t\tvar eventAndArgs = [event].concat(args);\n\t\t\t\t\tqueues.enqueueByQueue(handlersByType.event, this, eventAndArgs, event.makeMeta, event.reasonLog);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(keysNode) {\n\t\t\t\tqueues.enqueueByQueue(keysNode, this, [event.keyChanged], event.makeMeta, event.reasonLog);\n\t\t\t}\n\t\t\tif(patchesNode) {\n\t\t\t\tqueues.enqueueByQueue(patchesNode, this, [event.patches], event.makeMeta, event.reasonLog);\n\t\t\t}\n\t\t\tif(dispatchConstructorPatches) {\n\t\t\t\tthis.constructor[dispatchInstanceOnPatchesSymbol](this, event.patches);\n\t\t\t}\n\t\t\tif ( batch ) {\n\t\t\t\tqueues.batch.stop();\n\t\t\t}\n\t\t}\n\t\treturn event;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.addEventListener addEventListener\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `obj.addEventListener(eventName, handler(event, ...) [,queueName] )`\n\t *\n\t * Add a event listener to an object.  Handlers attached by `.addEventListener` get\n\t * called back with the [can-event-queue/map/map.dispatch]\n\t * `event` object and any arguments used to dispatch. [can-event-queue/map/map.can.onKeyValue] bindings do\n\t * not get the event object.\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * obj.addEventListener(\"foo\", function(event){ ... });\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to listen for.\n\t * @param {Function} handler(event,arg...) The handler that will be executed to handle the event.  The handler will be called\n\t *   with the dispatched `event` and `args`.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called\n\t *   back within. Defaults to `\"mutate\"`.\n\t * @return {Object} Returns the object `.addEventListener` was called on.\n\t *\n\t */\n\taddEventListener: function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.add([key, \"event\", queueName || \"mutate\", handler]);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.removeEventListener removeEventListener\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Unregister an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `obj.removeEventListener(eventName, [handler [,queueName]] )`\n\t *\n\t * Removes one or more handlers from being called when `eventName`\n\t * is [can-event-queue/map/map.dispatch]ed.\n\t *\n\t * ```js\n\t * // Removes `handler` if it is in the notify queue.\n\t * obj.removeEventListener(\"closed\", handler, \"notify\")\n\t *\n\t * // Removes `handler` if it is in the mutate queue.\n\t * obj.removeEventListener(\"closed\", handler)\n\t *\n\t * // Removes all \"closed\" handlers.\n\t * obj.removeEventListener(\"closed\")\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to remove. If not specified, all events are removed.\n\t * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `\"mutate\"`.\n\t * @return {Object} Returns the object `.removeEventListener` was called on.\n\t */\n\tremoveEventListener: function(key, handler, queueName) {\n\t\tif(key === undefined) {\n\t\t\t// This isn't super fast, but this pattern isn't used much.\n\t\t\t// We could re-arrange the tree so it would be faster.\n\t\t\tvar handlers = ensureMeta(this).handlers;\n\t\t\tvar keyHandlers = handlers.getNode([]);\n\t\t\tObject.keys(keyHandlers).forEach(function(key){\n\t\t\t\thandlers.delete([key,\"event\"]);\n\t\t\t});\n\t\t} else if (!handler && !queueName) {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\"]);\n\t\t} else if (!handler) {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\", queueName || \"mutate\"]);\n\t\t} else {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\", queueName || \"mutate\", handler]);\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.one one\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler that gets called only once.\n\t *\n\t * @signature `obj.one(event, handler(event, args...) )`\n\t *\n\t * Adds a basic event listener that listens to an event once and only once.\n\t *\n\t * ```js\n\t * obj.one(\"prop\", function(){\n\t *   console.log(\"prop dispatched\");\n\t * })\n\t *\n\t * obj[canSymbol.for(\"prop\")](\"prop\") //-> logs \"prop dispatched\"\n\t * obj[canSymbol.for(\"prop\")](\"prop\")\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to listen to.\n\t * @param {Function} handler(event, args...) The handler that will be run when the\n\t *   event is dispached.\n\t * @return {Object} this\n\t */\n\tone: function(event, handler) {\n\t\t// Unbind the listener after it has been executed\n\t\tvar one = function() {\n\t\t\tlegacyMapBindings.off.call(this, event, one);\n\t\t\treturn handler.apply(this, arguments);\n\t\t};\n\n\t\t// Bind the altered listener\n\t\tlegacyMapBindings.on.call(this, event, one);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.listenTo listenTo\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Listen to an event and register the binding for simplified unbinding.\n\t *\n\t * @signature `obj.listenTo([bindTarget,] event, handler)`\n\t *\n\t * `.listenTo` is useful for creating bindings that can can be torn down with\n\t * [can-event-queue/map/map.stopListening].  This is useful when creating\n\t * rich behaviors that can't be accomplished using computed values, or if you are trying to\n\t * avoid streams.\n\t *\n\t * For example, the following creates an observable that counts how many times its\n\t * `name` property has changed:\n\t *\n\t * ```js\n\t * class Person {\n\t *   constructor(){\n\t *     this.nameChanged = 0;\n\t *     this.listenTo(\"name\", function(){\n\t *       this.nameChanged++;\n\t *     })\n\t *   },\n\t *   setName(newVal) {\n\t *     this.name = newVal;\n\t *     this.dispatch(\"name\",[newVal])\n\t *   }\n\t * }\n\t * mixinMapBindings(Person.prototype);\n\t *\n\t * var person = new Person();\n\t * person.setName(\"Justin\");\n\t * person.setName(\"Ramiya\");\n\t * person.nameChanged //-> 2\n\t * ```\n\t *\n\t * `.listenTo` event bindings are stored on an observable and MUST be unbound using\n\t * [can-event-queue/map/map.stopListening]. `.stopListening` make it easy to unbind\n\t * all of the `.listenTo` event bindings when the observable is no longer needed:\n\t *\n\t * ```js\n\t * person.stopListening();\n\t * ```\n\t *\n\t * If no `bindTarget` is passed, `.listenTo` binds to the current\n\t * observable.\n\t *\n\t * [can-component]'s `connectedCallback` lifecyle hook is often used to call\n\t * `.listenTo` to setup bindings that update viewmodel properties.\n\t *\n\t *\n\t * @param {Object} [bindTarget] The object to listen for events on.  If `bindTarget` is not provided,\n\t * the observable `.listenTo` was called on will be the `bindTarget`.\n\t * @param {String} event The name of the event to listen for.\n\t * @param {Function} handler The handler that will be executed to handle the event.\n\t * @return {Object} this\n\t */\n\tlistenTo: function (bindTarget, event, handler, queueName) {\n\n\t\tif(canReflect.isPrimitive(bindTarget)) {\n\t\t\tqueueName = handler;\n\t\t\thandler = event;\n\t\t\tevent = bindTarget;\n\t\t\tbindTarget = this;\n\t\t}\n\n\t\tif(typeof event === \"function\") {\n\t\t\tqueueName = handler;\n\t\t\thandler = event;\n\t\t\tevent = undefined;\n\t\t}\n\n\t\t// Initialize event cache\n\t\tensureMeta(this).listenHandlers.add([bindTarget, event, queueName || \"mutate\", handler]);\n\n\t\tlegacyMapBindings.on.call(bindTarget, event, handler, queueName || \"mutate\");\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.stopListening stopListening\n\t * @parent can-event-queue/map/map\n\t * @description Stops listening for registered event handlers.\n\t *\n\t * @signature `obj.stopListening( [bindTarget], [event,] handler]] )`\n\t *\n\t * `.stopListening` unbinds on event handlers registered through\n\t * [can-event-queue/map/map.listenTo]. All event handlers\n\t * that match the arguments will be unbound. For example:\n\t *\n\t * ```js\n\t * // Unbinds all .listenTo registered handlers\n\t * obj.stopListening()\n\t *\n\t * // Unbinds all .listenTo registered with `bindTarget`\n\t * obj.stopListening(bindTarget)\n\t *\n\t * // Unbinds all .listenTo registered with `bindTarget`, `event`\n\t * obj.stopListening(bindTarget, event)\n\t *\n\t * // Unbinds the handler registered with `bindTarget`, `event`, `handler`\n\t * obj.stopListening(bindTarget, event, handler)\n\t * ```\n\t *\n\t * `.listenTo` is often returned by [can-component]'s `connectedCallback` lifecyle hook.\n\t *\n\t * @param {Object} [bindTarget] The object we will stop listening to event on. If `bindTarget` is\n\t * not provided, the observable `.stopListening` was called on will be the `bindTarget`.\n\t * @param {String} [event] The name of the event to listen for.\n\t * @param {Function} [handler] The handler that will be executed to handle the event.\n\t * @return {Object} this\n\t *\n\t */\n\tstopListening: function () {\n\t\tvar keys = stopListeningArgumentsToKeys.apply({context: this, defaultQueue: \"mutate\"}, arguments);\n\n\t\tvar listenHandlers = ensureMeta(this).listenHandlers;\n\n\t\tfunction deleteHandler(bindTarget, event, queue, handler){\n\t\t\tlegacyMapBindings.off.call(bindTarget, event, handler, queue);\n\t\t}\n\t\tlistenHandlers.delete(keys, deleteHandler);\n\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.on on\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description A shorthand method for listening to event.\n\t *\n\t * @signature `obj.on( event, handler [, queue] )`\n\t *\n\t * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]\n\t * change, or a [can-reflect/observe.onValue] change in that order.\n\t *\n\t * As this is the __legacy__ `.on`, it will look for an `.addEventListener`\n\t * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]\n\t * and then [can-symbol/symbols/onValue] symbol.\n\t *\n\t * @param {String} eventName\n\t * @param {Function} handler\n\t * @param {String} [queue]\n\t * @return {Any} The object `on` was called on.\n\t */\n\ton: function(eventName, handler, queue) {\n\t\tvar listenWithDOM = isDomEventTarget(this);\n\t\tif (listenWithDOM) {\n\t\t\tif (typeof handler === 'string') {\n\t\t\t\tdomEvents.addDelegateListener(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tdomEvents.addEventListener(this, eventName, handler, queue);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this[onEventSymbol]) {\n\t\t\t\tthis[onEventSymbol](eventName, handler, queue);\n\t\t\t} else if (\"addEventListener\" in this) {\n\t\t\t\tthis.addEventListener(eventName, handler, queue);\n\t\t\t} else if (this[onKeyValueSymbol]) {\n\t\t\t\tcanReflect.onKeyValue(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tif (!eventName && this[onValueSymbol]) {\n\t\t\t\t\tcanReflect.onValue(this, handler, queue);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"can-event-queue: Unable to bind \" + eventName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.off off\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description A shorthand method for unbinding an event.\n\t *\n\t * @signature `obj.on( event, handler [, queue] )`\n\t *\n\t * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]\n\t * change, or a [can-reflect/observe.onValue] change in that order.\n\t *\n\t * As this is the __legacy__ `.on`, it will look for an `.addEventListener`\n\t * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]\n\t * and then [can-symbol/symbols/onValue] symbol.\n\t *\n\t * @param {String} eventName\n\t * @param {Function} handler\n\t * @param {String} [queue]\n\t * @return {Any} The object `on` was called on.\n\t */\n\toff: function(eventName, handler, queue) {\n\t\tvar listenWithDOM = isDomEventTarget(this);\n\t\tif (listenWithDOM) {\n\t\t\tif (typeof handler === 'string') {\n\t\t\t\tdomEvents.removeDelegateListener(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tdomEvents.removeEventListener(this, eventName, handler, queue);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this[offEventSymbol]) {\n\t\t\t\tthis[offEventSymbol](eventName, handler, queue);\n\t\t\t} else if (\"removeEventListener\" in this) {\n\t\t\t\tthis.removeEventListener(eventName, handler, queue);\n\t\t\t} else if (this[offKeyValueSymbol]) {\n\t\t\t\tcanReflect.offKeyValue(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tif (!eventName && this[offValueSymbol]) {\n\t\t\t\t\tcanReflect.offValue(this, handler, queue);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"can-event-queue: Unable to unbind \" + eventName);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n};\n\n// The symbols we'll add to objects\nvar symbols = {\n\t/**\n\t * @function can-event-queue/map/map.can.onKeyValue @can.onKeyValue\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler to be called when a key value changes.\n\t *\n\t * @signature `canReflect.onKeyValue( obj, key, handler(newVal) [,queueName] )`\n\t *\n\t * Add a key change handler to an object.  Handlers attached by `.onKeyValue` get\n\t * called back with the new value of the `key`. Handlers attached with [can-event-queue/map/map.can.addEventListener]\n\t * get the event object.\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * canReflect.onKeyValue( obj, \"prop\", function(newPropValue){ ... });\n\t * ```\n\t *\n\t * @param {String} key The name of property to listen to changes in values.\n\t * @param {Function} handler(newVal, oldValue) The handler that will be called\n\t *   back with the new and old value of the key.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called\n\t *   back within. Defaults to `\"mutate\"`.\n\t */\n\t\"can.onKeyValue\": function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.add([key, \"onKeyValue\", queueName || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.offKeyValue @can.offKeyValue\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Unregister an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `canReflect.offKeyValue( obj, key, handler, queueName )`\n\t *\n\t * Removes a handlers from being called when `key` changes are\n\t * [can-event-queue/map/map.dispatch]ed.\n\t *\n\t * ```js\n\t * // Removes `handler` if it is in the notify queue.\n\t * canReflect.offKeyValue( obj, \"prop\", handler, \"notify\" )\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to remove. If not specified, all events are removed.\n\t * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `\"mutate\"`.\n\t */\n\t\"can.offKeyValue\": function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.delete([key, \"onKeyValue\", queueName || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.isBound @can.isBound\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Return if the observable is bound to.\n\t *\n\t * @signature `canReflect.isBound(obj)`\n\t *\n\t * The `@can.isBound` symbol is added to make [can-reflect/observe.isBound]\n\t * return if `obj` is bound or not.\n\t *\n\t * @return {Boolean} True if the observable has been bound to with `.onKeyValue` or `.addEventListener`.\n\t */\n\t\"can.isBound\": function() {\n\t\treturn !ensureMeta(this).handlers.isEmpty();\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.getWhatIChange @can.getWhatIChange\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Return observables whose values are affected by attached event handlers\n\t * @signature `@can.getWhatIChange(key)`\n\t *\n\t * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report\n\t * all the observables whose values are set by a given observable's key.\n\t *\n\t * This function iterates over the event handlers attached to a given `key` and\n\t * collects the result of calling `@@can.getChangesDependencyRecord` on each handler;\n\t * this symbol allows the caller to tell what observables are being mutated by\n\t * the event handler when it is executed.\n\t *\n\t * In the following example a [can-simple-map] instance named `me` is created\n\t * and when its `age` property changes, the value of a [can-simple-observable]\n\t * instance is set. The event handler that causes the mutation is then decatorated\n\t * with `@@can.getChangesDependencyRecord` to register the mutation dependency.\n\t *\n\t * ```js\n\t * var obs = new SimpleObservable(\"a\");\n\t * var me = new SimpleMap({ age: 30 });\n\t * var canReflect = require(\"can-reflect\");\n\t *\n\t * var onAgeChange = function onAgeChange() {\n\t *\tcanReflect.setValue(obs, \"b\");\n\t * };\n\t *\n\t * onAgeChange[canSymbol.for(\"can.getChangesDependencyRecord\")] = function() {\n\t *\treturn {\n\t *\t\tvalueDependencies: new Set([ obs ]);\n\t *\t}\n\t * };\n\t *\n\t * canReflect.onKeyValue(me, \"age\", onAgeChange);\n\t * me[canSymbol.for(\"can.getWhatIChange\")](\"age\");\n\t * ```\n\t *\n\t * The dependency records collected from the event handlers are divided into\n\t * two categories:\n\t *\n\t * - mutate: Handlers in the mutate/domUI queues\n\t * - derive: Handlers in the notify queue\n\t *\n\t * Since event handlers are added by default to the \"mutate\" queue, calling\n\t * `@@can.getWhatIChange` on the `me` instance returns an object with a mutate\n\t * property and the `valueDependencies` Set registered on the `onAgeChange`\n\t * handler.\n\t *\n\t * Please check out the [can-reflect-dependencies] docs to learn more about\n\t * how this symbol is used to keep track of custom observable dependencies.\n\t */\n\t\"can.getWhatIChange\": function getWhatIChange(key) {\n\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\tvar whatIChange = {};\n\t\t\tvar meta = ensureMeta(this);\n\n\t\t\tvar notifyHandlers = [].concat(\n\t\t\t\tmeta.handlers.get([key, \"event\", \"notify\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"notify\"])\n\t\t\t);\n\n\t\t\tvar mutateHandlers = [].concat(\n\t\t\t\tmeta.handlers.get([key, \"event\", \"mutate\"]),\n\t\t\t\tmeta.handlers.get([key, \"event\", \"domUI\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"mutate\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"domUI\"])\n\t\t\t);\n\n\t\t\tif (notifyHandlers.length) {\n\t\t\t\tnotifyHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.derive;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.derive = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (mutateHandlers.length) {\n\t\t\t\tmutateHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.mutate;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.mutate = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Object.keys(whatIChange).length ? whatIChange : undefined;\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t\"can.onPatches\": function(handler, queue) {\n\t\tvar handlers = ensureMeta(this).handlers;\n\t\thandlers.add([\"can.patches\", \"onKeyValue\", queue || \"notify\", handler]);\n\t},\n\t\"can.offPatches\": function(handler, queue) {\n\t\tvar handlers = ensureMeta(this).handlers;\n\t\thandlers.delete([\"can.patches\", \"onKeyValue\", queue || \"notify\", handler]);\n\t}\n};\n\n// This can be removed in a future version.\nfunction defineNonEnumerable(obj, prop, value) {\n\tObject.defineProperty(obj, prop, {\n\t\tenumerable: false,\n\t\tvalue: value\n\t});\n}\n\n// The actual legacyMapBindings mixin function\nlegacyMapBindings = function(obj) {\n\t// add properties\n\tcanReflect.assignMap(obj, props);\n\t// add symbols\n\treturn canReflect.assignSymbols(obj, symbols);\n};\n\ndefineNonEnumerable(legacyMapBindings, \"addHandlers\", addHandlers);\ndefineNonEnumerable(legacyMapBindings, \"stopListeningArgumentsToKeys\", stopListeningArgumentsToKeys);\n\n\n\n// ## LEGACY\n// The following is for compatability with the old can-event\nprops.bind = props.addEventListener;\nprops.unbind = props.removeEventListener;\n\n\n\n// Adds methods directly to method so it can be used like `can-event` used to be used.\ncanReflect.assignMap(legacyMapBindings, props);\ncanReflect.assignSymbols(legacyMapBindings, symbols);\n\ndefineNonEnumerable(legacyMapBindings, \"start\", function() {\n\tconsole.warn(\"use can-queues.batch.start()\");\n\tqueues.batch.start();\n});\ndefineNonEnumerable(legacyMapBindings, \"stop\", function() {\n\tconsole.warn(\"use can-queues.batch.stop()\");\n\tqueues.batch.stop();\n});\ndefineNonEnumerable(legacyMapBindings, \"flush\", function() {\n\tconsole.warn(\"use can-queues.flush()\");\n\tqueues.flush();\n});\n\ndefineNonEnumerable(legacyMapBindings, \"afterPreviousEvents\", function(handler) {\n\tconsole.warn(\"don't use afterPreviousEvents\");\n\tqueues.mutateQueue.enqueue(function afterPreviousEvents() {\n\t\tqueues.mutateQueue.enqueue(handler);\n\t});\n\tqueues.flush();\n});\n\ndefineNonEnumerable(legacyMapBindings, \"after\", function(handler) {\n\tconsole.warn(\"don't use after\");\n\tqueues.mutateQueue.enqueue(handler);\n\tqueues.flush();\n});\n\nmodule.exports = legacyMapBindings;\n\n\n//# sourceURL=webpack:///./node_modules/can-event-queue/map/map.js?");

/***/ }),

/***/ "./node_modules/can-event-queue/type/type.js":
/*!***************************************************!*\
  !*** ./node_modules/can-event-queue/type/type.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-event-queue/type/type\n * @parent can-event-queue\n *\n * @description Mixin methods and symbols to make a type constructor function able to\n * broadcast changes in its instances.\n *\n * @signature `mixinTypeBindings( type )`\n *\n * Adds symbols and methods that make `type` work with the following [can-reflect] APIs:\n *\n * - [can-reflect/observe.onInstanceBoundChange] - Observe when instances are bound.\n * - [can-reflect/observe.onInstancePatches] - Observe patche events on all instances.\n *\n * When `mixinTypeBindings` is called on an `Person` _type_ like:\n *\n * ```js\n * var mixinTypeBindings = require(\"can-event-queue/type/type\");\n * var mixinLegacyMapBindings = require(\"can-event-queue/map/map\");\n *\n * class Person {\n *   constructor(data){\n *     this.data = data;\n *   }\n * }\n * mixinTypeBindings(Person);\n * mixinLegacyMapBindings(Person.prototype);\n *\n * var me = new Person({first: \"Justin\", last: \"Meyer\"});\n *\n * // mixinTypeBindings allows you to listen to\n * // when a person instance's bind stache changes\n * canReflect.onInstanceBoundChange(Person, function(person, isBound){\n *    console.log(\"isBound\");\n * });\n *\n * // mixinTypeBindings allows you to listen to\n * // when a patch change happens.\n * canReflect.onInstancePatches(Person, function(person, patches){\n *    console.log(patches[0]);\n * });\n *\n * me.on(\"name\",function(ev, newVal, oldVal){}) //-> logs: \"isBound\"\n *\n * me.dispatch({\n *   type: \"first\",\n *   patches: [{type: \"set\", key: \"first\", value: \"Ramiya\"}]\n * }, [\"Ramiya\",\"Justin\"])\n * //-> logs: {type: \"set\", key: \"first\", value: \"Ramiya\"}\n * ```\n *\n */\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"./node_modules/can-key-tree/can-key-tree.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\n\nvar metaSymbol = canSymbol.for(\"can.meta\");\n\nfunction addHandlers(obj, meta) {\n    if (!meta.lifecycleHandlers) {\n        meta.lifecycleHandlers = new KeyTree([Object, Array]);\n    }\n    if (!meta.instancePatchesHandlers) {\n        meta.instancePatchesHandlers = new KeyTree([Object, Array]);\n    }\n}\n\nfunction ensureMeta(obj) {\n    var meta = obj[metaSymbol];\n\n    if (!meta) {\n        meta = {};\n        canReflect.setKeyValue(obj, metaSymbol, meta);\n    }\n\n    addHandlers(obj, meta);\n    return meta;\n}\n\nvar props = {\n    /**\n     * @function can-event-queue/type/type.can.onInstanceBoundChange @can.onInstanceBoundChange\n     * @parent can-event-queue/type/type\n     * @description Listen to when any instance is bound for the first time or all handlers are removed.\n     *\n     * @signature `canReflect.onInstanceBoundChange(Type, handler(instance, isBound) )`\n     *\n     * ```js\n     * canReflect.onInstanceBoundChange(Person, function(person, isBound){\n     *    console.log(\"isBound\");\n     * });\n     * ```\n     *\n     * @param {function(Any,Boolean)} handler(instance,isBound) A function is called\n     * when an instance is bound or unbound.  `isBound` will be `true` when the instance\n     * becomes bound and `false` when unbound.\n     */\n\n    /**\n     * @function can-event-queue/type/type.can.offInstanceBoundChange @can.offInstanceBoundChange\n     * @parent can-event-queue/type/type\n     *\n     * @description Stop listening to when an instance's bound status changes.\n     *\n     * @signature `canReflect.offInstanceBoundChange(Type, handler )`\n     *\n     * Stop listening to a handler bound with\n     * [can-event-queue/type/type.can.onInstanceBoundChange].\n     */\n\n\n    /**\n     * @function can-event-queue/type/type.can.onInstancePatches @can.onInstancePatches\n     * @parent can-event-queue/type/type\n     *\n     * @description Listen to patch changes on any instance.\n     *\n     * @signature `canReflect.onInstancePatches(Type, handler(instance, patches) )`\n     *\n     * Listen to patch changes on any instance of `Type`. This is used by\n     * [can-connect] to know when a potentially `unbound` instance's `id`\n     * changes. If the `id` changes, the instance can be moved into the store\n     * while it is being saved.\n     *\n     */\n\n    /**\n     * @function can-event-queue/type/type.can.offInstancePatches @can.offInstancePatches\n     * @parent can-event-queue/type/type\n     *\n     * @description Stop listening to patch changes on any instance.\n     *\n     * @signature `canReflect.onInstancePatches(Type, handler )`\n     *\n     * Stop listening to a handler bound with [can-event-queue/type/type.can.onInstancePatches].\n     */\n};\n\nfunction onOffAndDispatch(symbolName, dispatchName, handlersName){\n    props[\"can.on\"+symbolName] = function(handler, queueName) {\n        ensureMeta(this)[handlersName].add([queueName || \"mutate\", handler]);\n    };\n    props[\"can.off\"+symbolName] = function(handler, queueName) {\n        ensureMeta(this)[handlersName].delete([queueName || \"mutate\", handler]);\n    };\n    props[\"can.\"+dispatchName] = function(instance, arg){\n        queues.enqueueByQueue(ensureMeta(this)[handlersName].getNode([]), this, [instance, arg]);\n    };\n}\n\nonOffAndDispatch(\"InstancePatches\",\"dispatchInstanceOnPatches\",\"instancePatchesHandlers\");\nonOffAndDispatch(\"InstanceBoundChange\",\"dispatchInstanceBoundChange\",\"lifecycleHandlers\");\n\nfunction mixinTypeBindings(obj){\n    return canReflect.assignSymbols(obj,props);\n}\n\nObject.defineProperty(mixinTypeBindings, \"addHandlers\", {\n    enumerable: false,\n    value: addHandlers\n});\n\nmodule.exports = mixinTypeBindings;\n\n\n//# sourceURL=webpack:///./node_modules/can-event-queue/type/type.js?");

/***/ }),

/***/ "./node_modules/can-event-queue/value/value.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-event-queue/value/value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"./node_modules/can-key-tree/can-key-tree.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"./node_modules/can-define-lazy-value/define-lazy-value.js\");\nvar mergeDependencyRecords = __webpack_require__(/*! ../dependency-record/merge */ \"./node_modules/can-event-queue/dependency-record/merge.js\");\n\nvar properties = {\n\t/**\n\t * @function can-event-queue/value/value.on on\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Listen to changes in the observable's value.\n\t *\n\t * @signature `.on( handler[, queue='mutate'] )`\n\t *\n\t * This adds an event handler in the observable's [can-event-queue/value/value.handlers]\n\t * tree. If this is the first handler, the observable's [can-event-queue/value/value.onBound] method is called.\n\t *\n\t * ```js\n\t * observable.on(function(newVal){ ... });\n\t * observable.on(function(newVal){ ... }, \"notify\");\n\t * ```\n\t *\n\t * @param {function(*)} handler(newValue,oldValue) A handler that will be called with the new value of the\n\t * observable and optionally the old value of the observable.\n\t * @param {String} [queue] The [can-queues] queue this event handler should be bound to.  By default the handler will\n\t * be called within the `mutate` queue.\n\t */\n\ton: function(handler, queue) {\n\t\tthis.handlers.add([queue || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/value/value.off off\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Stop listening to changes in the observable's value.\n\t *\n\t * @signature `.off( [handler [, queue='mutate']] )`\n\t *\n\t * Removes one or more event handler in the observable's [can-event-queue/value/value.handlers]\n\t * tree. If the las handler is removed, the observable's [can-event-queue/value/value.onUnbound] method is called.\n\t *\n\t * ```js\n\t * observable.off(function(newVal){ ... });\n\t * observable.off(function(newVal){ ... }, \"notify\");\n\t * observable.off();\n\t * observable.off(undefined, \"mutate\");\n\t * ```\n\t *\n\t * @param {function(*)} handler(newValue,oldValue) The handler to be removed.  If no handler is provided and no\n\t * `queue` is provided, all handlers will be removed.\n\t * @param {String} [queue] The [can-queues] queue this event handler should be removed from.\n\t *\n\t *  If a `handler` is\n\t *  provided and no `queue` is provided, the `queue` will default to `\"mutate\"`.\n\t *\n\t *   If a `handler` is not provided, but a `queue` is provided, all handlers for the provided queue will be\n\t *   removed.\n\t */\n\toff: function(handler, queueName) {\n\t\tif (handler === undefined) {\n\t\t\tif (queueName === undefined) {\n\t\t\t\tthis.handlers.delete([]);\n\t\t\t} else {\n\t\t\t\tthis.handlers.delete([queueName]);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.handlers.delete([queueName || \"mutate\", handler]);\n\t\t}\n\t}\n};\n\nvar symbols = {\n\t/**\n\t * @function can-event-queue/value/value.can.onValue @can.onValue\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Listen to changes in this observable value.\n\t *\n\t * This is an alias for [can-event-queue/value/value.on].  It satisfies [can-reflect].[can-reflect/observe.onValue].\n\t */\n\t\"can.onValue\": properties.on,\n\t/**\n\t * @function can-event-queue/value/value.can.offValue @can.offValue\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Stop listening to changes in this observable value.\n\t *\n\t * This is an alias for [can-event-queue/value/value.off].  It satisfies [can-reflect].[can-reflect/observe.offValue].\n\t */\n\t\"can.offValue\": properties.off,\n\t/**\n\t * @function can-event-queue/value/value.can.dispatch @can.dispatch\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Dispatch all event handlers within their appropriate queues.\n\t *\n\t * @signature `@can.dispatch(newValue, oldValue)`\n\t *\n\t * This is a helper method that will dispatch all [can-event-queue/value/value.handlers] within\n\t * their appropriate [can-queues] queue.\n\t *\n\t * Furthermore, it will make sure the handlers include useful meta data for debugging.\n\t *\n\t * ```js\n\t * var observable = mixinValueBindings({});\n\t * observable[canSymbol.for(\"can.dispatch\")]( 2, 1 );\n\t * ```\n\t *\n\t * @param {Any} newValue The new value of the observable.\n\t * @param {Any} oldValue The old value of the observable.\n\t */\n\t\"can.dispatch\": function(value, old) {\n\t\tvar queuesArgs = [];\n\t\tqueuesArgs = [\n\t\t\tthis.handlers.getNode([]),\n\t\t\tthis,\n\t\t\t[value, old]\n\t\t];\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\tthis,\n\t\t\t\t[value, old]\n\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t, null\n\t\t\t\t, [canReflect.getName(this), \"changed to\", value, \"from\", old]\n\t\t\t\t/* jshint laxcomma: false */\n\t\t\t];\n\t\t}\n\t\t//!steal-remove-end\n\t\tqueues.enqueueByQueue.apply(queues, queuesArgs);\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\tthis._log(old, value);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-event-queue/value/value.can.getWhatIChange @can.getWhatIChange\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Return observables whose values are affected by attached event handlers\n\t * @signature `@can.getWhatIChange()`\n\t *\n\t * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report\n\t * all the observables whose values are set by value-like observables.\n\t *\n\t * This function iterates over the event handlers attached to  the observable's value\n\t * event and collects the result of calling `@@can.getChangesDependencyRecord` on each\n\t * handler; this symbol allows the caller to tell what observables are being mutated\n\t * by the event handler when it is executed.\n\t *\n\t * In the following example a [can-simple-observable] instance named `month` is\n\t * created and when its value changes the `age` property of the `map` [can-simple-map]\n\t * instance is set. The event handler that causes the mutation is then decatorated with\n\t * `@@can.getChangesDependencyRecord` to register the mutation dependency.\n\t *\n\t * ```js\n\t * var month = new SimpleObservable(11);\n\t * var map = new SimpleMap({ age: 30 });\n\t * var canReflect = require(\"can-reflect\");\n\t *\n\t * var onValueChange = function onValueChange() {\n\t *\tmap.set(\"age\", 31);\n\t * };\n\t *\n\t * onValueChange[canSymbol.for(\"can.getChangesDependencyRecord\")] = function() {\n\t *\treturn {\n\t *\t\tkeyDependencies: new Map([ [map, new Set([\"age\"])] ])\n\t *\t}\n\t * };\n\t *\n\t * canReflect.onValue(month, onValueChange);\n\t * month[canSymbol.for(\"can.getWhatIChange\")]();\n\t * ```\n\t *\n\t * The dependency records collected from the event handlers are divided into\n\t * two categories:\n\t *\n\t * - mutate: Handlers in the mutate/domUI queues\n\t * - derive: Handlers in the notify queue\n\t *\n\t * Since event handlers are added by default to the \"mutate\" queue, calling\n\t * `@@can.getWhatIChange` on the `month` instance returns an object with a mutate\n\t * property and the `keyDependencies` Map registered on the `onValueChange` handler.\n\t *\n\t * If multiple event handlers were attached to `month`, the dependency records\n\t * of each handler are merged by `@@can.getWhatIChange`. Please check out the\n\t * [can-reflect-dependencies] docs to learn more about how this symbol is used\n\t * to keep track of custom observable dependencies.\n\t */\n\t\"can.getWhatIChange\": function getWhatIChange() {\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tvar whatIChange = {};\n\n\t\t\tvar notifyHandlers = this.handlers.get([\"notify\"]);\n\t\t\tvar mutateHandlers = [].concat(\n\t\t\t\tthis.handlers.get([\"mutate\"]),\n\t\t\t\tthis.handlers.get([\"domUI\"]),\n\t\t\t\tthis.handlers.get([\"dom\"])\n\t\t\t);\n\n\t\t\tif (notifyHandlers.length) {\n\t\t\t\tnotifyHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.derive;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.derive = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (mutateHandlers.length) {\n\t\t\t\tmutateHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.mutate;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.mutate = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Object.keys(whatIChange).length ? whatIChange : undefined;\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\n\t/**\n\t * @function can-event-queue/value/value.can.isBound @can.isBound\n\t * @parent can-event-queue/value/value\n\t */\n\t\"can.isBound\": function isBound() {\n\t\treturn !this.handlers.isEmpty();\n\t}\n};\n\n/**\n * @property {can-key-tree} can-event-queue/value/value.handlers handlers\n * @parent can-event-queue/value/value\n *\n * @description Access the handlers tree directly.\n *\n * @type {can-key-tree}\n *\n *  The handlers property is a [can-define-lazy-value lazily] defined property containing\n *  all handlers bound with [can-event-queue/value/value.on] and\n *  [can-event-queue/value/value.can.onValue].  It is a [can-key-tree] defined like:\n *\n *  ```js\n *  this.handlers = new KeyTree([Object, Array])\n *  ```\n *\n *  It is configured to call [can-event-queue/value/value.onBound] and\n *  [can-event-queue/value/value.onUnbound] on the instances when the first item is\n *  added to the tree and when the tree is emptied.\n */\nfunction defineLazyHandlers(){\n\treturn new KeyTree([Object, Array], {\n\t\tonFirst: this.onBound !== undefined && this.onBound.bind(this),\n\t\tonEmpty: this.onUnbound !== undefined && this.onUnbound.bind(this)\n\t});\n}\n\n/**\n * @function can-event-queue/value/value.onBound onBound\n * @parent can-event-queue/value/value\n *\n * @description Perform operations when an observable is gains its first event handler.\n *\n * @signature `.onBound()`\n *\n * This method is not implemented by `can-event-queue/value/value`. Instead, the object\n * should implement it if it wants to perform some actions when it becomes bound.\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({\n *   onBound: function(){\n *     console.log(\"I AM BOUND!\");\n *   }\n * });\n *\n * observable.on(function(){});\n * // Logs: \"I AM BOUND!\"\n * ```\n *\n */\n\n/**\n * @function can-event-queue/value/value.onUnbound onUnbound\n * @parent can-event-queue/value/value\n *\n * @description Perform operations when an observable loses all of its event handlers.\n *\n * @signature `.onBound()`\n *\n * This method is not implemented by `can-event-queue/value/value`. Instead, the object\n * should implement it if it wants to perform some actions when it becomes unbound.\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({\n *   onUnbound: function(){\n *     console.log(\"I AM UNBOUND!\");\n *   }\n * });\n * var handler = function(){}\n * observable.on(function(){});\n * observable.off(function(){});\n * // Logs: \"I AM UNBOUND!\"\n * ```\n */\n\n/**\n * @module {function} can-event-queue/value/value\n * @parent can-event-queue\n *\n * @description Mixin methods and symbols to make this object or prototype object\n * behave like a single-value observable.\n *\n * @signature `mixinValueBindings( obj )`\n *\n * Adds symbols and methods that make `obj` or instances having `obj` on their prototype\n * behave like single-value observables.\n *\n * When `mixinValueBindings` is called on an `obj` like:\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({});\n *\n * observable.on(function(newVal, oldVal){\n *   console.log(newVal);\n * });\n *\n * observable[canSymbol.for(\"can.dispatch\")](2,1);\n * // Logs: 2\n * ```\n *\n * `mixinValueBindings` adds the following properties and symbols to the object:\n *\n * - [can-event-queue/value/value.on]\n * - [can-event-queue/value/value.off]\n * - [can-event-queue/value/value.can.dispatch]\n * - [can-event-queue/value/value.can.getWhatIChange]\n * - [can-event-queue/value/value.handlers]\n *\n * When the object is bound to for the first time with `.on` or `@can.onValue`, it will look for an [can-event-queue/value/value.onBound]\n * function on the object and call it.\n *\n * When the object is has no more handlers, it will look for an [can-event-queue/value/value.onUnbound]\n * function on the object and call it.\n */\nvar mixinValueEventBindings = function(obj) {\n\tcanReflect.assign(obj, properties);\n\tcanReflect.assignSymbols(obj, symbols);\n\tdefineLazyValue(obj,\"handlers\",defineLazyHandlers, true);\n\treturn obj;\n};\n\n// callbacks is optional\nmixinValueEventBindings.addHandlers = function(obj, callbacks) {\n\tconsole.warn(\"can-event-queue/value: Avoid using addHandlers. Add onBound and onUnbound methods instead.\");\n\tobj.handlers = new KeyTree([Object, Array], callbacks);\n\treturn obj;\n};\n\nmodule.exports = mixinValueEventBindings;\n\n\n//# sourceURL=webpack:///./node_modules/can-event-queue/value/value.js?");

/***/ }),

/***/ "./node_modules/can-fixture-socket/can-fixture-socket.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-fixture-socket/can-fixture-socket.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar fixtureSocket = __webpack_require__(/*! ./src/index */ \"./node_modules/can-fixture-socket/src/index.js\");\nvar fixtureStore = __webpack_require__(/*! ./src/store */ \"./node_modules/can-fixture-socket/src/store.js\");\n\nmodule.exports = {\n\tServer: fixtureSocket.Server,\n\trequestHandlerToListener: fixtureStore.requestHandlerToListener,\n\tstoreToListeners: fixtureStore.storeToListeners\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-fixture-socket/can-fixture-socket.js?");

/***/ }),

/***/ "./node_modules/can-fixture-socket/src/feathers-client.js":
/*!****************************************************************!*\
  !*** ./node_modules/can-fixture-socket/src/feathers-client.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * FEATHERS protocol.\n * Feathers service api (REST provider): https://docs.feathersjs.com/rest/readme.html\n * \n * \n * - Common Error Response Packet:\n * REQ: 422[\"messages::get\",111,{}]\n * RES: 432[{\"stack\":\"NotFound: No record found for id '111' ...\",\"message\":\"No record found for id '111'\",\"type\":\"FeathersError\",\"name\":\"NotFound\",\"code\":404,\"className\":\"not-found\",\"errors\":{}}]\n * \n * \n * - socket.emit('messages::find', {}, function(error, data){});\n * REQ: 421[\"messages::find\",{\"$sort\":{\"createdAt\":-1},\"$limit\":10}]\n * RES: 434[null,{\"total\":10,\"limit\":5,\"skip\":0,\"data\":[]}]\n * \n * \n * - socket.emit('messages::get', 'uOybkd5RVe5wKoxy', {}, function(error, data){});\n * REQ: 422[\"messages::get\",\"uOybkd5RVe5wKoxy\",{}]\n * RES: 432[null,{\"text\":\"Hello from cmd!\",\"createdAt\":1475294332699,\"_id\":\"uOybkd5RVe5wKoxy\"}]\n * \n * \n * - socket.emit('messages::create', {text: 'New message'}, {}, function(error, data){});\n * REQ: 422[\"messages::create\",{\"text\":\"new message\"},{}]\n * RES: 432[null,{\"text\":\"new message\",\"userId\":\"Ke8I0Kmn0lCyrEaq\",\"createdAt\":1476722319537,\"_id\":\"ttnWkW4YhGRc1CDM\",\"sentBy\":{\"email\":\"fadeev.ilya@gmail.com\",\"password\":\"$2a$10$QqI4Uamr/mTH8P/.W0TNTuofjRuNDZLuyNaQzl3vHXhpzrWBwCo7q\",\"avatar\":\"https://s.gravatar.com/avatar/44751bab986933e4405394fb32d6b91d?s=60\",\"_id\":\"Ke8I0Kmn0lCyrEaq\"}}]\n * EXT: 42[\"messages created\",{\"text\":\"new message\",\"userId\":\"Ke8I0Kmn0lCyrEaq\",\"createdAt\":1476722319537,\"_id\":\"ttnWkW4YhGRc1CDM\",\"sentBy\":{\"email\":\"fadeev.ilya@gmail.com\",\"password\":\"$2a$10$QqI4Uamr/mTH8P/.W0TNTuofjRuNDZLuyNaQzl3vHXhpzrWBwCo7q\",\"avatar\":\"https://s.gravatar.com/avatar/44751bab986933e4405394fb32d6b91d?s=60\",\"_id\":\"Ke8I0Kmn0lCyrEaq\"}}]\n * \n * \n * - socket.emit('messages::remove', 'yDLARueVwSF0S6v8', {}, function(error, data){});\n * REQ: 422[\"messages::remove\",\"yDLARueVwSF0S6v8\",{}]\n * RES: 432[null,{\"text\":\"helllllo\",\"userId\":\"Ke8I0Kmn0lCyrEaq\",\"createdAt\":1476722461622,\"_id\":\"yDLARueVwSF0S6v8\"}]\n * EXT: 42[\"messages removed\",{\"text\":\"helllllo\",\"userId\":\"Ke8I0Kmn0lCyrEaq\",\"createdAt\":1476722461622,\"_id\":\"yDLARueVwSF0S6v8\"}]\n * \n * \n * - socket.emit('messages::update', 'ttnWkW4YhGRc1CDM', {}, function(error, data){});\n * REQ: 422[\"messages::update\",\"ttnWkW4YhGRc1CDM\",{\"text\":\"Updated text!\"},{}]\n * RES: 432[null,{\"text\":\"Updated text!\",\"_id\":\"ttnWkW4YhGRc1CDM\"}]\n * EXT: 42 [\"messages updated\",{\"text\":\"Updated text!\",\"_id\":\"ttnWkW4YhGRc1CDM\"}]\n * \n */\n\nvar storeToListeners = __webpack_require__(/*! ./store */ \"./node_modules/can-fixture-socket/src/store.js\").storeToListeners;\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\n/**\n * Subscribes to mocked socket server events for FeathersJS service.\n * Transforms ((query, fn))\n * @param serviceName\n * @param fixtureStore\n * @param mockServer\n * @param options\n * @returns {*}\n * @hide\n *\n * fixture.store data:\n * \t\tgetListData: {}\n */\nfunction subscribeFeathersStoreToServer(serviceName, fixtureStore, mockServer, options){\n\tvar listeners = storeToListeners(fixtureStore);\n\tmockServer.on(serviceName + '::find', toFeathersDataHandler(listeners.getListData, null, toFeathersFind));\n\tmockServer.on(serviceName + '::get', toFeathersDataHandler(listeners.getData, wrapToId(options), null));\n\t\n\t// fixture.store.destroyData returns back the passed set, e.g. {id: 1}\n\t// https://github.com/canjs/can-connect/blob/master/data/memory-cache/memory-cache.js#L416\n\t// Feathers.remove returns back the whole object.\n\tmockServer.on(serviceName + '::remove', toFeathersRemoveHandler(listeners.getData, listeners.destroyData, options));\n\t\n\tmockServer.on(serviceName + '::create', toFeathersCreateHandler(listeners.createData));\n\tmockServer.on(serviceName + '::update', toFeathersUpdateHandler(listeners.updateData, options));\n}\n\nfunction toFeathersDataHandler(method, queryTransformer, dataTransformer){\n\treturn function(query){\n\t\tvar args = Array.prototype.slice.call(arguments),\n\t\t\tfn;\n\t\tif (typeof args[args.length-1] === 'function'){\n\t\t\tfn = args[args.length-1];\n\t\t}\n\t\tquery = queryTransformer ? queryTransformer(query) : query;\n\t\tmethod(query, function(err, data){\n\t\t\tif (err){\n\t\t\t\tfn && fn(err);\n\t\t\t} else {\n\t\t\t\tdata = dataTransformer ? dataTransformer(data) : data;\n\t\t\t\tfn && fn(null, data);\n\t\t\t}\n\t\t})\n\t}\n}\n/**\n * Wraps given id into an object with property name `id` (or options.id).\n * @param options\n * @returns {Function}\n * @hide\n */\nfunction wrapToId(options){\n\treturn function(id){\n\t\tvar o = {},\n\t\t\tidProp = options && options.id || 'id';\n\t\to[idProp] = id;\n\t\treturn o;\n\t}\n}\n\n/**\n * Transforms getListData from fixture to feathers format.\n *   - fixture.store.getListData: {count, limit, offset, data}\n *   - feathers.find:             {total, limit, skip, data}\n * @param data\n * @returns {{total: number, limit: number, skip: number, data: *}}\n */\n// fixture.store.getListData: {count, limit, offset, data}\n// feathers.find:             {total, limit, skip, data}\nfunction toFeathersFind(data){\n\treturn {\n\t\ttotal: data.count,\n\t\tlimit: data.limit,\n\t\tskip: data.offset,\n\t\tdata: data.data\n\t};\n}\n\n/**\n * FeathersJS's `remove` method returns the whole item back, when fixture.store's `destroyData` gives back only the given query (e.g. {id: 123}).\n * Find the item by id first, then remove from fixture.store and return the item back.\n * \n * Feathers `remove` method emits 2 arguments with data: `id` and `query`. But we ignore 2nd data argument for now.\n * \n * @param destroyData The wrapped fixture.store.destroyData method.\n * @param getData The wrapped fixture.store.getData method.\n * @returns {Function}\n * @hide\n */\nfunction toFeathersRemoveHandler(getData, destroyData, options){\n\treturn function(id, query, fn){\n\t\tvar setQuery = wrapToId(options)(id);\n\t\tgetData(setQuery, function(err, item){\n\t\t\tif (err){\n\t\t\t\tfn(err);\n\t\t\t} else {\n\t\t\t\tdestroyData(setQuery, function(err, data){\n\t\t\t\t\tif (err){\n\t\t\t\t\t\tfn(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfn(null, item);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\nfunction toFeathersUpdateHandler(updateData, options){\n\treturn function(id, data, query, fn){\n\t\tvar setQuery = wrapToId(options)(id);\n\t\tupdateData(assign(setQuery, data), function(err, data2){\n\t\t\tif (err){\n\t\t\t\tfn(err);\n\t\t\t} else {\n\t\t\t\tfn(null, assign(setQuery, assign(data, data2)));\n\t\t\t}\n\t\t});\n\t}\n}\nfunction toFeathersCreateHandler(createData){\n\treturn function(data, query, fn){\n\t\tcreateData(data, function(err, data2){\n\t\t\tif (err){\n\t\t\t\tfn(err);\n\t\t\t} else {\n\t\t\t\tfn(null, assign(data, data2));\n\t\t\t}\n\t\t});\n\t}\n}\n\nmodule.exports = {\n\tsubscribeFeathersStoreToServer: subscribeFeathersStoreToServer\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-fixture-socket/src/feathers-client.js?");

/***/ }),

/***/ "./node_modules/can-fixture-socket/src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/can-fixture-socket/src/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Summary: `io(url)` creates an instance of `io.Manager` for the given url and stores it in cache of managers `io.managers`.\n * If `io` is called with the same URL several times it will lookup Manager in the cache.\n * One manager creates one physical (transport) connection and can create several \"virtual\" connections within\n * the transport connection.\n * Manager has two main methods: `open` (alias `connect`) and `socket`. The first one establishes a transport connection\n * (e.g. http://localhost), the second one creates a socket.io connection (e.g. http://localhost/users).\n *\n * To fixture socket.io we need to:\n *   - mock a socket server;\n *   - override io.Manager.prototype methods to work with the mocked server.\n */\n\nvar subscribeFeathersStoreToServer = __webpack_require__(/*! ./feathers-client */ \"./node_modules/can-fixture-socket/src/feathers-client.js\").subscribeFeathersStoreToServer;\n\n/* \n * See/update `docs/can-fixture-socket.server.md`.\n *\n * Mocked socket.io server that intercepts socket.io connection and can simulate socket.io server behaviour.\n * @constructor\n * @param {Object} io Imported `socket.io-client` object.\n */\nvar MockedServer = function(io){\n\tthis.io = io;\n\t\n\t// PubSub:\n\tthis.events = {};\n\tthis.subscribers = {};\n\n\t// SocketIO stores an instantiated Manager in cache to reuse it for the same URL.\n\t// Reset cache of managers since we override Manager prototype to work with this particular instance of the mocked server:\n\tresetManagerCache(io.managers);\n\n\t// Override Manager's prototype:\n\tthis.origs = mockManager(io.Manager.prototype, this);\n};\n\n/**\n * @function can-fixture-socket.Server.prototype.on on\n * @parent can-fixture-socket.Server.prototype\n * \n * Adds a socket event listener.\n * \n * @signature `server.on(event, handler)`\n * \n * Adds a socket event listener.\n * \n * ```js\n * server.on(\"notifications\", function(data, ackFn){\n *   console.log(\"Received \" + data);\n *   ackFn(\"Acknowledged, thank you\");\n * });\n * ```\n * \n *   @param {string} event The name of the socket event to listen for.\n *   @param {can-fixture-socket.socket-event-listener} handler The handler that will be executed to handle the socket event.\n * \n * @signature `server.on(eventsObject)`\n * \n * A short hand method to add multiple event listeners.\n * \n * ```js\n * server.on({\n *   \"news\": handleNews,\n *   \"tweets\": handleTweets,\n *   \"users\": handleUsers\n * });\n * ```\n * \n *   @param {object} eventsObject \n */\nMockedServer.prototype.on = function(event, cb){\n\tvar self = this;\n\tvar events = {};\n\tif (typeof event === 'string'){\n\t\tevents[event] = cb;\n\t}\n\tif (typeof event === 'object'){\n\t\tevents = event;\n\t}\n\tObject.keys(events).forEach(function(name){\n\t\tsub(self.events,  name, events[name]);\n\t})\n};\n\n/**\n * @function can-fixture-socket.Server.prototype.emit emit\n * @parent can-fixture-socket.Server.prototype\n * \n * Emits a socket event.\n *\n * @signature `server.emit(event, ...data, [ackFn])`\n *\n * Emits a socket event.\n *\n * ```js\n * server.emit(\"news\", data1, data2, function(ackData){\n *   console.log(\"Client acknowledged\", ackData);\n * });\n * ```\n *\n *   @param {string} event The name of the socket event.\n *   @param {*} data Data to be sent with the event. Socket.io allows to send more than one data objects.\n *   @param {function} [ackFn] The acknowledgement function that will be executed if the receiver calls the acknowledgement callback.\n */\nMockedServer.prototype.emit = function(event){\n\tvar dataArgs = Array.prototype.slice.call(arguments, 1);\n\tpub(this.subscribers, event, dataArgs);\n};\n\n/* \n * See/update `docs/can-fixture-socket.on-feathers-service.md`.\n * \n * Subscribes to mocked server socket events to work as FeathersJS CRUD service. Uses fixture store [can-fixture.Store] as a resource storage.\n * \n * @param {String} name The name of Feathers service.\n * @param {can-fixture.Store} fixtureStore An instance of [can-fixture.Store].\n * @param {Object} [options] Options, e.g. property name for id.\n */\nMockedServer.prototype.onFeathersService = function(serviceName, fixtureStore, options){\n\tsubscribeFeathersStoreToServer(serviceName, fixtureStore, this, options);\n};\n\n/**\n * @function can-fixture-socket.Server.prototype.restore restore\n * @parent can-fixture-socket.Server.prototype\n * \n * @signature `server.restore()`\n * \n * Restores `io.Manager.prototype` and clears `io.managers` cache.\n * \n * ```\n * server.restore();\n * ```\n */\nMockedServer.prototype.restore = function(){\n\trestoreManager(this.io.Manager.prototype, this.origs);\n\tresetManagerCache(this.io.managers);\n};\n\n/*\n * @constructor can-fixture-socket.Socket Socket\n * @private\n * @parent can-fixture-socket.types\n * \n * @signature `new Socket(server)`\n * \n * Manager instantiates Socket. We mock Socket's methods to work with the mocked server instance.\n * \n *   @param {can-fixture-socket.Server} server Mocked server.\n */\nvar MockedSocket = function(server){\n\tthis._server = server;\n\tthis.io = {\n\t\tengine: this\n\t};\n};\nMockedSocket.prototype = {\n\ton: function(event, cb){\n\t\tdebug('MockedSocket.on ... ' + event);\n\t\tsub(this._server.subscribers, event, cb);\n\t},\n\t/*\n\t * The first argument is always `event`\n\t * The middle arguments are data (usually one or two arguments).\n\t * If the last argument is a function then its the ACK callback.\n     */\n\temit: function(event){\n\t\tvar dataArgs = Array.prototype.slice.call(arguments, 1);\n\t\tdebug('MockedSocket.emit ...' + event);\n\t\tpub(this._server.events, event, dataArgs);\n\t},\n\tonce: function(){\n\t\tdebug('MockedSocket.once ...');\n\t},\n\toff: function(event, cb){\n\t\tdebug('MockedSocket.off ... ' + event);\n\t\tunsub(this._server.subscribers, event, cb);\n\t},\n\topen: function(){\n\t\treturn this.connect();\n\t},\n\tconnect: function(){\n\t\tthis.connected = true;\n\t\tthis.disconnected = false;\n\t},\n\tclose: function(){\n\t\treturn this.disconnect();\n\t},\n\tdisconnect: function(){\n\t\tthis.connected = false;\n\t\tthis.disconnected = true;\n\t},\n};\n\n/*\n * PubSub helpers.\n * @param pubsub A list of pubs or subs.\n * @param event {String} A name for a pubsub item (e.g. a name of event that we emit or subscribe to).\n * @param dataArgs There could be either one or more data arguments (e.g. FeathersJS) and the last argument can be used for ACK callback. \n */\nfunction pub(pubsub, event, dataArgs){\n\tdebug(' >>> pub ' + event, dataArgs);\n\t// Feathers does not emit the event and path like `messages::find` anymore\n\t// The `path` or `serviceName` is now the first argument after the `event`\n\tif (dataArgs && typeof dataArgs[0] === 'string' && pubsub[dataArgs[0] + '::' + event]) {\n\t\tevent = dataArgs.shift() + '::' + event;\n\t}\n\tvar subscribers = pubsub[event] || [];\n\tsubscribers.forEach(function(subscriber){\n\t\tsubscriber.apply(null, dataArgs);\n\t});\n}\nfunction sub(pubsub, event, cb){\n\tdebug(' <<< sub ' + event);\n\tif (!pubsub[event]){\n\t\tpubsub[event] = [];\n\t}\n\tpubsub[event].push(cb);\n}\nfunction unsub(pubsub, event, cb){\n\tdebug(' <<< unsub ' + event);\n\tpubsub[event].forEach(function(registeredCb, index){\n\t\tif(registeredCb === cb){\n\t\t\tpubsub[event].splice(index, 1);\n\t\t}\n\t});\n}\n\n/*\n * Override Manager.prototype's method to work with the instantiated mocked server.\n * @param managerProto\n * @param server\n * @returns {Array}\n */\nfunction mockManager(managerProto, server){\n\t// We need to override `open` and `socket` methods:\n\tvar methods = ['open','socket'];\n\tvar origs = methods.map(function(name){\n\t\treturn {\n\t\t\tname: name,\n\t\t\tmethod: managerProto[name]\n\t\t};\n\t});\n\tmanagerProto.open = managerProto.connect = function(){\n\t\tdebug('MockedManager.prototype.open or connect ... arguments:', arguments);\n\t\tsetTimeout(function(){\n\t\t\tpub(server.subscribers, 'connect');\n\t\t\tpub(server.events, 'connection');\n\t\t}, 0);\n\t};\n\tmanagerProto.socket = function(){\n\t\tdebug('MockedManager.prototype.socket ...');\n\t\tvar socket = new MockedSocket(server);\n\t\tsocket.connected = true;\n\t\tsocket.disconnected = false;\n\t\treturn socket;\n\t};\n\treturn origs;\n}\n\n/*\n * Restore Manager prototype.\n * @param managerProto\n * @param origs\n */\nfunction restoreManager(managerProto, origs){\n\tdebug('Restore.');\n\torigs.forEach(function(orig){\n\t\tmanagerProto[orig.name] = orig.method;\n\t});\n}\n\n/*\n * We need to reset cache of Managers so that the new mocked server would create a new Manager for the same URL.\n * @param cache\n */\nfunction resetManagerCache(cache){\n\tfor (var i in cache){\n\t\tif (cache.hasOwnProperty(i)){\n\t\t\tdelete cache[i];\n\t\t}\n\t}\n}\n\nvar _DEBUG = false;\nfunction debug(msg, obj){\n\tif (_DEBUG){\n\t\tconsole.log.apply(console, arguments);\n\t}\n}\n\nmodule.exports = {\n\tServer: MockedServer,\n\tmockSocketManager: mockManager,\n\trestoreManager: restoreManager\n};\n\n\n\n\n//# sourceURL=webpack:///./node_modules/can-fixture-socket/src/index.js?");

/***/ }),

/***/ "./node_modules/can-fixture-socket/src/store.js":
/*!******************************************************!*\
  !*** ./node_modules/can-fixture-socket/src/store.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar extractResponse = __webpack_require__(/*! can-fixture/core */ \"./node_modules/can-fixture/core.js\").extractResponse;\n\n/**\n * @function can-fixture-socket.requestHandlerToListener requestHandlerToListener\n * @parent can-fixture-socket.properties\n * \n * Transforms XHR request handler into socket event listener.\n * \n * @signature `requestHandlerToListener( reqHandler )`\n *\n * Transforms request handler that expects two arguments `request` and `response` into socket event listener.\n * \n * ```js\n * server.on(\"news find\", requestHandlerToListener( fixtureStore.getListData ));\n * ```\n *     \n * @param {Function} reqHandler A request handler, e.g. [can-fixture/StoreType.prototype.getListData].\n * @returns {can-fixture-store.socket-event-listener}\n * \n * @body\n * \n * ## Use\n *\n * Fixture [can-fixture.store] methods expect two arguments `req` and `res` and work like this:\n *   - grab query from `req.data`;\n *   - on error call `res( 403, err )`;\n *   - on success call `res( data )`.\n *   \n * The format of the returned data is:\n *   - for [can-fixture/StoreType.prototype.getDataList]: {count: <number>, limit: <number>, offset: <number> , data: [{...},{...}, ...]}\n *   - for [can-fixture/StoreType.prototype.getData]: the item object.\n * \n * We can use the helper to transform fixture store methods into event listeners:\n * ```js\n * var fixture = require(\"can-fixture\");\n * var canSet = require(\"can-set\");\n * var io = require(\"socket.io-client\");\n * var fixtureSocket = require(\"can-fixture-socket\");\n * \n * // Create fixture store:\n * var fixtureStore = fixture.store([\n *   {id: 1, title: 'One'},\n *   {id: 2, title: 'Two'},\n *   {id: 3, title: 'Three'}\n * ], new canSet.Algebra({}));\n * \n * var mockedServer = new fixtureSocket.Server(io);\n * mockedServer.on(\"books find\", fixtureStore.requestHandlerToListener( fixtureStore.getListData ));\n * ```\n */\nfunction requestHandlerToListener(method){\n\treturn function(query, fn){\n\t\tvar req = {data: query};\n\t\tvar res = function(){\n\t\t\tvar response = extractResponse.apply(null, arguments);\n\t\t\tif (response[0] === 200){\n\t\t\t\tfn(null, response[1]);\n\t\t\t} else {\n\t\t\t\tfn(response[1]);\n\t\t\t}\n\t\t};\n\t\tmethod(req, res);\n\t}\n}\n\n/**\n * @function can-fixture-socket.storeToListeners storeToListeners\n * @parent can-fixture-socket.properties\n * \n * Returns a set of listeners transformed from fixture store request handlers. Useful for working with REST-ful resources.\n * \n * @signature `storeToListeners( fixtureStore )`\n * \n * Wraps methods of fixture.store to make them socket event listener.\n * \n * ```js\n * var listeners = storeToListeners( fixtureStore );\n * \n * server.on({\n *   \"news find\": listeners.getListData,\n *   \"news get\": listeners.getData,\n * })\n * ```\n * \n * @param fixtureStore\n * @returns {*}\n * \n * @body\n * \n * ## Use\n * \n * Fixture [can-fixture.store] provides REST-ful resource storage. Its designed to work with XHR requests thus its methods expect two arguments `request` and `response`. To work with socket events we need to transform request handlers into socket event listeners.\n * \n * Here is how we can do this:\n * \n * ```js\n * var fixture = require(\"can-fixture\");\n * var canSet = require(\"can-set\");\n * var io = require(\"socket.io-client\");\n * var fixtureSocket = require(\"can-fixture-socket\");\n *\n * // Create fixture store:\n * var fixtureStore = fixture.store([\n *   {id: 1, title: 'One'},\n *   {id: 2, title: 'Two'},\n *   {id: 3, title: 'Three'}\n * ], new canSet.Algebra({}));\n * \n * // Instantiate mocked socket server:\n * var mockedServer = new fixtureSocket.Server(io);\n * \n * // Now use fixture store to emulate REST-ful service:\n * var toListener = fixtureStore.requestHandlerToListener;\n * mockedServer.on({\n *   \"books find\":   toListener( fixtureStore.getListData ),\n *   \"books get\":    toListener( fixtureStore.getData ),\n *   \"books create\": toListener( fixtureStore.createData ),\n *   \"books update\": toListener( fixtureStore.updateData ),\n *   \"books delete\": toListener( fixtureStore.destroyData )\n * });\n * ```\n */\nfunction storeToListeners(fixtureStore){\n\tvar methods = ['getListData', 'getData', 'updateData', 'createData', 'destroyData'];\n\treturn methods.reduce(function(listeners, method){\n\t\tlisteners[method] = requestHandlerToListener(fixtureStore[method]);\n\t\treturn listeners;\n\t}, {});\n}\n\nmodule.exports = {\n\trequestHandlerToListener: requestHandlerToListener,\n\tstoreToListeners: storeToListeners\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-fixture-socket/src/store.js?");

/***/ }),

/***/ "./node_modules/can-fixture/core.js":
/*!******************************************!*\
  !*** ./node_modules/can-fixture/core.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// Adds\nvar sub = __webpack_require__(/*! can-key/sub/sub */ \"./node_modules/can-key/sub/sub.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar matches = __webpack_require__(/*! ./matches */ \"./node_modules/can-fixture/matches.js\");\nvar canLog = __webpack_require__(/*! can-log */ \"./node_modules/can-log/can-log.js\");\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar dataFromUrl = __webpack_require__(/*! ./data-from-url */ \"./node_modules/can-fixture/data-from-url.js\");\n\n__webpack_require__(/*! ./store */ \"./node_modules/can-fixture/store.js\");\n\nvar fixtures = [];\nexports.fixtures = fixtures;\n\nfunction isStoreLike (fixture) {\n\treturn fixture && (fixture.getData || fixture.getListData);\n}\n\nvar methodMapping = {\n\titem: {\n\t\t'GET': 'getData',\n\t\t'PUT': 'updateData',\n\t\t'DELETE': 'destroyData',\n\t},\n\tlist: {\n\t\t'GET': 'getListData',\n\t\t'POST': 'createData'\n\t}\n};\n\nfunction getMethodAndPath (route) {\n\t// Match URL if it has GET, POST, PUT, DELETE or PATCH.\n\tvar matches = route.match(/(GET|POST|PUT|DELETE|PATCH) (.+)/i);\n\tif (!matches) {\n\t\treturn [undefined, route];\n\t}\n\tvar method = matches[1];\n\tvar path = matches[2];\n\treturn [method, path];\n}\n\nfunction inferIdProp (url) {\n\tvar wrappedInBraces = /\\{(.*)\\}/;\n\tvar matches = url.match(wrappedInBraces);\n\tvar isUniqueMatch = matches && matches.length === 2;\n\tif (isUniqueMatch) {\n\t\treturn matches[1];\n\t}\n}\n\nfunction getItemAndListUrls (url, idProp) {\n\tidProp = idProp || inferIdProp(url);\n\tif (!idProp) {\n\t\treturn [undefined, url];\n\t}\n\tvar itemRegex = new RegExp('\\\\/\\\\{' + idProp+\"\\\\}.*\" );\n\tvar rootIsItemUrl = itemRegex.test(url);\n\tvar listUrl = rootIsItemUrl ? url.replace(itemRegex, \"\") : url;\n\tvar itemUrl = rootIsItemUrl ? url : (url.trim() + \"/{\" + idProp + \"}\");\n\treturn [itemUrl, listUrl];\n}\n\nfunction addStoreFixture (root, store) {\n\tvar settings = {};\n\tvar typeAndUrl = getMethodAndPath(root);\n\tvar type = typeAndUrl[0];\n\tvar url = typeAndUrl[1];\n\n\tvar itemAndListUrls = getItemAndListUrls(url, store.idProp);\n\tvar itemUrl = itemAndListUrls[0];\n\tvar listUrl = itemAndListUrls[1];\n\n\tif (type) {\n\t\tvar warning = [\n\t\t\t'fixture(\"' + root + '\", fixture) must use a store method, not a store directly.',\n\t\t];\n\t\tif (itemUrl) {\n\t\t\tvar itemAction = methodMapping.item[type];\n\t\t\tif (itemAction) {\n\t\t\t\tsettings[type + ' ' + itemUrl] = store[itemAction];\n\t\t\t\tvar itemWarning = 'Replace with fixture(\"' + type + ' ' + itemUrl + '\", fixture.' + itemAction + ') for items.';\n\t\t\t\twarning.push(itemWarning);\n\t\t\t}\n\t\t}\n\t\tvar listAction = methodMapping.list[type];\n\t\tif (listAction) {\n\t\t\tsettings[type + ' ' + listUrl] = store[listAction];\n\t\t\tvar listWarning = 'Replace with fixture(\"' + type + ' ' + listUrl + '\", fixture.' + listAction + ') for lists.';\n\t\t\twarning.push(listWarning);\n\t\t}\n\t\tvar message = warning.join(' ');\n\t\tcanDev.warn(message);\n\t} else {\n\t\tvar itemMapping = methodMapping.item;\n\t\tfor (var itemMethod in itemMapping) {\n\t\t\tvar storeItemMethod = itemMapping[itemMethod];\n\t\t\tsettings[itemMethod + ' ' + itemUrl] = store[storeItemMethod];\n\t\t}\n\t\tvar listMapping = methodMapping.list;\n\t\tfor (var listMethod in listMapping) {\n\t\t\tvar storeListMethod = listMapping[listMethod];\n\t\t\tsettings[listMethod + ' ' + listUrl] = store[storeListMethod];\n\t\t}\n\t}\n\n\treturn settings;\n}\n\nfunction getSettingsFromString (route) {\n\tvar typeAndUrl = getMethodAndPath(route);\n\tvar type = typeAndUrl[0];\n\tvar url = typeAndUrl[1];\n\tif (type) {\n\t\treturn {\n\t\t\ttype: type,\n\t\t\turl: url\n\t\t};\n\t}\n\treturn {\n\t\turl: url\n\t};\n}\n\n// Check if the same fixture was previously added, if so, we remove it\n// from our array of fixture overwrites.\nfunction upsertFixture (fixtureList, settings, fixture) {\n\tvar index = exports.index(settings, true);\n\tvar oldFixture;\n\tif (index > -1) {\n\t\toldFixture = fixtures.splice(index, 1);\n\t}\n\tif (fixture == null) {\n\t\treturn oldFixture;\n\t}\n\tif(typeof fixture === \"object\") {\n\t\tvar data = fixture;\n\t\tfixture = function(){\n\t\t\treturn data;\n\t\t};\n\t}\n\tsettings.fixture = fixture;\n\tfixtures.unshift(settings);\n\treturn oldFixture;\n}\n\n// Adds a fixture to the list of fixtures.\nexports.add = function (settings, fixture) {\n\t// If a fixture isn't provided, we assume that settings is\n\t// an array of fixtures, and we should iterate over it, and set up\n\t// the new fixtures.\n\tif (fixture === undefined) {\n\t\tvar oldFixtures = [];\n\t\tif(Array.isArray(settings)) {\n\t\t\tcanReflect.eachIndex(settings, function(ajaxSettings){\n\t\t\t\tvar fixture = ajaxSettings.fixture;\n\t\t\t\tajaxSettings = canReflect.assignMap({}, ajaxSettings);\n\t\t\t\tdelete ajaxSettings.fixture;\n\t\t\t\treturn exports.add(ajaxSettings, fixture);\n\t\t\t});\n\t\t} else {\n\t\t\tcanReflect.eachKey(settings, function (fixture, url) {\n\t\t\t\toldFixtures = oldFixtures.concat(exports.add(url, fixture));\n\t\t\t});\n\t\t\treturn oldFixtures;\n\t\t}\n\t}\n\n\t// When a fixture is passed a store like:\n\t// `fixture(\"/things/{id}\", store)`\n\tif (isStoreLike(fixture)) {\n\t\tsettings = addStoreFixture(settings, fixture);\n\t\treturn exports.add(settings);\n\t}\n\n\tif (typeof settings === 'string') {\n\t\tsettings = getSettingsFromString(settings);\n\t}\n\treturn upsertFixture(fixtures, settings, fixture);\n};\n\nvar $fixture = exports.add;\n$fixture.on = true;\n$fixture.delay =10;\n\nfunction FixtureResponse(fixture, response){\n\tthis.statusCode= response[0];\n\tthis.responseBody= response[1];\n\tthis.headers= response[2];\n\tthis.statusText= response[3];\n\tthis.fixture= fixture;\n}\n\n// Calls a dynamic fixture and calls `cb` with the response data.\nexports.callDynamicFixture = function(xhrSettings, fixtureSettings, cb){\n\t// this is for legacy.  In the future, people should get it from fixtureSettings probably.\n\txhrSettings.data = fixtureSettings.data;\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tvar json = JSON.stringify(xhrSettings.data);\n\t\tcanLog.log(\"\" + xhrSettings.type.toUpperCase() + \" \" + xhrSettings.url+\" \"+json.substr(0,50)+\" -> handler(req,res)\");\n\t}\n\t//!steal-remove-end\n\n\tvar response = function(){\n\t\tvar res = exports.extractResponse.apply(xhrSettings, arguments);\n\t\t//!steal-remove-start\n\t\tcanLog.log(\"can-fixture: \" + xhrSettings.type.toUpperCase() + \" \" + xhrSettings.url+\" \",xhrSettings.data,\" => \",new FixtureResponse(fixtureSettings.fixture,res));\n\t\t//!steal-remove-end\n\t\treturn cb.apply(this, res);\n\t};\n\tvar callFixture = function () {\n\t\t// fall the fixture\n\t\tvar result = fixtureSettings.fixture(xhrSettings, response, xhrSettings.headers, fixtureSettings);\n\n\t\tif (canReflect.isPromise(result)) {\n\t\t\t// If we have a promise, wait for it to resolve\n\t\t\tresult.then(function (result) {\n\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t// Resolve with fixture results\n\t\t\t\t\tresponse(200, result );\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tif (result !== undefined) {\n\t\t\t\t// Resolve with fixture results\n\t\t\t\tresponse(200, result );\n\t\t\t}\n\t\t}\n\t};\n\n\tif(!xhrSettings.async) {\n\t\tcallFixture();\n\t\treturn null;\n\t} else {\n\t\treturn setTimeout(callFixture, $fixture.delay);\n\t}\n};\n\nexports.index = function (settings, exact) {\n\tfor (var i = 0; i < fixtures.length; i++) {\n\t\tif (matches.matches(settings, fixtures[i], exact)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nexports.get = function(xhrSettings) {\n\tif ( !$fixture.on ) {\n\t\treturn;\n\t}\n\t// First try an exact match\n\tvar index = exports.index(xhrSettings, true);\n\n\t// If that doesn't work, try a looser match.\n\tif(index === -1) {\n\t\tindex = exports.index(xhrSettings, false);\n\t}\n\n\tvar fixtureSettings = index >=0 ? canReflect.assignMap({},fixtures[index]) : undefined;\n\tif(fixtureSettings) {\n\t\tvar url = fixtureSettings.fixture,\n\t\t\tdata = dataFromUrl(fixtureSettings.url, xhrSettings.url);\n\t\tif(typeof fixtureSettings.fixture === \"string\") {\n\t\t\t// check that we might have a replacement\n\n\t\t\t// here we could read data from first url and translate into next\n\t\t\tif (data) {\n\t\t\t\t// Template static fixture URLs\n\t\t\t\turl = sub(url, data);\n\t\t\t}\n\n\t\t\t// Override the AJAX settings, changing the URL to the fixture file,\n\t\t\t// removing the data, and changing the type to GET.\n\t\t\tfixtureSettings.url = url;\n\t\t\tfixtureSettings.data = null;\n\t\t\tfixtureSettings.type = \"GET\";\n\t\t\tif (!fixtureSettings.error) {\n\t\t\t\t// If no error handling is provided, we provide one and throw an\n\t\t\t\t// error.\n\t\t\t\tfixtureSettings.error = function (xhr, error, message) {\n\t\t\t\t\tthrow \"fixtures.js Error \" + error + \" \" + message;\n\t\t\t\t};\n\t\t\t}\n\n\t\t} else if (canReflect.isPlainObject(xhrSettings.data) || xhrSettings.data == null) {\n\t\t\tvar xhrData = canReflect.assignMap({}, xhrSettings.data || {});\n\t\t\tfixtureSettings.data = canReflect.assignMap(xhrData, data);\n\n\t\t} else {\n\t\t\tfixtureSettings.data = xhrSettings.data;\n\t\t}\n\t}\n\n\treturn fixtureSettings;\n};\n\nexports.matches = matches;\n\n\n\n\n// A helper function that takes what's called with response\n// and moves some common args around to make it easier to call\nexports.extractResponse = function (status, response, headers, statusText) {\n\t// if we get response(RESPONSE, HEADERS)\n\tif (typeof status !== \"number\") {\n\t\theaders = response;\n\t\tresponse = status;\n\t\tstatus = 200;\n\t}\n\t// if we get response(200, RESPONSE, STATUS_TEXT)\n\tif (typeof headers === \"string\") {\n\t\tstatusText = headers;\n\t\theaders = {};\n\t}\n\treturn [status, response, headers, statusText];\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-fixture/core.js?");

/***/ }),

/***/ "./node_modules/can-fixture/data-from-url.js":
/*!***************************************************!*\
  !*** ./node_modules/can-fixture/data-from-url.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var replacer =  /\\{([^\\}]+)\\}/g;\n// Returns data from a url, given a fixtue URL. For example, given\n// \"todo/{id}\" and \"todo/5\", it will return an object with an id property\n// equal to 5.\nmodule.exports = function dataFromUrl(fixtureUrl, url) {\n\tif(!fixtureUrl) {\n\t\t// if there's no url, it's a match\n\t\treturn {};\n\t}\n\n\tvar order = [],\n\t\t// Sanitizes fixture URL\n\t\tfixtureUrlAdjusted = fixtureUrl.replace('.', '\\\\.')\n\t\t\t.replace('?', '\\\\?'),\n\t\t// Creates a regular expression out of the adjusted fixture URL and\n\t\t// runs it on the URL we passed in.\n\t\tres = new RegExp(fixtureUrlAdjusted.replace(replacer, function (whole, part) {\n\t\t\torder.push(part);\n\t\t\treturn \"([^\\/]+)\";\n\t\t}) + \"$\")\n\t\t\t.exec(url),\n\t\tdata = {};\n\n\t// If there were no matches, return null;\n\tif (!res) {\n\t\treturn null;\n\t}\n\n\t// Shift off the URL and just keep the data.\n\tres.shift();\n\torder.forEach( function (name) {\n\t\t// Add data from regular expression onto data object.\n\t\tdata[name] = res.shift();\n\t});\n\treturn data;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-fixture/data-from-url.js?");

/***/ }),

/***/ "./node_modules/can-fixture/fixture.js":
/*!*********************************************!*\
  !*** ./node_modules/can-fixture/fixture.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core = __webpack_require__(/*! ./core */ \"./node_modules/can-fixture/core.js\");\nvar fixture = core.add;\nvar Store = __webpack_require__(/*! ./store */ \"./node_modules/can-fixture/store.js\");\n__webpack_require__(/*! ./xhr */ \"./node_modules/can-fixture/xhr.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar ns = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n// HELPERS START\n\nvar noop = function(){};\n\ncanReflect.assignMap(fixture, {\n\trand: function randomize (arr, min, max) {\n\t\tif (typeof arr === 'number') {\n\t\t\tif (typeof min === 'number') {\n\t\t\t\treturn arr + Math.floor(Math.random() * (min - arr+1));\n\t\t\t} else {\n\t\t\t\treturn Math.floor(Math.random() * (arr+1));\n\t\t\t}\n\n\t\t}\n\t\t// clone the array because we will remove items from it.\n\t\tvar choices = arr.slice(0);\n\n\t\t// get a random set\n\t\tif (min === undefined) {\n\t\t\tmin = 1;\n\t\t\tmax = choices.length;\n\t\t} else if(max === undefined){\n\t\t\tmax = min;\n\t\t}\n\t\t// get a random selection of arr\n\t\tvar result = [];\n\n\t\t// set max\n\t\t//random max\n\t\tvar selectedCount = min + Math.round(randomize(max - min));\n\t\tfor (var i = 0; i < selectedCount; i++) {\n\t\t\tvar selectedIndex = randomize(choices.length - 1),\n\t\t\t\tselected = choices.splice(selectedIndex, 1)[0];\n\t\t\tresult.push(selected);\n\t\t}\n\t\treturn result;\n\t},\n\txhr: function (xhr) {\n\t\treturn canReflect.assignMap({}, {\n\t\t\tabort: noop,\n\t\t\tgetAllResponseHeaders: function () {\n\t\t\t\treturn \"\";\n\t\t\t},\n\t\t\tgetResponseHeader: function () {\n\t\t\t\treturn \"\";\n\t\t\t},\n\t\t\topen: noop,\n\t\t\toverrideMimeType: noop,\n\t\t\treadyState: 4,\n\t\t\tresponseText: \"\",\n\t\t\tresponseXML: null,\n\t\t\tsend: noop,\n\t\t\tsetRequestHeader: noop,\n\t\t\tstatus: 200,\n\t\t\tstatusText: \"OK\"\n\t\t}, xhr);\n\t},\n\tstore: Store.make,\n\tfixtures: core.fixtures\n});\n\nif(typeof window !== \"undefined\" && \"function\" !== \"function\") {\n\n\twindow.fixture = function(){\n\t\tcanDev.warn(\"You are using the global fixture. Make sure you import can-fixture.\");\n\n\t\treturn fixture.apply(this, arguments);\n\t};\t\n}\n\n\nmodule.exports = ns.fixture = fixture;\n\n\n//# sourceURL=webpack:///./node_modules/can-fixture/fixture.js?");

/***/ }),

/***/ "./node_modules/can-fixture/matches.js":
/*!*********************************************!*\
  !*** ./node_modules/can-fixture/matches.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var set = __webpack_require__(/*! can-query-logic/src/set */ \"./node_modules/can-query-logic/src/set.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar dataFromUrl = __webpack_require__(/*! ./data-from-url */ \"./node_modules/can-fixture/data-from-url.js\");\nvar QueryLogic = __webpack_require__(/*! can-query-logic */ \"./node_modules/can-query-logic/can-query-logic.js\");\n\n\nfunction deepEqual(a, b) {\n\tif(a === b) {\n\t\treturn true;\n\t} else if(Array.isArray(a) && Array.isArray(b)) {\n\t\tif(a.length !== b.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn a.every(function(aVal, i){\n\t\t\t\treturn deepEqual(aVal, b[i]);\n\t\t\t});\n\t\t}\n\t} else if(a && b && canReflect.isPlainObject(a) && canReflect.isPlainObject(b)) {\n\t\tvar aKeys = Object.keys(a),\n\t\t\tbKeys = Object.keys(b);\n\t\tif(aKeys.length === bKeys.length) {\n\t\t\tfor(var prop in a) {\n\t\t\t\tif(!b.hasOwnProperty(prop)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(!deepEqual(a[prop], b[prop])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}\n\n\nfunction deepMatches(a, b) {\n\tif(a === b) {\n\t\treturn true;\n\t} else if(Array.isArray(a) && Array.isArray(b)) {\n\n\t\treturn a.every(function(aVal, i){\n\t\t\treturn deepMatches(aVal, b[i]);\n\t\t});\n\n\t} else if(a && b && canReflect.isPlainObject(a) && canReflect.isPlainObject(b)) {\n\n\t\tfor(var prop in a) {\n\t\t\tif(!b.hasOwnProperty(prop)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(!deepMatches(a[prop], b[prop])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\n\t} else {\n\t\treturn false\n\t}\n}\n\nfunction removeFixtureAndXHR(query) {\n\tif(query.fixture || query.xhr || query.data) {\n\t\tvar clone = canReflect.serialize(query);\n\t\tdelete clone.fixture;\n\t\tdelete clone.xhr;\n\t\tdelete clone.data;\n\t\treturn clone;\n\t} else {\n\t\treturn query;\n\t}\n}\n\nfunction identityIntersection(v1, v2) {\n    return v1.value === v2.value ? v1 : set.EMPTY;\n}\nfunction identityDifference(v1, v2){\n    return v1.value === v2.value ? set.EMPTY : v1;\n}\nfunction identityUnion(v1, v2) {\n    return v1.value === v2.value ? v1 : set.UNDEFINABLE;\n}\nvar identityComparitor = {\n    intersection: identityIntersection,\n    difference: identityDifference,\n    union: identityUnion\n};\n\n\n\nfunction makeComparatorType(compare) {\n\tvar Type = function(){};\n\tvar SetType = function(value) {\n\t\tthis.value = value;\n\t};\n\tSetType.prototype.isMember = function(value, root, keys){\n\t    return compare(this.value, value, root, keys);\n\t};\n\tcanReflect.assignSymbols(Type,{\n\t\t\"can.SetType\": SetType\n\t});\n\n\tset.defineComparison(SetType,SetType, identityComparitor);\n\n\tset.defineComparison(set.UNIVERSAL,SetType,{\n\t\tdifference: function(){\n\t\t\treturn set.UNDEFINABLE;\n\t\t}\n\t});\n\treturn Type;\n}\n\nfunction quickEqual(queryA, queryB){\n\tvar dataA = queryA.data,\n\t\tdataB = queryB.data;\n\tif(dataA && dataB) {\n\t\tif(!deepMatches(dataA, dataB)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tvar q1 = new QueryLogic.KeysAnd(removeFixtureAndXHR(queryA)),\n\t\tq2 = new QueryLogic.KeysAnd(removeFixtureAndXHR(queryB));\n\treturn set.isEqual( q1, q2 );\n}\n\nfunction quickSubset(queryA, queryB){\n\treturn set.isSubset( new QueryLogic.KeysAnd(queryA), new QueryLogic.KeysAnd(queryB) );\n}\n\n// Define types\nvar types = {};\ncanReflect.eachKey({\n\tIsEmptyOrNull: function(a, b){\n\t\tif( a == null && canReflect.size(b) === 0 ) {\n\t\t\treturn true;\n\t\t} else if( b == null && canReflect.size(a) === 0 ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn quickEqual(a, b);\n\t\t}\n\t},\n\tisEmptyOrSubset: function(a, b) {\n\t\tif( a == null && canReflect.size(b) === 0 ) {\n\t\t\treturn true;\n\t\t} else if( b == null && canReflect.size(a) === 0 ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn quickSubset(a, b);\n\t\t}\n\t},\n\tTemplateUrl: function(a, b) {\n\t\treturn !!dataFromUrl(a, b);\n\t},\n\tStringIgnoreCase: function(a, b){\n\t\treturn b && a ? a.toLowerCase() === b.toLowerCase() : b === a;\n\t},\n\tIgnore: function(){\n\t\treturn true;\n\t}\n}, function(compare, name){\n\ttypes[name] = makeComparatorType(compare);\n});\n\n\n\n\n\nvar schema = {\n\tidentity: [\"id\"],\n\tkeys: {\n\t\turl: types.TemplateUrl,\n\t\tfixture: types.Ignore,\n\t\txhr: types.Ignore,\n\t\ttype: types.StringIgnoreCase,\n\t\tmethod: types.StringIgnoreCase,\n\t\thelpers: types.Ignore,\n\t\theaders: types.IsEmptyOrNull,\n\t\tdata: types.IsEmptyOrSubset\n\t}\n};\n\nvar query = new QueryLogic(schema);\n\n\n\n\nmodule.exports = {\n\tfixture: quickEqual,\n\trequest: function(requestData, fixtureData) {\n\t\treturn query.isMember({filter: fixtureData}, requestData);\n\t},\n\tmatches: function(settings, fixture, exact) {\n\t\tif (exact) {\n\t\t\treturn this.fixture(settings, fixture);\n\t\t} else {\n\t\t\treturn this.request(settings, fixture)\n\t\t}\n\t},\n\tmakeComparatorType: makeComparatorType\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-fixture/matches.js?");

/***/ }),

/***/ "./node_modules/can-fixture/store.js":
/*!*******************************************!*\
  !*** ./node_modules/can-fixture/store.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var QueryLogic = __webpack_require__(/*! can-query-logic */ \"./node_modules/can-query-logic/can-query-logic.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar memoryStore = __webpack_require__(/*! can-memory-store */ \"./node_modules/can-memory-store/can-memory-store.js\");\n\n\n\n// Returns a function that calls the method on a connection.\n// Wires up fixture signature to a connection signature.\nvar connectToConnection = function(method, convert){\n\treturn function(req, res){\n\t\t// have to get data from\n\t\tthis.connection[method]( convert.call(this, req.data) ).then(function(data){\n\t\t\tres(data);\n\t\t}, function(err){\n\t\t\tres(parseInt(err.status, 10), err);\n\t\t});\n\t};\n};\n// Returns a new makeItems function for a different baseItems;\nvar makeMakeItems = function(baseItems, idProp){\n\treturn function () {\n\t\t// clone baseItems\n\t\tvar items = [],\n\t\t\tmaxId = 0,\n\t\t\tidType = \"number\";\n\t\tbaseItems.forEach(function(item){\n\t\t\titems.push(canReflect.serialize(item) );\n\t\t\tvar type = typeof item[idProp];\n\t\t\tif(type === \"number\") {\n\t\t\t\tmaxId = Math.max(item[idProp], maxId) ;\n\t\t\t} else {\n\t\t\t\tidType = type;\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tmaxId: maxId,\n\t\t\titems: items,\n\t\t\tidType: idType\n\t\t};\n\t};\n};\n\nvar stringToAny = function(str){\n\tswitch(str) {\n\t\tcase \"NaN\":\n\t\tcase \"Infinity\":\n\t\t\treturn +str;\n\t\tcase \"null\":\n\t\t\treturn null;\n\t\tcase \"undefined\":\n\t\t\treturn undefined;\n\t\tcase \"true\":\n\t\tcase \"false\":\n\t\t\treturn str === \"true\";\n\t\tdefault:\n\t\t\tvar val = +str;\n\t\t\tif(!isNaN(val)) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn str;\n\t\t\t}\n\t}\n};\n\n// A store constructor function\nvar Store = function(connection, makeItems, idProp){\n\tvar schema = connection.queryLogic.schema;\n\tvar identityKey = schema.identity[0],\n\t\tkeys = schema.keys;\n\n\tif(!keys || !keys[identityKey]) {\n\t\tconsole.warn(\"No type specified for identity key. Going to convert strings to reasonable type.\");\n\t}\n\n\tthis.connection = connection;\n\tthis.makeItems = makeItems;\n\tthis.idProp = idProp;\n\tthis.reset();\n\t// we have to make sure the methods can be called without their context\n\tfor(var method in Store.prototype) {\n\t\tthis[method] = this[method].bind(this);\n\t}\n};\n\nvar doNotConvert = function(v){ return v; };\n\nfunction typeConvert(data){\n\tvar schema = this.connection.queryLogic.schema;\n\tvar idType = this.idType;\n\tvar identityKey = schema.identity[0],\n\t\tkeys = schema.keys;\n\tif(!keys || !keys[identityKey]) {\n\t\tkeys = {};\n\t\tkeys[identityKey] = function(value) {\n\t\t\tif(idType === \"string\") {\n\t\t\t\treturn \"\"+value;\n\t\t\t} else {\n\t\t\t\treturn typeof value === \"string\" ? stringToAny(value) : value;\n\t\t\t}\n\n\t\t};\n\t}\n\t\t// this probably needs to be recursive, but this is ok for now\n\tvar copy = {};\n\tcanReflect.eachKey(data, function(value, key){\n\t\tif(keys[key]) {\n\t\t\tcopy[key] = canReflect.serialize(canReflect.convert(value, keys[key]));\n\t\t} else {\n\t\t\tcopy[key] = value;\n\t\t}\n\t});\n\t// clone the data\n\n\treturn copy;\n\n}\n\ncanReflect.assignMap(Store.prototype,{\n\tgetListData: connectToConnection(\"getListData\",doNotConvert),\n\tgetData: connectToConnection( \"getData\",typeConvert),\n\n\t// used\n\tcreateData: function(req, res){\n\t\tvar idProp = this.idProp;\n\t\t// add an id\n\t\treq.data[idProp] = ++this.maxId;\n\n\t\tthis.connection.createData( typeConvert.call(this,req.data) ).then(function(data){\n\t\t\tres(data);\n\t\t}, function(err){\n\t\t\tres(403, err);\n\t\t});\n\t},\n\tcreateInstance: function(record){\n\t\tvar idProp = this.idProp;\n\t\tif(!(idProp in record)) {\n\t\t\trecord[idProp] = ++this.maxId;\n\t\t}\n\t\treturn this.connection.createData( record );\n\t},\n\tupdateData: connectToConnection(\"updateData\",typeConvert),\n\tupdateInstance: function(record) {\n\t\treturn this.connection.updateData(record);\n\t},\n\tdestroyInstance: function(record) {\n\t\treturn this.connection.destroyData(record);\n\t},\n\tdestroyData: connectToConnection(\"destroyData\",typeConvert),\n\treset: function(newItems){\n\t\tif(newItems) {\n\t\t\tthis.makeItems = makeMakeItems(newItems, this.idProp);\n\t\t}\n\t\tvar itemData =  this.makeItems();\n\t\tthis.maxId = itemData.maxId;\n\t\tthis.idType = itemData.idType;\n\t\tthis.connection.updateListData(itemData.items, {});\n\t},\n\tget: function (params) {\n\t\tvar id = this.connection.queryLogic.memberIdentity(params);\n\t\treturn this.connection.getRecord(id);\n\t},\n\tgetList: function(set){\n\t\treturn this.connection.getListDataSync(set);\n\t}\n});\n\nfunction looksLikeAQueryLogic(obj){\n\treturn obj && (\"identityKeys\" in obj);\n}\n\n// ## fixture.store\n// Make a store of objects to use when making requests against fixtures.\nStore.make = function (count, make, queryLogic) {\n\t/*jshint eqeqeq:false */\n\n\n\t// Figure out makeItems which populates data\n\tvar makeItems,\n\t\tidProp;\n\tif(typeof count === \"number\") {\n\t\tif(!queryLogic) {\n\t\t\tqueryLogic = new QueryLogic({});\n\t\t} else if(!looksLikeAQueryLogic(queryLogic)) {\n\t\t\tqueryLogic = new QueryLogic(queryLogic);\n\t\t}\n\t\tidProp = queryLogic.identityKeys()[0] || \"id\";\n\t\tmakeItems = function () {\n\t\t\tvar items = [];\n\t\t\tvar maxId = 0;\n\t\t\tfor (var i = 0; i < (count); i++) {\n\t\t\t\t//call back provided make\n\t\t\t\tvar item = make(i, items);\n\n\t\t\t\tif (!item[idProp]) {\n\t\t\t\t\titem[idProp] = i;\n\t\t\t\t}\n\t\t\t\tmaxId = Math.max(item[idProp] , maxId);\n\t\t\t\titems.push(item);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tmaxId: maxId,\n\t\t\t\titems: items\n\t\t\t};\n\t\t};\n\t} else if(Array.isArray(count)){\n\t\tqueryLogic = make;\n\t\tif(!queryLogic) {\n\t\t\tqueryLogic = new QueryLogic({});\n\t\t} else if(!looksLikeAQueryLogic(queryLogic)) {\n\t\t\tqueryLogic = new QueryLogic(queryLogic);\n\t\t}\n\t\tidProp = queryLogic.identityKeys()[0] || \"id\";\n\t\tmakeItems = makeMakeItems(count, idProp);\n\t}\n\n\tvar connection = memoryStore({\n\t\tqueryLogic: queryLogic,\n\t\terrorOnMissingRecord: true\n\t});\n\n\treturn new Store(connection, makeItems, idProp);\n};\n\nmodule.exports = Store;\n\n\n//# sourceURL=webpack:///./node_modules/can-fixture/store.js?");

/***/ }),

/***/ "./node_modules/can-fixture/xhr.js":
/*!*****************************************!*\
  !*** ./node_modules/can-fixture/xhr.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n/* global require, window, global */\n/* global setTimeout, clearTimeout, XMLHttpRequest */\n\n// This overwrites the default XHR with a mock XHR object.\n// The mock XHR object's `.send` method is able to\n// call the fixture callbacks or create a real XHR request\n// and then respond normally.\nvar fixtureCore = __webpack_require__(/*! ./core */ \"./node_modules/can-fixture/core.js\");\nvar deparam = __webpack_require__(/*! can-deparam */ \"./node_modules/can-deparam/can-deparam.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canLog = __webpack_require__(/*! can-log */ \"./node_modules/can-log/can-log.js\");\n\n// Save the real XHR object as XHR\nvar XHR = XMLHttpRequest,\n// Get a global reference.\n\tGLOBAL = typeof global !== \"undefined\"? global : window;\n\n// Figure out props and events on XHR object\n// but start with some defaults\nvar props = [\n\t\"type\", \"url\", \"async\", \"response\", \"responseText\", \"responseType\",\n\t\"responseXML\", \"responseURL\", \"status\", \"statusText\", \"readyState\"\n];\nvar events = [\"abort\", \"error\", \"load\", \"loadend\", \"loadstart\",  \"progress\", \"readystatechange\"];\n(function(){\n\tvar x = new XHR();\n\tfor(var prop in x) {\n\t\tif(prop.indexOf(\"on\") === 0) {\n\t\t\tif (events.indexOf(prop.substr(2)) === -1) {\n\t\t\t\tevents.push(prop.substr(2));\n\t\t\t}\n\t\t} else if (props.indexOf(prop) === -1 && typeof x[prop] !== 'function') {\n\t\t\tprops.push(prop);\n\t\t}\n\t}\n})();\n// DEFINE HELPERS\n\n// Call all of an event for an XHR object\nfunction callEvents(xhr, ev) {\n\tvar evs = xhr.__events[ev] || [], fn;\n\tfor(var i = 0, len = evs.length; i < len; i++) {\n\t\tfn = evs[i];\n\t\tfn.call(xhr);\n\t}\n}\n\nfunction defineNonEnumerable(obj, prop, value) {\n\tObject.defineProperty(obj, prop, {\n\t\tenumerable: false,\n\t\tconfigurable: true,\n\t\twritable: true,\n\t\tvalue: value\n\t});\n}\n\nGLOBAL.XMLHttpRequest = function() {\n\tvar mockXHR = this;\n\tvar realXHR = new XHR();\n\n\t// store real xhr on mockXHR\n\tdefineNonEnumerable(this, \"_xhr\", realXHR);\n\n\t// create other properties needed by prototype functions\n\tdefineNonEnumerable(this, \"_requestHeaders\", {});\n\tdefineNonEnumerable(this, \"__events\", {});\n\n\t// wire up events to forward from real xhr to fake xhr\n\tevents.forEach(function(eventName) {\n\t\trealXHR[\"on\" + eventName] = function() {\n\t\t\tcallEvents(mockXHR, eventName);\n\t\t\tif(mockXHR[\"on\"+eventName]) {\n\t\t\t\treturn mockXHR[\"on\"+eventName].apply(mockXHR, arguments);\n\t\t\t}\n\t\t};\n\t});\n\n\t// The way code detects if the browser supports onload is to check\n\t// if a new XHR object has the onload property, so setting it to null\n\t// passes that check.\n\tthis.onload = null;\n};\nGLOBAL.XMLHttpRequest._XHR = XHR;\n\n// Methods on the mock XHR:\ncanReflect.assignMap(XMLHttpRequest.prototype,{\n\tsetRequestHeader: function(name, value){\n\t\tthis._requestHeaders[name] = value;\n\t},\n\topen: function(type, url, async){\n\t\tthis.type = type;\n\t\tthis.url = url;\n\t\tthis.async = async === false ? false : true;\n\t},\n\tgetAllResponseHeaders: function(){\n\t\treturn this._xhr.getAllResponseHeaders.apply(this._xhr, arguments);\n\t},\n\taddEventListener: function(ev, fn){\n\t\tvar evs = this.__events[ev] = this.__events[ev] || [];\n\t\tevs.push(fn);\n\t},\n\tremoveEventListener: function(ev, fn){\n\t\tvar evs = this.__events[ev] = this.__events[ev] || [];\n\t\tvar idx = evs.indexOf(fn);\n\t\tif(idx >= 0) {\n\t\t\tevs.splice(idx, 1);\n\t\t}\n\t},\n\tsetDisableHeaderCheck: function(val){\n\t\tthis._disableHeaderCheck = !!val;\n\t},\n\tgetResponseHeader: function(key){\n\t\treturn this._xhr.getResponseHeader(key);\n\t},\n\tabort: function() {\n\t\tvar xhr = this._xhr;\n\n\t\t// If we are aborting a delayed fixture we have to make the fake\n\t\t// steps that are expected for `abort` to\n\t\tif(this.timeoutId !== undefined) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t\txhr.open(this.type, this.url, this.async === false ? false : true);\n\t\t\txhr.send();\n\t\t}\n\n\t\treturn xhr.abort();\n\t},\n\t// This needs to compile the information necessary to see if\n\t// there is a corresponding fixture.\n\t// If there isn't a fixture, this should create a real XHR object\n\t// linked to the mock XHR instance and make a data request.\n\t// If there is a fixture, depending on the type of fixture the following happens:\n\t// - dynamic fixtures - call the dynamic fixture, use the result to update the\n\t//   mock XHR object and trigger its callbacks.\n\t// - redirect fixtures - create a real XHR linked to the mock XHR for the new url.\n\tsend: function(data) {\n\t\t// derive the XHR settings object from the XHR object\n\t\tvar type = this.type.toLowerCase() || 'get';\n\t\tvar xhrSettings = {\n\t\t\turl: this.url,\n\t\t\tdata: data,\n\t\t\theaders: this._requestHeaders,\n\t\t\ttype: type,\n\t\t\tmethod: type,\n\t\t\tasync: this.async,\n\t\t\txhr: this\n\t\t};\n\t\t// if get or delete, the url should not include the querystring.\n\t\t// the querystring should be the data.\n\t\tif(!xhrSettings.data && xhrSettings.type === \"get\" || xhrSettings.type === \"delete\") {\n\t\t\txhrSettings.data = deparam( xhrSettings.url.split(\"?\")[1] );\n\t\t\txhrSettings.url = xhrSettings.url.split(\"?\")[0];\n\t\t}\n\n\t\t// Try to convert the request body to POJOs.\n\t\tif(typeof xhrSettings.data === \"string\") {\n\t\t\ttry {\n\t\t\t\txhrSettings.data = JSON.parse(xhrSettings.data);\n\t\t\t} catch(e) {\n\t\t\t\txhrSettings.data = deparam( xhrSettings.data );\n\t\t\t}\n\t\t}\n\n\t\t// See if the XHR settings match a fixture.\n\t\tvar fixtureSettings = fixtureCore.get(xhrSettings);\n\t\tvar mockXHR = this;\n\n\t\t// If a dynamic fixture is being used, we call the dynamic fixture function and then\n\t\t// copy the response back onto the `mockXHR` in the right places.\n\t\tif(fixtureSettings && typeof fixtureSettings.fixture === \"function\") {\n\n\t\t\tthis.timeoutId = fixtureCore.callDynamicFixture(xhrSettings, fixtureSettings, function(status, body, headers, statusText){\n\t\t\t\tbody = typeof body === \"string\" ? body :  JSON.stringify(body);\n\n\t\t\t\t// we are no longer using the real XHR\n\t\t\t\t// set it to an object so that props like readyState can be set\n\t\t\t\tmockXHR._xhr = {\n\t\t\t\t\topen: function(){},\n\t\t\t\t\tsend: function() {},\n\t\t\t\t\tabort: function(){},\n\t\t\t\t\tgetResponseHeader: function(){}\n\t\t\t\t};\n\n\t\t\t\tcanReflect.assignMap(mockXHR, {\n\t\t\t\t\treadyState: 4,\n\t\t\t\t\tstatus: status\n\t\t\t\t});\n\n\t\t\t\tvar success = (status >= 200 && status < 300 || status === 304);\n\t\t\t\tif ( success ) {\n\t\t\t\t\tcanReflect.assignMap(mockXHR,{\n\t\t\t\t\t\tstatusText: statusText || \"OK\",\n\t\t\t\t\t\tresponseText: body\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcanReflect.assignMap(mockXHR,{\n\t\t\t\t\t\tstatusText: statusText || \"error\",\n\t\t\t\t\t\tresponseText: body\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tmockXHR.getAllResponseHeaders = function() {\n\t\t\t\t\tvar ret = [];\n\t\t\t\t\tcanReflect.eachKey(headers || {}, function(value, name) {\n\t\t\t\t\t\tArray.prototype.push.apply(ret, [name, ': ', value, '\\r\\n']);\n\t\t\t\t\t});\n\t\t\t\t\treturn ret.join('');\n\t\t\t\t};\n\n\t\t\t\tif(mockXHR.onreadystatechange) {\n\t\t\t\t\tmockXHR.onreadystatechange({ target: mockXHR });\n\t\t\t\t}\n\n\t\t\t\t// fire progress events\n\t\t\t\tcallEvents(mockXHR, \"progress\");\n\t\t\t\tif(mockXHR.onprogress) {\n\t\t\t\t\tmockXHR.onprogress();\n\t\t\t\t}\n\n\t\t\t\tcallEvents(mockXHR, \"load\");\n\t\t\t\tif(mockXHR.onload) {\n\t\t\t\t\tmockXHR.onload();\n\t\t\t\t}\n\n\t\t\t\tcallEvents(mockXHR, \"loadend\");\n\t\t\t\tif(mockXHR.onloadend) {\n\t\t\t\t\tmockXHR.onloadend();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\t\t// At this point there is either not a fixture or a redirect fixture.\n\t\t// Either way we are doing a request.\n\t\tvar makeRequest = function() {\n\t\t\tmockXHR._xhr.open(mockXHR._xhr.type, mockXHR._xhr.url, mockXHR._xhr.async);\n\t\t\tif(mockXHR._requestHeaders) {\n\t\t\t\tObject.keys(mockXHR._requestHeaders).forEach(function(key) {\n\t\t\t\t\tmockXHR._xhr.setRequestHeader(key, mockXHR._requestHeaders[key]);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn mockXHR._xhr.send(data);\n\t\t};\n\n\t\tif(fixtureSettings && typeof fixtureSettings.fixture === \"number\") {\n\t\t\tcanLog.log(\"can-fixture: \"+xhrSettings.url+\" => delay \" + fixtureSettings.fixture+\"ms\");\n\t\t\tthis.timeoutId = setTimeout(makeRequest, fixtureSettings.fixture);\n\t\t\treturn;\n\t\t}\n\n\t\t// if we do have a fixture, update the real XHR object.\n\t\tif(fixtureSettings) {\n\t\t\tcanLog.log(\"can-fixture: \"+xhrSettings.url+\" => \" + fixtureSettings.url);\n\t\t\tcanReflect.assignMap(mockXHR, fixtureSettings);\n\t\t}\n\n\t\t// Make the request.\n\t\treturn makeRequest();\n\t}\n});\n\n// when props of mockXHR are get/set, return the prop from the real XHR\nprops.forEach(function(prop) {\n\tObject.defineProperty(XMLHttpRequest.prototype, prop, {\n\t\tget: function(){\n\t\t\treturn this._xhr[prop];\n\t\t},\n\t\tset: function(newVal){\n\t\t\ttry {\n\t\t\t\tthis._xhr[prop] = newVal;\n\t\t\t} catch(e) {}\n\t\t}\n\t});\n});\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/can-fixture/xhr.js?");

/***/ }),

/***/ "./node_modules/can-fragment/can-fragment.js":
/*!***************************************************!*\
  !*** ./node_modules/can-fragment/can-fragment.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar childNodes = __webpack_require__(/*! can-child-nodes */ \"./node_modules/can-child-nodes/can-child-nodes.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n/**\n@module {function} can-fragment\n@parent can-dom-utilities\n@collection can-infrastructure\n@package ./package.json\n\nConvert a String, HTMLElement, documentFragment, contentArray, or object with a `can.toDOM` symbol into a documentFragment.\n\n@signature `fragment(item, doc)`\n\n@param {String|HTMLElement|documentFragment|contentArray} item\n@param {Document} doc   an optional DOM document in which to build the fragment\n\n@return {documentFragment}\n\n@body\n\n## Use\n\nContentArrays can be used to combine multiple HTMLElements into a single document fragment.  For example:\n\n    var fragment = require(\"can-fragment\");\n\n    var p = document.createElement(\"p\");\n    p.innerHTML = \"Welcome to <b>CanJS</b>\";\n    var contentArray = [\"<h1>Hi There</h1>\", p];\n    var fragment = fragment( contentArray )\n\n`fragment` will be a documentFragment with the following elements:\n\n    <h1>Hi There</h1>\n    <p>Welcome to <b>CanJS</b></p>\n\n */\n\n\n// fragment.js\n// ---------\n// _DOM Fragment support._\nvar fragmentRE = /^\\s*<(\\w+)[^>]*>/,\n\ttoString = {}.toString,\n\ttoDOMSymbol = canSymbol.for(\"can.toDOM\");\n\nfunction makeFragment(html, name, doc) {\n\tif (name === undefined) {\n\t\tname = fragmentRE.test(html) && RegExp.$1;\n\t}\n\tif (html && toString.call(html.replace) === \"[object Function]\") {\n\t\t// Fix \"XHTML\"-style tags in all browsers\n\t\thtml = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi, '<$1></$2>');\n\t}\n\tvar container = doc.createElement('div'),\n\t\ttemp = doc.createElement('div');\n\t// IE's parser will strip any `<tr><td>` tags when `innerHTML`\n\t// is called on a `tbody`. To get around this, we construct a\n\t// valid table with a `tbody` that has the `innerHTML` we want.\n\t// Then the container is the `firstChild` of the `tbody`.\n\t// [source](http://www.ericvasilik.com/2006/07/code-karma.html).\n\tif (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {\n\t\ttemp.innerHTML = '<table>' + html + '</table>';\n\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;\n\t} else if (name === 'col') {\n\t\ttemp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';\n\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;\n\t} else if (name === 'tr') {\n\t\ttemp.innerHTML = '<table><tbody>' + html + '</tbody></table>';\n\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;\n\t} else if (name === 'td' || name === 'th') {\n\t\ttemp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';\n\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;\n\t} else if (name === 'option') {\n\t\ttemp.innerHTML = '<select>' + html + '</select>';\n\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;\n\t} else {\n\t\tcontainer.innerHTML = '' + html;\n\t}\n\n\treturn [].slice.call(childNodes(container));\n}\n\nfunction fragment(html, doc) {\n\tif (html && html.nodeType === 11) {\n\t\treturn html;\n\t}\n\tif (!doc) {\n\t\tdoc = getDocument();\n\t} else if (doc.length) {\n\t\tdoc = doc[0];\n\t}\n\n\tvar parts = makeFragment(html, undefined, doc),\n\t\tfrag = (doc || document).createDocumentFragment();\n\tfor (var i = 0, length = parts.length; i < length; i++) {\n\t\tfrag.appendChild(parts[i]);\n\t}\n\treturn frag;\n}\n\nvar makeFrag = function(item, doc) {\n\tvar document = doc || getDocument();\n\tvar frag;\n\tif (!item || typeof item === \"string\") {\n\t\tfrag = fragment(item == null ? \"\" : \"\" + item, document);\n\t\t// If we have an empty frag...\n\t} else if(typeof item[toDOMSymbol] === \"function\") {\n\t\treturn makeFrag(item[toDOMSymbol]());\n\t}\n\telse if (item.nodeType === 11) {\n\t\treturn item;\n\t} else if (typeof item.nodeType === \"number\") {\n\t\tfrag = document.createDocumentFragment();\n\t\tfrag.appendChild(item);\n\t\treturn frag;\n\t} else if (canReflect.isListLike(item)) {\n\t\tfrag = document.createDocumentFragment();\n\t\tcanReflect.eachIndex(item, function(item) {\n\t\t\tfrag.appendChild(makeFrag(item));\n\t\t});\n\t} else {\n\t\tfrag = fragment(\"\" + item, document);\n\t}\n    if (!childNodes(frag).length) {\n        frag.appendChild(document.createTextNode(''));\n    }\n    return frag;\n};\n\nmodule.exports = namespace.fragment = namespace.frag = makeFrag;\n\n\n//# sourceURL=webpack:///./node_modules/can-fragment/can-fragment.js?");

/***/ }),

/***/ "./node_modules/can-globals/base-url/base-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-globals/base-url/base-url.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\n\nvar globals = __webpack_require__(/*! ../can-globals-instance */ \"./node_modules/can-globals/can-globals-instance.js\");\n__webpack_require__(/*! ../global/global */ \"./node_modules/can-globals/global/global.js\");\n__webpack_require__(/*! ../document/document */ \"./node_modules/can-globals/document/document.js\");\n\n/**\n * @module {function} can-globals/base-url/base-url base-url\n * @parent can-globals/modules\n *\n * @signature `baseUrl(optionalBaseUrlToSet)`\n *\n * Get and/or set the \"base\" (containing path) of the document.\n *\n * ```js\n * var baseUrl = require(\"can-globals/base-url/base-url\");\n *\n * console.log(baseUrl());           // -> \"http://localhost:8080\"\n * console.log(baseUrl(baseUrl() + \"/foo/bar\")); // -> \"http://localhost:8080/foo/bar\"\n * console.log(baseUrl());           // -> \"http://localhost:8080/foo/bar\"\n * ```\n *\n * @param {String} setUrl An optional base url to override reading the base URL from the known path.\n *\n * @return {String} Returns the set or computed base URL\n */\n\nglobals.define('base-url', function(){\n\tvar global = globals.getKeyValue('global');\n\tvar domDocument = globals.getKeyValue('document');\n\tif (domDocument && 'baseURI' in domDocument) {\n\t\treturn domDocument.baseURI;\n\t} else if(global.location) {\n\t\tvar href = global.location.href;\n\t\tvar lastSlash = href.lastIndexOf(\"/\");\n\t\treturn lastSlash !== -1 ? href.substr(0, lastSlash) : href;\n\t} else if(typeof process !== \"undefined\") {\n\t\treturn process.cwd();\n\t}\n});\n\nmodule.exports = globals.makeExport('base-url');\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/can-globals/base-url/base-url.js?");

/***/ }),

/***/ "./node_modules/can-globals/can-globals-instance.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-globals/can-globals-instance.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar Globals = __webpack_require__(/*! ./can-globals-proto */ \"./node_modules/can-globals/can-globals-proto.js\");\nvar globals = new Globals();\n\nif (namespace.globals) {\n\tthrow new Error(\"You can't have two versions of can-globals, check your dependencies\");\n} else {\n\tmodule.exports = namespace.globals = globals;\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-globals/can-globals-instance.js?");

/***/ }),

/***/ "./node_modules/can-globals/can-globals-proto.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-globals/can-globals-proto.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nfunction dispatch(key) {\n\t// jshint -W040\n\tvar handlers = this.eventHandlers[key];\n\tif (handlers) {\n\t\tvar handlersCopy = handlers.slice();\n\t\tvar value = this.getKeyValue(key);\n\t\tfor (var i = 0; i < handlersCopy.length; i++) {\n\t\t\thandlersCopy[i](value);\n\t\t}\n\t}\n}\n\nfunction Globals() {\n\tthis.eventHandlers = {};\n\tthis.properties = {};\n}\n\n/**\n * @function define \n * @parent can-globals/methods\n * \n * Create a new global environment variable.\n * \n * @signature `globals.define(key, value[, cache])`\n * \n * Defines a new global called `key`, who's value defaults to `value`.\n * \n * The following example defines the `global` key's default value to the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window) object:\n * ```javascript\n * globals.define('global', window);\n * globals.getKeyValue('window') //-> window\n * ```\n * \n * If a function is provided and `cache` is falsy, that function is run every time the key value is read:\n * ```javascript\n * globals.define('isBrowserWindow', function() {\n *   console.log('EVALUATING')\n *   return typeof window !== 'undefined' &&\n *     typeof document !== 'undefined' && typeof SimpleDOM === 'undefined'\n * }, false);\n * globals.get('isBrowserWindow') // logs 'EVALUATING'\n *                                // -> true\n * globals.get('isBrowserWindow') // logs 'EVALUATING' again\n *                                // -> true\n * ```\n * \n * If a function is provided and `cache` is truthy, that function is run only the first time the value is read:\n * ```javascript\n * globals.define('isWebkit', function() {\n *   console.log('EVALUATING')\n *   var div = document.createElement('div')\n *   return 'WebkitTransition' in div.style\n * })\n * globals.getKeyValue('isWebkit') // logs 'EVALUATING'\n * \t\t\t\t\t\t\t\t   // -> true\n * globals.getKeyValue('isWebkit') // Does NOT log again!\n * \t\t\t\t\t\t\t\t   // -> true\n * ```\n * \n * @param {String} key\n * The key value to create.\n * \n * @param {*} value\n * The default value. If this is a function, its return value will be used.\n * \n * @param {Boolean} [cache=true]\n * Enable cache. If false the `value` function is run every time the key value is read.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.define = function (key, value, enableCache) {\n\tif (enableCache === undefined) {\n\t\tenableCache = true;\n\t}\n\tif (!this.properties[key]) {\n\t\tthis.properties[key] = {\n\t\t\tdefault: value,\n\t\t\tvalue: value,\n\t\t\tenableCache: enableCache\n\t\t};\n\t}\n\treturn this;\n};\n\n/**\n * @function getKeyValue \n * @parent can-globals/methods\n * \n * Get a global environment variable by name.\n * \n * @signature `globals.getKeyValue(key)`\n * \n * Returns the current value at `key`. If no value has been set, it will return the default value (if it is not a function). If the default value is a function, it will return the output of the function. This execution is cached if the cache flag was set on initialization.\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.getKeyValue('foo'); //-> 'bar'\n * ```\n * \n * @param {String} key\n * The key value to access.\n * \n * @return {*}\n * Returns the value of a given key.\n */\nGlobals.prototype.getKeyValue = function (key) {\n\tvar property = this.properties[key];\n\tif (property) {\n\t\tif (typeof property.value === 'function') {\n\t\t\tif (property.cachedValue) {\n\t\t\t\treturn property.cachedValue;\n\t\t\t}\n\t\t\tif (property.enableCache) {\n\t\t\t\tproperty.cachedValue = property.value();\n\t\t\t\treturn property.cachedValue;\n\t\t\t} else {\n\t\t\t\treturn property.value();\n\t\t\t}\n\t\t}\n\t\treturn property.value;\n\t}\n};\n\nGlobals.prototype.makeExport = function (key) {\n\treturn function (value) {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.getKeyValue(key);\n\t\t}\n\n\t\tif (typeof value === 'undefined' || value === null) {\n\t\t\tthis.deleteKeyValue(key);\n\t\t} else {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\tthis.setKeyValue(key, function () {\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.setKeyValue(key, value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}.bind(this);\n};\n\n/**\n * @function offKeyValue \n * @parent can-globals/methods\n * \n * Remove handler from event queue.\n * \n * @signature `globals.offKeyValue(key, handler)`\n * \n * Removes `handler` from future change events for `key`.\n * \n * \n * ```javascript\n * var handler = (value) => {\n *   value === 'baz' //-> true\n * };\n * globals.define('foo', 'bar');\n * globals.onKeyValue('foo', handler);\n * globals.setKeyValue('foo', 'baz');\n * globals.offKeyValue('foo', handler);\n * ```\n * \n * @param {String} key\n * The key value to observe.\n * \n * @param {Function} handler([value])\n * The observer callback.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.offKeyValue = function (key, handler) {\n\tif (this.properties[key]) {\n\t\tvar handlers = this.eventHandlers[key];\n\t\tif (handlers) {\n\t\t\tvar i = handlers.indexOf(handler);\n\t\t\thandlers.splice(i, 1);\n\t\t}\n\t}\n\treturn this;\n};\n\n/**\n * @function onKeyValue \n * @parent can-globals/methods\n * \n * Add handler to event queue.\n * \n * @signature `globals.onKeyValue(key, handler)`\n * \n * Calls `handler` each time the value of `key` is set or reset.\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.onKeyValue('foo', (value) => {\n *   value === 'baz' //-> true\n * });\n * globals.setKeyValue('foo', 'baz');\n * ```\n * \n * @param {String} key\n * The key value to observe.\n * \n * @param {function(*)} handler([value])\n * The observer callback.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.onKeyValue = function (key, handler) {\n\tif (this.properties[key]) {\n\t\tif (!this.eventHandlers[key]) {\n\t\t\tthis.eventHandlers[key] = [];\n\t\t}\n\t\tthis.eventHandlers[key].push(handler);\n\t}\n\treturn this;\n};\n\n/**\n * @function deleteKeyValue \n * @parent can-globals/methods\n * \n * Reset global environment variable.\n * \n * @signature `globals.deleteKeyValue(key)`\n * \n * Deletes the current value at `key`. Future `get`s will use the default value.\n * \n * ```javascript\n * globals.define('global', window);\n * globals.setKeyValue('global', {});\n * globals.deleteKeyValue('global');\n * globals.getKeyValue('global') === window; //-> true\n * ```\n * \n * @param {String} key\n * The key value to access.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.deleteKeyValue = function (key) {\n\tvar property = this.properties[key];\n\tif (property !== undefined) {\n\t\tproperty.value = property.default;\n\t\tproperty.cachedValue = undefined;\n\t\tdispatch.call(this, key);\n\t}\n\treturn this;\n};\n\n/**\n * @function setKeyValue \n * @parent can-globals/methods\n * \n * Overwrite an existing global environment variable.\n * \n * @signature `globals.setKeyValue(key, value)`\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.setKeyValue('foo', 'baz');\n * globals.getKeyValue('foo'); //-> 'baz'\n * ```\n * \n * Sets the new value at `key`. Will override previously set values, but preserves the default (see `deleteKeyValue`).\n * \n * Setting a key which was not previously defined will call `define` with the key and value.\n * \n * @param {String} key\n * The key value to access.\n * \n * @param {*} value\n * The new value.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.setKeyValue = function (key, value) {\n\tif (!this.properties[key]) {\n\t\treturn this.define(key, value);\n\t}\n\tvar property = this.properties[key];\n\tproperty.value = value;\n\tproperty.cachedValue = undefined;\n\tdispatch.call(this, key);\n\treturn this;\n};\n\n/**\n * @function reset \n * @parent can-globals/methods\n * \n * Reset all keys to their default value and clear their caches.\n * \n * @signature `globals.setKeyValue(key, value)`\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.setKeyValue('foo', 'baz');\n * globals.getKeyValue('foo'); //-> 'baz'\n * globals.reset();\n * globals.getKeyValue('foo'); //-> 'bar'\n * ```\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.reset = function () {\n\tfor (var key in this.properties) {\n\t\tif (this.properties.hasOwnProperty(key)) {\n\t\t\tthis.properties[key].value = this.properties[key].default;\n\t\t\tthis.properties[key].cachedValue = undefined;\n\t\t\tdispatch.call(this, key);\n\t\t}\n\t}\n\treturn this;\n};\n\ncanReflect.assignSymbols(Globals.prototype, {\n\t'can.getKeyValue': Globals.prototype.getKeyValue,\n\t'can.setKeyValue': Globals.prototype.setKeyValue,\n\t'can.deleteKeyValue': Globals.prototype.deleteKeyValue,\n\t'can.onKeyValue': Globals.prototype.onKeyValue,\n\t'can.offKeyValue': Globals.prototype.offKeyValue\n});\n\nmodule.exports = Globals;\n\n\n//# sourceURL=webpack:///./node_modules/can-globals/can-globals-proto.js?");

/***/ }),

/***/ "./node_modules/can-globals/can-globals.js":
/*!*************************************************!*\
  !*** ./node_modules/can-globals/can-globals.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"./node_modules/can-globals/can-globals-instance.js\");\n\n__webpack_require__(/*! ./global/global */ \"./node_modules/can-globals/global/global.js\");\n__webpack_require__(/*! ./document/document */ \"./node_modules/can-globals/document/document.js\");\n__webpack_require__(/*! ./location/location */ \"./node_modules/can-globals/location/location.js\");\n__webpack_require__(/*! ./mutation-observer/mutation-observer */ \"./node_modules/can-globals/mutation-observer/mutation-observer.js\");\n__webpack_require__(/*! ./is-browser-window/is-browser-window */ \"./node_modules/can-globals/is-browser-window/is-browser-window.js\");\n__webpack_require__(/*! ./is-node/is-node */ \"./node_modules/can-globals/is-node/is-node.js\");\n__webpack_require__(/*! ./custom-elements/custom-elements */ \"./node_modules/can-globals/custom-elements/custom-elements.js\");\n\nmodule.exports = globals;\n\n\n//# sourceURL=webpack:///./node_modules/can-globals/can-globals.js?");

/***/ }),

/***/ "./node_modules/can-globals/custom-elements/custom-elements.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-globals/custom-elements/custom-elements.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"./node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/custom-elements/custom-elements custom-elements\n * @parent can-globals/modules\n *\n * Get the global [`customElements`](https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements) object for the current context.\n *\n * @signature `CUSTOMELEMENTS([newCustomElements])`\n *\n * Optionally sets, and returns, the [`customElements`](https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements) object for the context.\n *\n * ```js\n * var customElementsShim = require('some-custom-elements-shim');\n * CUSTOMELEMENTS(customElementsShim);\n * CUSTOMELEMENTS() //-> customElementsShim\n * ```\n *\n * @param {Object} customElements An optional CustomElementRegistry-like object to set as the context's customElements\n *\n * @return {Object} The customElements object for this JavaScript environment.\n */\n\nglobals.define('customElements', function(){\n\tvar GLOBAL = globals.getKeyValue('global');\n\treturn GLOBAL.customElements;\n});\n\nmodule.exports = globals.makeExport('customElements');\n\n\n//# sourceURL=webpack:///./node_modules/can-globals/custom-elements/custom-elements.js?");

/***/ }),

/***/ "./node_modules/can-globals/document/document.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-globals/document/document.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"./node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/document/document document\n * @parent can-globals/modules\n * \n * Get the global [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the current context.\n * \n * @signature `DOCUMENT([newDocument])`\n * \n * Optionally sets, and returns, the [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the context.\n * \n * ```js\n * var documentShim = { getElementById() {...} };\n * var DOCUMENT = require('can-globals/document/document');\n * DOCUMENT(documentShim); //-> document\n * DOCUMENT().getElementById('foo');\n * ```\n *\n * @param {Object} [newDocument] An optional document-like object to set as the context's document \n * \n * @return {Object} The window object for this JavaScript environment.\n */\nglobals.define('document', function(){\n\treturn globals.getKeyValue('global').document;\n});\n\nmodule.exports = globals.makeExport('document');\n\n\n//# sourceURL=webpack:///./node_modules/can-globals/document/document.js?");

/***/ }),

/***/ "./node_modules/can-globals/global/global.js":
/*!***************************************************!*\
  !*** ./node_modules/can-globals/global/global.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {\n\n/* global self */\n/* global WorkerGlobalScope */\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"./node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/global/global global\n * @parent can-globals/modules\n * \n * Get the global object for the current context.\n * \n * @signature `GLOBAL([newGlobal])`\n *\n * Optionally sets, and returns the global that this environment provides. It will be one of:\n * \n * ```js\n * var GLOBAL = require('can-globals/global/global');\n * var g = GLOBAL();\n * // In a browser\n * console.log(g === window); // -> true\n * ```\n *\n * - **Browser**: [`window`](https://developer.mozilla.org/en-US/docs/Web/API/window)\n * - **Web Worker**: [`self`](https://developer.mozilla.org/en-US/docs/Web/API/Window/self)\n * - **Node.js**: [`global`](https://nodejs.org/api/globals.html#globals_global)\n * \n * @param {Object} [newGlobal] An optional global-like object to set as the context's global \n *\n * @return {Object} The global object for this JavaScript environment.\n */\nglobals.define('global', function(){\n\t// Web Worker\n\treturn (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) ? self :\n\n\t\t// Node.js\n\t\ttypeof process === 'object' &&\n\t\t{}.toString.call(process) === '[object process]' ? global :\n\n\t\t// Browser window\n\t\twindow;\n});\n\nmodule.exports = globals.makeExport('global');\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/can-globals/global/global.js?");

/***/ }),

/***/ "./node_modules/can-globals/is-browser-window/is-browser-window.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-globals/is-browser-window/is-browser-window.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"./node_modules/can-globals/can-globals-instance.js\");\n\n// This module depends on isNode being defined\n__webpack_require__(/*! ../is-node/is-node */ \"./node_modules/can-globals/is-node/is-node.js\");\n\n/**\n * @module {function} can-globals/is-browser-window/is-browser-window is-browser-window\n * @parent can-globals/modules\n * @signature `isBrowserWindow()`\n *\n * Returns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).\n *\n * ```js\n * var isBrowserWindow = require(\"can-globals/is-browser-window/is-browser-window\");\n * var GLOBAL = require(\"can-globals/global/global\");\n *\n * if(isBrowserWindow()) {\n *   console.log(GLOBAL() === window); // -> true\n * }\n * ```\n *\n * @return {Boolean} True if the environment is a Browser window.\n */\n\nglobals.define('isBrowserWindow', function(){\n\tvar isNode = globals.getKeyValue('isNode');\n\treturn typeof window !== \"undefined\" &&\n\t\ttypeof document !== \"undefined\" &&\n\t\tisNode === false;\n});\n\nmodule.exports = globals.makeExport('isBrowserWindow');\n\n\n//# sourceURL=webpack:///./node_modules/can-globals/is-browser-window/is-browser-window.js?");

/***/ }),

/***/ "./node_modules/can-globals/is-node/is-node.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-globals/is-node/is-node.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"./node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/is-node/is-node is-node\n * @parent can-globals/modules\n * @description Determines if your code is running in [Node.js](https://nodejs.org).\n * @signature `isNode()`\n *\n * ```js\n * var isNode = require(\"can-globals/is-node/is-node\");\n * var GLOBAL = require(\"can-globals/global/global\");\n *\n * if(isNode()) {\n *   console.log(GLOBAL() === global); // -> true\n * }\n * ```\n *\n * @return {Boolean} True if running in Node.js\n */\n\nglobals.define('isNode', function(){\n\treturn typeof process === \"object\" &&\n\t\t{}.toString.call(process) === \"[object process]\";\n});\n\nmodule.exports = globals.makeExport('isNode');\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/can-globals/is-node/is-node.js?");

/***/ }),

/***/ "./node_modules/can-globals/is-web-worker/is-web-worker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-globals/is-web-worker/is-web-worker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"./node_modules/can-globals/can-globals-instance.js\");\n\n/* globals WorkerGlobalScope */\n// A bit of weirdness to avoid complaining linters\nvar funcConstructor = Function;\n\n\n/**\n * @module {function} can-globals/is-browser-window/is-web-worker is-web-worker\n * @parent can-globals/modules\n * @signature `isWebWorker()`\n *\n * Returns `true` if the code is running within a [web worker](https://developer.mozilla.org/en-US/docs/Web/API/Worker).\n *\n * ```js\n * var isWebWorker = require(\"can-globals/is-web-worker/is-web-worker\");\n * var GLOBAL = require(\"can-globals/global/global\");\n *\n * if(isWebWorker()) {\n *   ...\n * }\n * ```\n *\n * @return {Boolean} True if the environment is a web worker.\n */\n\nglobals.define('isWebWorker', function(){\n    var global = funcConstructor('return this')();\n    return typeof WorkerGlobalScope !== \"undefined\" &&\n        (global instanceof WorkerGlobalScope);\n});\n\nmodule.exports = globals.makeExport('isWebWorker');\n\n\n//# sourceURL=webpack:///./node_modules/can-globals/is-web-worker/is-web-worker.js?");

/***/ }),

/***/ "./node_modules/can-globals/location/location.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-globals/location/location.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"./node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/location/location location\n * @parent can-globals/modules\n * \n * Get the global [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the current context.\n * \n * @signature `LOCATION([newLocation])`\n * \n * Optionally sets, and returns, the [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the context.\n * \n * ```js\n * var locationShim = { path: '/' };\n * var LOCATION = require('can-globals/location/location');\n * LOCATION(locationShim);\n * LOCATION().path; // -> '/'\n * ```\n *\n * @param {Object} location An optional location-like object to set as the context's location\n *\n * @return {Object} The location object for this JavaScript environment.\n */\nglobals.define('location', function(){\n\treturn globals.getKeyValue('global').location;\n});\n\nmodule.exports = globals.makeExport('location');\n\n\n//# sourceURL=webpack:///./node_modules/can-globals/location/location.js?");

/***/ }),

/***/ "./node_modules/can-globals/mutation-observer/mutation-observer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-globals/mutation-observer/mutation-observer.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"./node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/mutation-observer/mutation-observer mutation-observer\n * @parent can-globals/modules\n * \n * Get the global [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the current context.\n * \n * @signature `MUTATIONOBSERVER([newMutationObserver])`\n * \n * Optionally sets, and returns, the [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the context.\n * \n * ```js\n * var mutationObserverShim = require('can-globals/mutation-observer/mutation-observer');\n * MUTATIONOBSERVER(mutationObserverShim);\n * MUTATIONOBSERVER() //-> MutationObserver\n * ```\n *\n * @param {Object} MutationObserver An optional MutationObserver-like object to set as the context's MutationObserver\n *\n * @return {Object} The MutationObserver object for this JavaScript environment.\n */\n\nglobals.define('MutationObserver', function(){\n\tvar GLOBAL = globals.getKeyValue('global');\n\treturn GLOBAL.MutationObserver || GLOBAL.WebKitMutationObserver || GLOBAL.MozMutationObserver;\n});\n\nmodule.exports = globals.makeExport('MutationObserver');\n\n\n//# sourceURL=webpack:///./node_modules/can-globals/mutation-observer/mutation-observer.js?");

/***/ }),

/***/ "./node_modules/can-import-module/can-import-module.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-import-module/can-import-module.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getGlobal = __webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\n/**\n * @module {function} can-util/js/import/import import\n * @parent can-util/js\n * @signature `importModule(moduleName, parentName)`\n *\n * ```js\n * var importModule = require(\"can-util/js/import/import\");\n *\n * importModule(\"foo.stache\").then(function(){\n *   // module was imported\n * });\n * ```\n *\n * @param {String} moduleName The module to be imported.\n * @param {String} [parentName] A parent module that will be used as a reference for resolving relative module imports.\n * @return {Promise} A Promise that will resolve when the module has been imported.\n */\n\nmodule.exports = namespace.import = function(moduleName, parentName) {\n\treturn new Promise(function(resolve, reject) {\n\t\ttry {\n\t\t\tvar global = getGlobal();\n\t\t\tif(typeof global.System === \"object\" && isFunction(global.System[\"import\"])) {\n\t\t\t\tglobal.System[\"import\"](moduleName, {\n\t\t\t\t\tname: parentName\n\t\t\t\t}).then(resolve, reject);\n\t\t\t} else if(global.define && global.define.amd){\n\t\t\t\tglobal.require([moduleName], function(value){\n\t\t\t\t\tresolve(value);\n\t\t\t\t});\n\t\t\t} else if(global.require){\n\t\t\t\tresolve(global.require(moduleName));\n\t\t\t} else {\n\t\t\t\t// steal optimized build\n\t\t\t\tif (typeof stealRequire !== \"undefined\") {\n\t\t\t\t\tsteal.import(moduleName, { name: parentName }).then(resolve, reject);\n\t\t\t\t} else {\n\t\t\t\t\t// ideally this will use can.getObject\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(err) {\n\t\t\treject(err);\n\t\t}\n\t});\n};\n\nfunction isFunction(fn) {\n\treturn typeof fn === \"function\";\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-import-module/can-import-module.js?");

/***/ }),

/***/ "./node_modules/can-join-uris/can-join-uris.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-join-uris/can-join-uris.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar parseURI = __webpack_require__(/*! can-parse-uri */ \"./node_modules/can-parse-uri/can-parse-uri.js\");\n\nmodule.exports = namespace.joinURIs = function(base, href) {\n\tfunction removeDotSegments(input) {\n\t\tvar output = [];\n\t\tinput.replace(/^(\\.\\.?(\\/|$))+/, '')\n\t\t\t.replace(/\\/(\\.(\\/|$))+/g, '/')\n\t\t\t.replace(/\\/\\.\\.$/, '/../')\n\t\t\t.replace(/\\/?[^\\/]*/g, function (p) {\n\t\t\t\tif (p === '/..') {\n\t\t\t\t\toutput.pop();\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(p);\n\t\t\t\t}\n\t\t\t});\n\t\treturn output.join('').replace(/^\\//, input.charAt(0) === '/' ? '/' : '');\n\t}\n\n\thref = parseURI(href || '');\n\tbase = parseURI(base || '');\n\n\treturn !href || !base ? null : (href.protocol || base.protocol) +\n\t\t(href.protocol || href.authority ? href.authority : base.authority) +\n\t\tremoveDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +\n\t\t\t(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +\n\t\t\thref.hash;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-join-uris/can-join-uris.js?");

/***/ }),

/***/ "./node_modules/can-kefir/can-kefir.js":
/*!*********************************************!*\
  !*** ./node_modules/can-kefir/can-kefir.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Kefir = __webpack_require__(/*! kefir */ \"./node_modules/kefir/dist/kefir.esm.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar mapEventsMixin = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar metaSymbol = canSymbol.for(\"can.meta\");\nvar onKeyValueSymbol = canSymbol.for(\"can.onKeyValue\");\nvar offKeyValueSymbol = canSymbol.for(\"can.offKeyValue\");\n\nvar keyNames = {\n\tvalue: {\n\t\ton: \"onValue\",\n\t\toff: \"offValue\",\n\t\thandler: \"onValueHandler\",\n\t\thandlers: \"onValueHandlers\"\n\t},\n\terror: {\n\t\ton: \"onError\",\n\t\toff: \"offError\",\n\t\thandler: \"onErrorHandler\",\n\t\thandlers: \"onErrorHandlers\"\n\t}\n};\n\nfunction ensureMeta(obj) {\n\tvar meta = obj[metaSymbol];\n\n\tif (!meta) {\n\t\tmeta = {};\n\t\tcanReflect.setKeyValue(obj, metaSymbol, meta);\n\t}\n\n\treturn meta;\n}\n\n// get the current value from a stream\nfunction getCurrentValue(stream, key) {\n\tif (stream._currentEvent && stream._currentEvent.type === key) {\n\t\treturn stream._currentEvent.value;\n\t} else {\n\t\tvar names = keyNames[key];\n\t\tif (!names) {\n\t\t\treturn stream[key];\n\t\t}\n\t\tvar VALUE,\n\t\t\tvalueHandler = function(value) {\n\t\t\t\tVALUE = value;\n\t\t\t};\n\t\tstream[names.on](valueHandler);\n\t\tstream[names.off](valueHandler);\n\t\treturn VALUE;\n\t}\n}\n\n// The conditional is needed or the global CanJS build,\n// this code should not break if Kefir is not bundled\nif (Kefir) {\n\t// https://github.com/donejs/bitballs/issues/332\n\t// Kefir can appear to be an ES module.  This works around that.\n\tif(Object.isExtensible && !Object.isExtensible(Kefir)) {\n\t\tKefir = Kefir.Kefir;\n\t}\n\n\tKefir.Observable.prototype._eventSetup = function eventSetup() {\n\t\tvar stream = this;\n\t\tvar meta = ensureMeta(stream);\n\n\t\tmeta.bound = true;\n\n\t\tmeta.onValueHandler = function onValueHandler(newValue) {\n\t\t\tvar oldValue = meta.value;\n\t\t\tmeta.value = newValue;\n\n\t\t\t// only send events for a change\n\t\t\tif (newValue !== oldValue) {\n\t\t\t\tmapEventsMixin.dispatch.call(\n\t\t\t\t\tstream,\n\t\t\t\t\t{ type: \"value\" },\n\t\t\t\t\t[newValue, oldValue]\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\n\t\tmeta.onErrorHandler = function onErrorHandler(error) {\n\t\t\tvar prevError = meta.error;\n\t\t\tmeta.error = error;\n\n\t\t\tmapEventsMixin.dispatch.call(\n\t\t\t\tstream,\n\t\t\t\t{ type: \"error\" },\n\t\t\t\t[error, prevError]\n\t\t\t);\n\t\t};\n\n\t\tstream.onValue(meta.onValueHandler);\n\t\tstream.onError(meta.onErrorHandler);\n\t};\n\n\tKefir.Observable.prototype._eventTeardown = function eventTeardown() {\n\t\tvar stream = this;\n\t\tvar meta = ensureMeta(stream);\n\n\t\tmeta.bound = false;\n\n\t\tstream.offValue(meta.onValueHandler);\n\t\tstream.offError(meta.onErrorHandler);\n\t};\n\n\t// Observable is parent of Kefir.Stream\n\tcanReflect.assignSymbols(Kefir.Observable.prototype, {\n\t\t\"can.onKeyValue\": function onKeyValue() {\n\t\t\treturn mapEventsMixin[onKeyValueSymbol].apply(\n\t\t\t\tthis,\n\t\t\t\targuments\n\t\t\t);\n\t\t},\n\t\t\"can.offKeyValue\": function() {\n\t\t\treturn mapEventsMixin[offKeyValueSymbol].apply(\n\t\t\t\tthis,\n\t\t\t\targuments\n\t\t\t);\n\t\t},\n\t\t\"can.getKeyValue\": function(key) {\n\t\t\tvar stream = this;\n\t\t\tvar meta = ensureMeta(stream);\n\n\t\t\tif (!keyNames[key]) {\n\t\t\t\treturn stream[key];\n\t\t\t}\n\n\t\t\tObservationRecorder.add(stream, key);\n\n\t\t\tif (meta.bound) {\n\t\t\t\treturn meta[key];\n\t\t\t} else {\n\t\t\t\t// we haven't been bound ... see what we can get from the observable\n\t\t\t\t// using internals for performance ...\n\t\t\t\tvar currentValue = getCurrentValue(stream, key);\n\n\t\t\t\t// save current value so we won't through events if we provided a value\n\t\t\t\tmeta[key] = currentValue;\n\n\t\t\t\treturn currentValue;\n\t\t\t}\n\t\t},\n\t\t\"can.getValueDependencies\": function getValueDependencies() {\n\t\t\tvar sources;\n\t\t\tvar stream = this;\n\n\t\t\t// streams created by methods like .scan have a single source,\n\t\t\t// stored in stream._source\n\t\t\tif (stream._source != null) {\n\t\t\t\tsources = [stream._source];\n\n\t\t\t// ... while methods like .combine have multiple sources\n\t\t\t// stored as an array in stream._sources\n\t\t\t} else if (stream._sources != null) {\n\t\t\t\tsources = stream._sources;\n\t\t\t}\n\n\t\t\tif (sources != null) {\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: new Set(sources)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t});\n\n\tKefir.emitterProperty = function() {\n\t\tvar emitter;\n\t\tvar setLastValue = false;\n\t\tvar lastValue, lastError;\n\n\t\tvar stream = Kefir.stream(function(EMITTER) {\n\t\t\temitter = EMITTER;\n\t\t\tif (setLastValue) {\n\t\t\t\temitter.value(lastValue);\n\t\t\t}\n\t\t\treturn function() {\n\t\t\t\temitter = undefined;\n\t\t\t};\n\t\t});\n\n\t\tvar property = stream.toProperty(function() {\n\t\t\treturn lastValue;\n\t\t});\n\t\tproperty.emitter = {\n\t\t\tvalue: function(newValue) {\n\t\t\t\tif (emitter) {\n\t\t\t\t\treturn emitter.emit(newValue);\n\t\t\t\t} else {\n\t\t\t\t\tsetLastValue = true;\n\t\t\t\t\tlastValue = newValue;\n\t\t\t\t}\n\t\t\t},\n\t\t\terror: function(error) {\n\t\t\t\tif (emitter) {\n\t\t\t\t\treturn emitter.error(error);\n\t\t\t\t} else {\n\t\t\t\t\tlastError = error;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tproperty.emitter.emit = property.emitter.value;\n\n\t\tcanReflect.assignSymbols(property, {\n\t\t\t\"can.setKeyValue\": function setKeyValue(key, value) {\n\t\t\t\tthis.emitter[key](value);\n\t\t\t},\n\t\t\t\"can.hasKey\": function hasKey(key) {\n\t\t\t\treturn key in this.emitter;\n\t\t\t}\n\t\t});\n\n\t\treturn property;\n\t};\n}\n\nmodule.exports = Kefir;\n\n\n//# sourceURL=webpack:///./node_modules/can-kefir/can-kefir.js?");

/***/ }),

/***/ "./node_modules/can-key-tree/can-key-tree.js":
/*!***************************************************!*\
  !*** ./node_modules/can-key-tree/can-key-tree.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar reflect = __webpack_require__( /*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\" );\n\n// ## Helpers\n// The following implement helper functions useful to `can-key-tree`'s main methods.\n\n// ### isBuiltInPrototype\n// Returns if `obj` is the prototype of a built-in JS type like `Map`.\n// Built in types' `toString` returns `[object TYPENAME]`.\nfunction isBuiltInPrototype ( obj ) {\n\tif ( obj === Object.prototype ) {\n\t\treturn true;\n\t}\n\tvar protoString = Object.prototype.toString.call( obj );\n\tvar isNotObjObj = protoString !== '[object Object]';\n\tvar isObjSomething = protoString.indexOf( '[object ' ) !== -1;\n\treturn isNotObjObj && isObjSomething;\n}\n\n// ### getDeepSize\n// Recursively returns the number of leaf values below `root` node.\nfunction getDeepSize ( root, level ) {\n\tif ( level === 0 ) {\n\t\treturn reflect.size( root );\n\t} else if ( reflect.size( root ) === 0 ) {\n\t\treturn 0;\n\t} else {\n\t\tvar count = 0;\n\t\treflect.each( root, function ( value ) {\n\t\t\tcount += getDeepSize( value, level - 1 );\n\t\t});\n\t\treturn count;\n\t}\n}\n\n// ### getDeep\n// Adds all leaf values under `node` to `items`.\n// `depth` is how deep `node` is in the tree.\n// `maxDepth` is the total depth of the tree structure.\nfunction getDeep ( node, items, depth, maxDepth ) {\n\tif ( !node ) {\n\t\treturn;\n\t}\n\tif ( maxDepth === depth ) {\n\t\tif ( reflect.isMoreListLikeThanMapLike( node ) ) {\n\t\t\treflect.addValues( items, reflect.toArray( node ) );\n\t\t} else {\n\t\t\tthrow new Error( \"can-key-tree: Map-type leaf containers are not supported yet.\" );\n\t\t}\n\t} else {\n\t\treflect.each( node, function ( value ) {\n\t\t\tgetDeep( value, items, depth + 1, maxDepth );\n\t\t});\n\t}\n}\n\n// ### clearDeep\n// Recursively removes value from all child nodes of `node`.\nfunction clearDeep ( node, keys, maxDepth, deleteHandler ) {\n\tif ( maxDepth === keys.length ) {\n\t\tif ( reflect.isMoreListLikeThanMapLike( node ) ) {\n\t\t\tvar valuesToRemove = reflect.toArray( node );\n\t\t\tif(deleteHandler) {\n\t\t\t\tvaluesToRemove.forEach(function(value){\n\t\t\t\t\tdeleteHandler.apply(null, keys.concat(value));\n\t\t\t\t});\n\t\t\t}\n\t\t\treflect.removeValues( node, valuesToRemove );\n\t\t} else {\n\t\t\tthrow new Error( \"can-key-tree: Map-type leaf containers are not supported yet.\" );\n\t\t}\n\t} else {\n\t\treflect.each( node, function ( value, key ) {\n\t\t\tclearDeep( value, keys.concat(key), maxDepth, deleteHandler );\n\t\t\treflect.deleteKeyValue( node, key );\n\t\t});\n\t}\n}\n\n// ## KeyTree\n// Creates an instance of the KeyTree.\nvar KeyTree = function ( treeStructure, callbacks ) {\n\tvar FirstConstructor = treeStructure[0];\n\tif ( reflect.isConstructorLike( FirstConstructor ) ) {\n\t\tthis.root = new FirstConstructor();\n\t} else {\n\t\tthis.root = FirstConstructor;\n\t}\n\tthis.callbacks = callbacks || {};\n\tthis.treeStructure = treeStructure;\n\t// An extra bit of state held for performance\n\tthis.empty = true;\n};\n\n// ## Methods\nreflect.assign(KeyTree.prototype,{\n    // ### Add\n    add: function ( keys ) {\n    \tif ( keys.length > this.treeStructure.length ) {\n    \t\tthrow new Error( \"can-key-tree: Can not add path deeper than tree.\" );\n    \t}\n        // The place we will add the final leaf value.\n    \tvar place = this.root;\n\n        // Record if the root was empty so we know to call `onFirst`.\n    \tvar rootWasEmpty = this.empty === true;\n\n        // For each key, try to get the corresponding childNode.\n        for ( var i = 0; i < keys.length - 1; i++ ) {\n    \t\tvar key = keys[i];\n    \t\tvar childNode = reflect.getKeyValue( place, key );\n    \t\tif ( !childNode ) {\n                // If there is no childNode, create it and add it to the parent node.\n    \t\t\tvar Constructor = this.treeStructure[i + 1];\n    \t\t\tif ( isBuiltInPrototype( Constructor.prototype ) ) {\n    \t\t\t\tchildNode = new Constructor();\n    \t\t\t} else {\n    \t\t\t\tchildNode = new Constructor( key );\n    \t\t\t}\n    \t\t\treflect.setKeyValue( place, key, childNode );\n    \t\t}\n    \t\tplace = childNode;\n    \t}\n\n        // Add the final leaf value in the tree.\n    \tif ( reflect.isMoreListLikeThanMapLike( place ) ) {\n    \t\treflect.addValues( place, [keys[keys.length - 1]] );\n    \t} else {\n    \t\tthrow new Error( \"can-key-tree: Map types are not supported yet.\" );\n    \t}\n\n        // Callback `onFirst` if appropriate.\n    \tif ( rootWasEmpty ) {\n\t\t\tthis.empty = false;\n\t\t\tif(this.callbacks.onFirst) {\n\t\t\t\tthis.callbacks.onFirst.call( this );\n\t\t\t}\n\n    \t}\n\n    \treturn this;\n    },\n    // ### getNode\n    getNode: function ( keys ) {\n        var node = this.root;\n        // For each key, try to read the child node.\n        // If a child is not found, return `undefined`.\n        for ( var i = 0; i < keys.length; i++ ) {\n            var key = keys[i];\n            node = reflect.getKeyValue( node, key );\n            if ( !node ) {\n                return;\n            }\n        }\n        return node;\n    },\n    // ### get\n    get: function ( keys ) {\n        // Get the node specified by keys.\n    \tvar node = this.getNode( keys );\n\n        // If it's a leaf, return it.\n    \tif ( this.treeStructure.length === keys.length ) {\n    \t\treturn node;\n    \t} else {\n    \t\t// Otherwise, create a container for leaf values and\n            // recursively walk the node's children.\n    \t\tvar Type = this.treeStructure[this.treeStructure.length - 1];\n    \t\tvar items = new Type();\n    \t\tgetDeep( node, items, keys.length, this.treeStructure.length - 1 );\n    \t\treturn items;\n    \t}\n    },\n    // ### delete\n    delete: function ( keys, deleteHandler ) {\n\n        // `parentNode` will eventually be the parent nodde of the\n        // node specified by keys.\n        var parentNode = this.root,\n            // The nodes traversed to the node specified by `keys`.\n            path = [this.root],\n            lastKey = keys[keys.length - 1];\n\n        // Set parentNode to the node specified by keys\n        // and record the nodes in `path`.\n        for ( var i = 0; i < keys.length - 1; i++ ) {\n    \t\tvar key = keys[i];\n    \t\tvar childNode = reflect.getKeyValue( parentNode, key );\n    \t\tif ( childNode === undefined ) {\n    \t\t\treturn false;\n    \t\t} else {\n    \t\t\tpath.push( childNode );\n    \t\t}\n    \t\tparentNode = childNode;\n    \t}\n\n\n        // Depending on which keys were specified and the content of the\n        // key, do various cleanups ...\n        if ( !keys.length ) {\n            // If there are no keys, recursively clear the entire tree.\n    \t\tclearDeep( parentNode, [], this.treeStructure.length - 1, deleteHandler );\n    \t}\n        else if ( keys.length === this.treeStructure.length ) {\n            // If removing a leaf, remove that value.\n    \t\tif ( reflect.isMoreListLikeThanMapLike( parentNode ) ) {\n\t\t\t\tif(deleteHandler) {\n\t\t\t\t\tdeleteHandler.apply(null, keys.concat(lastKey));\n\t\t\t\t}\n    \t\t\treflect.removeValues( parentNode, [lastKey] );\n    \t\t} else {\n    \t\t\tthrow new Error( \"can-key-tree: Map types are not supported yet.\" );\n    \t\t}\n    \t}\n        else {\n            // If removing a node 'within' the tree, recursively clear\n            // that node and then delete the key from parent to node.\n            var nodeToRemove = reflect.getKeyValue( parentNode, lastKey );\n    \t\tif ( nodeToRemove !== undefined ) {\n    \t\t\tclearDeep( nodeToRemove, keys, this.treeStructure.length - 1, deleteHandler );\n    \t\t\treflect.deleteKeyValue( parentNode, lastKey );\n    \t\t} else {\n    \t\t\treturn false;\n    \t\t}\n    \t}\n\n        // After deleting the node, check if its parent is empty and\n        // recursively prune parent nodes that are now empty.\n    \tfor ( i = path.length - 2; i >= 0; i-- ) {\n    \t\tif ( reflect.size( parentNode ) === 0 ) {\n    \t\t\tparentNode = path[i];\n    \t\t\treflect.deleteKeyValue( parentNode, keys[i] );\n    \t\t} else {\n    \t\t\tbreak;\n    \t\t}\n    \t}\n        // Call `onEmpty` if the tree is now empty.\n    \tif (  reflect.size( this.root ) === 0 ) {\n\t\t\tthis.empty = true;\n\t\t\tif(this.callbacks.onEmpty) {\n\t\t\t\tthis.callbacks.onEmpty.call( this );\n\t\t\t}\n    \t}\n    \treturn true;\n    },\n    // ### size\n    // Recursively count the number of leaf values.\n    size: function () {\n    \treturn getDeepSize( this.root, this.treeStructure.length - 1 );\n    },\n\tisEmpty: function(){\n\t\treturn this.empty;\n\t}\n});\n\nmodule.exports = KeyTree;\n\n\n//# sourceURL=webpack:///./node_modules/can-key-tree/can-key-tree.js?");

/***/ }),

/***/ "./node_modules/can-key/can-key.js":
/*!*****************************************!*\
  !*** ./node_modules/can-key/can-key.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar deleteKey = __webpack_require__(/*! can-key/delete/delete */ \"./node_modules/can-key/delete/delete.js\"),\n    get = __webpack_require__(/*! can-key/get/get */ \"./node_modules/can-key/get/get.js\"),\n    replaceWith = __webpack_require__(/*! can-key/replace-with/replace-with */ \"./node_modules/can-key/replace-with/replace-with.js\"),\n    set = __webpack_require__(/*! can-key/set/set */ \"./node_modules/can-key/set/set.js\"),\n    transform = __webpack_require__(/*! can-key/transform/transform */ \"./node_modules/can-key/transform/transform.js\"),\n    walk = __webpack_require__(/*! can-key/walk/walk */ \"./node_modules/can-key/walk/walk.js\"),\n    namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nmodule.exports = namespace.key = {\n    deleteKey: deleteKey,\n    get: get,\n    replaceWith: replaceWith,\n    set: set,\n    transform: transform,\n    walk: walk\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-key/can-key.js?");

/***/ }),

/***/ "./node_modules/can-key/delete/delete.js":
/*!***********************************************!*\
  !*** ./node_modules/can-key/delete/delete.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/can-key/utils.js\");\n\n/**\n * @module {function} can-key/delete/delete\n * @parent can-key\n */\nmodule.exports = function deleteAtPath(data, path) {\n    var parts = utils.parts(path);\n    var current = data;\n\n    for(var i = 0; i < parts.length - 1; i++) {\n        if(current) {\n            current = canReflect.getKeyValue( current, parts[i]);\n        }\n    }\n\n    if(current) {\n        canReflect.deleteKeyValue(current, parts[parts.length - 1 ]);\n    }\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-key/delete/delete.js?");

/***/ }),

/***/ "./node_modules/can-key/get/get.js":
/*!*****************************************!*\
  !*** ./node_modules/can-key/get/get.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/can-key/utils.js\");\n\n/**\n * @module {function} can-key/get/get\n * @parent can-key\n * @description Get properties on deep/nested objects of different types: Object, Map, [can-reflect] types, etc.\n *\n * @signature `get(obj, path)`\n * @param  {Object} obj the object to use as the root for property-based navigation\n * @param  {String} path a String of dot-separated keys, representing a path of properties\n * @return {*}       the value at the property path\n *\n * @body\n *\n * A *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n * 'bar' of the object at the property 'foo' of the root.\"  An empty path returns the object passed.\n *\n * ```js\n * var get = require(\"can-key\");\n * console.log(get({a: {b: {c: \"foo\"}}}, \"a.b.c\")); // -> \"foo\"\n * console.log(get({a: {}}, \"a.b.c\")); // -> undefined\n * console.log(get([{a: {}}, {a: {b: \"bar\"}}], \"a.b\")); // -> \"bar\"\n *\n * var map = new Map();\n * map.set(\"first\", {second: \"third\"});\n *\n * get(map, \"first.second\") //-> \"third\"\n * ```\n */\nfunction get(obj, name) {\n    // The parts of the name we are looking up\n    // `['App','Models','Recipe']`\n    var parts = utils.parts(name);\n\n    var length = parts.length,\n        current, i, container;\n\n    if (!length) {\n        return obj;\n    }\n\n    current = obj;\n\n    // Walk current to the 2nd to last object or until there\n    // is not a container.\n    for (i = 0; i < length && utils.isContainer(current) && current !== null; i++) {\n        container = current;\n        current = canReflect.getKeyValue( container, parts[i] );\n    }\n\n    return current;\n}\n\nmodule.exports = get;\n\n\n//# sourceURL=webpack:///./node_modules/can-key/get/get.js?");

/***/ }),

/***/ "./node_modules/can-key/replace-with/replace-with.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-key/replace-with/replace-with.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/can-key/utils.js\");\nvar get = __webpack_require__(/*! ../get/get */ \"./node_modules/can-key/get/get.js\");\nvar deleteKey = __webpack_require__(/*! ../delete/delete */ \"./node_modules/can-key/delete/delete.js\");\n/**\n * @module {function} can-key/replace-with/replace-with\n * @parent can-key\n *\n * Replace the templated parts of a string with values from an object.\n *\n * @signature `replaceWith(str, data, replacer, remove)`\n *\n * ```js\n * import replaceWith from \"can-key/replace-with/replace-with\";\n *\n * replaceWith(\"foo_{bar}\", {bar: \"baz\"}); // -> \"foo_baz\"\n * ```\n *\n * @param {String} str String with {curly brace} delimited property names.\n * @param {Object} data Object from which to read properties.\n * @param {function(String,*)} [replacer(key,value)] Function which returns string replacements.  Optional.\n *\n *   ```js\n *   replaceWith(\"foo_{bar}\", {bar: \"baz\"}, (key, value) => {\n *     return value.toUpperCase();\n *   }); // -> \"foo_BAZ\"\n *   ```\n *\n *\n * @param {Boolean} shouldRemoveMatchedPaths Whether to remove properties\n * found in delimiters in `str` from `data`.\n * @return {String} the supplied string with delimited properties replaced with their values.\n *\n * @body\n *\n * ```js\n * var replaceWith = require(\"can-key/replace-with/replace-with\");\n * var answer = replaceWith(\n *   '{.}{.}{.}{.}{.} Batman!',\n *   {},\n *   () => 'Na'\n * );\n * // => 'NaNaNaNaNa Batman!'\n * ```\n */\nmodule.exports = function (str, data, replacer, shouldRemoveMatchedPaths) {\n    return str.replace(utils.strReplacer, function (whole, path) {\n        var value = get(data, path);\n        if(shouldRemoveMatchedPaths) {\n            deleteKey(data, path);\n        }\n        return replacer ? replacer(path, value) : value;\n    });\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-key/replace-with/replace-with.js?");

/***/ }),

/***/ "./node_modules/can-key/set/set.js":
/*!*****************************************!*\
  !*** ./node_modules/can-key/set/set.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/can-key/utils.js\");\n\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\n\n/**\n * @module {function} can-key/set/set\n * @parent can-key\n * @description Set properties on deep/nested objects of different types: Object, Map, [can-reflect] types, etc.\n *\n * @signature `set(object, path, value)`\n * @param  {Object} object The object to use as the root for property-based navigation.\n * @param  {String} path A String of dot-separated keys, representing a path of properties.\n * @param  {*} value The new value to be set at the property path.\n * @return {*} The object passed to set (for chaining calls).\n *\n * @body\n *\n * A *path* is a dot-delimited sequence of one or more property names, such that \"foo.bar\" means \"the property\n * 'bar' of the object at the property 'foo' of the root.\"\n *\n * ```js\n * import set from \"can-key/set/set\";\n *\n * const object = {a: {b: {c: \"foo\"}}};\n * set(object, \"a.b.c\", \"bar\");\n * // Now object.a.b.c === \"bar\"\n *\n * var map = new Map();\n * map.set(\"first\", {second: \"third\"});\n *\n * set(map, \"first.second\", \"3rd\");\n * // Now map.first.second === \"3rd\"\n * ```\n *\n * > **Note:** an error will be thrown if one of the objects in the key path does not exist.\n */\nfunction set(object, path, value) {\n    var parts = utils.parts(path);\n\n    var current = object;\n    var length = parts.length;\n\n    // Walk current until there is not a container\n    for (var i = 0; i < length - 1; i++) {\n        if (utils.isContainer(current)) {\n            current = canReflect.getKeyValue(current, parts[i]);\n        } else {\n            break;\n        }\n    }\n\n    // Set the value\n    if (current) {\n        canReflect.setKeyValue(current, parts[i], value);\n    } else {\n        throw new TypeError(\"Cannot set value at key path '\" + path + \"'\");\n    }\n\n    return object;\n}\n\nmodule.exports = set;\n\n\n//# sourceURL=webpack:///./node_modules/can-key/set/set.js?");

/***/ }),

/***/ "./node_modules/can-key/sub/sub.js":
/*!*****************************************!*\
  !*** ./node_modules/can-key/sub/sub.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/can-key/utils.js\");\nvar get = __webpack_require__(/*! ../get/get */ \"./node_modules/can-key/get/get.js\");\nvar canReflect= __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar deleteKey = __webpack_require__(/*! ../delete/delete */ \"./node_modules/can-key/delete/delete.js\");\n/**\n * @module {function} can-key/sub/sub\n * @parent can-key\n * @hide\n *\n * Replace templated parts of a string with values.\n *\n * @signature `sub(str, data, remove)`\n *\n * `sub` is used to replace templated parts of a string with values.\n *\n * ```js\n * var sub = require(\"can-key/sub/sub\");\n *\n * sub(\"foo_{bar}\", {bar: \"baz\"}); // -> \"foo_baz\"\n * ```\n *\n * If `null` or `undefined` values are found, `null` is returned:\n *\n * ```js\n * sub(\"foo_{bar}\", {}); // -> null\n * ```\n *\n * If an object value is found, the templated part of the string is replace with `\"\"`\n * and the object is added to an array that is returned.\n *\n * ```js\n * var data = {element: div, selector: \"li\" }\n * var res = sub(\"{element} {selector} click\", data);\n * res //-> [\" li click\", div]\n * ```\n *\n * @param {String} str   a string with {curly brace} delimited property names\n * @param {Object} data  an object from which to read properties\n * @return {String|null|Array} the supplied string with delimited properties replaced with their values\n *                       if all properties exist on the object, null otherwise\n *\n * If `remove` is true, the properties found in delimiters in `str` are removed from `data`.\n *\n *\n */\nmodule.exports = function sub(str, data, remove) {\n\tvar obs = [];\n\tstr = str || '';\n\tobs.push(str.replace(utils.strReplacer, function (whole, inside) {\n\t\t// Convert inside to type.\n\t\tvar ob = get(data, inside);\n\n\t\tif(remove === true) {\n\t\t\tdeleteKey(data, inside);\n\t\t}\n\n\t\tif (ob === undefined || ob === null) {\n\t\t\tobs = null;\n\t\t\treturn '';\n\t\t}\n\t\t// If a container, push into objs (which will return objects found).\n\t\tif (!canReflect.isPrimitive(ob) && obs) {\n\t\t\tobs.push(ob);\n\t\t\treturn '';\n\t\t}\n\t\treturn '' + ob;\n\t}));\n\treturn obs === null ? obs : obs.length <= 1 ? obs[0] : obs;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-key/sub/sub.js?");

/***/ }),

/***/ "./node_modules/can-key/transform/transform.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-key/transform/transform.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar walk = __webpack_require__(/*! ../walk/walk */ \"./node_modules/can-key/walk/walk.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/can-key/utils.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nfunction deleteKeys(parentsAndKeys) {\n    for(var i  = parentsAndKeys.length - 1; i >= 0; i--) {\n        var parentAndKey = parentsAndKeys[i];\n        delete  parentAndKey.parent[parentAndKey.key];\n        if(canReflect.size(parentAndKey.parent) !== 0) {\n            return;\n        }\n    }\n}\n/**\n * @module {function} can-key/transform/transform\n * @parent can-key\n */\nmodule.exports = function(obj, transformer){\n    var copy = canReflect.serialize( obj);\n\n    canReflect.eachKey(transformer, function(writeKey, readKey){\n        var readParts = utils.parts(readKey),\n            writeParts = utils.parts(writeKey);\n\n        // find the value\n        var parentsAndKeys = [];\n        walk(copy, readParts, function(info){\n            parentsAndKeys.push(info);\n        });\n        var last = parentsAndKeys[parentsAndKeys.length - 1];\n        var value = last.value;\n        if(value !== undefined) {\n            // write the value\n            walk(copy, writeParts, function(info, i){\n                if(i < writeParts.length - 1 && !info.value) {\n                    return info.parent[info.key] = {};\n                } else if(i === writeParts.length - 1){\n                    info.parent[info.key] = value;\n                }\n            });\n            // delete the keys on old\n            deleteKeys(parentsAndKeys);\n\n        }\n    });\n    return copy;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-key/transform/transform.js?");

/***/ }),

/***/ "./node_modules/can-key/utils.js":
/*!***************************************!*\
  !*** ./node_modules/can-key/utils.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = {\n    isContainer: function (current) {\n        var type = typeof current;\n        return current && (type === \"object\" || type === \"function\");\n    },\n    strReplacer: /\\{([^\\}]+)\\}/g,\n\n    parts: function(name) {\n        if(Array.isArray(name)) {\n            return name;\n        } else {\n            return typeof name !== 'undefined' ? (name + '').replace(/\\[/g,'.')\n            \t\t.replace(/]/g,'').split('.') : [];\n        }\n    }\n};\n\nmodule.exports= utils;\n\n\n//# sourceURL=webpack:///./node_modules/can-key/utils.js?");

/***/ }),

/***/ "./node_modules/can-key/walk/walk.js":
/*!*******************************************!*\
  !*** ./node_modules/can-key/walk/walk.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/can-key/utils.js\");\n\n\n/**\n * @module {function} can-key/walk/walk\n * @parent can-key\n *\n * @signature `walk(obj, name, keyCallback(info) )`\n *\n * ```js\n * import walk from \"can-key/walk/walk\";\n *\n * var user = {name: {first: \"Justin\"}}\n * walk(user, \"name.first\", (keyInfo)=> {\n *   // Called 2 times.\n *   // first call:\n *   keyInfo //-> {parent: user, key: \"name\", value: user.name}\n *   // second call:\n *   keyInfo //-> {parent: user.name, key: \"first\", value: user.name.first}\n * })\n * ```\n *\n * @param {Object} obj An object to read key values from.\n * @param {String} name A string key name like \"foo.bar\".\n * @param {function(Object)} keyCallback(info) For every key value,\n * `keyCallback` will be called back with an `info` object containing:\n *\n * - `info.parent` - The object the property value is being read from.\n * - `info.key` - The key being read.\n * - `info.value` - The key's value.\n *\n * If `keyCallback` returns a value other than `undefined`, the next key value\n * will be read from that value.\n */\nmodule.exports = function walk(obj, name, keyCallback){\n\n    // The parts of the name we are looking up\n    // `['App','Models','Recipe']`\n    var parts = utils.parts(name);\n\n    var length = parts.length,\n        current, i, container, part;\n\n\n    if (!length) {\n        return;\n    }\n\n    current = obj;\n\n    // Walk current to the 2nd to last object or until there\n    // is not a container.\n    for (i = 0; i < length; i++) {\n        container = current;\n        part = parts[i];\n        current = utils.isContainer(container) && canReflect.getKeyValue( container, part );\n\n        var result = keyCallback({\n            parent:container,\n            key: part,\n            value: current\n        }, i);\n        if(result !== undefined) {\n            current = result;\n        }\n    }\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-key/walk/walk.js?");

/***/ }),

/***/ "./node_modules/can-list/can-list.js":
/*!*******************************************!*\
  !*** ./node_modules/can-list/can-list.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint -W079 */\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar Map = __webpack_require__(/*! can-map */ \"./node_modules/can-map/can-map.js\");\nvar bubble = __webpack_require__(/*! can-map/bubble */ \"./node_modules/can-map/bubble.js\");\nvar mapHelpers = __webpack_require__(/*! can-map/map-helpers */ \"./node_modules/can-map/map-helpers.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar canEvent = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar CID = __webpack_require__(/*! can-cid */ \"./node_modules/can-cid/can-cid.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar types = __webpack_require__(/*! can-types */ \"./node_modules/can-types/can-types.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar CIDMap = __webpack_require__(/*! can-cid/map/map */ \"./node_modules/can-cid/map/map.js\");\n\n// Helpers for `observable` lists.\nvar splice = [].splice,\n\t// test if splice works correctly\n\tspliceRemovesProps = (function () {\n\t\t// IE's splice doesn't remove properties\n\t\tvar obj = {\n\t\t\t0: \"a\",\n\t\t\tlength: 1\n\t\t};\n\t\tsplice.call(obj, 0, 1);\n\t\treturn !obj[0];\n\t})();\n\n// Function that serializes the passed arg if\n// type does not match MapType of `this` list\n// then adds to args array\nvar serializeNonTypes = function(MapType, arg, args) {\n\tif(arg && arg.serialize && !(arg instanceof MapType)) {\n\t\targs.push(new MapType(arg.serialize()));\n\t} else {\n\t\targs.push(arg);\n\t}\n};\n\nvar List = Map.extend(\n\t{\n\t\tMap: Map\n\t},\n\t{\n\t\tsetup: function (instances, options) {\n\t\t\tthis.length = 0;\n\t\t\tCID(this, \".map\");\n\t\t\tthis._setupComputedProperties();\n\t\t\tinstances = instances === undefined ? [] : canReflect.toArray(instances);\n\t\t\tvar teardownMapping;\n\n\t\t\tif (canReflect.isPromise(instances)) {\n\t\t\t\tthis.replace(instances);\n\t\t\t} else {\n\t\t\t\tteardownMapping = instances.length && mapHelpers.addToMap(instances, this);\n\t\t\t\tthis.push.apply(this, instances);\n\t\t\t}\n\n\t\t\tif (teardownMapping) {\n\t\t\t\tteardownMapping();\n\t\t\t}\n\n\t\t\t// this change needs to be ignored\n\t\t\tassign(this, options);\n\t\t},\n\t\t_triggerChange: function (attr, how, newVal, oldVal) {\n\t\t\tqueues.batch.start();\n\t\t\t// `batchTrigger` direct add and remove events...\n\t\t\tvar index = +attr, patches;\n\t\t\t// Make sure this is not nested and not an expando\n\n\t\t\tif (!~(\"\"+attr).indexOf('.') && !isNaN(index)) {\n\t\t\t\tif(bubble.isBubbling(this, \"change\")) {\n\t\t\t\t\tcanEvent.dispatch.call(this, {\n\t\t\t\t\t\ttype: \"change\",\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t}, [attr, how, newVal, oldVal]);\n\t\t\t\t}\n\t\t\t\tif (how === 'add') {\n\t\t\t\t\tpatches = [{insert: newVal, index: index, deleteCount: 0, type: \"splice\"}];\n\t\t\t\t\tcanEvent.dispatch.call(this, {type: how, patches: patches}, [newVal, index]);\n\t\t\t\t\tcanEvent.dispatch.call(this, 'length', [this.length]);\n\t\t\t\t\tcanEvent.dispatch.call(this, 'can.patches', [patches]);\n\t\t\t\t} else if (how === 'remove') {\n\t\t\t\t\tpatches = [{index: index, deleteCount: oldVal.length, type: \"splice\"}];\n\t\t\t\t\tcanEvent.dispatch.call(this, {type: how, patches: patches}, [oldVal, index]);\n\t\t\t\t\tcanEvent.dispatch.call(this, 'length', [this.length]);\n\t\t\t\t\tcanEvent.dispatch.call(this, 'can.patches', [patches]);\n\t\t\t\t} else {\n\t\t\t\t\tcanEvent.dispatch.call(this, how, [newVal, index]);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tMap.prototype._triggerChange.apply(this, arguments);\n\t\t\t}\n\t\t\tqueues.batch.stop();\n\t\t},\n\t\t__get: function(prop){\n\t\t\tprop = isNaN(+prop) || (prop % 1) ? prop : +prop;\n\t\t\tif(typeof prop === \"number\") {\n\t\t\t\tObservationRecorder.add(this, \"can.patches\");\n\t\t\t\treturn this.___get( \"\" + prop );\n\t\t\t} else {\n\t\t\t\treturn Map.prototype.__get.call(this, prop);\n\t\t\t}\n\t\t},\n\t\t___get: function (attr) {\n\t\t\tif (attr) {\n\t\t\t\tvar computedAttr = this._computedAttrs[attr];\n\t\t\t\tif(computedAttr && computedAttr.compute) {\n\t\t\t\t\treturn canReflect.getValue(computedAttr.compute);\n\t\t\t\t}\n\n\t\t\t\tif (this[attr] && this[attr].isComputed && typeof this.constructor.prototype[attr] === \"function\" ) {\n\t\t\t\t\treturn canReflect.getValue(this[attr]);\n\t\t\t\t} else {\n\t\t\t\t\treturn this[attr];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t},\n\t\t__set: function (prop, value, current) {\n\t\t\t// We want change events to notify using integers if we're\n\t\t\t// setting an integer index. Note that <float> % 1 !== 0;\n\t\t\tprop = isNaN(+prop) || (prop % 1) ? prop : +prop;\n\n\t\t\t// Check to see if we're doing a .attr() on an out of\n\t\t\t// bounds index property.\n\t\t\tif (typeof prop === \"number\") {\n\t\t\t\tif( prop > this.length - 1 ) {\n\t\t\t\t\tvar newArr = new Array((prop + 1) - this.length);\n\t\t\t\t\tnewArr[newArr.length-1] = value;\n\t\t\t\t\tthis.push.apply(this, newArr);\n\t\t\t\t\treturn newArr;\n\t\t\t\t} else {\n\t\t\t\t\tthis.splice(prop,1,value);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Map.prototype.__set.call(this, \"\"+prop, value, current);\n\t\t},\n\t\t___set: function (attr, val) {\n\t\t\tthis[attr] = val;\n\t\t\tif (+attr >= this.length) {\n\t\t\t\tthis.length = (+attr + 1);\n\t\t\t}\n\t\t},\n\t\t__remove: function(prop, current) {\n\t\t\t// if removing an expando property\n\t\t\tif(isNaN(+prop)) {\n\t\t\t\tdelete this[prop];\n\t\t\t\tthis._triggerChange(prop, \"remove\", undefined, current);\n\t\t\t} else {\n\t\t\t\tthis.splice(prop, 1);\n\t\t\t}\n\t\t},\n\t\t_each: function (callback) {\n\t\t\tvar data = this.___get();\n\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\tcallback(data[i], i);\n\t\t\t}\n\t\t},\n\t\t// Returns the serialized form of this list.\n\t\t/**\n\t\t * @hide\n\t\t * Returns the serialized form of this list.\n\t\t */\n\t\tserialize: function () {\n\t\t\treturn canReflect.serialize(this, CIDMap);\n\t\t},\n\t\tsplice: function (index, howMany) {\n\t\t\tvar args = canReflect.toArray(arguments),\n\t\t\t\tadded =[],\n\t\t\t\ti, len, listIndex,\n\t\t\t\tallSame = args.length > 2;\n\n\t\t\tindex = index || 0;\n\n\t\t\t// converting the arguments to the right type\n\t\t\tfor (i = 0, len = args.length-2; i < len; i++) {\n\t\t\t\tlistIndex = i + 2;\n\t\t\t\targs[listIndex] = this.__type(args[listIndex], listIndex);\n\t\t\t\tadded.push(args[listIndex]);\n\n\t\t\t\t// Now lets check if anything will change\n\t\t\t\tif(this[i+index] !== args[listIndex]) {\n\t\t\t\t\tallSame = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if nothing has changed, then return\n\t\t\tif(allSame && this.length <= added.length) {\n\t\t\t\treturn added;\n\t\t\t}\n\n\t\t\t// default howMany if not provided\n\t\t\tif (howMany === undefined) {\n\t\t\t\thowMany = args[1] = this.length - index;\n\t\t\t}\n\n\t\t\tvar removed = splice.apply(this, args);\n\n\t\t\t// delete properties for browsers who's splice sucks (old ie)\n\t\t\tif (!spliceRemovesProps) {\n\t\t\t\tfor (i = this.length; i < removed.length + this.length; i++) {\n\t\t\t\t\tdelete this[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqueues.batch.start();\n\t\t\tif (howMany > 0) {\n\t\t\t\t// tears down bubbling\n\t\t\t\tbubble.removeMany(this, removed);\n\t\t\t\tthis._triggerChange(\"\" + index, \"remove\", undefined, removed);\n\t\t\t}\n\t\t\tif (args.length > 2) {\n\t\t\t\t// make added items bubble to this list\n\t\t\t\tbubble.addMany(this, added);\n\t\t\t\tthis._triggerChange(\"\" + index, \"add\", added, removed);\n\t\t\t}\n\t\t\tqueues.batch.stop();\n\t\t\treturn removed;\n\t\t}\n\t}),\n\n\t// Converts to an `array` of arguments.\n\tgetArgs = function (args) {\n\t\treturn args[0] && Array.isArray(args[0]) ?\n\t\t\targs[0] :\n\t\t\tcanReflect.toArray(args);\n\t};\n// Create `push`, `pop`, `shift`, and `unshift`\ncanReflect.eachKey({\n\t\t/**\n\t\t * @function can-list.prototype.push push\n\t\t * @parent can-list.prototype\n\t\t * @description Add elements to the end of a list.\n\t\t * @signature `list.push(...elements)`\n\t\t *\n\t\t * `push` adds elements onto the end of a List.\n\t\t *\n\t\t * @param {*} elements the elements to add to the List\n\t\t *\n\t\t * @return {Number} the new length of the List\n\t\t *\n\t\t * @body\n\t\t * `push` adds elements onto the end of a List here is an example:\n\t\t *\n\t\t * ```\n\t\t * var list = new List(['Alice']);\n\t\t *\n\t\t * list.push('Bob', 'Eve');\n\t\t * list.attr(); // ['Alice', 'Bob', 'Eve']\n\t\t * ```\n\t\t *\n\t\t * If you have an array you want to concatenate to the end\n\t\t * of the List, you can use `apply`:\n\t\t *\n\t\t * ```\n\t\t * var names = ['Bob', 'Eve'],\n\t\t *     list = new List(['Alice']);\n\t\t *\n\t\t * list.push.apply(list, names);\n\t\t * list.attr(); // ['Alice', 'Bob', 'Eve']\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `push` causes _change_, _add_, and _length_ events to be fired.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `push` has a counterpart in [can-list.prototype.pop], or you may be\n\t\t * looking for [can-list.prototype.unshift] and its counterpart [can-list.prototype.shift].\n\t\t */\n\t\tpush: \"length\",\n\t\t/**\n\t\t * @function can-list.prototype.unshift unshift\n\t\t * @parent can-list.prototype\n\t\t * @description Add elements to the beginning of a List.\n\t\t * @signature `list.unshift(...elements)`\n\t\t *\n\t\t * `unshift` adds elements onto the beginning of a List.\n\t\t *\n\t\t * @param {*} elements the elements to add to the List\n\t\t *\n\t\t * @return {Number} the new length of the List\n\t\t *\n\t\t * @body\n\t\t * `unshift` adds elements to the front of the list in bulk in the order specified:\n\t\t *\n\t\t * ```\n\t\t * var list = new List(['Alice']);\n\t\t *\n\t\t * list.unshift('Bob', 'Eve');\n\t\t * list.attr(); // ['Bob', 'Eve', 'Alice']\n\t\t * ```\n\t\t *\n\t\t * If you have an array you want to concatenate to the beginning\n\t\t * of the List, you can use `apply`:\n\t\t *\n\t\t * ```\n\t\t * var names = ['Bob', 'Eve'],\n\t\t *     list = new List(['Alice']);\n\t\t *\n\t\t * list.unshift.apply(list, names);\n\t\t * list.attr(); // ['Bob', 'Eve', 'Alice']\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `unshift` causes _change_, _add_, and _length_ events to be fired.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `unshift` has a counterpart in [can-list.prototype.shift], or you may be\n\t\t * looking for [can-list.prototype.push] and its counterpart [can-list.prototype.pop].\n\t\t */\n\t\tunshift: 0\n\t},\n\t// Adds a method\n\t// `name` - The method name.\n\t// `where` - Where items in the `array` should be added.\n\tfunction (where, name) {\n\t\tvar orig = [][name];\n\t\tList.prototype[name] = function () {\n\t\t\t// Get the items being added.\n\t\t\tvar args = [],\n\t\t\t\t// Where we are going to add items.\n\t\t\t\tlen = where ? this.length : 0,\n\t\t\t\ti = arguments.length,\n\t\t\t\tres, val;\n\n\t\t\t// Go through and convert anything to a `map` that needs to be converted.\n\t\t\twhile (i--) {\n\t\t\t\tval = arguments[i];\n\t\t\t\targs[i] = bubble.set(this, i, this.__type(val, i) );\n\t\t\t}\n\n\t\t\t// Call the original method.\n\t\t\tres = orig.apply(this, args);\n\n\t\t\tif (!this.comparator || args.length) {\n\n\t\t\t\tthis._triggerChange(\"\" + len, \"add\", args, undefined);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t};\n\t});\n\ncanReflect.eachKey({\n\t\t/**\n\t\t * @function can-list.prototype.pop pop\n\t\t * @parent can-list.prototype\n\t\t * @description Remove an element from the end of a List.\n\t\t * @signature `list.pop()`\n\t\t *\n\t\t * `pop` removes an element from the end of a List.\n\t\t *\n\t\t * @return {*} the element just popped off the List, or `undefined` if the List was empty\n\t\t *\n\t\t * @body\n\t\t * `pop` is the opposite action from [can-list.prototype.push]:\n\t\t *\n\t\t * ```\n\t\t * var list = new List(['Alice', 'Bob', 'Eve']);\n\t\t * list.attr(); // ['Alice', 'Bob', 'Eve']\n\t\t *\n\t\t * list.pop(); // 'Eve'\n\t\t * list.pop(); // 'Bob'\n\t\t * list.pop(); // 'Alice'\n\t\t * list.pop(); // undefined\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\n\t\t * when it is called.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `pop` has its counterpart in [can-list.prototype.push], or you may be\n\t\t * looking for [can-list.prototype.unshift] and its counterpart [can-list.prototype.shift].\n\t\t */\n\t\tpop: \"length\",\n\t\t/**\n\t\t * @function can-list.prototype.shift shift\n\t\t * @parent can-list.prototype\n\t\t * @description Remove en element from the front of a list.\n\t\t * @signature `list.shift()`\n\t\t *\n\t\t * `shift` removes an element from the beginning of a List.\n\t\t *\n\t\t * @return {*} the element just shifted off the List, or `undefined` if the List is empty\n\t\t *\n\t\t * @body\n\t\t * `shift` is the opposite action from `[can-list.prototype.unshift]`:\n\t\t *\n\t\t * ```\n\t\t * var list = new List(['Alice']);\n\t\t *\n\t\t * list.unshift('Bob', 'Eve');\n\t\t * list.attr(); // ['Bob', 'Eve', 'Alice']\n\t\t *\n\t\t * list.shift(); // 'Bob'\n\t\t * list.shift(); // 'Eve'\n\t\t * list.shift(); // 'Alice'\n\t\t * list.shift(); // undefined\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\n\t\t * when it is called.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `shift` has a counterpart in [can-list.prototype.unshift], or you may be\n\t\t * looking for [can-list.prototype.push] and its counterpart [can-list.prototype.pop].\n\t\t */\n\t\tshift: 0\n\t},\n\t// Creates a `remove` type method\n\tfunction (where, name) {\n\t\tList.prototype[name] = function () {\n\t\t\tif (!this.length) {\n\t\t\t\t// For shift and pop, we just return undefined without\n\t\t\t\t// triggering events.\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tvar args = getArgs(arguments),\n\t\t\t\tlen = where && this.length ? this.length - 1 : 0;\n\n\t\t\tvar res = [][name].apply(this, args);\n\n\t\t\t// Create a change where the args are\n\t\t\t// `len` - Where these items were removed.\n\t\t\t// `remove` - Items removed.\n\t\t\t// `undefined` - The new values (there are none).\n\t\t\t// `res` - The old, removed values (should these be unbound).\n\t\t\tthis._triggerChange(\"\" + len, \"remove\", undefined, [res]);\n\n\t\t\tif (res && res.removeEventListener) {\n\t\t\t\tbubble.remove(this, res);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t};\n\t});\n\nassign(List.prototype, {\n\t/**\n\t * @function can-list.prototype.indexOf indexOf\n\t * @parent can-list.prototype\n\t * @description Look for an item in a List.\n\t * @signature `list.indexOf(item)`\n\t *\n\t * `indexOf` finds the position of a given item in the List.\n\t *\n\t * @param {*} item the item to find\n\t *\n\t * @return {Number} the position of the item in the List, or -1 if the item is not found.\n\t *\n\t * @body\n\t * ```\n\t * var list = new List(['Alice', 'Bob', 'Eve']);\n\t * list.indexOf('Alice');   // 0\n\t * list.indexOf('Charlie'); // -1\n\t * ```\n\t *\n\t * It is trivial to make a `contains`-type function using `indexOf`:\n\t *\n\t * ```\n\t * function(list, item) {\n\t *     return list.indexOf(item) >= 0;\n\t * }\n\t * ```\n\t */\n\tindexOf: function (item, fromIndex) {\n\t\tObservationRecorder.add(this, \"length\");\n\t\tfor(var i = fromIndex || 0, len = this.length; i < len; i++) {\n\t\t\tif(this.attr(i) === item) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\t/**\n\t * @function can-list.prototype.join join\n\t * @parent can-list.prototype\n\t * @description Join a List's elements into a string.\n\t * @signature `list.join(separator)`\n\t *\n\t * `join` turns a List into a string by inserting _separator_ between the string representations\n\t * of all the elements of the List.\n\t *\n\t * @param {String} separator the string to seperate elements with\n\t *\n\t * @return {String} the joined string\n\t *\n\t * @body\n\t * ```\n\t * var list = new List(['Alice', 'Bob', 'Eve']);\n\t * list.join(', '); // 'Alice, Bob, Eve'\n\t *\n\t * var beatles = new List(['John', 'Paul', 'Ringo', 'George']);\n\t * beatles.join('&'); // 'John&Paul&Ringo&George'\n\t * ```\n\t */\n\tjoin: function () {\n\t\tObservationRecorder.add(this, \"length\");\n\t\treturn [].join.apply(this, arguments);\n\t},\n\n\t/**\n\t * @function can-list.prototype.reverse reverse\n\t * @parent can-list.prototype\n\t * @description Reverse the order of a List.\n\t * @signature `list.reverse()`\n\t *\n\t * `reverse` reverses the elements of the List in place.\n\t *\n\t * @return {can-list} the List, for chaining\n\t *\n\t * @body\n\t * ```\n\t * var list = new List(['Alice', 'Bob', 'Eve']);\n\t * var reversedList = list.reverse();\n\t *\n\t * reversedList.attr(); // ['Eve', 'Bob', 'Alice'];\n\t * list === reversedList; // true\n\t * ```\n\t */\n\treverse: function() {\n\t\tvar list = [].reverse.call(canReflect.toArray(this));\n\t\treturn this.replace(list);\n\t},\n\n\t/**\n\t * @function can-list.prototype.slice slice\n\t * @parent can-list.prototype\n\t * @description Make a copy of a part of a List.\n\t * @signature `list.slice([start[, end]])`\n\t *\n\t * `slice` creates a copy of a portion of the List.\n\t *\n\t * @param {Number} [start=0] the index to start copying from\n\t *\n\t * @param {Number} [end] the first index not to include in the copy\n\t * If _end_ is not supplied, `slice` will copy until the end of the list.\n\t *\n\t * @return {can-list} a new `can-list` with the extracted elements\n\t *\n\t * @body\n\t * ```\n\t * var list = new List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\n\t * var newList = list.slice(1, 4);\n\t * newList.attr(); // ['Bob', 'Charlie', 'Daniel']\n\t * ```\n\t *\n\t * `slice` is the simplest way to copy a List:\n\t *\n\t * ```\n\t * var list = new List(['Alice', 'Bob', 'Eve']);\n\t * var copy = list.slice();\n\t *\n\t * copy.attr();   // ['Alice', 'Bob', 'Eve']\n\t * list === copy; // false\n\t * ```\n\t */\n\tslice: function () {\n\t\t// tells computes to listen on length for changes.\n\t\tObservationRecorder.add(this, \"length\");\n\t\tvar temp = Array.prototype.slice.apply(this, arguments);\n\t\treturn new this.constructor(temp);\n\t},\n\n\t/**\n\t * @function can-list.prototype.concat concat\n\t * @parent can-list.prototype\n\t * @description Merge many collections together into a List.\n\t * @signature `list.concat(...args)`\n\t * @param {Array|can-list|*} args Any number of arrays, Lists, or values to add in\n\t * For each parameter given, if it is an Array or a List, each of its elements will be added to\n\t * the end of the concatenated List. Otherwise, the parameter itself will be added.\n\t *\n\t * @body\n\t * `concat` makes a new List with the elements of the List followed by the elements of the parameters.\n\t *\n\t * ```\n\t * var list = new List();\n\t * var newList = list.concat(\n\t *     'Alice',\n\t *     ['Bob', 'Charlie']),\n\t *     new List(['Daniel', 'Eve']),\n\t *     {f: 'Francis'}\n\t * );\n\t * newList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n\t * ```\n\t */\n\tconcat: function() {\n\t\tvar args = [],\n\t\t\tMapType = this.constructor.Map;\n\t\t// Go through each of the passed `arguments` and\n\t\t// see if it is list-like, an array, or something else\n\t\tcanReflect.each(arguments, function(arg) {\n\t\t\tif((canReflect.isObservableLike(arg) && canReflect.isListLike(arg)) || Array.isArray(arg)) {\n\t\t\t\t// If it is list-like we want convert to a JS array then\n\t\t\t\t// pass each item of the array to serializeNonTypes\n\t\t\t\tvar arr = (canReflect.isObservableLike(arg) && canReflect.isListLike(arg)) ? canReflect.toArray(arg) : arg;\n\t\t\t\tcanReflect.each(arr, function(innerArg) {\n\t\t\t\t\tserializeNonTypes(MapType, innerArg, args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// If it is a Map, Object, or some primitive\n\t\t\t\t// just pass arg to serializeNonTypes\n\t\t\t\tserializeNonTypes(MapType, arg, args);\n\t\t\t}\n\t\t});\n\n\t\t// We will want to make `this` list into a JS array\n\t\t// as well (We know it should be list-like), then\n\t\t// concat with our passed in args, then pass it to\n\t\t// list constructor to make it back into a list\n\t\treturn new this.constructor(Array.prototype.concat.apply(canReflect.toArray(this), args));\n\t},\n\n\t/**\n\t * @function can-list.prototype.forEach forEach\n\t * @parent can-list.prototype\n\t * @description Call a function for each element of a List.\n\t * @signature `list.forEach(callback[, thisArg])`\n\t * @param {function(element, index, list)} callback a function to call with each element of the List\n\t * The three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the\n\t * current element of the list, and _list_ the List the elements are coming from. _callback_ is\n\t * not invoked for List elements that were never initialized.\n\t * @param {Object} [thisArg] the object to use as `this` inside the callback\n\t *\n\t * @body\n\t * `forEach` calls a callback for each element in the List.\n\t *\n\t * ```\n\t * var list = new List([1, 2, 3]);\n\t * list.forEach(function(element, index, list) {\n\t *     list.attr(index, element * element);\n\t * });\n\t * list.attr(); // [1, 4, 9]\n\t * ```\n\t */\n\tforEach: function (cb, thisarg) {\n\t\tvar item;\n\t\tfor (var i = 0, len = this.attr(\"length\"); i < len; i++) {\n\t\t\titem = this.attr(i);\n\t\t\tif (item !== undefined && cb.call(thisarg || item, item, i, this) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * @function can-list.prototype.replace replace\n\t * @parent can-list.prototype\n\t * @description Replace all the elements of a List.\n\t * @signature `list.replace(collection)`\n\t * @param {Array|can-list|can.Deferred} collection the collection of new elements to use\n\t * If a [can.Deferred] is passed, it must resolve to an `Array` or `can-list`.\n\t * The elements of the list are not actually removed until the Deferred resolves.\n\t *\n\t * @body\n\t * `replace` replaces all the elements of this List with new ones.\n\t *\n\t * `replace` is especially useful when `can-list`s are live-bound into `[can-control]`s,\n\t * and you intend to populate them with the results of a `[can-model]` call:\n\t *\n\t * ```\n\t * can.Control({\n\t *     init: function() {\n\t *         this.list = new Todo.List();\n\t *         // live-bind the list into the DOM\n\t *         this.element.html(can.view('list.stache', this.list));\n\t *         // when this AJAX call returns, the live-bound DOM will be updated\n\t *         this.list.replace(Todo.findAll());\n\t *     }\n\t * });\n\t * ```\n\t *\n\t * Learn more about [can.Model.List making Lists of models].\n\t *\n\t * ## Events\n\t *\n\t * A major difference between `replace` and `attr(newElements, true)` is that `replace` always emits\n\t * an _add_ event and a _remove_ event, whereas `attr` will cause _set_ events along with an _add_ or _remove_\n\t * event if needed. Corresponding _change_ and _length_ events will be fired as well.\n\t *\n\t * The differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:\n\t * ```\n\t * var attrList = new List(['Alexis', 'Bill']);\n\t * attrList.bind('change', function(ev, index, how, newVals, oldVals) {\n\t *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n\t * });\n\t *\n\t * var replaceList = new List(['Alexis', 'Bill']);\n\t * replaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n\t *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n\t * });\n\t *\n\t * attrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n\t *                                               // 1, set, Ben, Bill\n\t * replaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n\t *                                               // 0, add, ['Adam', 'Ben'], ['Alexis', 'Bill']\n\t *\n\t * attrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n\t *                                               // 1, remove, undefined, Ben\n\t * replaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n\t *                                               // 0, add, Amber, ['Adam', 'Ben']\n\t *\n\t * attrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n\t *                                               // 1, add, ['Bob', 'Eve'], undefined\n\t * replaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n\t *                                               // 0, add, ['Alice', 'Bob', 'Eve'], Amber\n\t * ```\n\t */\n\treplace: function (newList) {\n\t\tif (canReflect.isPromise(newList)) {\n\t\t\tif(this._promise) {\n\t\t\t\tthis._promise.__isCurrentPromise = false;\n\t\t\t}\n\t\t\tvar promise = this._promise = newList;\n\t\t\tpromise.__isCurrentPromise = true;\n\t\t\tvar self = this;\n\t\t\tnewList.then(function(newList){\n\t\t\t\tif(promise.__isCurrentPromise) {\n\t\t\t\t\tself.replace(newList);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tnewList = newList === undefined ? [] : canReflect.toArray(newList);\n\t\t\tthis.splice.apply(this, [0, this.length].concat(newList));\n\t\t}\n\n\t\treturn this;\n\t},\n\tfilter: function (callback, thisArg) {\n\t\tvar filteredList = new this.constructor(),\n\t\t\tself = this,\n\t\t\tfiltered;\n\t\tthis.forEach(function(item, index, list){\n\t\t\tfiltered = callback.call( thisArg || self, item, index, self);\n\t\t\tif(filtered){\n\t\t\t\tfilteredList.push(item);\n\t\t\t}\n\t\t});\n\t\treturn filteredList;\n\t},\n\tmap: function (callback, thisArg) {\n\t\tvar filteredList = new List(),\n\t\t\tself = this;\n\t\tthis.forEach(function(item, index, list){\n\t\t\tvar mapped = callback.call( thisArg || self, item, index, self);\n\t\t\tfilteredList.push(mapped);\n\n\t\t});\n\t\treturn filteredList;\n\t},\n\tsort: function(compareFunction) {\n\t\tvar sorting = Array.prototype.slice.call(this);\n\t\tArray.prototype.sort.call(sorting, compareFunction);\n\t\tthis.splice.apply(this, [0,sorting.length].concat(sorting) );\n\t\treturn this;\n\t}\n});\n\n// change some map stuff to include list stuff\nvar oldType = Map.prototype.__type;\nMap.prototype.__type = function(value, prop){\n\n\tif (typeof value === \"object\" && Array.isArray(value) ) {\n\n\t\tvar cached = mapHelpers.getMapFromObject(value);\n\t\tif(cached) {\n\t\t\treturn cached;\n\t\t}\n\n\t\treturn new List(value);\n\n\t}\n\treturn oldType.apply(this, arguments);\n};\n\nvar oldSetup = Map.setup;\nMap.setup = function(){\n\toldSetup.apply(this, arguments);\n\tif (!(this.prototype instanceof List)) {\n\t\tthis.List = Map.List.extend({\n\t\t\tMap: this\n\t\t}, {});\n\t}\n};\n\nif(!types.DefaultList) {\n\ttypes.DefaultList = List;\n}\n\n// Setup other symbols\n\ncanReflect.assignSymbols(List.prototype,{\n\t// -type-\n\n\t\"can.isMoreListLikeThanMapLike\":  true,\n\t\"can.isListLike\":  true,\n\n\t// -get/set-\n\t\"can.getKeyValue\": List.prototype._get,\n\t\"can.setKeyValue\": List.prototype._set,\n\t\"can.deleteKeyValue\": List.prototype._remove,\n\n\t// -shape\n\t\"can.getOwnEnumerableKeys\": function(){\n\t\treturn Object.keys(this._data || {}).concat(this.map(function(val, index) {\n\t\t\treturn index;\n\t\t}));\n\t},\n\n\t// -shape get/set-\n\t\"can.assignDeep\": function(source){\n\t\tqueues.batch.start();\n\t\t// TODO: we should probably just throw an error instead of cleaning\n\t\tcanReflect.assignDeepList(this, source);\n\t\tqueues.batch.stop();\n\t},\n\t\"can.updateDeep\": function(source){\n\t\tqueues.batch.start();\n\t\t// TODO: we should probably just throw an error instead of cleaning\n\t\tcanReflect.updateDeepList(this, source);\n\t\tqueues.batch.stop();\n\t},\n\n\t\"can.unwrap\": mapHelpers.reflectUnwrap,\n\t\"can.serialize\": mapHelpers.reflectSerialize,\n\n\t// observable\n\t\"can.onKeysAdded\": function(handler) {\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](\"add\", handler);\n\t},\n\t\"can.onKeysRemoved\":  function(handler) {\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](\"remove\", handler);\n\t},\n\t\"can.splice\": function(index, deleteCount, insert){\n\t\tthis.splice.apply(this, [index, deleteCount].concat(insert));\n\t},\n\t\"can.onPatches\": function(handler,queue){\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](\"can.patches\", handler,queue);\n\t},\n\t\"can.offPatches\": function(handler,queue) {\n\t\tthis[canSymbol.for(\"can.offKeyValue\")](\"can.patches\", handler,queue);\n\t}\n});\n\n\n\n\n// @@can.keyHasDependencies and @@can.getKeyDependencies same as can-map\n\nMap.List = List;\nmodule.exports = namespace.List = List;\n\n\n//# sourceURL=webpack:///./node_modules/can-list/can-list.js?");

/***/ }),

/***/ "./node_modules/can-local-store/can-local-store.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-local-store/can-local-store.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar makeSimpleStore = __webpack_require__(/*! can-memory-store/make-simple-store */ \"./node_modules/can-memory-store/make-simple-store.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nmodule.exports = namespace.localStore = function localStore(baseConnection){\n    baseConnection.constructor = localStore;\n    var behavior = Object.create(makeSimpleStore(baseConnection));\n\n    canReflect.assignMap(behavior, {\n\t\tclear: function(){\n\t\t\tlocalStorage.removeItem(this.name+\"/queries\");\n\t\t\tlocalStorage.removeItem(this.name+\"/records\");\n            this._recordsMap = null;\n            return Promise.resolve();\n\t\t},\n\t\tupdateQueryDataSync: function(queries){\n\t\t\tlocalStorage.setItem(this.name+\"/queries\", JSON.stringify(queries) );\n\t\t},\n\t\tgetQueryDataSync: function(){\n\t\t\treturn JSON.parse( localStorage.getItem(this.name+\"/queries\") ) || [];\n\t\t},\n\n\t\tgetRecord: function(id){\n\t\t\t// a little side-effectual mischeif for performance\n\t\t\tif(!this._recordsMap) {\n\t\t\t\tthis.getAllRecords();\n\t\t\t}\n\n\t\t\treturn this._recordsMap[id];\n\t\t},\n\t\tgetAllRecords: function(){\n\t\t\t// this._records is a in memory representation so things can be fast\n            // Must turn on `cacheLocalStorageReads` for this to work.\n\t\t\tif(!this.cacheLocalStorageReads || !this._recordsMap) {\n\t\t\t\tvar recordsMap = JSON.parse( localStorage.getItem(this.name+\"/records\") ) || {};\n\t\t\t\tthis._recordsMap = recordsMap;\n\t\t\t}\n\n\t\t\tvar records = [];\n\t\t\tfor(var id in this._recordsMap) {\n\t\t\t\trecords.push(this._recordsMap[id]);\n\t\t\t}\n\t\t\treturn records;\n\t\t},\n\t\tdestroyRecords: function(records) {\n            if(!this._recordsMap) {\n\t\t\t\tthis.getAllRecords();\n\t\t\t}\n\t\t\tcanReflect.eachIndex(records, function(record){\n\t\t\t\tvar id = canReflect.getIdentity(record, this.queryLogic.schema);\n\t\t\t\tdelete this._recordsMap[id];\n\t\t\t}, this);\n\t\t\tlocalStorage.setItem(this.name+\"/records\", JSON.stringify(this._recordsMap) );\n\t\t},\n\t\tupdateRecordsSync: function(records){\n            if(!this._recordsMap) {\n\t\t\t\tthis.getAllRecords();\n\t\t\t}\n\t\t\trecords.forEach(function(record){\n\t\t\t\tvar id = canReflect.getIdentity(record, this.queryLogic.schema);\n\t\t\t\tthis._recordsMap[id] = record;\n\t\t\t},this);\n\t\t\tlocalStorage.setItem(this.name+\"/records\", JSON.stringify(this._recordsMap) );\n\t\t}\n\t\t// ## Identifiers\n\n\t\t/**\n\t\t * @property {String} can-connect/data/localstorage-cache/localstorage-cache.name name\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.identifiers\n\t\t *\n\t\t * Specify a name to use when saving data in localstorage.\n\t\t *\n\t\t * @option {String} This name is used to find and save data in\n\t\t * localstorage. Instances are saved in `{name}/instance/{id}`\n\t\t * and sets are saved in `{name}/set/{set}`.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * ```\n\t\t * var cacheConnection = connect([\"data-localstorage-cache\"],{\n\t\t *   name: \"todos\"\n\t\t * });\n\t\t * ```\n\t\t */\n\n\n\t\t// ## External interface\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.clear clear\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Resets the memory cache so it contains nothing.\n\t\t *\n\t\t * @signature `connection.clear()`\n\t\t *\n\t\t */\n\n\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.getSets getSets\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Returns the sets contained within the cache.\n\t\t *\n\t\t * @signature `connection.getSets(set)`\n\t\t *\n\t\t *   Returns the sets added by [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n\t\t *\n\t\t *   @return {Promise<Array<Set>>} A promise that resolves to the list of sets.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * ```\n\t\t * connection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n\t\t * ```\n\t\t *\n\t\t */\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.getListData getListData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Gets a set of data from localstorage.\n\t\t *\n\t\t * @signature `connection.getListData(set)`\n\t\t *\n\t\t *   Goes through each set add by [can-connect/data/memory-cache.updateListData]. If\n\t\t *   `set` is a subset, uses [can-connect/base/base.queryLogic] to get the data for the requested `set`.\n\t\t *\n\t\t *   @param {can-query-logic/query} query An object that represents the data to load.\n\t\t *\n\t\t *   @return {Promise<can-connect.listData>} A promise that resolves if `set` is a subset of\n\t\t *   some data added by [can-connect/data/memory-cache.updateListData].  If it is not,\n\t\t *   the promise is rejected.\n\t\t */\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache.getListDataSync getListDataSync\n\t\t * @parent can-connect/data/localstorage-cache.data-methods\n\t\t *\n\t\t * Synchronously gets a set of data from localstorage.\n\t\t *\n\t\t * @signature `connection.getListDataSync(set)`\n\t\t * @hide\n\t\t */\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.getData getData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Get an instance's data from localstorage.\n\t\t *\n\t\t * @signature `connection.getData(params)`\n\t\t *\n\t\t *   Looks in localstorage for the requested instance.\n\t\t *\n\t\t *   @param {Object} params An object that should have the [conenction.id] of the element\n\t\t *   being retrieved.\n\t\t *\n\t\t *   @return {Promise} A promise that resolves to the item if the memory cache has this item.\n\t\t *   If localstorage does not have this item, it rejects the promise.\n\t\t */\n\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.updateListData updateListData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Saves a set of data in the cache.\n\t\t *\n\t\t * @signature `connection.updateListData(listData, set)`\n\t\t *\n\t\t *   Tries to merge this set of data with any other saved sets of data. If\n\t\t *   unable to merge this data, saves the set by itself.\n\t\t *\n\t\t *   @param {can-connect.listData} listData\n\t\t *   @param {can-query-logic/query} query\n\t\t *   @return {Promise} Promise resolves if and when the data has been successfully saved.\n\t\t */\n\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.createData createData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Called when an instance is created and should be added to cache.\n\t\t *\n\t\t * @signature `connection.createData(props)`\n\t\t *\n\t\t *   Adds `props` to the stored list of instances. Then, goes\n\t\t *   through every set and adds props the sets it belongs to.\n\t\t */\n\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.updateData updateData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Called when an instance is updated.\n\t\t *\n\t\t * @signature `connection.updateData(props)`\n\t\t *\n\t\t *   Overwrites the stored instance with the new props. Then, goes\n\t\t *   through every set and adds or removes the instance if it belongs or not.\n\t\t */\n\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.destroyData destroyData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Called when an instance should be removed from the cache.\n\t\t *\n\t\t * @signature `connection.destroyData(props)`\n\t\t *\n\t\t *   Goes through each set of data and removes any data that matches\n\t\t *   `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t\t */\n\n\t});\n\n\treturn behavior;\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-local-store/can-local-store.js?");

/***/ }),

/***/ "./node_modules/can-log/can-log.js":
/*!*****************************************!*\
  !*** ./node_modules/can-log/can-log.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.warnTimeout = 5000;\nexports.logLevel = 0;\n\n/**\n * @module {{}} can-log log\n * @parent can-js-utilities\n * @collection can-infrastructure\n * @hide\n *\n * Utilities for logging to the console.\n */\n\n/**\n * @function can-log.warn warn\n * @parent can-log\n * @description\n *\n * Adds a warning message to the console.\n *\n * ```\n * var canLog = require(\"can-log\");\n *\n * canLog.warn(\"something evil\");\n * ```\n *\n * @signature `canLog.warn(msg)`\n * @param {String} msg the message to be logged.\n */\nexports.warn = function() {\n\tvar ll = this.logLevel;\n\tif (ll < 2) {\n\t\tif (typeof console !== \"undefined\" && console.warn) {\n\t\t\tthis._logger(\"warn\", Array.prototype.slice.call(arguments));\n\t\t} else if (typeof console !== \"undefined\" && console.log) {\n\t\t\tthis._logger(\"log\", Array.prototype.slice.call(arguments));\n\t\t}\n\t}\n};\n\n/**\n * @function can-log.log log\n * @parent can-log\n * @description\n * Adds a message to the console.\n * @hide\n *\n * ```\n * var canLog = require(\"can-log\");\n *\n * canLog.log(\"hi\");\n * ```\n *\n * @signature `canLog.log(msg)`\n * @param {String} msg the message\n */\nexports.log = function() {\n\tvar ll = this.logLevel;\n\tif (ll < 1) {\n\t\tif (typeof console !== \"undefined\" && console.log) {\n\t\t\tthis._logger(\"log\", Array.prototype.slice.call(arguments));\n\t\t}\n\t}\n};\n\n/**\n * @function can-log.error error\n * @parent can-log\n * @description\n * Adds an error message to the console.\n * @hide\n *\n * ```\n * var canLog = require(\"can-log\");\n *\n * canLog.error(new Error(\"Oh no!\"));\n * ```\n *\n * @signature `canLog.error(err)`\n * @param {String|Error} err The error to be logged.\n */\nexports.error = function() {\n\tvar ll = this.logLevel;\n\tif (ll < 1) {\n\t\tif (typeof console !== \"undefined\" && console.error) {\n\t\t\tthis._logger(\"error\", Array.prototype.slice.call(arguments));\n\t\t}\n\t}\n};\n\nexports._logger = function (type, arr) {\n\ttry {\n\t\tconsole[type].apply(console, arr);\n\t} catch(e) {\n\t\tconsole[type](arr);\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-log/can-log.js?");

/***/ }),

/***/ "./node_modules/can-log/dev/dev.js":
/*!*****************************************!*\
  !*** ./node_modules/can-log/dev/dev.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canLog = __webpack_require__(/*! ../can-log */ \"./node_modules/can-log/can-log.js\");\n\n/**\n * @module {{}} can-log/dev dev\n * @parent can-log\n * @hide\n * \n * Utilities for logging development-mode messages. Use this module for\n * anything that should be shown to the user during development but isn't\n * needed in production. In production these functions become noops.\n */\nmodule.exports = {\n\twarnTimeout: 5000,\n\tlogLevel: 0,\n\t/**\n\t * @function can-log/dev.stringify stringify\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * JSON stringifies a value, but unlike JSON, will output properties with\n\t * a value of `undefined` (e.g. `{ \"prop\": undefined }`, not `{}`).\n\t *\n\t * ```\n\t * var dev = require('can-log/dev');\n\t * var query = { where: undefined };\n\t * \n\t * dev.warn('No records found: ' + dev.stringify(query));\n\t * ```\n\t *\n\t * @signature `dev.stringify(value)`\n\t * @param {Any} value A value to stringify.\n\t * @return {String} A stringified representation of the passed in value.\n\t */\n\tstringify: function(value) {\n\t\tvar flagUndefined = function flagUndefined(key, value) {\n\t\t\treturn value === undefined ?\n\t\t\t\t \"/* void(undefined) */\" : value;\n\t\t};\n\t\t\n\t\treturn JSON.stringify(value, flagUndefined, \"  \").replace(\n\t\t\t/\"\\/\\* void\\(undefined\\) \\*\\/\"/g, \"undefined\");\n\t},\n\t/**\n\t * @function can-log/dev.warn warn\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * Adds a warning message to the console.\n\t *\n\t * ```\n\t * var dev = require('can-log/dev');\n\t * \n\t * dev.warn(\"something evil\");\n\t * ```\n\t *\n\t * @signature `dev.warn(msg)`\n\t * @param {String} msg The warning message.\n\t */\n\twarn: function() {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tcanLog.warn.apply(this, arguments);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-log/dev.log log\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * Adds a message to the console.\n\t *\n\t * ```\n\t * var dev = require('can-log/dev');\n\t * \n\t * dev.log(\"hi\");\n\t * ```\n\t *\n\t * @signature `dev.log(msg)`\n\t * @param {String} msg The message.\n\t */\n\tlog: function() {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tcanLog.log.apply(this, arguments);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-log/dev.error error\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * Adds an error message to the console.\n\t *\n\t * ```\n\t * var dev = require(\"can-log/dev\");\n\t * \n\t * dev.error(new Error(\"Oh no!\"));\n\t * ```\n\t *\n\t * @signature `dev.error(err)`\n\t * @param {String|Error} err The error to be logged.\n\t */\n\terror: function() {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tcanLog.error.apply(this, arguments);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t_logger: canLog._logger\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-log/dev/dev.js?");

/***/ }),

/***/ "./node_modules/can-make-map/can-make-map.js":
/*!***************************************************!*\
  !*** ./node_modules/can-make-map/can-make-map.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-make-map can-make-map\n * @parent can-js-utilities\n * @collection can-infrastructure\n * @package ./package.json\n * @description Convert a comma-separated string into a plain JavaScript object.\n * @signature `makeMap( string )`\n * @param  {String} string A comma separated list of values\n * @return {Object} A JavaScript object with the same keys as the passed-in comma-separated values\n *\n * makeMap takes a comma-separated string (can-list, NodeList, etc.) and converts it to a JavaScript object\n */\nfunction makeMap(str) {\n\tvar obj = {}, items = str.split(\",\");\n\titems.forEach(function(name){\n\t\tobj[name] = true;\n\t});\n\treturn obj;\n}\n\nmodule.exports = makeMap;\n\n\n//# sourceURL=webpack:///./node_modules/can-make-map/can-make-map.js?");

/***/ }),

/***/ "./node_modules/can-make-rest/can-make-rest.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-make-rest/can-make-rest.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar methodMapping = {\n\titem: {\n\t\t'GET': 'getData',\n\t\t'PUT': 'updateData',\n\t\t'DELETE': 'destroyData',\n\t},\n\tlist: {\n\t\t'GET': 'getListData',\n\t\t'POST': 'createData'\n\t}\n};\n\n\nfunction inferIdProp (url) {\n\tvar wrappedInBraces = /\\{(.*)\\}/;\n\tvar matches = url.match(wrappedInBraces);\n\tvar isUniqueMatch = matches && matches.length === 2;\n\tif (isUniqueMatch) {\n\t\treturn matches[1];\n\t}\n}\n\nfunction getItemAndListUrls (url, idProp) {\n\tidProp = idProp || inferIdProp(url) || \"id\";\n\tvar itemRegex = new RegExp('\\\\/\\\\{' + idProp+\"\\\\}.*\" );\n\tvar rootIsItemUrl = itemRegex.test(url);\n\tvar listUrl = rootIsItemUrl ? url.replace(itemRegex, \"\") : url;\n\tvar itemUrl = rootIsItemUrl ? url : (url.trim() + \"/{\" + idProp + \"}\");\n\treturn {item: itemUrl, list: listUrl};\n}\n\n\n\nmodule.exports = function(url, idProp){\n\tvar data= {};\n\tcanReflect.eachKey( getItemAndListUrls(url, idProp), function(url, type){\n\t\tcanReflect.eachKey(methodMapping[type], function(interfaceMethod, method){\n\t\t\tdata[interfaceMethod] = {\n\t\t\t\tmethod: method,\n\t\t\t\turl: url\n\t\t\t};\n\t\t});\n\t});\n\treturn data;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-make-rest/can-make-rest.js?");

/***/ }),

/***/ "./node_modules/can-map-compat/can-map-compat.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-map-compat/can-map-compat.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canKey = __webpack_require__(/*! can-key */ \"./node_modules/can-key/can-key.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canLog = __webpack_require__(/*! can-log */ \"./node_modules/can-log/can-log.js\");\n\nfunction makeCompat(Type, enableWarning) {\n\tvar proto = Type.prototype;\n\tvar isDefined = typeof proto.attr === \"function\";\n\n\tif(isDefined) {\n\t\treturn Type;\n\t}\n\n\t// Whether we should be warning when this is used.\n\tvar warnOnUse = enableWarning === true;\n\n\tproto.attr = function(key, value) {\n\t\tif(warnOnUse) {\n\t\t\tcanLog.warn(\"can-map-compat is intended for migrating away from can-map. Remove all uses of .attr() to remove this warning.\");\n\t\t}\n\n\t\tvar type = typeof key;\n\t\tvar argsLen = arguments.length;\n\n\t\t// map.attr()\n\t\tif(argsLen === 0) {\n\t\t\treturn canReflect.unwrap(this);\n\t\t}\n\t\t// map.attr({ key: val })\n\t\telse if(type !== \"string\" && type !== \"number\") {\n\t\t\t// Remove others\n\t\t\tif(value === true) {\n\t\t\t\tcanReflect.updateDeep(this, key);\n\t\t\t} else {\n\t\t\t\tcanReflect.assignDeep(this, key);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t// map.attr(key)\n\t\telse if(argsLen === 1) {\n\t\t\treturn canKey.get(this, key);\n\t\t}\n\t\t// map.attr(key, val)\n\t\telse {\n\t\t\tcanKey.set(this, key, value);\n\t\t\treturn this;\n\t\t}\n\t};\n\n\tproto.removeAttr = function(key) {\n\t\tvar val = canReflect.getKeyValue(this, key);\n\t\tcanReflect.deleteKeyValue(this, key);\n\t\treturn val;\n\t};\n\n\treturn Type;\n}\n\nexports = module.exports = function(Type) {\n\treturn makeCompat(Type, true);\n};\n\nexports.makeCompat = makeCompat;\n\n\n//# sourceURL=webpack:///./node_modules/can-map-compat/can-map-compat.js?");

/***/ }),

/***/ "./node_modules/can-map-define/can-map-define.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-map-define/can-map-define.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar extend = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar mapEventsMixin = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar mapHelpers = __webpack_require__(/*! can-map/map-helpers */ \"./node_modules/can-map/map-helpers.js\");\nvar CanMap = __webpack_require__(/*! can-map */ \"./node_modules/can-map/can-map.js\");\nvar compute = __webpack_require__(/*! can-compute */ \"./node_modules/can-compute/can-compute.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar Resolver = __webpack_require__(/*! can-simple-observable/resolver/resolver */ \"./node_modules/can-simple-observable/resolver/resolver.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\n__webpack_require__(/*! can-list */ \"./node_modules/can-list/can-list.js\");\n\nvar define = {}; // jshint ignore:line\nvar inSetupSymbol = canSymbol.for(\"can.initializing\");\n\nvar hasDefaultForSerialize = function(defaultDefinition) {\n\treturn (\n\t\ttypeof defaultDefinition === \"object\" &&\n\t\t\"serialize\" in defaultDefinition\n\t);\n};\n\nvar getDefaultForSerialize = function(defaultDefinition) {\n\tvar shouldSerialize = true;\n\n\tif (hasDefaultForSerialize(defaultDefinition)) {\n\t\tshouldSerialize = !!defaultDefinition.serialize;\n\t}\n\n\treturn shouldSerialize;\n};\n\nvar keysForDefinition = function(definitions) {\n\tvar keys = [];\n\tvar defaultDefinition = definitions && definitions[\"*\"];\n\tfor (var prop in definitions) {\n\t\tvar definition = definitions[prop];\n\t\tvar shouldSerialize = getDefaultForSerialize(defaultDefinition);\n\t\t// allow property definitions to override default behavior\n\t\tif (typeof definition === \"object\" && \"serialize\" in definition) {\n\t\t\tshouldSerialize = !!definition.serialize;\n\t\t} else if (\n\t\t\ttypeof definition === \"object\" &&\n\t\t\t!hasDefaultForSerialize(defaultDefinition)\n\t\t) {\n\t\t\tshouldSerialize = !definition.get;\n\t\t}\n\t\tif (shouldSerialize) {\n\t\t\tkeys.push(prop);\n\t\t}\n\t}\n\treturn keys;\n};\n\nvar getPropDefineBehavior = function(behavior, attr, define) {\n\tvar prop, defaultProp;\n\n\tif (define) {\n\t\tprop = define[attr];\n\t\tdefaultProp = define['*'];\n\n\t\tif (prop && prop[behavior] !== undefined) {\n\t\t\treturn prop[behavior];\n\t\t} else if (defaultProp && defaultProp[behavior] !== undefined) {\n\t\t\treturn defaultProp[behavior];\n\t\t}\n\t}\n};\n\n// This is called when the Map is defined\nmapHelpers.define = function(Map, baseDefine) {\n\tvar definitions = Map.prototype.define;\n\n\tif (baseDefine) {\n\t\tvar defines = {};\n\t\tmapHelpers.twoLevelDeepExtend(defines, baseDefine);\n\t\tmapHelpers.twoLevelDeepExtend(defines, definitions);\n\t\textend(definitions, defines);\n\t}\n\t//!steal-remove-start\n\tif (true) {\n\t\tif (Map.define) {\n\t\t\tdev.warn(\"The define property should be on the map's prototype properties, \" +\n\t\t\t\t\"not the static properties.\");\n\t\t}\n\t}\n\t//!steal-remove-end\n\tMap.defaultGenerators = {};\n\tfor (var prop in definitions) {\n\t\tvar type = definitions[prop].type;\n\t\tif (typeof type === \"string\") {\n\t\t\tif (typeof define.types[type] === \"object\") {\n\t\t\t\tdelete definitions[prop].type;\n\t\t\t\textend(definitions[prop], define.types[type]);\n\t\t\t}\n\t\t}\n\t\tif (\"value\" in definitions[prop]) {\n\t\t\tif (typeof definitions[prop].value === \"function\") {\n\t\t\t\tMap.defaultGenerators[prop] = definitions[prop].value;\n\t\t\t} else {\n\t\t\t\tMap.defaults[prop] = definitions[prop].value;\n\t\t\t}\n\t\t}\n\t\tif (typeof definitions[prop].Value === \"function\") {\n\t\t\t(function(Constructor) {\n\t\t\t\tMap.defaultGenerators[prop] = function() {\n\t\t\t\t\treturn new Constructor();\n\t\t\t\t};\n\t\t\t})(definitions[prop].Value);\n\t\t}\n\t}\n};\n\nvar oldSetupDefaults = CanMap.prototype._setupDefaults;\nCanMap.prototype._setupDefaults = function(obj) {\n\tvar defaults = extend({},oldSetupDefaults.call(this)),\n\t\tpropsCommittedToAttr = {},\n\t\tMap = this.constructor,\n\t\toriginalGet = this._get;\n\n\t// Overwrite this._get with a version that commits defaults to\n\t// this.attr() as needed. Because calling this.attr() for each\n\t// individual default would be expensive.\n\tthis._get = function(originalProp) {\n\t\t// If a this.attr() was called using dot syntax (e.g number.0),\n\t\t// disregard everything after the \".\" until we call the\n\t\t// original this._get().\n\t\tvar prop = (originalProp.indexOf('.') !== -1 ?\n\t\t\toriginalProp.substr(0, originalProp.indexOf('.')) :\n\t\t\toriginalProp);\n\n\t\t// If this property has a default and we haven't yet committed it to\n\t\t// this.attr()\n\t\tif ((prop in defaults) && !(prop in propsCommittedToAttr)) {\n\n\t\t\t// Commit the property's default so that it can be read in\n\t\t\t// other defaultGenerators.\n\t\t\tthis.attr(prop, defaults[prop]);\n\n\t\t\t// Make not so that we don't commit this property again.\n\t\t\tpropsCommittedToAttr[prop] = true;\n\t\t}\n\n\t\treturn originalGet.apply(this, arguments);\n\t};\n\n\tfor (var prop in Map.defaultGenerators) {\n\t\t// Only call the prop's value method if the property wasn't provided\n\t\t// during instantiation.\n\t\tif (!obj || !(prop in obj)) {\n\t\t\tdefaults[prop] = Map.defaultGenerators[prop].call(this);\n\t\t}\n\t}\n\n\t// delete this._get which will default to the one on the prototype.\n\tdelete this._get;\n\n\treturn defaults;\n};\n\n\nvar proto = CanMap.prototype,\n\toldSet = proto.__set;\nproto.__set = function(prop, value, current, success, error) {\n\t//!steal-remove-start\n\tvar asyncTimer;\n\t//!steal-remove-end\n\n\tvar self = this;\n\n\t// check if there's a setter\n\tvar errorCallback = function(errors) {\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tclearTimeout(asyncTimer);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tvar stub = error && error.call(self, errors);\n\t\t\t// if 'validations' is on the page it will trigger\n\t\t\t// the error itself and we dont want to trigger\n\t\t\t// the event twice. :)\n\t\t\tif (stub !== false) {\n\t\t\t\tmapEventsMixin.dispatch.call(self, 'error', [ prop, errors ], true);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tsetter = getPropDefineBehavior(\"set\", prop, this.define),\n\t\tgetter = getPropDefineBehavior(\"get\", prop, this.define);\n\n\n\t// if we have a setter\n\tif (setter) {\n\t\t// call the setter, if returned value is undefined,\n\t\t// this means the setter is async so we\n\t\t// do not call update property and return right away\n\t\tqueues.batch.start();\n\t\tvar setterCalled = false,\n\n\t\t\tsetValue = setter.call(this, value, function(value) {\n\t\t\t\tif (getter) {\n\t\t\t\t\tself[prop](value);\n\t\t\t\t} else {\n\t\t\t\t\toldSet.call(self, prop, value, current, success, errorCallback);\n\t\t\t\t}\n\n\t\t\t\tsetterCalled = true;\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tclearTimeout(asyncTimer);\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t}, errorCallback, getter ? this._computedAttrs[prop].compute.computeInstance.lastSetValue.get() : current);\n\t\tif (getter) {\n\t\t\t// if there's a getter we don't call old set\n\t\t\t// instead we call the getter's compute with the new value\n\t\t\tif (setValue !== undefined && !setterCalled && setter.length >= 1) {\n\t\t\t\tthis._computedAttrs[prop].compute(setValue);\n\t\t\t}\n\n\t\t\tqueues.batch.stop();\n\t\t\treturn;\n\t\t}\n\t\t// if it took a setter and returned nothing, don't set the value\n\t\telse if (setValue === undefined && !setterCalled && setter.length > 1) {\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tasyncTimer = setTimeout(function() {\n\t\t\t\t\tdev.warn('can/map/define: Setter \"' + prop + '\" did not return a value or call the setter callback.');\n\t\t\t\t}, dev.warnTimeout);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tqueues.batch.stop();\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (!setterCalled) {\n\t\t\t\toldSet.call(self, prop,\n\t\t\t\t\t// if no arguments, we are side-effects only\n\t\t\t\t\tsetter.length === 0 && setValue === undefined ? value : setValue,\n\t\t\t\t\tcurrent,\n\t\t\t\t\tsuccess,\n\t\t\t\t\terrorCallback);\n\t\t\t}\n\t\t\tqueues.batch.stop();\n\t\t\treturn this;\n\t\t}\n\n\t} else {\n\t\toldSet.call(self, prop, value, current, success, errorCallback);\n\t}\n\n\treturn this;\n};\n\ndefine.types = {\n\t'date': function(str) {\n\t\tvar type = typeof str;\n\t\tif (type === 'string') {\n\t\t\tstr = Date.parse(str);\n\t\t\treturn isNaN(str) ? null : new Date(str);\n\t\t} else if (type === 'number') {\n\t\t\treturn new Date(str);\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t},\n\t'number': function(val) {\n\t\tif (val == null) {\n\t\t\treturn val;\n\t\t}\n\t\treturn +(val);\n\t},\n\t'boolean': function(val) {\n\t\tif(val == null) {\n\t\t\treturn val;\n\t\t}\n\t\tif (val === 'false' || val === '0' || !val) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\t'htmlbool': function(val) {\n\t\treturn typeof val === \"string\" || !!val;\n\t},\n\t'*': function(val) {\n\t\treturn val;\n\t},\n\t'string': function(val) {\n\t\tif (val == null) {\n\t\t\treturn val;\n\t\t}\n\t\treturn '' + val;\n\t},\n\t'compute': {\n\t\tset: function(newValue, setVal, setErr, oldValue) {\n\t\t\tif (newValue && newValue.isComputed) {\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t\tif (oldValue && oldValue.isComputed) {\n\t\t\t\toldValue(newValue);\n\t\t\t\treturn oldValue;\n\t\t\t}\n\t\t\treturn newValue;\n\t\t},\n\t\tget: function(value) {\n\t\t\treturn value && value.isComputed ? value() : value;\n\t\t}\n\t}\n};\n\n// the old type sets up bubbling\nvar oldType = proto.__type;\nproto.__type = function(value, prop) {\n\tvar type = getPropDefineBehavior(\"type\", prop, this.define),\n\t\tType = getPropDefineBehavior(\"Type\", prop, this.define),\n\t\tnewValue = value;\n\n\tif (typeof type === \"string\") {\n\t\ttype = define.types[type];\n\t}\n\n\tif (type || Type) {\n\t\t// If there's a type, convert it.\n\t\tif (type) {\n\t\t\tnewValue = type.call(this, newValue, prop);\n\t\t}\n\t\t// If there's a Type and newValue is non-null create a new instance of it\n\t\tif (Type && newValue != null && !(newValue instanceof Type)) {\n\t\t\tnewValue = new Type(newValue);\n\t\t}\n\t\t// If the newValue is a Map, we need to hook it up\n\t\treturn newValue;\n\n\t}\n\t// If we pass in a object with define\n\telse if (canReflect.isPlainObject(newValue) && newValue.define) {\n\t\tnewValue = CanMap.extend(newValue);\n\t\tnewValue = new newValue();\n\t}\n\treturn oldType.call(this, newValue, prop);\n};\n\nvar oldRemove = proto.__remove;\nproto.__remove = function(prop, current) {\n\tvar remove = getPropDefineBehavior(\"remove\", prop, this.define),\n\t\tres;\n\tif (remove) {\n\t\tqueues.batch.start();\n\t\tres = remove.call(this, current);\n\n\t\tif (res === false) {\n\t\t\tqueues.batch.stop();\n\t\t\treturn;\n\t\t} else {\n\n\t\t\tres = oldRemove.call(this, prop, current);\n\t\t\tqueues.batch.stop();\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn oldRemove.call(this, prop, current);\n};\n\nvar oldSetupComputes = proto._setupComputedProperties;\nproto._setupComputedProperties = function() {\n\toldSetupComputes.apply(this, arguments);\n\tfor (var attr in this.define) {\n\t\tvar def = this.define[attr],\n\t\t\tget = def.get;\n\t\tif (get) {\n\t\t\tmapHelpers.addComputedAttr(this, attr, compute.async(undefined, get, this));\n\t\t}\n\t\tif (def.resolver) {\n\t\t\tmapHelpers.addComputedAttr(this, attr, new Resolver(def.resolver, this, def.value ) );\n\t\t}\n\t}\n};\n// Overwrite the invidual property serializer b/c we will overwrite it.\nvar oldSingleSerialize = proto.___serialize;\n// If the map has a define serializer for the given attr, run it.\nvar serializeProp = function(map, attr, val) {\n\tvar serializer = attr === \"*\" ? false : getPropDefineBehavior(\"serialize\", attr, map.define);\n\tif (serializer === undefined) {\n\t\treturn oldSingleSerialize.call(map, attr, val);\n\t} else if (serializer !== false) {\n\t\treturn typeof serializer === \"function\" ? serializer.call(map, val, attr) : oldSingleSerialize.call(map, attr, val);\n\t}\n};\n\nproto.___serialize = function(name, val) {\n\treturn serializeProp(this, name, val);\n};\n\n// Overwrite serialize to add in any missing define serialized properties.\nvar oldSerialize = proto.serialize;\nproto.serialize = function(property) {\n\tvar serialized = oldSerialize.apply(this, arguments);\n\tif (property) {\n\t\treturn serialized;\n\t}\n\t// add in properties not already serialized\n\n\tvar serializer,\n\t\tval;\n\t// Go through each property.\n\tfor (var attr in this.define) {\n\t\t// if it's not already defined\n\t\tif (!(attr in serialized)) {\n\t\t\t// check there is a serializer so we aren't doing extra work on serializer:false\n\t\t\t// also check for a wildcard serializer\n\t\t\tserializer = this.define && (this.define[attr] && this.define[attr].serialize || this.define['*'] && this.define['*'].serialize);\n\t\t\tif (serializer) {\n\t\t\t\tval = serializeProp(this, attr, this.attr(attr));\n\t\t\t\tif (val !== undefined) {\n\t\t\t\t\tserialized[attr] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn serialized;\n};\n\ncanReflect.assignSymbols(proto, {\n\t\"can.hasKey\": function(key) {\n\t\tvar defined = this.define && key in this.define;\n\t\tvar dataExists = this._data && key in this._data;\n\t\tvar propExists = key in this;\n\t\treturn defined || dataExists || propExists;\n\t},\n\n\t\"can.getOwnEnumerableKeys\": function() {\n\t\tif (!this[inSetupSymbol]) {\n\t\t\tObservationRecorder.add(this, '__keys');\n\t\t}\n\n\t\tvar definedKeys = keysForDefinition(this.define);\n\t\tvar dataKeys = Object.keys(this._data);\n\t\tvar shouldSerialize = getDefaultForSerialize(this.define && this.define[\"*\"]);\n\n\t\tvar enumerable = this.constructor.enumerable;\n\t\tdataKeys = dataKeys.filter(function(key) {\n\t\t\treturn enumerable ?\n\t\t\t\tshouldSerialize && enumerable[key] !== false :\n\t\t\t\tshouldSerialize;\n\t\t});\n\n\t\tvar i, newKey;\n\t\tfor(i=0; i<dataKeys.length; i++) {\n\t\t\tnewKey = dataKeys[i];\n\t\t\t// add keys that are in _data, but are not in `define`\n\t\t\t// keys in `define` are in `definedKeys` based on their `serialize` prop\n\t\t\tif (definedKeys.indexOf(newKey) < 0 && (!this.define || !this.define[newKey])) {\n\t\t\t\tdefinedKeys.push(dataKeys[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn definedKeys;\n\t}\n});\n\nmodule.exports = define;\n\n\n//# sourceURL=webpack:///./node_modules/can-map-define/can-map-define.js?");

/***/ }),

/***/ "./node_modules/can-map/bubble.js":
/*!****************************************!*\
  !*** ./node_modules/can-map/bubble.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # can/map/map_helpers\n// Helpers that enable bubbling of an event on a child object to a\n// parent event on a parent object. Bubbling works by listening on the child object\n// and forwarding events to the parent object.\n//\n// Bubbling is complicated because bubbling setup can happen before or after\n// items are added to the parent object.\n//\n// This means that:\n// - When bubbling is first initialied, by binding to an event that bubbles,\n//   all child objects need to be setup to bubble. This is managed by [bubble.bind](#bubble-bind).\n// - When bubbling is stopped, by removing all listeners to events that bubble,\n//   all child objects need to have bubbling torn down. This is managed by [bubble.unbind](#bubble-unbind).\n// - While bubbling is running, as child items are added,\n//   the child elements need to be setup to bubble.  This is managed by [bubble.add](#bubble-add) and [bubble.addMany](#bubble-addmany).\n// - While bubbling is running, as child items are removed,\n//   the child elements need to stop bubbling. This is managed by\n//   [bubble.remove](#bubble-remove) and [bubble.removeMany](#bubble-removeMany).\n// - While bubbling is running, as child item replaces another child, the old child needs bubbling removed\n//   and the new child needs bubbling setup. This is managed by [bubble.set](bubble-set).\n//\n// [bubble.events](bubble-events) controls which events setup bubbling.\n\nvar canEvent = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\n// Helper function to check the Map type\nvar isMap = function(map) {\n\treturn (\n\t\tmap &&\n\t\t!canReflect.isFunctionLike(map) && \n\t\tcanReflect.isMapLike(map) &&\n\t\t!Array.isArray(map) &&\n\t\tcanReflect.isObservableLike(map)\n\t);\n};\n\n\nvar bubble = {\n\t\t// ## bubble.bind\n\t\t// Called when an event is bound to an object. This\n\t\t// should setup bubbling if this is the first time\n\t\t// an event that bubbles is bound.\n\t\tbind: function(parent, eventName) {\n\t\t\tif (!parent.__inSetup ) {\n\n\t\t\t\tvar bubbleEvents = bubble.events(parent, eventName),\n\t\t\t\t\tlen = bubbleEvents.length,\n\t\t\t\t\tbubbleEvent;\n\n\t\t\t\tif(!parent._bubbleBindings) {\n\t\t\t\t\tparent._bubbleBindings = {};\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\t\tbubbleEvent = bubbleEvents[i];\n\n\t\t\t\t\t// If there isn't a bubbling setup for this binding,\n\t\t\t\t\t// bubble all the children; otherwise, increment the\n\t\t\t\t\t// number of bubble bindings.\n\t\t\t\t\tif (!parent._bubbleBindings[bubbleEvent]) {\n\t\t\t\t\t\tparent._bubbleBindings[bubbleEvent] = 1;\n\t\t\t\t\t\tbubble.childrenOf(parent, bubbleEvent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparent._bubbleBindings[bubbleEvent]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// ## bubble.unbind\n\t\t// Called when an event is unbound from an object.  This should\n\t\t// teardown bubbling if there are no more bubbling event handlers.\n\t\tunbind: function(parent, eventName) {\n\t\t\tvar bubbleEvents = bubble.events(parent, eventName),\n\t\t\t\tlen = bubbleEvents.length,\n\t\t\t\tbubbleEvent;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tbubbleEvent = bubbleEvents[i];\n\n\t\t\t\tif (parent._bubbleBindings ) {\n\t\t\t\t\tparent._bubbleBindings[bubbleEvent]--;\n\t\t\t\t}\n\n\t\t\t\tif (parent._bubbleBindings && !parent._bubbleBindings[bubbleEvent] ) {\n\t\t\t\t\tdelete parent._bubbleBindings[bubbleEvent];\n\t\t\t\t\tbubble.teardownChildrenFrom(parent, bubbleEvent);\n\t\t\t\t\tif(canReflect.size(parent._bubbleBindings) === 0) {\n\t\t\t\t\t\tdelete parent._bubbleBindings;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// ## bubble.add\n\t\t// Called when a new `child` value has been added to `parent`.\n\t\t// If the `parent` is bubbling and the child is observable,\n\t\t// setup bubbling on the child to the parent. This calls\n\t\t// `teardownFromParent` to ensure we aren't bubbling the same\n\t\t// child more than once.\n\t\tadd: function(parent, child, prop){\n\t\t\tif(canReflect.isObservableLike(child) && canReflect.isMapLike(child) && parent._bubbleBindings) {\n\t\t\t\tfor(var eventName in parent._bubbleBindings) {\n\t\t\t\t\tif( parent._bubbleBindings[eventName] ) {\n\t\t\t\t\t\tbubble.teardownFromParent(parent, child, eventName);\n\t\t\t\t\t\tbubble.toParent(child, parent, prop, eventName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// ## bubble.addMany\n\t\t// Called when many `children` are added to `parent`.\n\t\taddMany: function(parent, children){\n\t\t\tfor (var i = 0, len = children.length; i < len; i++) {\n\t\t\t\tbubble.add(parent, children[i], i);\n\t\t\t}\n\t\t},\n\t\t// ## bubble.remove\n\t\t// Called when a `child` has been removed from `parent`.\n\t\t// Removes all bubbling events from `child` to `parent`.\n\t\tremove: function(parent, child){\n\t\t\tif(canReflect.isObservableLike(child) && canReflect.isMapLike(child) && parent._bubbleBindings) {\n\t\t\t\tfor(var eventName in parent._bubbleBindings) {\n\t\t\t\t\tif( parent._bubbleBindings[eventName] ) {\n\t\t\t\t\t\tbubble.teardownFromParent(parent, child, eventName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// ## bubble.removeMany\n\t\t// Called when many `children` are removed from `parent`.\n\t\tremoveMany: function(parent, children){\n\t\t\tfor(var i = 0, len = children.length; i < len; i++) {\n\t\t\t\tbubble.remove(parent, children[i]);\n\t\t\t}\n\t\t},\n\t\t// ## bubble.set\n\t\t// Called when a new child `value` replaces `current` value.\n\t\tset: function(parent, prop, value, current){\n\n\t\t\tif(canReflect.isObservableLike(value) && canReflect.isMapLike(value)) {\n\t\t\t\tbubble.add(parent, value, prop);\n\t\t\t}\n\t\t\t// bubble.add will remove, so only remove if we are replacing another object\n\t\t\tif(canReflect.isObservableLike(current) && canReflect.isMapLike(current)) {\n\t\t\t\tbubble.remove(parent, current);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\t\t// ## bubble.events\n\t\t// For an event binding on an object, returns the events that should be bubbled.\n\t\t// For example, `\"change\" -> [\"change\"]`.\n\t\tevents: function(map, boundEventName) {\n\t\t\tif (isMap(map)) {\n\t\t\t\treturn map.constructor._bubbleRule(boundEventName, map);\n\t\t\t}\n\t\t},\n\n\n\t\t// ## bubble.toParent\n\t\t// Forwards an event on `child` to `parent`.  `child` is\n\t\t// the `prop` property of `parent`.\n\t\ttoParent: function(child, parent, prop, eventName) {\n\t\t\tcanEvent.listenTo.call(parent, child, eventName, function ( /* ev, attr */ ) {\n\n\t\t\t\tvar args = canReflect.toArray(arguments),\n\t\t\t\t\tev = args.shift();\n\n\t\t\t\t// Updates the nested property name that will be dispatched.\n\t\t\t\t// If the parent is a list, the index of the child needs to\n\t\t\t\t// be calculated every time.\n\t\t\t\targs[0] =\n\t\t\t\t\t((canReflect.isObservableLike(parent) && canReflect.isListLike(parent)) ?\n\t\t\t\t\t\tparent.indexOf(child) :\n\t\t\t\t\t\tprop ) + (args[0] ? \".\"+args[0] : \"\");\n\n\t\t\t\t// Track all objects that we have bubbled this event to.\n\t\t\t\t// If we have already bubbled to this object, do not dispatch another\n\t\t\t\t// event on it. This prevents cycles.\n\t\t\t\tev.triggeredNS = ev.triggeredNS || {};\n\t\t\t\tif (ev.triggeredNS[parent._cid]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tev.triggeredNS[parent._cid] = true;\n\n\t\t\t\t// Send bubbled event to parent.\n\t\t\t\tcanEvent.dispatch.call(parent, ev, args);\n\n\t\t\t\t// Trigger named event.\n\t\t\t\tif(eventName === \"change\") {\n\t\t\t\t\tcanEvent.dispatch.call(parent, args[0], [args[2], args[3]]);\n\t\t\t\t}\n\n\t\t\t});\n\t\t},\n\n\t\t// ## bubble.childrenOf\n\t\t// Bubbles all the observable children of `parent`.\n\t\tchildrenOf: function (parent, eventName) {\n\n\t\t\tparent._each(function (child, prop) {\n\t\t\t\tif (isMap(child)) {\n\t\t\t\t\tbubble.toParent(child, parent, prop, eventName);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// ## bubble.teardownFromParent\n\t\t// Undo the bubbling from `child` to `parent`.\n\t\tteardownFromParent: function (parent, child, eventName ) {\n\t\t\tif(child && child.unbind ) {\n\t\t\t\tcanEvent.stopListening.call(parent, child, eventName);\n\t\t\t}\n\t\t},\n\n\t\t// ## bubble.teardownChildrenFrom\n\t\t// Undo the bubbling of every child of `parent`\n\t\tteardownChildrenFrom: function(parent, eventName){\n\t\t\tparent._each(function (child) {\n\n\t\t\t\tbubble.teardownFromParent(parent, child, eventName);\n\t\t\t});\n\t\t},\n\n\t\t// ## bubble.isBubbling\n\t\t// Returns true or false if `parent` is bubbling `eventName`.\n\t\tisBubbling: function(parent, eventName){\n\t\t\treturn parent._bubbleBindings && parent._bubbleBindings[eventName];\n\t\t}\n\t};\n\nmodule.exports = bubble;\n\n\n//# sourceURL=webpack:///./node_modules/can-map/bubble.js?");

/***/ }),

/***/ "./node_modules/can-map/can-map.js":
/*!*****************************************!*\
  !*** ./node_modules/can-map/can-map.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint -W079 */\n// # can/map/map.js (aka can.Map)\n// `can.Map` provides the observable pattern for JavaScript objects. It\n// provides an `attr` and `removeAttr` method that can be used to get/set and\n// remove properties and nested properties by calling a \"pipeline\" of protected\n// methods:\n//\n// - `_get`, `_set`, `_remove` - handle nested properties.\n// - `__get`, `__set`, `__remove` - handle triggering events.\n// - `___get`, `___set`, `___remove` - read / write / remove raw values.\n//\n// When `attr` gets or sets multiple properties it calls `_getAttrs` or `_setAttrs`.\n//\n// [bubble.js](bubble.html) - Handles bubbling of child events to parent events.\n// [map_helpers.js](map_helpers.html) - Assorted helpers for handling cycles during serialization or\n// instantition of objects.\nvar bubble = __webpack_require__(/*! ./bubble */ \"./node_modules/can-map/bubble.js\");\nvar mapHelpers = __webpack_require__(/*! ./map-helpers */ \"./node_modules/can-map/map-helpers.js\");\nvar canEvent = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ \"./node_modules/can-event-queue/type/type.js\");\nvar Construct = __webpack_require__(/*! can-construct */ \"./node_modules/can-construct/can-construct.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar ObserveReader = __webpack_require__(/*! can-stache-key */ \"./node_modules/can-stache-key/can-stache-key.js\");\nvar canCompute = __webpack_require__(/*! can-compute */ \"./node_modules/can-compute/can-compute.js\");\nvar singleReference = __webpack_require__(/*! can-single-reference */ \"./node_modules/can-single-reference/can-single-reference.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar CID = __webpack_require__(/*! can-cid */ \"./node_modules/can-cid/can-cid.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar types = __webpack_require__(/*! can-types */ \"./node_modules/can-types/can-types.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar CIDSet = __webpack_require__(/*! can-cid/set/set */ \"./node_modules/can-cid/set/set.js\");\nvar CIDMap = __webpack_require__(/*! can-cid/map/map */ \"./node_modules/can-cid/map/map.js\");\nvar canQueues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\n\n// properties that can't be observed on ... no matter what\nvar unobservable = {\n\t\"constructor\": true\n};\n\nvar hasOwnProperty = ({}).hasOwnProperty;\nvar inSetupSymbol = canSymbol.for(\"can.initializing\");\n\n// Extend [can.Construct](../construct/construct.html) to make inheriting a `can.Map` easier.\nvar Map = Construct.extend(\n\t/**\n\t * @static\n\t */\n\t// ## Static Properties and Methods\n\t{\n\t\t// ### setup\n\t\t// Called when a Map constructor is defined/extended to\n\t\t// perform any initialization behavior for the new constructor\n\t\t// function.\n\t\tsetup: function (baseMap) {\n\n\t\t\tConstruct.setup.apply(this, arguments);\n\n\t\t\t// A cached list of computed properties on the prototype.\n\t\t\tthis._computedPropertyNames = [];\n\n\t\t\t// Do not run if we are defining can.Map.\n\t\t\tif (Map) {\n\t\t\t\taddTypeEvents(this);\n\t\t\t\tthis[canSymbol.for(\"can.defineInstanceKey\")] = function(prop, definition){\n\t\t\t\t\tif(definition.value !== undefined) {\n\t\t\t\t\t\tthis.defaults[prop] = definition.value;\n\t\t\t\t\t}\n\t\t\t\t\tif(definition.enumerable === false ) {\n\t\t\t\t\t\tthis.enumerable[prop] = false;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t// Provide warnings if can.Map is used incorrectly.\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tif(this.prototype.define && !mapHelpers.define) {\n\t\t\t\t\t\tdev.warn(\"can/map/define is not included, yet there is a define property \"+\n\t\t\t\t\t\t\"used. You may want to add this plugin.\");\n\t\t\t\t\t}\n\t\t\t\t\tif(this.define && !mapHelpers.define) {\n\t\t\t\t\t\tdev.warn(\"The define property should be on the map's prototype properties, \"+\n\t\t\t\t\t\t\"not the static properties. Also, can/map/define is not included.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\t// Create a placeholder for default values.\n\t\t\t\tif (!this.defaults) {\n\t\t\t\t\tthis.defaults = {};\n\t\t\t\t}\n\t\t\t\tif(!this.enumerable) {\n\t\t\t\t\tthis.enumerable = {};\n\t\t\t\t}\n\n\n\t\t\t\t// Go through everything on the prototype.  If it's a primitive,\n\t\t\t\t// treat it as a default value.  If it's a compute, identify it so\n\t\t\t\t// it can be setup as a computed property.\n\t\t\t\tfor (var prop in this.prototype) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tprop !== \"define\" &&\n\t\t\t\t\t\tprop !== \"constructor\" &&\n\t\t\t\t\t\t(typeof this.prototype[prop] !== \"function\" ||\n\t\t\t\t\t\t\tthis.prototype[prop].prototype instanceof Construct)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.defaults[prop] = this.prototype[prop];\n\t\t\t\t\t} else if (canReflect.isObservableLike(this.prototype[prop])) {\n\t\t\t\t\t\tthis._computedPropertyNames.push(prop);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If define is a function, call it with this can.Map\n\t\t\t\tif(mapHelpers.define) {\n\t\t\t\t\tmapHelpers.define(this, baseMap.prototype.define);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we inherit from can.Map, but not can.List, create a can.List that\n\t\t\t// creates instances of this Map type.\n            // This is something List should weave in.\n\t\t\t/*if (can.List && !(this.prototype instanceof can.List)) {\n\t\t\t\tthis.List = Map.List.extend({\n\t\t\t\t\tMap: this\n\t\t\t\t}, {});\n\t\t\t}*/\n\n\t\t},\n\t\t// ### shortName\n\t\t// Tells `can.Construct` to show instance as `Map` in the debugger.\n\t\tshortName: \"Map\",\n\n\t\t// ### _bubbleRule\n\t\t// Returns which events to setup bubbling on for a given bound event.\n\t\t// By default, only bubbles \"change\" events if someone listens to a\n\t\t// \"change\" event or a nested event like \"foo.bar\".\n\t\t_bubbleRule: function(eventName) {\n\t\t\treturn (eventName === \"change\" || eventName.indexOf(\".\") >= 0 ) ?\n\t\t\t\t[\"change\"] :\n\t\t\t\t[];\n\t\t},\n\n\t\t// ### bind,  unbind\n\t\t// Listen to events on the Map constructor.  These\n\t\t// are here mostly for can.Model.\n\t\taddEventListener: canEvent.addEventListener,\n\t\tremoveEventListener: canEvent.removeEventListener,\n\n\t\t// ### keys\n\t\t// An observable way to get the keys from a map.\n\t\tkeys: function (map) {\n\t\t\treturn canReflect.getOwnEnumerableKeys(map);\n\t\t}\n\t},\n\t/**\n\t * @prototype\n\t */\n\t// ## Prototype Properties and Methods\n\t{\n\t\t// ### setup\n\t\t// Initializes the map instance's behavior.\n\t\tsetup: function (obj) {\n\n\t\t\tif(canReflect.isObservableLike(obj) && typeof obj.serialize === \"function\"){\n\t\t\t\tobj = obj.serialize();\n\t\t\t}\n\n\t\t\t// Where we keep the values of the compute.\n\t\t\tthis._data = Object.create(null);\n\n\t\t\t// The namespace this `object` uses to listen to events.\n\t\t\tCID(this, \".map\");\n\n\t\t\tthis._setupComputedProperties();\n\t\t\tvar teardownMapping = obj && mapHelpers.addToMap(obj, this);\n\n\t\t\tvar defaultValues = this._setupDefaults(obj);\n\t\t\tvar data = assign(canReflect.assignDeep({}, defaultValues), obj);\n\n\t\t\tthis.attr(data);\n\n\t\t\tif (teardownMapping) {\n\t\t\t\tteardownMapping();\n\t\t\t}\n\t\t},\n\n\t\t// ### _setupComputes\n\t\t// Sets up computed properties on a Map.\n\t\t// Stores information for each computed property on\n\t\t//  `this._computedAttrs` that looks like:\n\t\t//\n\t\t// ```\n\t\t// {\n\t\t//   // the number of bindings on this property\n\t\t//   count: 1,\n\t\t//   // a handler that forwards events on the compute\n\t\t//   // to the map instance\n\t\t//   handler: handler,\n\t\t//   compute: compute  // the compute\n\t\t// }\n\t\t// ```\n\t\t_setupComputedProperties: function () {\n\t\t\tthis._computedAttrs = Object.create(null);\n\n\t\t\tvar computes = this.constructor._computedPropertyNames;\n\n\t\t\tfor (var i = 0, len = computes.length; i < len; i++) {\n\t\t\t\tvar attrName = computes[i];\n\t\t\t\tmapHelpers.addComputedAttr(this, attrName, this[attrName]);\n\t\t\t}\n\t\t},\n\n\t\t// ### _setupDefaults\n\t\t// Returns the default values for the instance.\n\t\t_setupDefaults: function(){\n\t\t\treturn this.constructor.defaults || {};\n\t\t},\n\n\t\t// ### attr\n\t\t// The primary get/set interface for can.Map.\n\t\t// Calls `_get`, `_set` or `_attrs` depending on\n\t\t// how it is called.\n\t\tattr: function (attr, val) {\n\t\t\tvar type = typeof attr;\n\t\t\tif(attr === undefined) {\n\t\t\t\treturn this._getAttrs();\n\t\t\t} else if (type !== \"string\" && type !== \"number\") {\n\t\t\t\t// Get or set multiple attributes.\n\t\t\t\treturn this._setAttrs(attr, val);\n\t\t\t}\n\t\t\telse if (arguments.length === 1) {\n\t\t\t\t// Get a single attribute.\n\t\t\t\treturn this._get(attr);\n\t\t\t} else {\n\t\t\t\t// Set an attribute.\n\t\t\t\tthis._set(attr+\"\", val);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t},\n\n\t\t// ### _get\n\t\t// Handles reading nested properties like \"foo.bar\" by\n\t\t// getting the value of \"foo\" and recursively\n\t\t// calling `_get` for the value of \"bar\".\n\t\t// To read the actual values, `_get` calls\n\t\t// `___get`.\n\t\t_get: function (attr) {\n\t\t\tattr = attr + \"\";\n\t\t\tvar dotIndex = attr.indexOf('.');\n\n\t\t\tif( dotIndex >= 0 ) {\n\n\t\t\t\t// Attempt to get the value anyway in case\n\t\t\t\t// somone wrote `new can.Map({\"foo.bar\": 1})`.\n\t\t\t\tvar value = this.___get(attr);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tObservationRecorder.add(this, attr);\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tvar first = attr.substr(0, dotIndex),\n\t\t\t\t\tsecond = attr.substr(dotIndex+1);\n\n\t\t\t\tvar current = this.__get( first );\n\n\t\t\t\treturn current && canReflect.getKeyValue(current, second);\n\t\t\t} else {\n\t\t\t\treturn this.__get( attr );\n\t\t\t}\n\t\t},\n\n\t\t// ### __get\n\t\t// Signals `can.compute` that an observable\n\t\t// property is being read.\n\t\t__get: function(attr){\n\t\t\tif(!unobservable[attr] && !this._computedAttrs[attr]) {\n\t\t\t\tObservationRecorder.add(this, attr);\n\t\t\t}\n\t\t\treturn this.___get( attr );\n\t\t},\n\n\t\t// ### ___get\n\t\t// When called with an argument, returns the value of this property. If that\n\t\t// property is represented by a computed attribute, return the value of that compute.\n\t\t// If no argument is provided, return the raw data.\n\t\t___get: function (attr) {\n\t\t\tif (attr !== undefined) {\n\t\t\t\tvar computedAttr = this._computedAttrs[attr];\n\t\t\t\tif (computedAttr) {\n\t\t\t\t\t// return computedAttr.compute();\n\t\t\t\t\treturn canReflect.getValue(computedAttr.compute);\n\t\t\t\t} else {\n\t\t\t\t\treturn hasOwnProperty.call(this._data, attr) ? this._data[attr] : undefined;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this._data;\n\t\t\t}\n\t\t},\n\n\t\t// ### _set\n\t\t// Handles setting nested properties by finding the\n\t\t// nested observable and recursively calling `_set` on it. Eventually,\n\t\t// it calls `__set` with the `__type` converted value to set\n\t\t// and the current value.  The current value is passed for two reasons:\n\t\t//  - so `__set` can trigger an event if the value has changed.\n\t\t//  - for advanced setting behavior that define.set can do.\n\t\t//\n\t\t// If the map is initializing, the current value does not need to be\n\t\t// read because no change events are dispatched anyway.\n\t\t_set: function (attr, value, keepKey) {\n\t\t\tattr = attr + \"\";\n\n\t\t\tvar dotIndex = attr.indexOf('.'),\n\t\t\t\tcurrent;\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tvar lastItem, lastFn;\n\t\t\t\t// If there are observations currently recording, this isn't a good time to\n\t\t\t\t//   mutate values: it's likely a cycle, and even if it doesn't cycle infinitely,\n\t\t\t\t//   it will likely cause unnecessary recomputation of derived values.  Warn the user.\n\t\t\t\tif(ObservationRecorder.isRecording() && canQueues.stack().length && !this[inSetupSymbol]) {\n\t\t\t\t\tlastItem = canQueues.stack()[canQueues.stack().length - 1];\n\t\t\t\t\tlastFn = lastItem.context instanceof Observation ? lastItem.context.func : lastItem.fn;\n\t\t\t\t\tvar mutationWarning = \"can-map: The \" + attr + \" property on \" +\n\t\t\t\t\t\tcanReflect.getName(this) +\n\t\t\t\t\t\t\" is being set in \" +\n\t\t\t\t\t\t(canReflect.getName(lastFn) || canReflect.getName(lastItem.fn)) +\n\t\t\t\t\t\t\". This can cause infinite loops and performance issues. \" +\n\t\t\t\t\t\t\"Use getters and listeners to derive properties instead. https://canjs.com/doc/guides/logic.html#Derivedproperties\";\n\n\t\t\t\t\tdev.warn(mutationWarning);\n\t\t\t\t\tcanQueues.logStack();\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tif(dotIndex >= 0 && !keepKey){\n\t\t\t\tvar first = attr.substr(0, dotIndex),\n\t\t\t\t\tsecond = attr.substr(dotIndex+1);\n\n\t\t\t\tcurrent =  this[inSetupSymbol] ? undefined : this.___get( first );\n\n\t\t\t\tif( canReflect.isMapLike(current) ) {\n\t\t\t\t\tcanReflect.setKeyValue(current, second, value);\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = this[inSetupSymbol] ? undefined : this.___get( attr );\n\n\t\t\t\t\t// //Convert if there is a converter.  Remove in 3.0.\n\t\t\t\t\tif (this.__convert) {\n\t\t\t\t\t\tvalue = this.__convert(attr, value);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.__set(attr, this.__type(value, attr), current);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tcurrent = this[inSetupSymbol] ? undefined : this.___get( attr );\n\n\t\t\t\t// //Convert if there is a converter.  Remove in 3.0.\n\t\t\t\tif (this.__convert) {\n\t\t\t\t\tvalue = this.__convert(attr, value);\n\t\t\t\t}\n\n\t\t\t\tthis.__set(attr, this.__type(value, attr), current);\n\t\t\t}\n\t\t},\n\n\t\t// ## __type\n\t\t// Converts set values to another type.  By default,\n\t\t// this converts Objects to can.Maps and Arrays to\n\t\t// can.Lists.\n\t\t// This also makes it so if a plain JavaScript object\n\t\t// has already been converted to a list or map, that same\n\t\t// list or map instance is used.\n\t\t__type: function(value, prop){\n\n\t\t\tif (typeof value === \"object\" &&\n\t\t\t\t!canReflect.isObservableLike( value ) &&\n\t\t\t\tmapHelpers.canMakeObserve(value) &&\n\t\t\t\t!canReflect.isListLike(value)\n\t\t\t) {\n\n\t\t\t\tvar cached = mapHelpers.getMapFromObject(value);\n\t\t\t\tif(cached) {\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t\tvar MapConstructor = this.constructor.Map || Map;\n\t\t\t\treturn new MapConstructor(value);\n\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\t\t// ## __set\n\t\t// Handles firing events if the value has changed and\n\t\t// works with the `bubble` helpers to setup bubbling.\n\t\t// Calls `___set` to do the actual setting.\n\t\t__set: function (prop, value, current) {\n\n\t\t\tif ( value !== current || !Object.prototype.hasOwnProperty.call( this._data, prop ) ) {\n\t\t\t\tvar computedAttr = this._computedAttrs[prop];\n\n\t\t\t\t// Dispatch an \"add\" event if adding a new property.\n\t\t\t\tvar changeType = computedAttr || current !== undefined ||\n\t\t\t\t\thasOwnProperty.call(this.___get(), prop) ? \"set\" : \"add\";\n\n\t\t\t\t// Set the value on `_data` and set up bubbling.\n\t\t\t\tthis.___set(prop, typeof value === \"object\" ? bubble.set(this, prop, value, current) : value );\n\n\t\t\t\t// Computed properties change events are already forwarded except if\n\t\t\t\t// no one is listening to them.\n\t\t\t\tif(!computedAttr || !computedAttr.count) {\n\t\t\t\t\tthis._triggerChange(prop, changeType, value, current);\n\t\t\t\t}\n\n\n\t\t\t\t// Stop bubbling old nested maps.\n\t\t\t\tif (typeof current === \"object\") {\n\t\t\t\t\tbubble.teardownFromParent(this, current);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// ### ___set\n\t\t// Directly saves the set value as a property on `_data`\n\t\t// or sets the computed attribute.\n\t\t___set: function (prop, val) {\n\t\t\tvar computedAttr = this._computedAttrs[prop];\n\t\t\tif ( computedAttr ) {\n\t\t\t\tcanReflect.setValue(computedAttr.compute, val);\n\t\t\t} else {\n\t\t\t\tthis._data[prop] = val;\n\t\t\t}\n\n\t\t\t// Adds the property directly to the map instance. But first,\n\t\t\t// checks that it's not overwriting a method. This should be removed\n\t\t\t// in 3.0.\n\t\t\tif ( typeof this.constructor.prototype[prop] !== 'function' && !computedAttr ) {\n\t\t\t\tthis[prop] = val;\n\t\t\t}\n\t\t},\n\n\t\tremoveAttr: function (attr) {\n\t\t\treturn this._remove(attr);\n\t\t},\n\n\t\t// ### _remove\n\t\t// Handles removing nested observes.\n\t\t_remove: function(attr){\n\t\t\t// If this is List.\n\t\t\tvar parts = mapHelpers.attrParts(attr),\n\t\t\t// The actual property to remove.\n\t\t\t\tprop = parts.shift(),\n\t\t\t// The current value.\n\t\t\t\tcurrent = this.___get(prop);\n\n\t\t\t// If we have more parts, call `removeAttr` on that part.\n\t\t\tif (parts.length && current) {\n\t\t\t\treturn canReflect.deleteKeyValue(current, parts.join(\".\"));\n\t\t\t} else {\n\n\t\t\t\t// If attr does not have a `.`\n\t\t\t\tif (typeof attr === 'string' && !!~attr.indexOf('.')) {\n\t\t\t\t\tprop = attr;\n\t\t\t\t}\n\n\t\t\t\tthis.__remove(prop, current);\n\t\t\t\treturn current;\n\t\t\t}\n\t\t},\n\n\t\t// ### __remove\n\t\t// Handles triggering an event if a property could be removed.\n\t\t__remove: function(prop, current){\n\t\t\tif (prop in this._data) {\n\t\t\t\tthis.___remove(prop);\n\t\t\t\t// Let others now this property has been removed.\n\t\t\t\tthis._triggerChange(prop, \"remove\", undefined, current);\n\t\t\t}\n\t\t},\n\n\t\t// ### ___remove\n\t\t// Deletes a property from `_data` and the map instance.\n\t\t___remove: function(prop){\n\t\t\tdelete this._data[prop];\n\t\t\tif (!(prop in this.constructor.prototype)) {\n\t\t\t\tdelete this[prop];\n\t\t\t}\n\t\t},\n\n\t\t// ### ___serialize\n\t\t// Serializes a property.  Uses map helpers to\n\t\t// recursively serialize nested observables.\n\t\t___serialize: function(name, val){\n\t\t\tif(this._legacyAttrBehavior) {\n\t\t\t\treturn mapHelpers.getValue(this, name, val, \"serialize\");\n\t\t\t} else {\n\t\t\t\treturn canReflect.serialize(val, CIDMap);\n\t\t\t}\n\t\t},\n\n\t\t// ### _getAttrs\n\t\t// Returns the values of all attributes as a plain JavaScript object.\n\t\t_getAttrs: function(){\n\t\t\tif(this._legacyAttrBehavior) {\n\t\t\t\treturn mapHelpers.serialize(this, 'attr', {});\n\t\t\t} else {\n\t\t\t\treturn canReflect.unwrap(this, CIDMap);\n\t\t\t}\n\n\t\t},\n\t\t// ### _setAttrs\n\t\t// Sets multiple properties on this object at once.\n\t\t// First, goes through all current properties and either merges\n\t\t// or removes old properties.\n\t\t// Then it goes through the remaining ones to be added and sets those properties.\n\t\t_setAttrs: function (props, remove) {\n\t\t\tif(this._legacyAttrBehavior) {\n\t\t\t\treturn this.__setAttrs(props, remove);\n\t\t\t}\n\t\t\tif(remove === true || remove === \"true\") {\n\t\t\t\tthis[canSymbol.for(\"can.updateDeep\")](props);\n\t\t\t} else {\n\t\t\t\tthis[canSymbol.for(\"can.assignDeep\")](props);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t__setAttrs: function (props, remove) {\n\t\t\tprops = assign({}, props);\n\t\t\tvar prop,\n\t\t\t\tself = this,\n\t\t\t\tnewVal;\n\n\t\t\t// Batch all of the change events until we are done.\n\t\t\tcanQueues.batch.start();\n\t\t\t// Merge current properties with the new ones.\n\t\t\tthis._each(function (curVal, prop) {\n\t\t\t\t// You can not have a _cid property; abort.\n\t\t\t\tif (prop === \"_cid\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tnewVal = props[prop];\n\n\t\t\t\t// If we are merging, remove the property if it has no value.\n\t\t\t\tif (newVal === undefined) {\n\t\t\t\t\tif (remove) {\n\t\t\t\t\t\tself.removeAttr(prop);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Run converter if there is one. Remove in 3.0.\n\t\t\t\tif (self.__convert) {\n\t\t\t\t\tnewVal = self.__convert( prop, newVal );\n\t\t\t\t}\n\n\t\t\t\tif ( canReflect.isObservableLike(curVal) && canReflect.isMapLike(curVal) && mapHelpers.canMakeObserve(newVal) ) {\n\t\t\t\t\tif(remove === true) {\n\t\t\t\t\t\tcanReflect.updateDeep(curVal, newVal);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanReflect.assignDeep(curVal, newVal);\n\t\t\t\t\t}\n\t\t\t\t\t// Otherwise just set.\n\t\t\t\t} else if (curVal !== newVal) {\n\t\t\t\t\tself.__set(prop, self.__type(newVal, prop), curVal);\n\t\t\t\t}\n\n\t\t\t\tdelete props[prop];\n\t\t\t});\n\t\t\t// Add remaining props.\n\t\t\tfor (prop in props) {\n\t\t\t\t// Ignore _cid.\n\t\t\t\tif (prop !== \"_cid\") {\n\t\t\t\t\tnewVal = props[prop];\n\t\t\t\t\tthis._set(prop, newVal, true);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tcanQueues.batch.stop();\n\t\t\treturn this;\n\t\t},\n\n\t\tserialize: function () {\n\t\t\treturn canReflect.serialize(this, CIDMap);\n\t\t},\n\n\n\t\t// ### _triggerChange\n\t\t// A helper function used to trigger events on this map.\n\t\t// If the map is bubbling, this will fire a change event.\n\t\t// Otherwise, it only fires a \"named\" event. Triggers a\n\t\t// \"__keys\" event if a property has been added or removed.\n\t\t_triggerChange: function (attr, how, newVal, oldVal, batchNum) {\n\t\t\tcanQueues.batch.start();\n\t\t\tif(bubble.isBubbling(this, \"change\")) {\n\t\t\t\tcanEvent.dispatch.call(this, {\n\t\t\t\t\ttype: \"change\",\n\t\t\t\t\ttarget: this,\n\t\t\t\t\tbatchNum: batchNum\n\t\t\t\t}, [attr, how, newVal, oldVal]);\n\n\t\t\t}\n\n\t\t\tcanEvent.dispatch.call(this, {\n\t\t\t\ttype: attr,\n\t\t\t\ttarget: this,\n\t\t\t\tbatchNum: batchNum,\n\t\t\t\tpatches: [{type: \"set\", key: attr, value: newVal}]\n\t\t\t}, [newVal, oldVal]);\n\n\t\t\tif(how === \"remove\" || how === \"add\") {\n\t\t\t\tcanEvent.dispatch.call(this, {\n\t\t\t\t\ttype: \"__keys\",\n\t\t\t\t\ttarget: this,\n\t\t\t\t\tbatchNum: batchNum\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcanQueues.batch.stop();\n\t\t},\n\n\n\n\t\t// ### compute\n\t\t// Creates a compute that represents a value on this map. If the property is a function\n\t\t// on the prototype, a \"function\" compute wil be created.\n\t\t// Otherwise, a compute will be created that reads the observable attributes\n\t\tcompute: function (prop) {\n\t\t\tif (typeof this.constructor.prototype[prop] === \"function\") {\n\t\t\t\treturn canCompute(this[prop], this);\n\t\t\t} else {\n\t\t\t\tvar reads = ObserveReader.reads(prop);\n\t\t\t\tvar last = reads.length - 1;\n\n\t\t\t\treturn canCompute(function (newVal) {\n\t\t\t\t\tif (arguments.length) {\n\t\t\t\t\t\tObserveReader.write(this, reads[last].key, newVal, {});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn ObserveReader.get(this, prop);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\t\t}\n\t\t},\n\n\t\t// ### each\n\t\t// loops through all the key-value pairs on this map.\n\t\tforEach: function (callback, context) {\n\t\t\t\tvar key, item;\n\t\t\tvar keys = canReflect.getOwnEnumerableKeys(this);\n\t\t\tfor(var i =0, len = keys.length; i < len; i++) {\n\t\t\t    key = keys[i];\n\t\t\t    item = this.attr(key);\n\t\t\t    if (callback.call(context || item, item, key, this) === false) {\n\t\t\t        break;\n\t\t\t    }\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t// ### _each\n\t\t// Iterator that does not trigger live binding.\n\t\t_each: function (callback) {\n\t\t\tvar data = this.___get();\n\t\t\tfor (var prop in data) {\n\t\t\t\tif (hasOwnProperty.call(data, prop)) {\n\t\t\t\t\tcallback(data[prop], prop);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdispatch: canEvent.dispatch\n\t});\n\n// makes it so things can read this.\ncanEvent(Map.prototype);\n\n// ### bind\n// Listens to an event on a map.\n// If the event is a  computed property,\n// listen to the compute and forward its events\n// to this map.\nMap.prototype.addEventListener = function (eventName, handler) {\n\n\tvar computedBinding = this._computedAttrs && this._computedAttrs[eventName];\n\tif (computedBinding && computedBinding.compute) {\n\t\tif (!computedBinding.count) {\n\t\t\tcomputedBinding.count = 1;\n\t\t\tcanReflect.onValue(computedBinding.compute, computedBinding.handler, \"notify\");\n\t\t} else {\n\t\t\tcomputedBinding.count++;\n\t\t}\n\n\t}\n\n\t// Sets up bubbling if needed.\n\tbubble.bind(this, eventName);\n\n\treturn canEvent.addEventListener.apply(this, arguments);\n};\n\n// ### unbind\n// Stops listening to an event.\n// If this is the last listener of a computed property,\n// stop forwarding events of the computed property to this map.\nMap.prototype.removeEventListener = function (eventName, handler) {\n\tvar computedBinding = this._computedAttrs && this._computedAttrs[eventName];\n\tif (computedBinding) {\n\t\tif (computedBinding.count === 1) {\n\t\t\tcomputedBinding.count = 0;\n\t\t\tcanReflect.offValue(computedBinding.compute, computedBinding.handler, \"notify\");\n\t\t} else {\n\t\t\tcomputedBinding.count--;\n\t\t}\n\n\t}\n\n\t// Teardown bubbling if needed.\n\tbubble.unbind(this, eventName);\n\treturn canEvent.removeEventListener.apply(this, arguments);\n\n};\n\n// ### etc\n// Setup on/off aliases\nMap.prototype.on = Map.prototype.bind = Map.prototype.addEventListener;\nMap.prototype.off = Map.prototype.unbind = Map.prototype.removeEventListener;\nMap.on = Map.bind = Map.addEventListener;\nMap.off = Map.unbind = Map.removeEventListener;\n\n// - type -\n\ncanReflect.assignSymbols(Map.prototype,{\n\t// -type-\n\t\"can.isMapLike\": true,\n\t\"can.isListLike\":  false,\n\t\"can.isValueLike\": false,\n\n\t// -get/set-\n\t\"can.getKeyValue\": Map.prototype._get,\n\t\"can.setKeyValue\": Map.prototype._set,\n\t\"can.deleteKeyValue\": Map.prototype._remove,\n\n\t// -shape\n\t\"can.getOwnEnumerableKeys\": function(){\n\t\tif (!this[inSetupSymbol]) {\n\t\t\tObservationRecorder.add(this, '__keys');\n\t\t}\n\t\tvar enumerable = this.constructor.enumerable;\n\t\tif(enumerable) {\n\t\t\treturn Object.keys(this._data).filter(function(key){\n\t\t\t\treturn enumerable[key] !== false;\n\t\t\t},this);\n\t\t} else {\n\t\t\treturn Object.keys(this._data);\n\t\t}\n\t},\n\n\t// -shape get/set-\n\t\"can.assignDeep\": function(source){\n\t\tcanQueues.batch.start();\n\t\t// TODO: we should probably just throw an error instead of cleaning\n\t\tcanReflect.assignDeepMap(this, mapHelpers.removeSpecialKeys(canReflect.assignMap({}, source)));\n\t\tcanQueues.batch.stop();\n\t},\n\t\"can.updateDeep\": function(source){\n\t\tcanQueues.batch.start();\n\t\t// TODO: we should probably just throw an error instead of cleaning\n\t\tcanReflect.updateDeepMap(this, mapHelpers.removeSpecialKeys(canReflect.assignMap({}, source)));\n\t\tcanQueues.batch.stop();\n\t},\n\t\"can.unwrap\": mapHelpers.reflectUnwrap,\n\t\"can.serialize\": mapHelpers.reflectSerialize,\n\n\t// observable\n\t\"can.onKeyValue\": function(key, handler, queue){\n\t\tvar translationHandler = function(ev, newValue, oldValue){\n\t\t\thandler.call(this, newValue, oldValue);\n\t\t};\n\t\tsingleReference.set(handler, this, translationHandler, key);\n\n\t\tthis.addEventListener(key, translationHandler, queue);\n\t},\n\t\"can.offKeyValue\": function(key, handler, queue){\n\t\tthis.removeEventListener(key, singleReference.getAndDelete(handler, this, key), queue );\n\t},\n\t\"can.keyHasDependencies\": function(key) {\n\t\treturn !!(this._computedAttrs && this._computedAttrs[key] &&\n\t\t\tthis._computedAttrs[key].compute);\n\t},\n\t\"can.getKeyDependencies\": function(key) {\n\t\tvar ret;\n\t\tif(this._computedAttrs && this._computedAttrs[key] && this._computedAttrs[key].compute) {\n\t\t\tret = {};\n\t\t\tret.valueDependencies = new CIDSet();\n\t\t\tret.valueDependencies.add(this._computedAttrs[key].compute);\n\t\t}\n\t\treturn ret;\n\t}\n});\n\n\nif(!types.DefaultMap) {\n\ttypes.DefaultMap = Map;\n}\n\nmodule.exports = namespace.Map = Map;\n\n\n//# sourceURL=webpack:///./node_modules/can-map/can-map.js?");

/***/ }),

/***/ "./node_modules/can-map/map-helpers.js":
/*!*********************************************!*\
  !*** ./node_modules/can-map/map-helpers.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # can/map/map_hepers\n// Helper functions that are primarily used to serialize\n// a map, or track the maps created from plain JavaScript objects.\n// `can.Map` handles cycles in objects nicely!\nvar CID = __webpack_require__(/*! can-cid */ \"./node_modules/can-cid/can-cid.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n// ## POJOs to Map instance helpers\n\n// ### madeMap\n// A temporary map of Maps that have been made from plain JS objects.\n// `{POJO_CID: {obj: POJO, instance: MAP, added: Boolean}}`\nvar madeMap = null;\n\n// ### teardownMap\n// Clears out map of converted objects and removes temporary `cids`.\nvar teardownMap = function () {\n\tfor (var cid in madeMap) {\n\t\tif (madeMap[cid].added) {\n\t\t\tdelete madeMap[cid].obj._cid;\n\t\t}\n\t}\n\tmadeMap = null;\n};\n\nvar mapHelpers = {\n\t// ### mapHelpers.attrParts\n\t// Parses attribute name into its parts.\n\tattrParts: function (attr, keepKey) {\n\t\t//Keep key intact\n\t\tif (keepKey ) {\n\t\t\treturn [attr];\n\t\t}\n\t\t// Split key on '.'\n\t\treturn typeof attr === \"object\" ? attr : (\"\" + attr)\n\t\t\t.split(\".\");\n\t},\n\n\t// ### can.mapHelpers.canMakeObserve\n\t// Determines if an object can be made into an observable.\n\tcanMakeObserve: function (obj) {\n\t\treturn obj && !canReflect.isPromise(obj) && (Array.isArray(obj) || canReflect.isPlainObject(obj) );\n\t},\n\treflectSerialize: function(unwrapped){\n\t\tthis.forEach(function(val, name){\n\t\t\tif( this.___serialize ) {\n\t\t\t\tval = this.___serialize(name, val);\n\t\t\t} else {\n\t\t\t\tval = canReflect.serialize(val);\n\t\t\t}\n\t\t\tif(val !== undefined) {\n\t\t\t\tunwrapped[name] = val;\n\t\t\t}\n\t\t}, this);\n\t\treturn unwrapped;\n\t},\n\treflectUnwrap: function(unwrapped){\n\t\tthis.forEach(function(value, key){\n\t\t\tif(value !== undefined) {\n\t\t\t\tunwrapped[key] = canReflect.unwrap(value);\n\t\t\t}\n\t\t});\n\t\treturn unwrapped;\n\t},\n\tremoveSpecialKeys: function(map) {\n\t\tif(map) {\n\t\t\t[\"_data\", \"constructor\", \"_cid\", \"__bindEvents\"].forEach(function(key) {\n\t\t\t\tdelete map[key];\n\t\t\t});\n\t\t}\n\t\treturn map;\n\t},\n\t// ### mapHelpers.serialize\n\t// Serializes a Map or Map.List by recursively calling the `how`\n\t// method on any child objects. This is able to handle\n\t// cycles.\n\t// `map` - the map or list to serialize.\n\t// `how` - the method to call recursively.\n\t// `where` - the target Object or Array that becomes the serialized result.\n\tserialize: (function(){\n\n\t\t// A temporary mapping of map cids to the serialized result.\n\t\tvar serializeMap = null;\n\n\t\treturn function (map, how, where) {\n\t\t\tvar cid = CID(map),\n\t\t\t\tfirstSerialize = false;\n\n\t\t\t// If there isn't an existing serializeMap, this means\n\t\t\t// this is the initial non-recursive call to this function.\n\t\t\t// We mark this  as the first call, and then setup the serializeMap.\n\t\t\t// The serialize map is further devided into `how` because\n\t\t\t// `.serialize` might call `.attr`.\n\t\t\tif(!serializeMap) {\n\t\t\t\tfirstSerialize = true;\n\t\t\t\tserializeMap = {\n\t\t\t\t\tattr: {},\n\t\t\t\t\tserialize: {}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tserializeMap[how][cid] = where;\n\t\t\t// Go through each property.\n\t\t\tmap.forEach(function (val, name) {\n\t\t\t\t// If the value is an `object`, and has an `attr` or `serialize` function.\n\t\t\t\tvar result,\n\t\t\t\t\tisObservable = canReflect.isObservableLike(val),\n\t\t\t\t\tserialized = isObservable && serializeMap[how][CID(val)];\n\n\t\t\t\tif( serialized ) {\n\t\t\t\t\tresult = serialized;\n\t\t\t\t} else {\n\t\t\t\t\t// special attr or serializer\n\t\t\t\t\tif(map[\"___\"+how]) {\n\t\t\t\t\t\tresult =  map[\"___\"+how](name, val);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = mapHelpers.getValue(map, name, val, how);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// this is probably removable\n\t\t\t\tif(result !== undefined){\n\t\t\t\t\twhere[name] = result;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif(firstSerialize) {\n\t\t\t\tserializeMap = null;\n\t\t\t}\n\t\t\treturn where;\n\t\t};\n\t})(),\n\n\t// ## getValue\n\t// If `val` is an observable, calls `how` on it; otherwise\n\t// returns the value of `val`.\n\tgetValue: function(map, name, val, how){\n\t\tif(how === \"attr\") {\n\t\t\thow = canSymbol.for(\"can.getValue\");\n\t\t}\n\t\tif( canReflect.isObservableLike(val) && val[how] ) {\n\t\t\treturn val[how]();\n\t\t} else {\n\t\t\treturn val;\n\t\t}\n\t},\n\n\t// ## define\n\t// A hook to call whenever a Map is defined.\n\t// We need a better place for this.\n\tdefine: null,\n\n\t// ## addComputedAttr\n\t// Adds a compute so it will control the behavior of an\n\t// attribute.  Each computedAttrs object has:\n\t// - `compute` - the compute that will be read and updated.\n\t// - `count` - the number of bindings to this individual property.\n\t//   This is used to know when to bind `handler` to the compute.\n\t// - `handler` - a function that when bound to `compute` forwards all\n\t//   events to `map`.\n\taddComputedAttr: function(map, attrName, compute){\n\t\tmap._computedAttrs[attrName] = {\n\t\t\tcompute: compute,\n\t\t\tcount: 0,\n\t\t\thandler: function (newVal, oldVal) {\n\t\t\t\tmap._triggerChange(attrName, \"set\", newVal, oldVal);\n\t\t\t}\n\t\t};\n\t},\n\n\t// ### can.mapHelpers.addToMap\n\t// Tracks map instances created from JS objects.\n\t// This should be called whenever an instance is created for a particular object.\n\t// This may return a `teardown` function that should be called after all instances\n\t// might be created.\n\t//\n\t// While creating map instances from plain ole JS objects (POJOs), it's\n\t// possible that the same JS object exists as two different properties and\n\t// we want only one map instance created for one JS object.\n\t//\n\t// ```\n\t// var obj = {name: \"I am everywhere\"}\n\t// var map = new can.Map({obj1: obj, obj2: obj});\n\t// ok( map.attr(\"obj1\") === map.attr(\"obj2\") )\n\t// ```\n\t//\n\t// This works by temporarily adding a `cid` to any found POJO object\n\t// and storing it in a temporary Object that maps those `cid`s to\n\t// the POJO and the instance created for it.\n\t// The `teardown` function removes those temporary `cid`s and\n\t// clears the map for memory safety.\n\taddToMap: function addToMap(obj, instance) {\n\t\tvar teardown;\n\n\t\t// Setup a fresh mapping if `madeMap` is missing.\n\t\tif (!madeMap) {\n\t\t\tteardown = teardownMap;\n\t\t\tmadeMap = {};\n\t\t}\n\n\t\t// Record if Object has a `_cid` before adding one.\n\t\tvar hasCid = obj._cid;\n\t\tvar cid = CID(obj);\n\n\t\t// Only update if there already isn't one already.\n\t\tif (!madeMap[cid]) {\n\n\t\t\tmadeMap[cid] = {\n\t\t\t\tobj: obj,\n\t\t\t\tinstance: instance,\n\t\t\t\tadded: !hasCid\n\t\t\t};\n\t\t}\n\t\treturn teardown;\n\t},\n\n\t// ### getMapFromObject\n\t// Returns the map instance already created for this object `obj` or\n\t// `undefined` if nothing has been already created.\n\tgetMapFromObject: function (obj) {\n\t\treturn madeMap && madeMap[obj._cid] && madeMap[obj._cid].instance;\n\t},\n\ttwoLevelDeepExtend: function (destination, source) {\n\t\tfor (var prop in source) {\n\t\t\tdestination[prop] = destination[prop] || {};\n\t\t\tassign(destination[prop], source[prop]);\n\t\t}\n\t}\n};\n\nmodule.exports = exports = mapHelpers;\n\n\n//# sourceURL=webpack:///./node_modules/can-map/map-helpers.js?");

/***/ }),

/***/ "./node_modules/can-memory-store/can-memory-store.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-memory-store/can-memory-store.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar makeSimpleStore = __webpack_require__(/*! ./make-simple-store */ \"./node_modules/can-memory-store/make-simple-store.js\");\n\n\nmodule.exports = namespace.memoryStore = function memoryStore(baseConnection){\n    baseConnection.constructor = memoryStore;\n    var behavior = Object.create(makeSimpleStore(baseConnection));\n\n    canReflect.assignMap(behavior, {\n\t\tclear: function(){\n\t\t\tthis._instances = {};\n\t\t\tthis._queryData = [];\n\t\t},\n\t\t_queryData: [],\n\t\tupdateQueryDataSync: function(queries){\n\t\t\tthis._queryData = queries;\n\t\t},\n\t\tgetQueryDataSync: function(){\n\t\t\treturn this._queryData;\n\t\t},\n\n\t\t_instances: {},\n\t\tgetRecord: function(id){\n\t\t\treturn this._instances[id];\n\t\t},\n\t\tgetAllRecords: function(){\n\t\t\tvar records = [];\n\t\t\tfor(var id in this._instances) {\n\t\t\t\trecords.push(this._instances[id]);\n\t\t\t}\n\t\t\treturn records;\n\t\t},\n\t\tdestroyRecords: function(records) {\n\t\t\tcanReflect.eachIndex(records, function(record){\n\t\t\t\tvar id = canReflect.getIdentity(record, this.queryLogic.schema);\n\t\t\t\tdelete this._instances[id];\n\t\t\t}, this);\n\t\t},\n\t\tupdateRecordsSync: function(records){\n\t\t\trecords.forEach(function(record){\n\t\t\t\tvar id = canReflect.getIdentity(record, this.queryLogic.schema);\n\t\t\t\tthis._instances[id] = record;\n\t\t\t},this);\n\t\t},\n\n\t\t// ## External interface\n\n\t\t/**\n\t\t * @function can-memory-store.getQueries getQueries\n\t\t * @parent can-memory-store.data-methods\n\t\t *\n\t\t * Returns the queries contained within the cache.\n\t\t *\n\t\t * @signature `connection.getQueries()`\n\t\t *\n\t\t *   Returns the queries added by [can-memory-store.updateListData].\n\t\t *\n\t\t *   @return {Promise<Array<can-query-logic/query>>} A promise that resolves to the list of queries.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * ```js\n\t\t * connection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n\t\t * ```\n\t\t *\n\t\t */\n\n\t\t/**\n\t\t * @function can-memory-store.clear clear\n\t\t * @parent can-memory-store.data-methods\n\t\t *\n\t\t * Resets the memory store so it contains nothing.\n\t\t *\n\t\t * @signature `connection.clear()`\n\t\t *\n\t\t *   Removes all instances and lists being stored in memory.\n\t\t *\n\t\t *   ```js\n\t\t *   memoryStore({queryLogic: new QueryLogic()});\n\t\t *\n\t\t *   cacheConnection.updateInstance({id: 5, name: \"justin\"});\n\t\t *\n\t\t *   cacheConnection.getData({id: 5}).then(function(data){\n\t\t *     data //-> {id: 5, name: \"justin\"}\n\t\t *     cacheConnection.clear();\n\t\t *     cacheConnection.getData({id: 5}).catch(function(err){\n\t\t *       err -> {message: \"no data\", error: 404}\n\t\t *     });\n\t\t *   });\n\t\t *   ```\n\t\t *\n\t\t */\n\n\t\t/**\n\t\t * @function can-memory-store.getListData getListData\n\t\t * @parent can-memory-store.data-methods\n\t\t *\n\t\t * Gets a list of data from the memory store.\n\t\t *\n\t\t * @signature `connection.getListData(query)`\n\t\t *\n\t\t *   Goes through each query add by [can-memory-store.updateListData]. If\n\t\t *   `query` is a subset, uses [can-connect/base/base.queryLogic] to get the data for the requested `query`.\n\t\t *\n\t\t *   @param {can-query-logic/query} query An object that represents the data to load.\n\t\t *\n\t\t *   @return {Promise<can-connect.listData>} A promise that resolves if `query` is a subset of\n\t\t *   some data added by [can-memory-store.updateListData].  If it is not,\n\t\t *   the promise is rejected.\n\t\t */\n\n\t\t/**\n\t\t * @function can-connect/data/memory-cache.getListDataSync getListDataSync\n\t\t * @parent can-connect/data/memory-cache.data-methods\n\t\t *\n\t\t * Synchronously gets a query of data from the memory cache.\n\t\t *\n\t\t * @signature `connection.getListDataSync(query)`\n\t\t * @hide\n\t\t */\n\n\n\t\t/**\n\t\t * @function can-memory-store.updateListData updateListData\n\t\t * @parent can-memory-store.data-methods\n\t\t *\n\t\t * Saves a query of data in the cache.\n\t\t *\n\t\t * @signature `connection.updateListData(listData, query)`\n\t\t *\n\t\t *   Tries to merge this query of data with any other saved queries of data. If\n\t\t *   unable to merge this data, saves the query by itself.\n\t\t *\n\t\t *   @param {can-connect.listData} listData The data that belongs to `query`.\n\t\t *   @param {can-query-logic/query} query The query `listData` belongs to.\n\t\t *   @return {Promise} Promise resolves if and when the data has been successfully saved.\n\t\t */\n\n\n\t\t/**\n\t\t * @function can-memory-store.getData getData\n\t\t * @parent can-memory-store.data-methods\n\t\t *\n\t\t * Get an instance's data from the memory cache.\n\t\t *\n\t\t * @signature `connection.getData(params)`\n\t\t *\n\t\t *   Looks in the instance store for the requested instance.\n\t\t *\n\t\t *   @param {Object} params An object that should have the [conenction.id] of the element\n\t\t *   being retrieved.\n\t\t *\n\t\t *   @return {Promise} A promise that resolves to the item if the memory cache has this item.\n\t\t *   If the memory cache does not have this item, it rejects the promise.\n\t\t */\n\n\n\n\n\t\t/**\n\t\t * @function can-memory-store.createData createData\n\t\t * @parent can-memory-store.data-methods\n\t\t *\n\t\t * Called when an instance is created and should be added to cache.\n\t\t *\n\t\t * @signature `connection.createData(record)`\n\t\t *\n\t\t *   Adds `record` to the stored list of instances. Then, goes\n\t\t *   through every query and adds record the queries it belongs to.\n\t\t */\n\n\n\t\t/**\n\t\t * @function can-memory-store.updateData updateData\n\t\t * @parent can-memory-store.data-methods\n\t\t *\n\t\t * Called when an instance is updated.\n\t\t *\n\t\t * @signature `connection.updateData(record)`\n\t\t *\n\t\t *   Overwrites the stored instance with the new record. Then, goes\n\t\t *   through every query and adds or removes the instance if it belongs or not.\n\t\t */\n\n\t\t/**\n\t\t * @function can-memory-store.destroyData destroyData\n\t\t * @parent can-memory-store.data-methods\n\t\t *\n\t\t * Called when an instance should be removed from the cache.\n\t\t *\n\t\t * @signature `connection.destroyData(record)`\n\t\t *\n\t\t *   Goes through each query of data and removes any data that matches\n\t\t *   `record`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t\t */\n\n\t});\n\n\treturn behavior;\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-memory-store/can-memory-store.js?");

/***/ }),

/***/ "./node_modules/can-memory-store/make-simple-store.js":
/*!************************************************************!*\
  !*** ./node_modules/can-memory-store/make-simple-store.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\n\nfunction getItems(data){\n\tif(Array.isArray(data)) {\n\t\treturn data;\n\t} else {\n\t\treturn data.data;\n\t}\n}\n\nfunction indexOf(records, identity, queryLogic ){\n\tvar schema = canReflect.getSchema( queryLogic );\n\tfor(var i = 0 ; i < records.length; i++) {\n\t\tif(identity === canReflect.getIdentity(records[i],  schema) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n// update could remove all other records that would be in the set\nfunction makeSimpleStore(baseConnection) {\n    baseConnection.constructor = makeSimpleStore;\n    var behavior = Object.create(baseConnection);\n\n    // this stores data like:\n    // queries: {[queryKey]: {queryKey, query, recordIds}}\n    // records\n    return canReflect.assignMap(behavior, {\n        getRecordFromParams: function(record) {\n        \tvar id = canReflect.getIdentity(record, this.queryLogic.schema);\n        \treturn this.getRecord(id);\n        },\n\n        log: function(){\n\t\t\tthis._log = true;\n\t\t},\n\n        getSets: function(){\n\t\t\treturn this.getQueries();\n\t\t},\n\t\tgetQueries: function(){\n\t\t\treturn Promise.resolve(this.getQueriesSync());\n\t\t},\n\t\tgetQueriesSync: function(){\n\t\t\treturn this.getQueryDataSync().map(function(queryData){\n\t\t\t\treturn queryData.query;\n\t\t\t});\n\t\t},\n\n        getListData: function(query){\n        \tquery = query || {};\n        \tvar listData = this.getListDataSync(query);\n        \tif(listData) {\n        \t\treturn Promise.resolve(listData);\n        \t}\n        \treturn Promise.reject({\n        \t\ttitle: \"no data\",\n        \t\tstatus: \"404\",\n        \t\tdetail: \"No data available for this query.\\nAvailable queries: \"+\n        \t\t\tJSON.stringify(this.getQueriesSync())\n        \t});\n        },\n\t\tgetPaginatedListDataSync: function(superSetQueryData) {\n\t\t\tvar records = this.getAllRecords();\n\t\t\tvar queryWithoutPagination = this.queryLogic.removePagination(superSetQueryData.query);\n\t\t\tvar matchingSuperRecordsNoPagination = this.queryLogic.filterMembersAndGetCount(queryWithoutPagination, {}, records);\n\t\t\tvar startIndex = indexOf(matchingSuperRecordsNoPagination.data, superSetQueryData.startIdentity, this.queryLogic);\n\t\t\tvar matchingSuperRecords = matchingSuperRecordsNoPagination.data.slice(startIndex, startIndex+ this.queryLogic.count(superSetQueryData.query));\n\t\t\treturn {\n\t\t\t\tcount: matchingSuperRecordsNoPagination.data.length,\n\t\t\t\tdata: matchingSuperRecords\n\t\t\t};\n\t\t},\n        getListDataSync: function(query){\n\t\t\tvar queryData = this.getQueryDataSync(),\n\t\t\t\tsuperSetQueryData,\n\t\t\t\tisPaginated = this.queryLogic.isPaginated(query);\n\n\t\t\tfor(var i = 0; i < queryData.length; i++) {\n        \t\tvar checkSet = queryData[i].query;\n        \t\tif( this.queryLogic.isSubset(query, checkSet) ) {\n\t\t\t\t\tsuperSetQueryData = queryData[i];\n        \t\t}\n        \t}\n\t\t\tvar records = this.getAllRecords();\n\n\t\t\tif(isPaginated && this.queryLogic.isPaginated(superSetQueryData.query) ) {\n\t\t\t\tvar result = this.getPaginatedListDataSync(superSetQueryData);\n\t\t\t\treturn this.queryLogic.filterMembersAndGetCount(query, superSetQueryData.query, result.data);\n\t\t\t}\n\n            var matching = this.queryLogic.filterMembersAndGetCount(query, {}, records);\n            if(matching && matching.count) {\n                return matching;\n            }\n            // now check if we have a query  for it\n        \tif(superSetQueryData) {\n\t\t\t\treturn {count: 0, data: []};\n\t\t\t}\n        },\n\n        updateListData: function(data, query){\n\t\t\tvar queryData = this.getQueryDataSync();\n        \tquery = query || {};\n            var clonedData = canReflect.serialize(data);\n        \tvar records = getItems(clonedData);\n\t\t\t// Update or create all records\n\t\t\tthis.updateRecordsSync(records);\n\t\t\tvar isPaginated = this.queryLogic.isPaginated(query);\n\t\t\tvar identity = records.length ? canReflect.getIdentity(records[0],  this.queryLogic.schema) : undefined;\n\t\t\tif(isPaginated) {\n\t\t\t\t// we are going to merge with some paginated set\n\t\t\t\tfor(var i = 0; i < queryData.length; i++) {\n\t        \t\tvar checkSet = queryData[i].query;\n\t\t\t\t\tvar union = this.queryLogic.union(checkSet, query);\n\t\t\t\t\tif( this.queryLogic.isDefinedAndHasMembers(union)  ) {\n\t\t\t\t\t\tvar siblingRecords = this.getPaginatedListDataSync(queryData[i]);\n\t\t\t\t\t\tvar res = this.queryLogic.unionMembers(checkSet, query, siblingRecords.data, records );\n\t\t\t\t\t\tidentity = canReflect.getIdentity(res[0],  this.queryLogic.schema);\n\t\t\t\t\t\tqueryData[i] = {\n\t\t\t\t\t\t\tquery: union,\n\t\t\t\t\t\t\tstartIdentity: identity\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis.updateQueryDataSync(queryData);\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\t        \t}\n\n\t\t\t\tqueryData.push({\n\t\t\t\t\tquery: query,\n\t\t\t\t\tstartIdentity: identity\n\t\t\t\t});\n\t\t\t\tthis.updateQueryDataSync(queryData);\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n            // we need to remove everything that would have matched this query before, but that's not in data\n            // but what if it's in another set -> we remove it\n            var allRecords = this.getAllRecords();\n            var curretMatching = this.queryLogic.filterMembers(query, allRecords);\n            if(curretMatching.length) {\n                var toBeDeleted = new Map();\n                curretMatching.forEach(function(record){\n                    toBeDeleted.set( canReflect.getIdentity(record, this.queryLogic.schema), record );\n                }, this);\n\n                // remove what's in records\n                records.forEach(function(record){\n                    toBeDeleted.delete( canReflect.getIdentity(record, this.queryLogic.schema) );\n                }, this);\n\n                this.destroyRecords( canReflect.toArray(toBeDeleted) );\n            }\n\n            // the queries that are not consumed by query\n            var allQueries = this.getQueryDataSync();\n            var notSubsets = allQueries.filter(function(existingQueryData){\n                    return !this.queryLogic.isSubset(existingQueryData.query, query);\n                }, this),\n                superSets = notSubsets.filter(function(existingQueryData){\n                    return this.queryLogic.isSubset(query, existingQueryData.query);\n                }, this);\n\n\t\t\t// would need to note the first record ... so we can do a query w/o pagination\n\t\t\t//\n\n            // if there are sets that are parents of query\n            if(superSets.length) {\n                this.updateQueryDataSync(notSubsets);\n            } else {\n                this.updateQueryDataSync(notSubsets.concat([{\n\t\t\t\t\tquery: query,\n\t\t\t\t\tstartIdentity:identity\n\t\t\t\t}]));\n            }\n\n        \t// setData.push({query: query, items: data});\n        \treturn Promise.resolve();\n        },\n\n        getData: function(params){\n        \tvar id = canReflect.getIdentity(params, canReflect.getSchema( this.queryLogic ) );\n        \tvar res = this.getRecord(id);\n        \tif(res){\n        \t\treturn Promise.resolve( res );\n        \t} else {\n        \t\treturn Promise.reject({\n        \t\t\ttitle: \"no data\",\n        \t\t\tstatus: \"404\",\n        \t\t\tdetail: \"No record with matching identity (\"+id+\").\"\n        \t\t});\n        \t}\n        },\n        createData: function(record){\n\t\t\tthis.updateRecordsSync([record]);\n\n\t\t\treturn Promise.resolve(canReflect.assignMap({}, this.getRecordFromParams(record) ));\n\t\t},\n\n\t\tupdateData: function(record){\n\n\t\t\tif(this.errorOnMissingRecord && !this.getRecordFromParams(record)) {\n\t\t\t\tvar id = canReflect.getIdentity(record, this.queryLogic.schema);\n\t\t\t\treturn Promise.reject({\n\t\t\t\t\ttitle: \"no data\",\n\t\t\t\t\tstatus: \"404\",\n\t\t\t\t\tdetail: \"No record with matching identity (\"+id+\").\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.updateRecordsSync([record]);\n\n\t\t\treturn Promise.resolve(canReflect.assignMap({},this.getRecordFromParams(record) ));\n\t\t},\n\n\t\tdestroyData: function(record){\n\t\t\tvar id = canReflect.getIdentity(record,  this.queryLogic.schema),\n\t\t\t\tsavedRecord = this.getRecordFromParams(record);\n\n\t\t\tif(this.errorOnMissingRecord && !savedRecord) {\n\n\t\t\t\treturn Promise.reject({\n\t\t\t\t\ttitle: \"no data\",\n\t\t\t\t\tstatus: \"404\",\n\t\t\t\t\tdetail: \"No record with matching identity (\"+id+\").\"\n\t\t\t\t});\n\t\t\t}\n            this.destroyRecords([record]);\n\t\t\treturn Promise.resolve(canReflect.assignMap({},savedRecord || record));\n\t\t}\n    });\n}\n\nmodule.exports = makeSimpleStore;\n\n\n//# sourceURL=webpack:///./node_modules/can-memory-store/make-simple-store.js?");

/***/ }),

/***/ "./node_modules/can-namespace/can-namespace.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-namespace/can-namespace.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {};\n\n\n//# sourceURL=webpack:///./node_modules/can-namespace/can-namespace.js?");

/***/ }),

/***/ "./node_modules/can-ndjson-stream/can-ndjson-stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-ndjson-stream/can-ndjson-stream.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*exported ndjsonStream*/\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar ndjsonStream = function(response) {\n  // For cancellation\n  var is_reader, cancellationRequest = false;\n  return new ReadableStream({\n    start: function(controller) {\n      var reader = response.getReader();\n      is_reader = reader;\n      var decoder = new TextDecoder();\n      var data_buf = \"\";\n\n      reader.read().then(function processResult(result) {\n        if (result.done) {\n          if (cancellationRequest) {\n            // Immediately exit\n            return;\n          }\n\n          data_buf = data_buf.trim();\n          if (data_buf.length !== 0) {\n            try {\n              var data_l = JSON.parse(data_buf);\n              controller.enqueue(data_l);\n            } catch(e) {\n              controller.error(e);\n              return;\n            }\n          }\n          controller.close();\n          return;\n        }\n\n        var data = decoder.decode(result.value, {stream: true});\n        data_buf += data;\n        var lines = data_buf.split(\"\\n\");\n        for(var i = 0; i < lines.length - 1; ++i) {\n          var l = lines[i].trim();\n          if (l.length > 0) {\n            try {\n              var data_line = JSON.parse(l);\n              controller.enqueue(data_line);\n            } catch(e) {\n              controller.error(e);\n              cancellationRequest = true;\n              reader.cancel();\n              return;\n            }\n          }\n        }\n        data_buf = lines[lines.length-1];\n\n        return reader.read().then(processResult);\n      });\n\n    },\n    cancel: function(reason) {\n      console.log(\"Cancel registered due to \", reason);\n      cancellationRequest = true;\n      is_reader.cancel();\n    }\n  });\n};\n\nmodule.exports = namespace.ndjsonStream = ndjsonStream;\n\n\n//# sourceURL=webpack:///./node_modules/can-ndjson-stream/can-ndjson-stream.js?");

/***/ }),

/***/ "./node_modules/can-observable-array/dist/can-observable-array.js":
/*!************************************************************************!*\
  !*** ./node_modules/can-observable-array/dist/can-observable-array.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar _require = __webpack_require__(/*! can-observable-mixin */ \"./node_modules/can-observable-mixin/dist/mixins.js\"),\n    createConstructorFunction = _require.createConstructorFunction,\n    makeDefineInstanceKey = _require.makeDefineInstanceKey,\n    mixins = _require.mixins,\n    mixinMapProps = _require.mixinMapProps,\n    mixinTypeEvents = _require.mixinTypeEvents;\n\nvar _require2 = __webpack_require__(/*! ./helpers */ \"./node_modules/can-observable-array/dist/helpers.js\"),\n    convertItem = _require2.convertItem,\n    convertItems = _require2.convertItems,\n    dispatchLengthPatch = _require2.dispatchLengthPatch;\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar ProxyArray = __webpack_require__(/*! ./proxy-array */ \"./node_modules/can-observable-array/dist/proxy-array.js\")();\n\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\n\nvar type = __webpack_require__(/*! can-type */ \"./node_modules/can-type/can-type.js\"); // symbols aren't enumerable ... we'd need a version of Object that treats them that way\n\n\nvar localOnPatchesSymbol = \"can.patches\";\nvar onKeyValueSymbol = Symbol.for(\"can.onKeyValue\");\nvar offKeyValueSymbol = Symbol.for(\"can.offKeyValue\");\nvar metaSymbol = Symbol.for(\"can.meta\");\n\nfunction isListLike(items) {\n  return canReflect.isListLike(items) && typeof items !== \"string\";\n}\n\nvar MixedInArray = mixinTypeEvents(mixinMapProps(ProxyArray));\n\nvar ObservableArray = /*#__PURE__*/function (_MixedInArray) {\n  _inherits(ObservableArray, _MixedInArray);\n\n  // TODO define stuff here\n  function ObservableArray(items, props) {\n    var _this;\n\n    _classCallCheck(this, ObservableArray);\n\n    // Arrays can be passed a length like `new Array(15)`\n    var isLengthArg = typeof items === \"number\";\n\n    if (isLengthArg) {\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(ObservableArray).call(this, items));\n    } else if (arguments.length > 0 && !isListLike(items)) {\n      throw new Error(\"can-observable-array: Unexpected argument: \" + _typeof(items));\n    } else {\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(ObservableArray).call(this));\n    }\n\n    mixins.finalizeClass(this instanceof ObservableArray ? this.constructor : void 0);\n    mixins.initialize(_assertThisInitialized(_this), props || {});\n\n    for (var i = 0, len = items && items.length; i < len; i++) {\n      _this[i] = convertItem(this instanceof ObservableArray ? this.constructor : void 0, items[i]);\n    }\n\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(ObservableArray, [{\n    key: \"push\",\n    value: function push() {\n      var _get2;\n\n      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n        items[_key] = arguments[_key];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(ObservableArray.prototype), \"push\", this)).call.apply(_get2, [this].concat(items));\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift() {\n      var _get3;\n\n      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n\n      return (_get3 = _get(_getPrototypeOf(ObservableArray.prototype), \"unshift\", this)).call.apply(_get3, [this].concat(items));\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(callback) {\n      if (_typeof(callback) === \"object\") {\n        var props = callback;\n\n        callback = function callback(item) {\n          for (var prop in props) {\n            if (item[prop] !== props[prop]) {\n              return false;\n            }\n          }\n\n          return true;\n        };\n      }\n\n      return _get(_getPrototypeOf(ObservableArray.prototype), \"filter\", this).call(this, callback);\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return Array.prototype.forEach.apply(this, args);\n    }\n  }, {\n    key: \"splice\",\n    value: function splice() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var index = args[0],\n          howMany = args[1],\n          added = [],\n          i,\n          len,\n          listIndex,\n          allSame = args.length > 2;\n      index = index || 0; // converting the arguments to the right type\n\n      for (i = 0, len = args.length - 2; i < len; i++) {\n        listIndex = i + 2;\n        added.push(args[listIndex]); // Now lets check if anything will change\n\n        if (this[i + index] !== args[listIndex]) {\n          allSame = false;\n        }\n      } // if nothing has changed, then return\n\n\n      if (allSame && this.length <= added.length) {\n        return added;\n      } // default howMany if not provided\n\n\n      if (howMany === undefined) {\n        howMany = args[1] = this.length - index;\n      }\n\n      queues.batch.start();\n\n      var removed = _get(_getPrototypeOf(ObservableArray.prototype), \"splice\", this).apply(this, args);\n\n      queues.batch.stop();\n      return removed;\n    }\n  }, {\n    key: Symbol.for(\"can.splice\"),\n\n    /* Symbols */\n    value: function value(index, deleteCount, insert) {\n      return this.splice.apply(this, _toConsumableArray([index, deleteCount].concat(insert)));\n    }\n  }, {\n    key: Symbol.for(\"can.onPatches\"),\n    value: function value(handler, queue) {\n      this[onKeyValueSymbol](localOnPatchesSymbol, handler, queue);\n    }\n  }, {\n    key: Symbol.for(\"can.offPatches\"),\n    value: function value(handler, queue) {\n      this[offKeyValueSymbol](localOnPatchesSymbol, handler, queue);\n    }\n  }, {\n    key: Symbol.for(\"can.getOwnEnumerableKeys\"),\n    value: function value() {\n      var base = _get(_getPrototypeOf(ObservableArray.prototype), Symbol.for(\"can.getOwnEnumerableKeys\"), this).call(this);\n\n      var keysSet = new Set([].concat(_toConsumableArray(Object.keys(this)), _toConsumableArray(base)));\n      return Array.from(keysSet);\n    }\n  }, {\n    key: Symbol.for(\"can.isListLike\"),\n    get: function get() {\n      return true;\n    }\n  }], [{\n    key: Symbol.for(\"can.new\"),\n    value: function value(items) {\n      var array = items || [];\n      return new this(array);\n    }\n  }, {\n    key: \"convertsTo\",\n    value: function convertsTo(Type) {\n      var ConvertedType = type.convert(Type);\n\n      var ArrayType = /*#__PURE__*/function (_this2) {\n        _inherits(ArrayType, _this2);\n\n        function ArrayType() {\n          _classCallCheck(this, ArrayType);\n\n          return _possibleConstructorReturn(this, _getPrototypeOf(ArrayType).apply(this, arguments));\n        }\n\n        _createClass(ArrayType, null, [{\n          key: \"items\",\n          get: function get() {\n            return ConvertedType;\n          }\n        }]);\n\n        return ArrayType;\n      }(this);\n\n      var name = \"ConvertedObservableArray<\".concat(canReflect.getName(Type), \">\");\n      canReflect.setName(ArrayType, name);\n      return ArrayType;\n    }\n  }, {\n    key: Symbol.species,\n    get: function get() {\n      return this;\n    }\n  }]);\n\n  return ObservableArray;\n}(MixedInArray);\n\nvar mutateMethods = {\n  \"push\": function push(arr, args) {\n    return [{\n      index: arr.length - args.length,\n      deleteCount: 0,\n      insert: args,\n      type: \"splice\"\n    }];\n  },\n  \"pop\": function pop(arr, args, oldLength) {\n    return [{\n      index: arr.length,\n      deleteCount: oldLength > 0 ? 1 : 0,\n      type: \"splice\"\n    }];\n  },\n  \"shift\": function shift(arr, args, oldLength) {\n    return [{\n      index: 0,\n      deleteCount: oldLength > 0 ? 1 : 0,\n      type: \"splice\"\n    }];\n  },\n  \"unshift\": function unshift(arr, args) {\n    return [{\n      index: 0,\n      deleteCount: 0,\n      insert: args,\n      type: \"splice\"\n    }];\n  },\n  \"splice\": function splice(arr, args, oldLength) {\n    var index = args[0] < 0 ? Math.max(oldLength + args[0], 0) : Math.min(oldLength, args[0]);\n    return [{\n      index: index,\n      deleteCount: Math.max(0, Math.min(args[1], oldLength - index)),\n      insert: args.slice(2),\n      type: \"splice\"\n    }];\n  },\n  \"sort\": function sort(arr) {\n    return [{\n      index: 0,\n      deleteCount: arr.length,\n      insert: arr,\n      type: \"splice\"\n    }];\n  },\n  \"reverse\": function reverse(arr) {\n    return [{\n      index: 0,\n      deleteCount: arr.length,\n      insert: arr,\n      type: \"splice\"\n    }];\n  }\n};\nvar convertArgs = {\n  \"push\": function push(arr, args) {\n    return convertItems(arr.constructor, args);\n  },\n  \"unshift\": function unshift(arr, args) {\n    return convertItems(arr.constructor, args);\n  },\n  \"splice\": function splice(arr, args) {\n    return args.slice(0, 2).concat(convertItems(arr.constructor, args.slice(2)));\n  }\n};\ncanReflect.eachKey(mutateMethods, function (makePatches, prop) {\n  var protoFn = ObservableArray.prototype[prop];\n\n  ObservableArray.prototype[prop] = function () {\n    var oldLength = this.length;\n    var args = Array.from(arguments);\n\n    if (convertArgs[prop]) {\n      args = convertArgs[prop](this, args);\n    } // prevent `length` event from being dispatched by get/set proxy hooks\n\n\n    this[metaSymbol].preventSideEffects++;\n    var result = protoFn.apply(this, args);\n    this[metaSymbol].preventSideEffects--;\n    var patches = makePatches(this, args, oldLength);\n    dispatchLengthPatch.call(this, prop, patches, this.length, oldLength);\n    return result;\n  };\n});\nmakeDefineInstanceKey(ObservableArray); // Export a constructor function to workaround an issue where ES2015 classes\n// cannot be extended in code that's transpiled by Babel.\n\nmodule.exports = namespace.ObservableArray = createConstructorFunction(ObservableArray);\n\n//# sourceURL=webpack:///./node_modules/can-observable-array/dist/can-observable-array.js?");

/***/ }),

/***/ "./node_modules/can-observable-array/dist/computed-helpers.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-observable-array/dist/computed-helpers.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar mapBindings = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\n\nvar canMeta = Symbol.for(\"can.meta\");\nvar computedPropertyDefinitionSymbol = Symbol.for(\"can.computedPropertyDefinitions\");\nvar onKeyValueSymbol = Symbol.for(\"can.onKeyValue\");\nvar offKeyValueSymbol = Symbol.for(\"can.offKeyValue\"); // ## ComputedObjectObservationData\n// Instances of this are created to wrap the observation.\n// The `.bind` and `.unbind` methods should be called when the\n// instance's prop is bound or unbound.\n\nfunction ComputedObjectObservationData(instance, prop, observation) {\n  this.instance = instance;\n  this.prop = prop;\n  this.observation = observation;\n  this.forward = this.forward.bind(this);\n}\n\nComputedObjectObservationData.prototype.bind = function () {\n  this.bindingCount++;\n\n  if (this.bindingCount === 1) {\n    this.observation.on(this.forward, \"notify\");\n  }\n};\n\nComputedObjectObservationData.prototype.unbind = function () {\n  this.bindingCount--;\n\n  if (this.bindingCount === 0) {\n    this.observation.off(this.forward, \"notify\");\n  }\n};\n\nComputedObjectObservationData.prototype.forward = function (newValue, oldValue) {\n  mapBindings.dispatch.call(this.instance, {\n    type: this.prop,\n    key: this.prop,\n    target: this.instance,\n    value: newValue,\n    oldValue: oldValue // patches: [{\n    // \tkey: this.prop,\n    // \ttype: \"set\",\n    // \tvalue: newValue\n    // }]\n    // keyChanged: undefined\n\n  }, [newValue, oldValue]);\n};\n\nComputedObjectObservationData.prototype.bindingCount = 0;\n\nfunction findComputed(instance, key) {\n  var meta = instance[canMeta];\n  var target = meta.target;\n  var computedPropertyDefinitions = target[computedPropertyDefinitionSymbol];\n\n  if (computedPropertyDefinitions === undefined) {\n    return;\n  }\n\n  var computedPropertyDefinition = computedPropertyDefinitions[key];\n\n  if (computedPropertyDefinition === undefined) {\n    return;\n  }\n\n  if (meta.computedKeys[key] === undefined) {\n    meta.computedKeys[key] = new ComputedObjectObservationData(instance, key, computedPropertyDefinition(instance, key));\n  }\n\n  return meta.computedKeys[key];\n}\n\nvar computedHelpers = {\n  bind: function bind(instance, key) {\n    var computedObj = findComputed(instance, key);\n\n    if (computedObj === undefined) {\n      return;\n    }\n\n    computedObj.bind();\n  },\n  addKeyDependencies: function addKeyDependencies(proxyKeys) {\n    var onKeyValue = proxyKeys[onKeyValueSymbol];\n    var offKeyValue = proxyKeys[offKeyValueSymbol];\n    canReflect.assignSymbols(proxyKeys, {\n      \"can.onKeyValue\": function canOnKeyValue(key) {\n        computedHelpers.bind(this, key);\n        return onKeyValue.apply(this, arguments);\n      },\n      \"can.offKeyValue\": function canOffKeyValue(key) {\n        computedHelpers.unbind(this, key);\n        return offKeyValue.apply(this, arguments);\n      },\n      \"can.getKeyDependencies\": function canGetKeyDependencies(key) {\n        var computedObj = findComputed(this, key);\n\n        if (computedObj === undefined) {\n          return;\n        }\n\n        return {\n          valueDependencies: new Set([computedObj.observation])\n        };\n      }\n    });\n  }\n};\nmodule.exports = computedHelpers;\n\n//# sourceURL=webpack:///./node_modules/can-observable-array/dist/computed-helpers.js?");

/***/ }),

/***/ "./node_modules/can-observable-array/dist/helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-observable-array/dist/helpers.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar _require = __webpack_require__(/*! can-observable-mixin */ \"./node_modules/can-observable-mixin/dist/mixins.js\"),\n    mixins = _require.mixins;\n\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar mapBindings = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\n\nvar metaSymbol = Symbol.for(\"can.meta\");\nvar helpers = {\n  assignNonEnumerable: function assignNonEnumerable(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      enumerable: false,\n      writable: true,\n      configurable: true,\n      value: value\n    });\n  },\n  shouldRecordObservationOnAllKeysExceptFunctionsOnProto: function shouldRecordObservationOnAllKeysExceptFunctionsOnProto(keyInfo, meta) {\n    return meta.preventSideEffects === 0 && !keyInfo.isAccessor && ( // it's on us\n    // it's on our proto, but not a function\n    keyInfo.targetHasOwnKey || // it's \"missing\", and we are not sealed\n    !keyInfo.protoHasKey && !Object.isSealed(meta.target) || keyInfo.protoHasKey && typeof targetValue !== \"function\");\n  },\n\n  /*\n   * dispatch an event when an index changes\n   */\n  dispatchIndexEvent: function dispatchIndexEvent(attr, how, newVal, oldVal) {\n    var index = +attr; // Make sure this is not nested and not an expando\n\n    if (!isNaN(index)) {\n      var itemsDefinition = this._define.definitions[\"#\"];\n\n      if (how === 'set') {\n        this.dispatch({\n          type: index,\n          action: how,\n          key: index,\n          value: newVal,\n          oldValue: oldVal\n        }, [newVal, oldVal]); // if event is being set through an ObservableArray.prototype method,\n        // do not dispatch length or patch events.\n        // This will be handled by ObservableArray.prototype method.\n\n        var meta = this[metaSymbol];\n\n        if (!(\"preventSideEffects\" in meta) || meta.preventSideEffects === 0) {\n          var patches = [{\n            index: index,\n            deleteCount: 1,\n            insert: [newVal],\n            type: \"splice\"\n          }];\n          helpers.dispatchLengthPatch.call(this, how, patches, this.length, this.length);\n        }\n      } else if (how === 'add') {\n        if (itemsDefinition && typeof itemsDefinition.added === 'function') {\n          ObservationRecorder.ignore(itemsDefinition.added).call(this, newVal, index);\n        }\n\n        this.dispatch({\n          type: index,\n          action: how,\n          key: index,\n          value: newVal,\n          oldValue: oldVal\n        }, [newVal, oldVal]); // if event is being set through an ObservableArray.prototype method,\n        // do not dispatch length or patch events.\n        // This will be handled by ObservableArray.prototype method.\n\n        var _meta = this[metaSymbol];\n\n        if (!(\"preventSideEffects\" in _meta) || _meta.preventSideEffects === 0) {\n          var _patches = [{\n            index: index,\n            deleteCount: 0,\n            insert: [newVal],\n            type: \"splice\"\n          }];\n          helpers.dispatchLengthPatch.call(this, how, _patches, this.length, this.length - 1);\n        }\n      } else if (how === 'remove') {\n        if (itemsDefinition && typeof itemsDefinition.removed === 'function') {\n          ObservationRecorder.ignore(itemsDefinition.removed).call(this, oldVal, index);\n        }\n      }\n    } else {\n      var key = \"\" + attr;\n      this.dispatch({\n        type: key,\n        key: key,\n        action: how,\n        value: newVal,\n        oldValue: oldVal,\n        target: this\n      }, [newVal, oldVal]);\n    }\n  },\n\n  /*\n   * Dispatch a `type: \"splice\"` patch and a `length` event\n   */\n  dispatchLengthPatch: function dispatchLengthPatch(how, patches, newLength, oldLength) {\n    var dispatchArgs = {\n      type: \"length\",\n      key: \"length\",\n      action: how,\n      value: newLength,\n      oldValue: oldLength,\n      patches: patches\n    }; //!steal-remove-start\n\n    if (true) {\n      dispatchArgs.reasonLog = [canReflect.getName(this) + \".\" + how + \" called with\", arguments];\n    } //!steal-remove-end\n\n\n    mapBindings.dispatch.call(this, dispatchArgs, [newLength, oldLength]);\n  },\n  convertItem: function convertItem(Constructor, item) {\n    if (Constructor.items) {\n      var definition = mixins.normalizeTypeDefinition(Constructor.items.type || Constructor.items);\n      return canReflect.convert(item, definition);\n    }\n\n    return item;\n  },\n  convertItems: function convertItems(Constructor, items) {\n    if (items.length) {\n      if (Constructor.items) {\n        for (var i = 0, len = items.length; i < len; i++) {\n          items[i] = helpers.convertItem(Constructor, items[i]);\n        }\n      }\n    }\n\n    return items;\n  }\n};\nmodule.exports = helpers;\n\n//# sourceURL=webpack:///./node_modules/can-observable-array/dist/helpers.js?");

/***/ }),

/***/ "./node_modules/can-observable-array/dist/proxy-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-observable-array/dist/proxy-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar computedHelpers = __webpack_require__(/*! ./computed-helpers */ \"./node_modules/can-observable-array/dist/computed-helpers.js\");\n\nvar mapBindings = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\n\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar _require = __webpack_require__(/*! ./helpers */ \"./node_modules/can-observable-array/dist/helpers.js\"),\n    assignNonEnumerable = _require.assignNonEnumerable,\n    convertItem = _require.convertItem,\n    dispatchIndexEvent = _require.dispatchIndexEvent,\n    shouldRecordObservationOnAllKeysExceptFunctionsOnProto = _require.shouldRecordObservationOnAllKeysExceptFunctionsOnProto;\n\nvar _require2 = __webpack_require__(/*! can-observable-mixin */ \"./node_modules/can-observable-mixin/dist/mixins.js\"),\n    mixins = _require2.mixins;\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar isSymbolLike = canReflect.isSymbolLike;\nvar metaSymbol = Symbol.for(\"can.meta\");\nvar proxiedObjects = new WeakMap();\nvar proxies = new WeakSet();\nvar proxyKeys = Object.create(null);\nObject.getOwnPropertySymbols(mapBindings).forEach(function (symbol) {\n  assignNonEnumerable(proxyKeys, symbol, mapBindings[symbol]);\n});\ncomputedHelpers.addKeyDependencies(proxyKeys);\nvar mutateMethods = {\n  \"push\": function push(arr, args) {\n    return [{\n      index: arr.length - args.length,\n      deleteCount: 0,\n      insert: args,\n      type: \"splice\"\n    }];\n  },\n  \"pop\": function pop(arr) {\n    return [{\n      index: arr.length,\n      deleteCount: 1,\n      insert: [],\n      type: \"splice\"\n    }];\n  },\n  \"shift\": function shift() {\n    return [{\n      index: 0,\n      deleteCount: 1,\n      insert: [],\n      type: \"splice\"\n    }];\n  },\n  \"unshift\": function unshift(arr, args) {\n    return [{\n      index: 0,\n      deleteCount: 0,\n      insert: args,\n      type: \"splice\"\n    }];\n  },\n  \"splice\": function splice(arr, args) {\n    return [{\n      index: args[0],\n      deleteCount: args[1],\n      insert: args.slice(2),\n      type: \"splice\"\n    }];\n  },\n  \"sort\": function sort(arr) {\n    // The array replaced everything.\n    return [{\n      index: 0,\n      deleteCount: arr.length,\n      insert: arr,\n      type: \"splice\"\n    }];\n  },\n  \"reverse\": function reverse(arr) {\n    // The array replaced everything.\n    return [{\n      index: 0,\n      deleteCount: arr.length,\n      insert: arr,\n      type: \"splice\"\n    }];\n  }\n}; // Overwrite Array's methods that mutate to:\n// - prevent other events from being fired off (index events and length events.)\n// - dispatch patches events.\n\ncanReflect.eachKey(mutateMethods, function (makePatches, prop) {\n  var protoFn = Array.prototype[prop];\n\n  var mutateMethod = function mutateMethod() {\n    var meta = this[metaSymbol],\n        // Capture if this function should be making sideEffects\n    makeSideEffects = meta.preventSideEffects === 0,\n        oldLength = meta.target.length; // Prevent proxy from calling ObservationRecorder and sending events.\n\n    meta.preventSideEffects++; // Call the function -- note that *this* is the Proxy here, so\n    // accesses in the function still go through `get()` and `set()`.\n\n    var ret = protoFn.apply(meta.target, arguments);\n    var patches = makePatches(meta.target, Array.from(arguments), oldLength);\n\n    if (makeSideEffects === true) {\n      //!steal-remove-start\n      var reasonLog = [canReflect.getName(meta.proxy) + \".\" + prop + \" called with\", arguments]; //!steal-remove-end\n\n      var dispatchArgs = {\n        type: \"length\",\n        key: \"length\",\n        value: meta.target.length,\n        oldValue: oldLength,\n        patches: patches\n      }; //!steal-remove-start\n\n      if (true) {\n        dispatchArgs.reasonLog = reasonLog;\n      } //!steal-remove-end\n\n\n      mapBindings.dispatch.call(meta.proxy, dispatchArgs, [meta.target.length, oldLength]);\n    }\n\n    meta.preventSideEffects--;\n    return ret;\n  }; //!steal-remove-start\n\n\n  if (true) {\n    Object.defineProperty(mutateMethod, \"name\", {\n      value: prop\n    });\n  } //!steal-remove-end\n  // Store the proxied method so it will be used instead of the\n  // prototype method.\n\n\n  proxiedObjects.set(protoFn, mutateMethod);\n  proxies.add(mutateMethod);\n});\n\nfunction setValueAndOnChange(key, value, target, proxy, onChange) {\n  var old, change;\n  var hadOwn = hasOwn.call(target, key);\n  var descriptor = Object.getOwnPropertyDescriptor(target, key); // call the setter on the Proxy to properly do any side-effect sets (and run corresponding handlers)\n  // -- setters do not return values, so it is unnecessary to check for changes.\n\n  if (descriptor && descriptor.set) {\n    descriptor.set.call(proxy, value);\n  } else {\n    // otherwise check for a changed value\n    old = target[key];\n    change = old !== value;\n\n    if (change) {\n      var keyType = _typeof(key);\n\n      var keyIsString = keyType === \"string\"; // String keys added to the instance (and is not \"length\")\n      // Are newly defined properties and have propertyDefaults provided.\n\n      if (keyIsString && !(key in target)) {\n        mixins.expando(target, key, value);\n      } else {\n        // arr[0] = { foo: 'bar' } should convert to MyArray.items\n        if (keyType === \"number\") {\n          value = convertItem(target.constructor, value);\n        }\n\n        target[key] = value;\n        onChange(hadOwn, old);\n      }\n    }\n  }\n}\n\nvar proxyHandlers = {\n  get: function get(target, key, receiver) {\n    if (isSymbolLike(key)) {\n      return target[key];\n    }\n\n    var proxy = proxiedObjects.get(target);\n    ObservationRecorder.add(proxy, key.toString());\n    var numberKey = !isSymbolLike(key) && +key;\n\n    if (Number.isInteger(numberKey)) {\n      ObservationRecorder.add(proxy, \"length\");\n    }\n\n    var value = Reflect.get(target, key, receiver);\n    return value;\n  },\n  set: function set(target, key, newValue, receiver) {\n    var proxy = proxiedObjects.get(target);\n    var numberKey = !isSymbolLike(key) && +key;\n\n    if (Number.isInteger(numberKey)) {\n      key = numberKey;\n    }\n\n    setValueAndOnChange(key, newValue, target, proxy, function onChange(hadOwn, oldValue) {\n      if (Number.isInteger(key)) {\n        dispatchIndexEvent.call(receiver, key, hadOwn ? newValue ? \"set\" : \"remove\" : \"add\", newValue, oldValue);\n      }\n    });\n    return true;\n  },\n  deleteProperty: function deleteProperty(target, key) {\n    var old = this.target[key];\n    var deleteSuccessful = delete this.target[key]; // Fire event handlers if we were able to delete and the value changed.\n\n    if (deleteSuccessful && this.preventSideEffects === 0 && old !== undefined) {\n      dispatchIndexEvent.call(this.proxy, key, \"remove\", undefined, old);\n    }\n\n    return deleteSuccessful;\n  },\n  ownKeys: function ownKeys() {\n    ObservationRecorder.add(this.proxy, \"can.keys\");\n    var keysSet = new Set(Object.getOwnPropertyNames(this.target).concat(Object.getOwnPropertySymbols(this.target)).concat(Object.getOwnPropertySymbols(this.proxyKeys)));\n    return Array.from(keysSet);\n  }\n};\n\nfunction makeObservable(array, options) {\n  var meta = {\n    target: array,\n    proxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(proxyKeys),\n    computedKeys: Object.create(null),\n    options: options,\n    // `preventSideEffects` is a counter used to \"turn off\" the proxy.  This is incremented when some\n    // function (like `Array.splice`) wants to handle event dispatching and/or calling\n    // `ObservationRecorder` itself for performance reasons.\n    preventSideEffects: 0\n  };\n  meta.proxyKeys[metaSymbol] = meta;\n  meta.proxy = new Proxy(array, {\n    get: proxyHandlers.get.bind(meta),\n    set: proxyHandlers.set.bind(meta),\n    ownKeys: proxyHandlers.ownKeys.bind(meta),\n    deleteProperty: proxyHandlers.deleteProperty.bind(meta),\n    meta: meta\n  });\n  mapBindings.addHandlers(meta.proxy, meta);\n  return meta.proxy;\n}\n\nfunction proxyArray() {\n  return (/*#__PURE__*/function (_Array) {\n      _inherits(ProxyArray, _Array);\n\n      function ProxyArray() {\n        var _getPrototypeOf2;\n\n        var _this;\n\n        _classCallCheck(this, ProxyArray);\n\n        for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n          items[_key] = arguments[_key];\n        }\n\n        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ProxyArray)).call.apply(_getPrototypeOf2, [this].concat(items)));\n        var localProxyKeys = Object.create(proxyKeys);\n        localProxyKeys.constructor = _this.constructor;\n        var observable = makeObservable(_assertThisInitialized(_this), {\n          //observe: makeObserve.observe,\n          proxyKeys: localProxyKeys,\n          shouldRecordObservation: shouldRecordObservationOnAllKeysExceptFunctionsOnProto\n        });\n        proxiedObjects.set(_assertThisInitialized(_this), observable);\n        proxies.add(observable);\n        return _possibleConstructorReturn(_this, observable);\n      }\n\n      return ProxyArray;\n    }( /*#__PURE__*/_wrapNativeSuper(Array))\n  );\n}\n\nmodule.exports = proxyArray;\n\n//# sourceURL=webpack:///./node_modules/can-observable-array/dist/proxy-array.js?");

/***/ }),

/***/ "./node_modules/can-observable-bindings/can-observable-bindings.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-observable-bindings/can-observable-bindings.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nconst fromAttribute = __webpack_require__(/*! ./from-attribute */ \"./node_modules/can-observable-bindings/from-attribute.js\");\n\nnamespace.fromAttribute = fromAttribute;\n\nmodule.exports = {\n\tfromAttribute: fromAttribute\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-observable-bindings/can-observable-bindings.js?");

/***/ }),

/***/ "./node_modules/can-observable-bindings/from-attribute.js":
/*!****************************************************************!*\
  !*** ./node_modules/can-observable-bindings/from-attribute.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const value = __webpack_require__(/*! can-value */ \"./node_modules/can-value/can-value.js\");\nconst Bind = __webpack_require__(/*! can-bind */ \"./node_modules/can-bind/can-bind.js\");\nconst canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nconst canString = __webpack_require__(/*! can-string */ \"./node_modules/can-string/can-string.js\");\nconst type = __webpack_require__(/*! can-type */ \"./node_modules/can-type/can-type.js\");\n\n//!steal-remove-start\nif(true) {\n\tvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\n}\n//!steal-remove-end\n\nconst metaSymbol = Symbol.for(\"can.meta\");\n\nfunction isJSONLike (obj) {\n\treturn (canReflect.isFunctionLike(obj.parse) &&\n\t\t\tcanReflect.isFunctionLike(obj.stringify));\n}\n\nfunction initializeFromAttribute (propertyName, ctr, converter, attributeName) {\n\tif (ctr[metaSymbol] === undefined) {\n\t\tctr[metaSymbol] = {};\n\t}\n\t// Create array for all attributes we want to listen to change events for\n\tif (ctr[metaSymbol]._observedAttributes === undefined) {\n\t\tctr[metaSymbol]._observedAttributes = [];\n\t}\n\t// Create object for attributeChangedCallback for each prop\n\tif (ctr[metaSymbol]._attributeChangedCallbackHandler === undefined) {\n\t\tctr[metaSymbol]._attributeChangedCallbackHandler = {};\n\t}\n\n\tif (attributeName === undefined) {\n\t\tattributeName = propertyName;\n\t}\n\t// Ensure the attributeName is hyphen case\n\tattributeName = canString.hyphenate(attributeName);\n\n\t// Modify the class prototype here\n\tif (!ctr[metaSymbol]._hasInitializedAttributeBindings) {\n\t\t// Set up the static getter for `observedAttributes`\n\t\tObject.defineProperty(ctr, \"observedAttributes\", {\n\t\t\tget() {\n\t\t\t\treturn ctr[metaSymbol]._observedAttributes;\n\t\t\t}\n\t\t});\n\n\t\tctr.prototype.attributeChangedCallback = function (prop) {\n\t\t\tctr[metaSymbol]._attributeChangedCallbackHandler[prop].apply(this, arguments);\n\t\t};\n\n\t\tctr[metaSymbol]._hasInitializedAttributeBindings = true;\n\t}\n\t// Push into `_observedAttributes` for `observedAttributes` getter\n\tctr[metaSymbol]._observedAttributes.push(attributeName);\n\n\t// Create the attributeChangedCallback handler\n\tctr[metaSymbol]._attributeChangedCallbackHandler[attributeName] = function (prop, oldVal, newVal) {\n\t\tif (this[metaSymbol] && this[metaSymbol]._attributeBindings && newVal !== oldVal) {\n\t\t\tcanReflect.setValue(this[metaSymbol]._attributeBindings[prop], newVal);\n\t\t}\n\t};\n\n\tvar lazyGetType = function() {\n\t\tvar Type;\n\t\tvar schema = canReflect.getSchema(ctr);\n\t\tif(schema) {\n\t\t\tType = schema.keys[propertyName];\n\t\t}\n\t\tif(!Type) {\n\t\t\tType = type.Any;\n\t\t}\n\t\tType = type.convert(Type);\n\t\tlazyGetType = function() { return Type; };\n\t\treturn Type;\n\t};\n\tfunction convertToValue(value) {\n\t\tif (converter) {\n\t\t\tvalue = converter.parse(value);\n\t\t}\n\t\treturn canReflect.convert(value, lazyGetType());\n\t}\n\n\treturn function fromAttributeBind (instance) {\n\t\t// Child binding used by `attributeChangedCallback` to update the value when an attribute change occurs\n\t\tconst childValue = value.to(instance, propertyName);\n\t\tconst intermediateValue = {};\n\t\tcanReflect.assignSymbols(intermediateValue, {\n\t\t\t\"can.setValue\": function(value) {\n\t\t\t\tcanReflect.setValue(childValue, convertToValue(value) );\n\t\t\t}\n\t\t});\n\t\tconst parentValue = value.from(instance.hasAttribute(attributeName) ?  convertToValue(instance.getAttribute(attributeName)) : undefined);\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\t// Ensure pretty names for dep graph\n\t\t\tcanReflect.assignSymbols(parentValue, {\n\t\t\t\t\"can.getName\": function getName() {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"FromAttribute<\" +\n\t\t\t\t\t\tinstance.nodeName.toLowerCase() +\n\t\t\t\t\t\t\".\" +\n\t\t\t\t\t\tattributeName +\n\t\t\t\t\t\t\">\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tcanReflect.assignSymbols(childValue, {\n\t\t\t\t\"can.getName\": function getName() {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Observation<\" +\n\t\t\t\t\t\tcanReflect.getName(parentValue) +\n\t\t\t\t\t\t\">\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// Create temporary binding to initialize dep graph\n\t\t\tObservation.temporarilyBind(childValue);\n\t\t}\n\t\t//!steal-remove-end\n\t\tconst bind = new Bind({\n\t\t\tparent: parentValue,\n\t\t\tchild: intermediateValue,\n\t\t\tqueue: \"dom\",\n\t\t\t// During initialization prevent update of child\n\t\t\tonInitDoNotUpdateChild: true\n\t\t});\n\n\t\tif (instance[metaSymbol] === undefined) {\n\t\t\tinstance[metaSymbol] = {};\n\t\t}\n\t\tif (instance[metaSymbol]._attributeBindings === undefined) {\n\t\t\tinstance[metaSymbol]._attributeBindings = {};\n\t\t}\n\n\t\t// Push binding so it can be used within `attributeChangedCallback`\n\t\tinstance[metaSymbol]._attributeBindings[attributeName] = intermediateValue;\n\n\t\treturn bind;\n\t};\n}\n\nmodule.exports = function fromAttribute (attributeName, ctr) {\n\tvar converter;\n\t// Handle the class constructor\n\tif (arguments.length === 2 && canReflect.isConstructorLike(ctr) && !isJSONLike(ctr)) {\n\t\treturn initializeFromAttribute(attributeName, ctr);\n\t} else if (arguments.length === 1 && typeof attributeName === 'object') {\n\t\t// Handle fromAttribute(JSON)\n\t\tconverter = attributeName;\n\t\tattributeName = undefined;\n\t} else if (typeof ctr === 'object' && isJSONLike(ctr)) {\n\t\t// Handle the case where an attribute name\n\t\t// and JSON like converter is passed\n\t\t// fromAttribute('attr', JSON)\n\t\tconverter = ctr;\n\t}\n\t//!steal-remove-start\n\tif(true) {\n\t\tif (converter && !isJSONLike(converter)) {\n\t\t\tthrow new Error('The passed converter object is wrong! The object must have \"parse\" and \"stringify\" methods!');\n\t\t}\n\t}\n\t//!steal-remove-end\n\treturn function (propertyName, ctr) {\n\t\treturn initializeFromAttribute(propertyName, ctr, converter, attributeName);\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-observable-bindings/from-attribute.js?");

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/create-constructor-function.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/create-constructor-function.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Creates a constructor function from an ES2015 class, this is a workaround\n * needed to being able to extend a class from code that's transpiled by Babel.\n * See https://github.com/babel/babel/pull/8656\n * @param {*} Type The ES2015 base class used to create the constructor\n * @param {*} Parent The object where the prototype chain walk to copy over\n * symbols and static properties to the constructor stops. If not provided,\n * the chain stops at Object.\n * @returns {Function} Constructor function than can be safely subclassed from\n * transpiled code.\n */\nfunction createConstructorFunction(Type, Parent) {\n  if (typeof Parent === \"undefined\") {\n    Parent = Object.getPrototypeOf(Object);\n  }\n\n  function TypeConstructor() {\n    return Reflect.construct(Type, arguments, this.constructor);\n  }\n\n  TypeConstructor.prototype = Object.create(Type.prototype);\n  TypeConstructor.prototype.constructor = TypeConstructor;\n  /**\n   * Add `prop` to TypeConstructor from `source` if not defined already\n   * @param {{}} source The object that owns `prop`\n   * @param {string} prop The name of the property to be defined\n   */\n\n  function copyIfMissing(source, prop) {\n    if (!TypeConstructor[prop]) {\n      Object.defineProperty(TypeConstructor, prop, Object.getOwnPropertyDescriptor(source, prop));\n    }\n  } // Walk up the prototype chain to copy over all Symbols and\n  // static properties to the constructor function\n\n\n  var Link = Type;\n\n  while (Link !== Parent && Link !== null) {\n    var props = Object.getOwnPropertyNames(Link);\n    props.forEach(function (prop) {\n      copyIfMissing(Link, prop);\n    });\n    var symbols = Object.getOwnPropertySymbols(Link);\n    symbols.forEach(function (symbol) {\n      copyIfMissing(Link, symbol);\n    });\n    Link = Object.getPrototypeOf(Link);\n  }\n\n  return TypeConstructor;\n}\n\nmodule.exports = createConstructorFunction;\n\n//# sourceURL=webpack:///./node_modules/can-observable-mixin/dist/create-constructor-function.js?");

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/define-helpers.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/define-helpers.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*jshint -W079 */\n\nvar define = __webpack_require__(/*! ./define */ \"./node_modules/can-observable-mixin/dist/define.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\n\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\nvar ensureMeta = __webpack_require__(/*! ./ensure-meta */ \"./node_modules/can-observable-mixin/dist/ensure-meta.js\");\n\nvar defineHelpers = {\n  // returns `true` if the value was defined and set\n  defineExpando: define.expando,\n  reflectSerialize: function reflectSerialize(unwrapped) {\n    var constructorDefinitions = this._define.definitions;\n    var defaultDefinition = this._define.defaultDefinition;\n    this.forEach(function (val, name) {\n      var propDef = constructorDefinitions[name];\n\n      if (propDef && typeof propDef.serialize === \"function\") {\n        val = propDef.serialize.call(this, val, name);\n      } else if (defaultDefinition && typeof defaultDefinition.serialize === \"function\") {\n        val = defaultDefinition.serialize.call(this, val, name);\n      } else {\n        val = canReflect.serialize(val);\n      }\n\n      if (val !== undefined) {\n        unwrapped[name] = val;\n      }\n    }, this);\n    return unwrapped;\n  },\n  reflectUnwrap: function reflectUnwrap(unwrapped) {\n    this.forEach(function (value, key) {\n      if (value !== undefined) {\n        unwrapped[key] = canReflect.unwrap(value);\n      }\n    });\n    return unwrapped;\n  },\n  log: function log(key) {\n    var instance = this;\n\n    var quoteString = function quoteString(x) {\n      return typeof x === \"string\" ? JSON.stringify(x) : x;\n    };\n\n    var meta = ensureMeta(instance);\n    var allowed = meta.allowedLogKeysSet || new Set();\n    meta.allowedLogKeysSet = allowed;\n\n    if (key) {\n      allowed.add(key);\n    }\n\n    meta._log = function (event, data) {\n      var type = event.type;\n\n      if (type === \"can.onPatches\" || key && !allowed.has(type) || type === \"can.keys\" || key && !allowed.has(type)) {\n        return;\n      }\n\n      if (type === \"add\" || type === \"remove\") {\n        dev.log(canReflect.getName(instance), \"\\n how   \", quoteString(type), \"\\n what  \", quoteString(data[0]), \"\\n index \", quoteString(data[1]));\n      } else {\n        // log `length` and `propertyName` events\n        dev.log(canReflect.getName(instance), \"\\n key \", quoteString(type), \"\\n is  \", quoteString(data[0]), \"\\n was \", quoteString(data[1]));\n      }\n    };\n  },\n  deleteKey: function deleteKey(prop) {\n    var instanceDefines = this._instanceDefinitions;\n\n    if (instanceDefines && Object.prototype.hasOwnProperty.call(instanceDefines, prop) && !Object.isSealed(this)) {\n      delete instanceDefines[prop];\n      delete this[prop];\n      queues.batch.start();\n      this.dispatch({\n        action: \"can.keys\",\n        type: \"can.keys\",\n        target: this\n      });\n      var oldValue = this._data[prop];\n\n      if (oldValue !== undefined) {\n        delete this._data[prop]; //delete this[prop];\n\n        this.dispatch({\n          action: \"delete\",\n          key: prop,\n          oldValue: oldValue,\n          type: prop,\n          target: this,\n          patches: [{\n            type: \"delete\",\n            key: prop\n          }]\n        }, [undefined, oldValue]);\n      }\n\n      queues.batch.stop();\n    } else {\n      this.set(prop, undefined);\n    }\n\n    return this;\n  }\n};\nmodule.exports = defineHelpers;\n\n//# sourceURL=webpack:///./node_modules/can-observable-mixin/dist/define-helpers.js?");

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/define.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/define.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar _define;\n\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\n\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar AsyncObservable = __webpack_require__(/*! can-simple-observable/async/async */ \"./node_modules/can-simple-observable/async/async.js\");\n\nvar SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ \"./node_modules/can-simple-observable/settable/settable.js\");\n\nvar ResolverObservable = __webpack_require__(/*! can-simple-observable/resolver/resolver */ \"./node_modules/can-simple-observable/resolver/resolver.js\");\n\nvar eventQueue = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\n\nvar addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ \"./node_modules/can-event-queue/type/type.js\");\n\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\nvar canLogDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"./node_modules/can-define-lazy-value/define-lazy-value.js\");\n\nvar type = __webpack_require__(/*! can-type */ \"./node_modules/can-type/can-type.js\");\n\nvar newSymbol = Symbol.for(\"can.new\"),\n    serializeSymbol = Symbol.for(\"can.serialize\"),\n    inSetupSymbol = Symbol.for(\"can.initializing\"),\n    isMemberSymbol = Symbol.for(\"can.isMember\"),\n    hasBeenDefinedSymbol = Symbol.for(\"can.hasBeenDefined\"),\n    canMetaSymbol = Symbol.for(\"can.meta\"),\n    baseTypeSymbol = Symbol.for(\"can.baseType\");\n\nvar eventsProto, _define, make, makeDefinition, getDefinitionsAndMethods, getDefinitionOrMethod; // UTILITIES\n\n\nfunction isDefineType(func) {\n  return func && (func.canDefineType === true || func[newSymbol]);\n}\n\nfunction observableType() {\n  throw new Error(\"This is not currently implemented.\");\n}\n\nvar AsyncFunction;\n\nvar browserSupportsAsyncFunctions = function () {\n  try {\n    AsyncFunction = function _callee() {\n      return regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      });\n    }.constructor;\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n}();\n\nfunction isAsyncFunction(fn) {\n  if (!browserSupportsAsyncFunctions) {\n    return false;\n  }\n\n  return fn && fn instanceof AsyncFunction;\n}\n\nvar peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));\nvar Object_defineNamedPrototypeProperty = Object.defineProperty; //!steal-remove-start\n\nif (true) {\n  Object_defineNamedPrototypeProperty = function Object_defineNamedPrototypeProperty(obj, prop, definition) {\n    if (definition.get) {\n      Object.defineProperty(definition.get, \"name\", {\n        value: \"get \" + canReflect.getName(obj) + \".\" + prop,\n        writable: true,\n        configurable: true\n      });\n    }\n\n    if (definition.set) {\n      Object.defineProperty(definition.set, \"name\", {\n        value: \"set \" + canReflect.getName(obj) + \".\" + prop,\n        configurable: true\n      });\n    }\n\n    return Object.defineProperty(obj, prop, definition);\n  };\n} //!steal-remove-end\n\n\nfunction defineConfigurableAndNotEnumerable(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: value\n  });\n}\n\nfunction defineNotWritableAndNotEnumerable(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value: value,\n    enumerable: false,\n    writable: false\n  });\n}\n\nfunction eachPropertyDescriptor(map, cb) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Object.getOwnPropertyNames(map)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var prop = _step.value;\n\n      if (map.hasOwnProperty(prop)) {\n        cb.call.apply(cb, [map, prop, Object.getOwnPropertyDescriptor(map, prop)].concat(args));\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nfunction getEveryPropertyAndSymbol(obj) {\n  var props = Object.getOwnPropertyNames(obj);\n  var symbols = \"getOwnPropertySymbols\" in Object ? Object.getOwnPropertySymbols(obj) : [];\n  return props.concat(symbols);\n}\n\nmodule.exports = _define = function define(typePrototype, defines, baseDefine) {\n  var propertyDefaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  // default property definitions on _data\n  var prop,\n      dataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null),\n      // computed property definitions on _computed\n  computedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null),\n      required = new Set();\n  var result = getDefinitionsAndMethods(defines, baseDefine, typePrototype, propertyDefaults);\n  result.dataInitializers = dataInitializers;\n  result.computedInitializers = computedInitializers;\n  result.required = required; // Goes through each property definition and creates\n  // a `getter` and `setter` function for `Object.defineProperty`.\n\n  canReflect.eachKey(result.definitions, function (definition, property) {\n    // Add this as a required property\n    if (definition.required === true) {\n      required.add(property);\n    }\n\n    _define.property(typePrototype, property, definition, dataInitializers, computedInitializers, result.defaultDefinition);\n  }); // Places a `_data` on the prototype that when first called replaces itself\n  // with a `_data` object local to the instance.  It also defines getters\n  // for any value that has a default value.\n\n  if (typePrototype.hasOwnProperty(\"_data\")) {\n    for (prop in dataInitializers) {\n      defineLazyValue(typePrototype._data, prop, dataInitializers[prop].bind(typePrototype), true);\n    }\n  } else {\n    defineLazyValue(typePrototype, \"_data\", function () {\n      var map = this;\n      var data = {};\n\n      for (var prop in dataInitializers) {\n        defineLazyValue(data, prop, dataInitializers[prop].bind(map), true);\n      }\n\n      return data;\n    });\n  } // Places a `_computed` on the prototype that when first called replaces itself\n  // with a `_computed` object local to the instance.  It also defines getters\n  // that will create the property's compute when read.\n\n\n  if (typePrototype.hasOwnProperty(\"_computed\")) {\n    for (prop in computedInitializers) {\n      defineLazyValue(typePrototype._computed, prop, computedInitializers[prop].bind(typePrototype));\n    }\n  } else {\n    defineLazyValue(typePrototype, \"_computed\", function () {\n      var map = this;\n      var data = Object.create(null);\n\n      for (var prop in computedInitializers) {\n        defineLazyValue(data, prop, computedInitializers[prop].bind(map));\n      }\n\n      return data;\n    });\n  } // Add necessary event methods to this object.\n\n\n  getEveryPropertyAndSymbol(eventsProto).forEach(function (prop) {\n    Object.defineProperty(typePrototype, prop, {\n      enumerable: false,\n      value: eventsProto[prop],\n      configurable: true,\n      writable: true\n    });\n  }); // also add any symbols\n  // add so instance defs can be dynamically added\n\n  Object.defineProperty(typePrototype, \"_define\", {\n    enumerable: false,\n    value: result,\n    configurable: true,\n    writable: true\n  }); // Places Symbol.iterator or @@iterator on the prototype\n  // so that this can be iterated with for/of and canReflect.eachIndex\n\n  var iteratorSymbol = Symbol.iterator || Symbol.for(\"iterator\");\n\n  if (!typePrototype[iteratorSymbol]) {\n    defineConfigurableAndNotEnumerable(typePrototype, iteratorSymbol, function () {\n      return new _define.Iterator(this);\n    });\n  }\n\n  return result;\n};\n\nvar onlyType = function onlyType(obj) {\n  for (var prop in obj) {\n    if (prop !== \"type\") {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar callAsync = function callAsync(fn) {\n  return function asyncResolver(lastSet, resolve) {\n    var newValue = fn.call(this, resolve, lastSet); // This should really be happening in can-simple-observable/async/\n    // But that would be a breaking change so putting it here.\n\n    if (canReflect.isPromise(newValue)) {\n      newValue.then(resolve);\n      return undefined;\n    }\n\n    return newValue;\n  };\n};\n\n_define.extensions = function () {};\n\n_define.isEnumerable = function (definition) {\n  return _typeof(definition) !== \"object\" || (\"serialize\" in definition ? !!definition.serialize : !definition.get && !definition.async && !definition.value);\n}; // typePrototype - the prototype of the type we are defining `prop` on.\n// `definition` - the user provided definition\n\n\n_define.property = function (typePrototype, prop, definition, dataInitializers, computedInitializers, defaultDefinition) {\n  var propertyDefinition = _define.extensions.apply(this, arguments);\n\n  if (propertyDefinition) {\n    definition = makeDefinition(prop, propertyDefinition, defaultDefinition || {}, typePrototype);\n  }\n\n  var type = definition.type; //!steal-remove-start\n\n  if (true) {\n    if (!definition.set && definition.get && definition.get.length === 0 && \"default\" in definition) {\n      canLogDev.warn(\"can-observable-object: default value for property \" + canReflect.getName(typePrototype) + \".\" + prop + \" ignored, as its definition has a zero-argument getter and no setter\");\n    }\n\n    if (!definition.set && definition.get && definition.get.length === 0 && definition.type && definition.type !== defaultDefinition.type) {\n      canLogDev.warn(\"can-observable-object: type value for property \" + canReflect.getName(typePrototype) + \".\" + prop + \" ignored, as its definition has a zero-argument getter and no setter\");\n    }\n  }\n\n  for (var _i = 0, _arr = ['get', 'set', 'value']; _i < _arr.length; _i++) {\n    var defFuncProp = _arr[_i];\n\n    var propType = definition[defFuncProp] && _typeof(definition[defFuncProp]);\n\n    if (propType && propType !== 'function') {\n      canLogDev.error(\"can-observable-object: \\\"\".concat(defFuncProp, \"\\\" for property \").concat(canReflect.getName(typePrototype), \".\").concat(prop) + \" is expected to be a function, but it's a \".concat(propType, \".\"));\n      return;\n    }\n  } //!steal-remove-end\n  // Special case definitions that have only `type: \"*\"`.\n\n\n  if (type && onlyType(definition) && type === type.Any) {\n    Object_defineNamedPrototypeProperty(typePrototype, prop, {\n      get: make.get.data(prop),\n      set: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),\n      enumerable: true,\n      configurable: true\n    });\n    return;\n  }\n\n  definition.type = type; // Where the value is stored.  If there is a `get` the source of the value\n  // will be a compute in `this._computed[prop]`.  If not, the source of the\n  // value will be in `this._data[prop]`.\n\n  var dataProperty = definition.get || definition.async || definition.value ? \"computed\" : \"data\",\n      // simple functions that all read/get/set to the right place.\n  // - reader - reads the value but does not observe.\n  // - getter - reads the value and notifies observers.\n  // - setter - sets the value.\n  reader = make.read[dataProperty](prop),\n      getter = make.get[dataProperty](prop),\n      setter = make.set[dataProperty](prop),\n      getInitialValue; //!steal-remove-start\n\n  if (true) {\n    if (definition.get) {\n      Object.defineProperty(definition.get, \"name\", {\n        value: canReflect.getName(typePrototype) + \"'s \" + prop + \" getter\",\n        configurable: true\n      });\n    }\n\n    if (definition.set) {\n      Object.defineProperty(definition.set, \"name\", {\n        value: canReflect.getName(typePrototype) + \"'s \" + prop + \" setter\",\n        configurable: true\n      });\n    }\n\n    if (definition.value) {\n      Object.defineProperty(definition.value, \"name\", {\n        value: canReflect.getName(typePrototype) + \"'s \" + prop + \" value\",\n        configurable: true\n      });\n    }\n  } //!steal-remove-end\n  // Determine the type converter\n\n\n  var typeConvert = function typeConvert(val) {\n    return val;\n  };\n\n  if (type) {\n    typeConvert = make.set.type(prop, type, typeConvert);\n  } // make a setter that's going to fire of events\n\n\n  var eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));\n\n  if (definition.value) {\n    computedInitializers[prop] = make.resolver(prop, definition, typeConvert);\n  } // Determine a function that will provide the initial property value.\n  else if (definition.default !== undefined) {\n      //!steal-remove-start\n      if (true) {\n        // If value is an object or array, give a warning\n        if (definition.default !== null && _typeof(definition.default) === 'object') {\n          canLogDev.warn(\"can-observable-object: The default value for \" + canReflect.getName(typePrototype) + \".\" + prop + \" is set to an object. This will be shared by all instances of the DefineMap. Use a function that returns the object instead.\");\n        } // If value is a constructor, give a warning\n\n\n        if (definition.default && canReflect.isConstructorLike(definition.default)) {\n          canLogDev.warn(\"can-observable-object: The \\\"default\\\" for \" + canReflect.getName(typePrototype) + \".\" + prop + \" is set to a constructor. Did you mean \\\"Default\\\" instead?\");\n        }\n      } //!steal-remove-end\n\n\n      getInitialValue = ObservationRecorder.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));\n    } // If property has a getter, create the compute that stores its data.\n\n\n  if (definition.get) {\n    computedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);\n  } else if (definition.async) {\n    computedInitializers[prop] = make.compute(prop, callAsync(definition.async), getInitialValue);\n  } // If the property isn't a getter, but has an initial value, setup a\n  // default value on `this._data[prop]`.\n  else if (getInitialValue) {\n      dataInitializers[prop] = getInitialValue;\n    } // Define setter behavior.\n  // If there's a `get` and `set`, make the setter get the `lastSetValue` on the\n  // `get`'s compute.\n\n\n  if (definition.get && definition.set) {\n    // the compute will set off events, so we can use the basic setter\n    setter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);\n  } // If there's a `set` and no `get`,\n  else if (definition.set) {\n      // Add `set` functionality to the eventSetter.\n      setter = make.set.setter(prop, definition.set, reader, eventsSetter, false);\n    } // If there's neither `set` or `get` or `value` (resolver)\n    else if (dataProperty === \"data\") {\n        // make a set that produces events.\n        setter = eventsSetter;\n      } // If there's zero-arg `get` but not `set`, warn on all sets in dev mode\n      else if (definition.get && definition.get.length < 1) {\n          setter = function setter() {\n            //!steal-remove-start\n            if (true) {\n              canLogDev.warn(\"can-observable-object: Set value for property \" + canReflect.getName(typePrototype) + \".\" + prop + \" ignored, as its definition has a zero-argument getter and no setter\");\n            } //!steal-remove-end\n\n          };\n        } // Add type behavior to the setter.\n\n\n  if (type) {\n    setter = make.set.type(prop, type, setter);\n  } // Define the property.\n\n\n  Object_defineNamedPrototypeProperty(typePrototype, prop, {\n    get: getter,\n    set: setter,\n    enumerable: _define.isEnumerable(definition),\n    configurable: true\n  });\n};\n\n_define.makeDefineInstanceKey = function (constructor) {\n  constructor[Symbol.for(\"can.defineInstanceKey\")] = function (property, value) {\n    _define.hooks.finalizeClass(this);\n\n    var defineResult = this.prototype._define;\n\n    if (value && typeof value.value !== \"undefined\") {\n      value.default = value.value;\n      value.type = type.Any;\n      delete value.value;\n    }\n\n    var definition = getDefinitionOrMethod(property, value, defineResult.defaultDefinition, this);\n\n    if (definition && _typeof(definition) === \"object\") {\n      _define.property(this.prototype, property, definition, defineResult.dataInitializers, defineResult.computedInitializers, defineResult.defaultDefinition);\n\n      defineResult.definitions[property] = definition;\n    } else {\n      defineResult.methods[property] = definition;\n    }\n\n    this.prototype.dispatch({\n      action: \"can.keys\",\n      type: \"can.keys\",\n      target: this.prototype\n    });\n  };\n}; // Makes a simple constructor function.\n\n\n_define.Constructor = function (defines, sealed) {\n  var constructor = function DefineConstructor(props) {\n    Object.defineProperty(this, inSetupSymbol, {\n      configurable: true,\n      enumerable: false,\n      value: true,\n      writable: true\n    });\n\n    _define.setup.call(this, props, sealed);\n\n    this[inSetupSymbol] = false;\n  };\n\n  var result = _define(constructor.prototype, defines);\n\n  addTypeEvents(constructor);\n\n  _define.makeDefineInstanceKey(constructor, result);\n\n  return constructor;\n}; // A bunch of helper functions that are used to create various behaviors.\n\n\nmake = {\n  computeObj: function computeObj(map, prop, observable) {\n    var computeObj = {\n      oldValue: undefined,\n      compute: observable,\n      count: 0,\n      handler: function handler(newVal) {\n        var oldValue = computeObj.oldValue;\n        computeObj.oldValue = newVal;\n        map.dispatch({\n          action: \"prop\",\n          key: prop,\n          value: newVal,\n          oldValue: oldValue,\n          type: prop,\n          target: map\n        }, [newVal, oldValue]);\n      }\n    };\n    return computeObj;\n  },\n  resolver: function resolver(prop, definition, typeConvert) {\n    var getDefault = make.get.defaultValue(prop, definition, typeConvert);\n    return function () {\n      var map = this;\n      var defaultValue = getDefault.call(this);\n      var computeObj = make.computeObj(map, prop, new ResolverObservable(definition.value, map, defaultValue, {\n        resetUnboundValueInGet: true\n      })); //!steal-remove-start\n\n      if (true) {\n        Object.defineProperty(computeObj.handler, \"name\", {\n          value: canReflect.getName(definition.value).replace('value', 'event emitter')\n        });\n      } //!steal-remove-end\n\n\n      return computeObj;\n    };\n  },\n  // Returns a function that creates the `_computed` prop.\n  compute: function compute(prop, get, defaultValueFn) {\n    return function () {\n      var map = this,\n          defaultValue = defaultValueFn && defaultValueFn.call(this),\n          observable,\n          computeObj;\n\n      if (get.length === 0) {\n        observable = new Observation(get, map);\n      } else if (get.length === 1) {\n        observable = new SettableObservable(get, map, defaultValue);\n      } else {\n        observable = new AsyncObservable(get, map, defaultValue);\n      }\n\n      computeObj = make.computeObj(map, prop, observable); //!steal-remove-start\n\n      if (true) {\n        Object.defineProperty(computeObj.handler, \"name\", {\n          value: canReflect.getName(get).replace('getter', 'event emitter')\n        });\n      } //!steal-remove-end\n\n\n      return computeObj;\n    };\n  },\n  // Set related helpers.\n  set: {\n    data: function data(prop) {\n      return function (newVal) {\n        this._data[prop] = newVal;\n      };\n    },\n    computed: function computed(prop) {\n      return function (val) {\n        canReflect.setValue(this._computed[prop].compute, val);\n      };\n    },\n    events: function events(prop, getCurrent, setData\n    /*, eventType*/\n    ) {\n      return function (newVal) {\n        if (this[inSetupSymbol]) {\n          setData.call(this, newVal);\n        } else {\n          var current = getCurrent.call(this);\n\n          if (newVal !== current) {\n            var dispatched;\n            setData.call(this, newVal);\n            dispatched = {\n              patches: [{\n                type: \"set\",\n                key: prop,\n                value: newVal\n              }],\n              action: \"prop\",\n              key: prop,\n              value: newVal,\n              oldValue: current,\n              type: prop,\n              target: this\n            }; //!steal-remove-start\n\n            if (true) {\n              dispatched.reasonLog = [canReflect.getName(this) + \"'s\", prop, \"changed to\", newVal, \"from\", current];\n            } //!steal-remove-end\n\n\n            this.dispatch(dispatched, [newVal, current]);\n          }\n        }\n      };\n    },\n    eventDispatcher: function eventDispatcher(map, prop, current, newVal) {\n      if (map[inSetupSymbol]) {\n        return;\n      } else {\n        if (newVal !== current) {\n          var dispatched = {\n            patches: [{\n              type: \"set\",\n              key: prop,\n              value: newVal\n            }],\n            action: \"prop\",\n            key: prop,\n            value: newVal,\n            oldValue: current,\n            type: prop,\n            target: map\n          }; //!steal-remove-start\n\n          if (true) {\n            dispatched.reasonLog = [canReflect.getName(this) + \"'s\", prop, \"changed to\", newVal, \"from\", current];\n          } //!steal-remove-end\n\n\n          eventQueue.dispatch.call(map, dispatched, [newVal, current]);\n        }\n      }\n    },\n    setter: function setter(prop, _setter, getCurrent, setEvents, hasGetter) {\n      return function (value) {\n        //!steal-remove-start\n        var asyncTimer; //!steal-remove-end\n\n        var self = this; // call the setter, if returned value is undefined,\n        // this means the setter is async so we\n        // do not call update property and return right away\n\n        queues.batch.start();\n\n        var setterCalled = false,\n            current = getCurrent.call(this),\n            setValue = _setter.call(this, value, current);\n\n        if (setterCalled) {\n          queues.batch.stop();\n        } else {\n          if (hasGetter) {\n            // we got a return value\n            if (setValue !== undefined) {\n              // if the current `set` value is returned, don't set\n              // because current might be the `lastSetVal` of the internal compute.\n              if (current !== setValue) {\n                setEvents.call(this, setValue);\n              }\n\n              queues.batch.stop();\n            } // this is a side effect, it didn't take a value\n            // so use the original set value\n            else if (_setter.length === 0) {\n                setEvents.call(this, value);\n                queues.batch.stop();\n                return;\n              } // it took a value\n              else if (_setter.length === 1) {\n                  // if we have a getter, and undefined was returned,\n                  // we should assume this is setting the getters properties\n                  // and we shouldn't do anything.\n                  queues.batch.stop();\n                } // we are expecting something\n                else {\n                    //!steal-remove-start\n                    if (true) {\n                      asyncTimer = setTimeout(function () {\n                        canLogDev.warn('can-observable-object: Setter \"' + canReflect.getName(self) + \".\" + prop + '\" did not return a value or call the setter callback.');\n                      }, canLogDev.warnTimeout);\n                    } //!steal-remove-end\n\n\n                    queues.batch.stop();\n                    return;\n                  }\n          } else {\n            // we got a return value\n            if (setValue !== undefined) {\n              // if the current `set` value is returned, don't set\n              // because current might be the `lastSetVal` of the internal compute.\n              setEvents.call(this, setValue);\n              queues.batch.stop();\n            } // this is a side effect, it didn't take a value\n            // so use the original set value\n            else if (_setter.length === 0) {\n                setEvents.call(this, value);\n                queues.batch.stop();\n                return;\n              } // it took a value\n              else if (_setter.length === 1) {\n                  // if we don't have a getter, we should probably be setting the\n                  // value to undefined\n                  setEvents.call(this, undefined);\n                  queues.batch.stop();\n                } // we are expecting something\n                else {\n                    //!steal-remove-start\n                    if (true) {\n                      asyncTimer = setTimeout(function () {\n                        canLogDev.warn('can/map/setter.js: Setter \"' + canReflect.getName(self) + \".\" + prop + '\" did not return a value or call the setter callback.');\n                      }, canLogDev.warnTimeout);\n                    } //!steal-remove-end\n\n\n                    queues.batch.stop();\n                    return;\n                  }\n          }\n        }\n      };\n    },\n    type: function type(prop, _type, set) {\n      function setter(newValue) {\n        return set.call(this, _type.call(this, newValue, prop));\n      }\n\n      if (isDefineType(_type)) {\n        // TODO: remove this `canDefineType` check in a future release.\n        if (_type.canDefineType) {\n          return setter;\n        } else {\n          return function setter(newValue) {\n            //!steal-remove-start\n            if (true) {\n              try {\n                return set.call(this, canReflect.convert(newValue, _type));\n              } catch (error) {\n                if (error.type === 'can-type-error') {\n                  var typeName = canReflect.getName(_type[baseTypeSymbol]);\n\n                  var valueType = _typeof(newValue);\n\n                  var message = '\"' + newValue + '\"' + ' (' + valueType + ') is not of type ' + typeName + '. Property ' + prop + ' is using \"type: ' + typeName + '\". ';\n                  message += 'Use \"' + prop + ': type.convert(' + typeName + ')\" to automatically convert values to ' + typeName + 's when setting the \"' + prop + '\" property.';\n                  error.message = message;\n                }\n\n                throw error;\n              }\n            } //!steal-remove-end\n\n\n            return set.call(this, canReflect.convert(newValue, _type));\n          };\n        }\n      }\n\n      return setter;\n    }\n  },\n  // Helpes that indicate what the event type should be.  These probably aren't needed.\n  eventType: {\n    data: function data(prop) {\n      return function (newVal, oldVal) {\n        return oldVal !== undefined || this._data.hasOwnProperty(prop) ? \"set\" : \"add\";\n      };\n    },\n    computed: function computed() {\n      return function () {\n        return \"set\";\n      };\n    }\n  },\n  // Helpers that read the data in a non-observable way.\n  read: {\n    data: function data(prop) {\n      return function () {\n        return this._data[prop];\n      };\n    },\n    computed: function computed(prop) {\n      // might want to protect this\n      return function () {\n        return canReflect.getValue(this._computed[prop].compute);\n      };\n    },\n    lastSet: function lastSet(prop) {\n      return function () {\n        var observable = this._computed[prop].compute;\n\n        if (observable.lastSetValue) {\n          return canReflect.getValue(observable.lastSetValue);\n        }\n      };\n    }\n  },\n  // Helpers that read the data in an observable way.\n  get: {\n    // uses the default value\n    defaultValue: function defaultValue(prop, definition, typeConvert, callSetter) {\n      return function () {\n        var value = definition.default;\n\n        if (value !== undefined) {\n          // call `get default() { ... }` but not `default() { ... }`\n          if (typeof value === \"function\" && value.isAGetter) {\n            value = value.call(this);\n          }\n\n          value = typeConvert.call(this, value);\n        }\n\n        if (definition.set) {\n          // TODO: there's almost certainly a faster way of making this happen\n          // But this is maintainable.\n          var VALUE;\n          var sync = true;\n          var setter = make.set.setter(prop, definition.set, function () {}, function (value) {\n            if (sync) {\n              VALUE = value;\n            } else {\n              callSetter.call(this, value);\n            }\n          }, definition.get);\n          setter.call(this, value);\n          sync = false; // VALUE will be undefined if the callback is never called.\n\n          return VALUE;\n        }\n\n        return value;\n      };\n    },\n    data: function data(prop) {\n      return function () {\n        if (!this[inSetupSymbol]) {\n          ObservationRecorder.add(this, prop);\n        }\n\n        return this._data[prop];\n      };\n    },\n    computed: function computed(prop) {\n      return function ()\n      /*val*/\n      {\n        var compute = this._computed[prop].compute;\n\n        if (ObservationRecorder.isRecording()) {\n          ObservationRecorder.add(this, prop);\n\n          if (!canReflect.isBound(compute)) {\n            Observation.temporarilyBind(compute);\n          }\n        }\n\n        return peek(compute);\n      };\n    }\n  }\n};\n_define.behaviors = [\"get\", \"set\", \"value\", \"type\", \"serialize\"]; // This cleans up a particular behavior and adds it to the definition\n\nvar addBehaviorToDefinition = function addBehaviorToDefinition(definition, behavior, descriptor, def, prop, typePrototype) {\n  if (behavior === \"enumerable\") {\n    // treat enumerable like serialize\n    definition.serialize = !!def[behavior];\n  } else if (behavior === \"type\") {\n    var behaviorDef = def[behavior];\n\n    if (typeof behaviorDef !== 'undefined') {\n      definition[behavior] = behaviorDef;\n    }\n  } else {\n    // This is a good place to do warnings? This gets called for every behavior\n    // Both by .define() and .property()\n    var value = descriptor.get || descriptor.value;\n\n    if (descriptor.get) {\n      value.isAGetter = true;\n    }\n\n    if (behavior === \"async\") {\n      if (value.length === 1 && isAsyncFunction(value)) {\n        canLogDev.warn(\"\".concat(canReflect.getName(typePrototype), \": async property [\").concat(prop, \"] should not be an async function and also use the resolve() argument. Remove the argument and return a value from the async function instead.\"));\n      }\n    }\n\n    definition[behavior] = value;\n  }\n}; // This is called by `define.property` AND `getDefinitionOrMethod` (which is called by `define`)\n// Currently, this is adding default behavior\n// copying `type` over, and even cleaning up the final definition object\n\n\nmakeDefinition = function makeDefinition(prop, def, defaultDefinition, typePrototype) {\n  var definition = {};\n  eachPropertyDescriptor(def, function (behavior, descriptor) {\n    addBehaviorToDefinition(definition, behavior, descriptor, def, prop, typePrototype);\n  }); // only add default if it doesn't exist\n\n  canReflect.eachKey(defaultDefinition, function (value, prop) {\n    if (definition[prop] === undefined) {\n      if (prop !== \"type\") {\n        definition[prop] = value;\n      }\n    }\n  });\n\n  if (def.type) {\n    var value = def.type;\n    var serialize = value[serializeSymbol];\n\n    if (serialize) {\n      definition.serialize = function (val) {\n        return serialize.call(val);\n      };\n    }\n\n    definition.type = type.normalize(value);\n  }\n\n  var noTypeDefined = !definition.type && (!defaultDefinition.type || defaultDefinition.type && defaultDefinition.typeSetByDefault);\n\n  if (definition.hasOwnProperty(\"default\")) {\n    if (typeof definition.default === \"function\" && !definition.default.isAGetter && noTypeDefined) {\n      definition.type = type.normalize(Function);\n    }\n\n    if (canReflect.isPrimitive(definition.default) && noTypeDefined) {\n      if (definition.default === null || typeof definition.default === 'undefined') {\n        definition.type = type.Any;\n      } else {\n        definition.type = type.normalize(definition.default.constructor);\n      }\n    }\n  } // if there's no type definition, take it from the defaultDefinition\n\n\n  if (!definition.type) {\n    var defaultsCopy = canReflect.assignMap({}, defaultDefinition);\n    definition = canReflect.assignMap(defaultsCopy, definition);\n  }\n\n  if (canReflect.size(definition) === 0) {\n    definition.type = type.Any; // `setByDefault` indicates that the default type can be\n    // overridden by an inferred type\n\n    definition.typeSetByDefault = true;\n  }\n\n  return definition;\n}; // called by `can.defineInstanceKey` and `getDefinitionsAndMethods`\n// returns the value or the definition object.\n// calls makeDefinition\n// This is dealing with a string value\n\n\ngetDefinitionOrMethod = function getDefinitionOrMethod(prop, value, defaultDefinition, typePrototype) {\n  // Clean up the value to make it a definition-like object\n  var definition;\n  var definitionType;\n\n  if (canReflect.isPrimitive(value)) {\n    if (value === null || typeof value === 'undefined') {\n      definitionType = type.Any;\n    } else {\n      // only include type from defaultDefininition\n      // if it came from propertyDefaults\n      definitionType = defaultDefinition.typeSetByDefault ? type.normalize(value.constructor) : defaultDefinition.type;\n    }\n\n    definition = {\n      default: value,\n      type: definitionType\n    };\n  } // copies a `Type`'s methods over\n  else if (value && (value[serializeSymbol] || value[newSymbol])) {\n      if (value[isMemberSymbol]) {\n        definition = {\n          type: value\n        };\n      } else {\n        definition = {\n          type: type.normalize(value)\n        };\n      }\n    } else if (typeof value === \"function\") {\n      if (canReflect.isConstructorLike(value)) {\n        definition = {\n          type: type.normalize(value)\n        };\n      } else {\n        definition = {\n          default: value,\n          type: Function\n        };\n      }\n    } else if (Array.isArray(value)) {\n      definition = {\n        type: type.normalize(Array)\n      };\n    } else if (canReflect.isPlainObject(value)) {\n      definition = value;\n    }\n\n  if (definition) {\n    return makeDefinition(prop, definition, defaultDefinition, typePrototype);\n  } else {\n    return value;\n  }\n}; // called by can.define\n\n\ngetDefinitionsAndMethods = function getDefinitionsAndMethods(defines, baseDefines, typePrototype, propertyDefaults) {\n  // make it so the definitions include base definitions on the proto\n  var definitions = Object.create(baseDefines ? baseDefines.definitions : null);\n  var methods = {}; // first lets get a default if it exists\n\n  var defaultDefinition;\n\n  if (propertyDefaults) {\n    defaultDefinition = getDefinitionOrMethod(\"*\", propertyDefaults, {}, typePrototype);\n  } else {\n    defaultDefinition = Object.create(null);\n  }\n\n  function addDefinition(prop, propertyDescriptor, skipGetDefinitionForMethods) {\n    var value;\n\n    if (propertyDescriptor.get || propertyDescriptor.set) {\n      value = {\n        get: propertyDescriptor.get,\n        set: propertyDescriptor.set\n      };\n    } else {\n      value = propertyDescriptor.value;\n    }\n\n    if (prop === \"constructor\" || skipGetDefinitionForMethods && typeof value === \"function\") {\n      methods[prop] = value;\n      return;\n    } else {\n      var result = getDefinitionOrMethod(prop, value, defaultDefinition, typePrototype);\n\n      var resultType = _typeof(result);\n\n      if (result && resultType === \"object\" && canReflect.size(result) > 0) {\n        definitions[prop] = result;\n      } else {\n        // Removed adding raw values that are not functions\n        if (resultType === \"function\") {\n          methods[prop] = result;\n        } //!steal-remove-start\n        else if (resultType !== 'undefined') {\n            if (true) {\n              // Ex: {prop: 0}\n              canLogDev.error(canReflect.getName(typePrototype) + \".\" + prop + \" does not match a supported definitionObject. See: https://canjs.com/doc/can-observable-object/object.types.definitionObject.html\");\n            }\n          } //!steal-remove-end\n\n      }\n    }\n  }\n\n  eachPropertyDescriptor(typePrototype, addDefinition, true);\n  eachPropertyDescriptor(defines, addDefinition);\n\n  if (propertyDefaults) {\n    // we should move this property off the prototype.\n    defineConfigurableAndNotEnumerable(defines, \"*\", propertyDefaults);\n  }\n\n  return {\n    definitions: definitions,\n    methods: methods,\n    defaultDefinition: defaultDefinition\n  };\n};\n\neventsProto = eventQueue({});\n\nfunction setupComputed(instance, eventName) {\n  var computedBinding = instance._computed && instance._computed[eventName];\n\n  if (computedBinding && computedBinding.compute) {\n    if (!computedBinding.count) {\n      computedBinding.count = 1;\n      canReflect.onValue(computedBinding.compute, computedBinding.handler, \"notify\");\n      computedBinding.oldValue = peek(computedBinding.compute);\n    } else {\n      computedBinding.count++;\n    }\n  }\n}\n\nfunction teardownComputed(instance, eventName) {\n  var computedBinding = instance._computed && instance._computed[eventName];\n\n  if (computedBinding) {\n    if (computedBinding.count === 1) {\n      computedBinding.count = 0;\n      canReflect.offValue(computedBinding.compute, computedBinding.handler, \"notify\");\n    } else {\n      computedBinding.count--;\n    }\n  }\n}\n\nassign(eventsProto, {\n  _eventSetup: function _eventSetup() {},\n  _eventTeardown: function _eventTeardown() {},\n  addEventListener: function addEventListener(eventName\n  /*, handler, queue*/\n  ) {\n    setupComputed(this, eventName);\n    return eventQueue.addEventListener.apply(this, arguments);\n  },\n  // ### unbind\n  // Stops listening to an event.\n  // If this is the last listener of a computed property,\n  // stop forwarding events of the computed property to this map.\n  removeEventListener: function removeEventListener(eventName\n  /*, handler*/\n  ) {\n    teardownComputed(this, eventName);\n    return eventQueue.removeEventListener.apply(this, arguments);\n  }\n});\neventsProto.on = eventsProto.bind = eventsProto.addEventListener;\neventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;\nvar onKeyValueSymbol = Symbol.for(\"can.onKeyValue\");\nvar offKeyValueSymbol = Symbol.for(\"can.offKeyValue\");\ncanReflect.assignSymbols(eventsProto, {\n  \"can.onKeyValue\": function canOnKeyValue(key) {\n    setupComputed(this, key);\n    return eventQueue[onKeyValueSymbol].apply(this, arguments);\n  },\n  \"can.offKeyValue\": function canOffKeyValue(key) {\n    teardownComputed(this, key);\n    return eventQueue[offKeyValueSymbol].apply(this, arguments);\n  }\n});\ndelete eventsProto.one;\n\n_define.finalizeInstance = function () {\n  defineNotWritableAndNotEnumerable(this, \"constructor\", this.constructor);\n  defineNotWritableAndNotEnumerable(this, canMetaSymbol, Object.create(null));\n};\n\n_define.setup = function (props, sealed) {\n  var requiredButNotProvided = new Set(this._define.required);\n  var definitions = this._define.definitions;\n  var instanceDefinitions = Object.create(null);\n  var map = this;\n  canReflect.eachKey(props, function (value, prop) {\n    if (requiredButNotProvided.has(prop)) {\n      requiredButNotProvided.delete(prop);\n    }\n\n    if (definitions[prop] !== undefined) {\n      map[prop] = value;\n    } else {\n      if (sealed) {\n        throw new Error(\"The type \".concat(canReflect.getName(map.constructor), \" is sealed, but the property [\").concat(prop, \"] has no definition.\"));\n      }\n\n      _define.expando(map, prop, value);\n    }\n  });\n\n  if (canReflect.size(instanceDefinitions) > 0) {\n    defineConfigurableAndNotEnumerable(this, \"_instanceDefinitions\", instanceDefinitions);\n  }\n\n  if (requiredButNotProvided.size) {\n    var msg,\n        missingProps = Array.from(requiredButNotProvided);\n    var thisName = canReflect.getName(this);\n\n    if (requiredButNotProvided.size === 1) {\n      msg = \"\".concat(thisName, \": Missing required property [\").concat(missingProps[0], \"].\");\n    } else {\n      msg = \"\".concat(thisName, \": Missing required properties [\").concat(missingProps.join(\", \"), \"].\");\n    }\n\n    throw new Error(msg);\n  }\n};\n\nvar returnFirstArg = function returnFirstArg(arg) {\n  return arg;\n}; // TODO Why is this exported, does it need to be?\n\n\n_define.normalizeTypeDefinition = type.normalize;\n\n_define.expando = function (map, prop, value) {\n  if (_define._specialKeys[prop]) {\n    // ignores _data and _computed\n    return true;\n  } // first check if it's already a constructor define\n\n\n  var constructorDefines = map._define.definitions;\n\n  if (constructorDefines && constructorDefines[prop]) {\n    return;\n  } // next if it's already on this instances\n\n\n  var instanceDefines = map._instanceDefinitions;\n\n  if (!instanceDefines) {\n    if (Object.isSealed(map)) {\n      var errorMessage = \"Cannot set property [\".concat(prop, \"] on sealed instance of \").concat(canReflect.getName(map));\n      throw new Error(errorMessage);\n    }\n\n    Object.defineProperty(map, \"_instanceDefinitions\", {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: {}\n    });\n    instanceDefines = map._instanceDefinitions;\n  }\n\n  if (!instanceDefines[prop]) {\n    var defaultDefinition = map._define.defaultDefinition || {\n      type: observableType\n    };\n\n    _define.property(map, prop, defaultDefinition, {}, {}); // possibly convert value to List or DefineMap\n\n\n    if (defaultDefinition.type) {\n      map._data[prop] = _define.make.set.type(prop, defaultDefinition.type, returnFirstArg).call(map, value);\n    } else {\n      map._data[prop] = observableType(value);\n    }\n\n    instanceDefines[prop] = defaultDefinition;\n\n    if (!map[inSetupSymbol]) {\n      queues.batch.start();\n      map.dispatch({\n        action: \"can.keys\",\n        type: \"can.keys\",\n        target: map\n      });\n\n      if (Object.prototype.hasOwnProperty.call(map._data, prop)) {\n        map.dispatch({\n          action: \"add\",\n          key: prop,\n          type: prop,\n          value: map._data[prop],\n          target: map,\n          patches: [{\n            type: \"add\",\n            key: prop,\n            value: map._data[prop]\n          }]\n        }, [map._data[prop], undefined]);\n      } else {\n        map.dispatch({\n          action: \"set\",\n          type: \"set\",\n          value: map._data[prop],\n          target: map,\n          patches: [{\n            type: \"add\",\n            key: prop,\n            value: map._data[prop]\n          }]\n        }, [map._data[prop], undefined]);\n      }\n\n      queues.batch.stop();\n    }\n\n    return true;\n  }\n};\n\n_define.replaceWith = defineLazyValue;\n_define.eventsProto = eventsProto;\n_define.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;\n_define.make = make;\n_define.getDefinitionOrMethod = getDefinitionOrMethod;\n_define._specialKeys = {\n  _data: true,\n  _computed: true\n};\nvar simpleGetterSetters = {};\n\n_define.makeSimpleGetterSetter = function (prop) {\n  if (simpleGetterSetters[prop] === undefined) {\n    var setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop));\n    simpleGetterSetters[prop] = {\n      get: make.get.data(prop),\n      set: function set(newVal) {\n        return setter.call(this, observableType(newVal));\n      },\n      enumerable: true,\n      configurable: true\n    };\n  }\n\n  return simpleGetterSetters[prop];\n};\n\n_define.Iterator = function (obj) {\n  this.obj = obj;\n  this.definitions = Object.keys(obj._define.definitions);\n  this.instanceDefinitions = obj._instanceDefinitions ? Object.keys(obj._instanceDefinitions) : Object.keys(obj);\n  this.hasGet = typeof obj.get === \"function\";\n};\n\n_define.Iterator.prototype.next = function () {\n  var key;\n\n  if (this.definitions.length) {\n    key = this.definitions.shift(); // Getters should not be enumerable\n\n    var def = this.obj._define.definitions[key];\n\n    if (def.get) {\n      return this.next();\n    }\n  } else if (this.instanceDefinitions.length) {\n    key = this.instanceDefinitions.shift();\n  } else {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  return {\n    value: [key, this.hasGet ? this.obj.get(key) : this.obj[key]],\n    done: false\n  };\n};\n\n_define.updateSchemaKeys = function (schema, definitions) {\n  for (var prop in definitions) {\n    var definition = definitions[prop];\n\n    if (definition.serialize !== false) {\n      if (definition.type) {\n        schema.keys[prop] = definition.type;\n      } else {\n        schema.keys[prop] = function (val) {\n          return val;\n        };\n      } // some unknown type\n\n\n      if (definitions[prop].identity === true) {\n        schema.identity.push(prop);\n      }\n    }\n  }\n\n  return schema;\n};\n\n_define.hooks = {\n  finalizeClass: function finalizeClass(Type) {\n    var hasBeenDefined = Type.hasOwnProperty(hasBeenDefinedSymbol);\n\n    if (!hasBeenDefined) {\n      var prototypeObject = Type.prototype; // check for `static props = {}`\n      // fall back to `static define = {}` if `props` doesn't exist\n\n      var defines = _typeof(Type.props) === \"object\" ? Type.props : _typeof(Type.define) === \"object\" ? Type.define : {};\n\n      _define(prototypeObject, defines, null, Type.propertyDefaults);\n\n      Type[hasBeenDefinedSymbol] = true;\n    }\n  },\n  initialize: function initialize(instance, props) {\n    var firstInitialize = !instance.hasOwnProperty(canMetaSymbol);\n    var sealed = instance.constructor.seal;\n\n    if (firstInitialize) {\n      _define.finalizeInstance.call(instance);\n    }\n\n    if (!instance[canMetaSymbol].initialized) {\n      defineConfigurableAndNotEnumerable(instance, inSetupSymbol, true);\n\n      _define.setup.call(instance, props, sealed); // set inSetup to false so events can be dispatched\n\n\n      instance[inSetupSymbol] = false; // set instance as initialized so this is only called once\n\n      instance[canMetaSymbol].initialized = true;\n    } // only seal in dev mode for performance reasons.\n    //!steal-remove-start\n\n\n    if (true) {\n      // only seal the first time initialize is called\n      // even if meta.initialized is reset to false\n      if (firstInitialize) {\n        /* jshint -W030 */\n        instance._data;\n        instance._computed;\n\n        if (sealed === true) {\n          Object.seal(instance);\n        }\n      }\n    } //!steal-remove-end\n\n  },\n  expando: _define.expando,\n  normalizeTypeDefinition: type.normalize //define.normalizeTypeDefinition\n\n};\n\n//# sourceURL=webpack:///./node_modules/can-observable-mixin/dist/define.js?");

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/ensure-meta.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/ensure-meta.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\"); // Ensure the \"obj\" passed as an argument has an object on @@can.meta\n\n\nmodule.exports = function ensureMeta(obj) {\n  var metaSymbol = Symbol.for(\"can.meta\");\n  var meta = obj[metaSymbol];\n\n  if (!meta) {\n    meta = {};\n    canReflect.setKeyValue(obj, metaSymbol, meta);\n  }\n\n  return meta;\n};\n\n//# sourceURL=webpack:///./node_modules/can-observable-mixin/dist/ensure-meta.js?");

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/mixin-element.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/mixin-element.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar _require = __webpack_require__(/*! ./define */ \"./node_modules/can-observable-mixin/dist/define.js\"),\n    hooks = _require.hooks,\n    makeDefineInstanceKey = _require.makeDefineInstanceKey;\n\nvar mixinMapProps = __webpack_require__(/*! ./mixin-mapprops */ \"./node_modules/can-observable-mixin/dist/mixin-mapprops.js\");\n\nvar mixinProxy = __webpack_require__(/*! ./mixin-proxy */ \"./node_modules/can-observable-mixin/dist/mixin-proxy.js\");\n\nvar mixinTypeEvents = __webpack_require__(/*! ./mixin-typeevents */ \"./node_modules/can-observable-mixin/dist/mixin-typeevents.js\");\n\nvar constructorPropsSymbol = Symbol.for(\"can.constructorProps\");\nvar renderedSymbol = Symbol.for(\"can.rendered\");\n\nmodule.exports = function mixinElement(BaseElement) {\n  var Element =\n  /*#__PURE__*/\n  function (_mixinProxy) {\n    _inherits(Element, _mixinProxy);\n\n    function Element(props) {\n      var _this;\n\n      _classCallCheck(this, Element);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Element).call(this));\n      hooks.finalizeClass(_this.constructor);\n      _this[constructorPropsSymbol] = props;\n      return _this;\n    }\n\n    _createClass(Element, [{\n      key: \"initialize\",\n      value: function initialize(props) {\n        if (_get(_getPrototypeOf(Element.prototype), \"initialize\", this)) {\n          _get(_getPrototypeOf(Element.prototype), \"initialize\", this).call(this, props);\n        }\n\n        hooks.initialize(this, props || this[constructorPropsSymbol]);\n      }\n    }, {\n      key: \"render\",\n      value: function render(props) {\n        if (_get(_getPrototypeOf(Element.prototype), \"render\", this)) {\n          _get(_getPrototypeOf(Element.prototype), \"render\", this).call(this, props);\n        }\n\n        hooks.initialize(this, props || this[constructorPropsSymbol]);\n        this[renderedSymbol] = true;\n      }\n    }, {\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        if (_get(_getPrototypeOf(Element.prototype), \"connectedCallback\", this)) {\n          _get(_getPrototypeOf(Element.prototype), \"connectedCallback\", this).call(this);\n        }\n\n        if (!this[renderedSymbol]) {\n          this.render();\n        }\n      }\n    }]);\n\n    return Element;\n  }(mixinProxy(BaseElement));\n\n  Element = mixinTypeEvents(mixinMapProps(Element));\n  makeDefineInstanceKey(Element);\n  return Element;\n};\n\n//# sourceURL=webpack:///./node_modules/can-observable-mixin/dist/mixin-element.js?");

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/mixin-mapprops.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/mixin-mapprops.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar addDefinedProps = __webpack_require__(/*! ./define */ \"./node_modules/can-observable-mixin/dist/define.js\");\n\nvar updateSchemaKeys = addDefinedProps.updateSchemaKeys,\n    hooks = addDefinedProps.hooks,\n    isEnumerable = addDefinedProps.isEnumerable;\n\nvar defineHelpers = __webpack_require__(/*! ./define-helpers */ \"./node_modules/can-observable-mixin/dist/define-helpers.js\");\n\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar canLogDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\n\nvar getSchemaSymbol = Symbol.for(\"can.getSchema\");\n\nfunction keysForDefinition(definitions) {\n  var keys = [];\n\n  for (var prop in definitions) {\n    if (isEnumerable(definitions[prop])) {\n      keys.push(prop);\n    }\n  }\n\n  return keys;\n}\n\nfunction _assign(source) {\n  queues.batch.start();\n  canReflect.assignMap(this, source || {});\n  queues.batch.stop();\n}\n\nfunction _update(source) {\n  queues.batch.start();\n\n  if (canReflect.isListLike(source)) {\n    canReflect.updateList(this, source);\n  } else {\n    canReflect.updateMap(this, source || {});\n  }\n\n  queues.batch.stop();\n}\n\nfunction _assignDeep(source) {\n  queues.batch.start(); // TODO: we should probably just throw an error instead of cleaning\n\n  canReflect.assignDeepMap(this, source || {});\n  queues.batch.stop();\n}\n\nfunction _updateDeep(source) {\n  queues.batch.start();\n\n  if (canReflect.isListLike(source)) {\n    canReflect.updateDeepList(this, source);\n  } else {\n    // TODO: we should probably just throw an error instead of cleaning\n    canReflect.updateDeepMap(this, source || {});\n  }\n\n  queues.batch.stop();\n}\n\nfunction setKeyValue(key, value) {\n  var defined = defineHelpers.defineExpando(this, key, value);\n\n  if (!defined) {\n    this[key] = value;\n  }\n}\n\nfunction getKeyValue(key) {\n  var value = this[key];\n\n  if (value !== undefined || key in this || Object.isSealed(this)) {\n    return value;\n  } else {\n    ObservationRecorder.add(this, key);\n    return this[key];\n  }\n}\n\nmodule.exports = function (Type) {\n  return (\n    /*#__PURE__*/\n    function (_Type) {\n      _inherits(_class, _Type);\n\n      function _class() {\n        _classCallCheck(this, _class);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(_class).apply(this, arguments));\n      }\n\n      _createClass(_class, [{\n        key: \"get\",\n        value: function get(prop) {\n          if (prop) {\n            return getKeyValue.call(this, prop);\n          } else {\n            return canReflect.unwrap(this, Map);\n          }\n        }\n      }, {\n        key: \"set\",\n        value: function set(prop, value) {\n          if (_typeof(prop) === \"object\") {\n            //!steal-remove-start\n            if (true) {\n              canLogDev.warn('can-define/map/map.prototype.set is deprecated; please use can-define/map/map.prototype.assign or can-define/map/map.prototype.update instead');\n            } //!steal-remove-end\n\n\n            if (value === true) {\n              _updateDeep.call(this, prop);\n            } else {\n              _assignDeep.call(this, prop);\n            }\n          } else {\n            setKeyValue.call(this, prop, value);\n          }\n\n          return this;\n        }\n      }, {\n        key: \"assignDeep\",\n        value: function assignDeep(prop) {\n          _assignDeep.call(this, prop);\n\n          return this;\n        }\n      }, {\n        key: \"updateDeep\",\n        value: function updateDeep(prop) {\n          _updateDeep.call(this, prop);\n\n          return this;\n        }\n      }, {\n        key: \"assign\",\n        value: function assign(prop) {\n          _assign.call(this, prop);\n\n          return this;\n        }\n      }, {\n        key: \"update\",\n        value: function update(prop) {\n          _update.call(this, prop);\n\n          return this;\n        }\n      }, {\n        key: \"serialize\",\n        value: function serialize() {\n          return canReflect.serialize(this, Map);\n        }\n      }, {\n        key: \"deleteKey\",\n        value: function deleteKey() {\n          return defineHelpers.deleteKey.apply(this, arguments);\n        }\n      }, {\n        key: \"forEach\",\n        value: function forEach(cb, thisarg, observe) {\n          function forEach(list, cb, thisarg) {\n            return canReflect.eachKey(list, cb, thisarg);\n          }\n\n          if (observe === false) {\n            ObservationRecorder.ignore(forEach)(this, cb, thisarg);\n          } else {\n            return forEach(this, cb, thisarg);\n          }\n        }\n      }, {\n        key: Symbol.for(\"can.getKeyValue\"),\n        value: function value() {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return getKeyValue.apply(this, args);\n        }\n      }, {\n        key: Symbol.for(\"can.deleteKeyValue\"),\n        value: function value() {\n          var _defineHelpers$delete;\n\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          return (_defineHelpers$delete = defineHelpers.deleteKey).call.apply(_defineHelpers$delete, [this].concat(args));\n        }\n      }, {\n        key: Symbol.for(\"can.getOwnKeys\"),\n        value: function value() {\n          var keys = canReflect.getOwnEnumerableKeys(this);\n\n          if (this._computed) {\n            var computedKeys = canReflect.getOwnKeys(this._computed);\n            var key;\n\n            for (var i = 0; i < computedKeys.length; i++) {\n              key = computedKeys[i];\n\n              if (keys.indexOf(key) < 0) {\n                keys.push(key);\n              }\n            }\n          }\n\n          return keys;\n        }\n      }, {\n        key: Symbol.for(\"can.getOwnEnumerableKeys\"),\n        value: function value() {\n          ObservationRecorder.add(this, 'can.keys');\n          ObservationRecorder.add(Object.getPrototypeOf(this), 'can.keys');\n          return keysForDefinition(this._define.definitions).concat(keysForDefinition(this._instanceDefinitions));\n        }\n      }, {\n        key: Symbol.for(\"can.serialize\"),\n        value: function value() {\n          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n          }\n\n          return defineHelpers.reflectSerialize.apply(this, args);\n        }\n      }, {\n        key: Symbol.for(\"can.unwrap\"),\n        value: function value() {\n          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n            args[_key4] = arguments[_key4];\n          }\n\n          return defineHelpers.reflectUnwrap.apply(this, args);\n        }\n      }, {\n        key: Symbol.for(\"can.hasKey\"),\n        value: function value(key) {\n          return key in this._define.definitions || this._instanceDefinitions !== undefined && key in this._instanceDefinitions;\n        }\n      }, {\n        key: Symbol.for(\"can.updateDeep\"),\n        value: function value() {\n          return this.updateDeep.apply(this, arguments);\n        }\n      }, {\n        key: Symbol.for(\"can.isMapLike\"),\n        get: function get() {\n          return true;\n        }\n      }, {\n        key: Symbol.for(\"can.isListLike\"),\n        get: function get() {\n          return false;\n        }\n      }, {\n        key: Symbol.for(\"can.isValueLike\"),\n        get: function get() {\n          return false;\n        }\n      }], [{\n        key: getSchemaSymbol,\n        value: function value() {\n          hooks.finalizeClass(this);\n          var def = this.prototype._define;\n          var definitions = def ? def.definitions : {};\n          var schema = {\n            type: \"map\",\n            identity: [],\n            keys: {}\n          };\n          return updateSchemaKeys(schema, definitions);\n        }\n      }, {\n        key: Symbol.for(\"can.new\"),\n        value: function value() {\n          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n            args[_key5] = arguments[_key5];\n          }\n\n          return _construct(this, args);\n        }\n      }]);\n\n      return _class;\n    }(Type)\n  );\n};\n\n//# sourceURL=webpack:///./node_modules/can-observable-mixin/dist/mixin-mapprops.js?");

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/mixin-proxy.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/mixin-proxy.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar defineBehavior = __webpack_require__(/*! ./define */ \"./node_modules/can-observable-mixin/dist/define.js\");\n\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar eventDispatcher = defineBehavior.make.set.eventDispatcher;\nvar inSetupSymbol = canSymbol.for(\"can.initializing\");\n\nvar canLogDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\"); // A bug in Safari means that __proto__ key is sent. This causes problems\n// When addEventListener is called on a non-element.\n// https://github.com/tc39/test262/pull/2203\n\n\nvar isProtoReadOnSuper = false;\n\n(function () {\n  if (typeof Proxy === \"function\") {\n    var par =\n    /*#__PURE__*/\n    function () {\n      function par() {\n        _classCallCheck(this, par);\n      }\n\n      _createClass(par, [{\n        key: \"fn\",\n        value: function fn() {}\n      }]);\n\n      return par;\n    }();\n\n    var base = new Proxy(par, {\n      get: function get(t, k, r) {\n        if (k === \"__proto__\") {\n          isProtoReadOnSuper = true;\n        }\n\n        return Reflect.get(t, k, r);\n      }\n    });\n\n    var chi =\n    /*#__PURE__*/\n    function (_base) {\n      _inherits(chi, _base);\n\n      function chi() {\n        _classCallCheck(this, chi);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(chi).apply(this, arguments));\n      }\n\n      _createClass(chi, [{\n        key: \"fn\",\n        value: function fn() {\n          _get(_getPrototypeOf(chi.prototype), \"fn\", this).call(this);\n        }\n      }]);\n\n      return chi;\n    }(base);\n\n    new chi().fn();\n  }\n})();\n\nvar wasLogged = false;\n\nfunction logNotSupported() {\n  if (!wasLogged && typeof Proxy !== \"function\") {\n    wasLogged = true;\n    canLogDev.warn(\"can-observable-mixin/mixin-proxy requires ES Proxies which are not supported by your JS runtime.\");\n  }\n}\n\nfunction proxyPrototype(Base) {\n  var instances = new WeakSet();\n\n  function LateDefined() {\n    //!steal-remove-start\n    if (true) {\n      logNotSupported();\n    } //!steal-remove-end\n\n\n    var inst = Reflect.construct(Base, arguments, this instanceof LateDefined ? this.constructor : void 0);\n    instances.add(inst);\n    return inst;\n  }\n\n  var underlyingPrototypeObject = Object.create(Base.prototype);\n  var getHandler = isProtoReadOnSuper ? function (target, key, receiver) {\n    if (!this[inSetupSymbol] && _typeof(key) !== \"symbol\" && key !== \"__proto__\") {\n      ObservationRecorder.add(receiver, key);\n    }\n\n    return Reflect.get(target, key, receiver);\n  } : function (target, key, receiver) {\n    if (!this[inSetupSymbol] && _typeof(key) !== \"symbol\") {\n      ObservationRecorder.add(receiver, key);\n    }\n\n    return Reflect.get(target, key, receiver);\n  };\n  var proxyHandlers = {\n    get: getHandler,\n    set: function set(target, key, value, receiver) {\n      // Symbols are not observable, so just set the value\n      if (_typeof(key) === \"symbol\") {\n        Reflect.set(target, key, value, receiver);\n        return true;\n      } // We decided to punt on making the prototype observable, so anything\n      // set on a prototype just gets set.\n\n\n      if (key in target || !instances.has(receiver)) {\n        var current = Reflect.get(target, key, receiver);\n        Reflect.set(target, key, value, receiver);\n        eventDispatcher(receiver, key, current, value);\n      } else {\n        defineBehavior.expando(receiver, key, value);\n      }\n\n      return true;\n    }\n  };\n  LateDefined.prototype = typeof Proxy === \"function\" ? new Proxy(underlyingPrototypeObject, proxyHandlers) : underlyingPrototypeObject;\n  return LateDefined;\n}\n\nmodule.exports = proxyPrototype;\n\n//# sourceURL=webpack:///./node_modules/can-observable-mixin/dist/mixin-proxy.js?");

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/mixin-typeevents.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/mixin-typeevents.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ \"./node_modules/can-event-queue/type/type.js\");\n\nvar addMapEvents = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\n\nfunction mixinTypeEvents(Type) {\n  var Child =\n  /*#__PURE__*/\n  function (_Type) {\n    _inherits(Child, _Type);\n\n    function Child() {\n      _classCallCheck(this, Child);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Child).apply(this, arguments));\n    }\n\n    return Child;\n  }(Type);\n\n  addTypeEvents(Child);\n  addMapEvents(Child);\n  return Child;\n}\n\nmodule.exports = mixinTypeEvents;\n\n//# sourceURL=webpack:///./node_modules/can-observable-mixin/dist/mixin-typeevents.js?");

/***/ }),

/***/ "./node_modules/can-observable-mixin/dist/mixins.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-observable-mixin/dist/mixins.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createConstructorFunction = __webpack_require__(/*! ./create-constructor-function */ \"./node_modules/can-observable-mixin/dist/create-constructor-function.js\");\n\nvar defineBehavior = __webpack_require__(/*! ./define */ \"./node_modules/can-observable-mixin/dist/define.js\");\n\nvar mixinElement = __webpack_require__(/*! ./mixin-element */ \"./node_modules/can-observable-mixin/dist/mixin-element.js\");\n\nvar mixinMapProps = __webpack_require__(/*! ./mixin-mapprops */ \"./node_modules/can-observable-mixin/dist/mixin-mapprops.js\");\n\nvar mixinProxy = __webpack_require__(/*! ./mixin-proxy */ \"./node_modules/can-observable-mixin/dist/mixin-proxy.js\");\n\nvar mixinTypeEvents = __webpack_require__(/*! ./mixin-typeevents */ \"./node_modules/can-observable-mixin/dist/mixin-typeevents.js\");\n\nexports.createConstructorFunction = createConstructorFunction;\nexports.makeDefineInstanceKey = defineBehavior.makeDefineInstanceKey;\nexports.mixins = defineBehavior.hooks;\nexports.mixinElement = mixinElement;\nexports.mixinMapProps = mixinMapProps;\nexports.mixinProxy = mixinProxy;\nexports.mixinTypeEvents = mixinTypeEvents;\n\n//# sourceURL=webpack:///./node_modules/can-observable-mixin/dist/mixins.js?");

/***/ }),

/***/ "./node_modules/can-observable-object/dist/can-observable-object.js":
/*!**************************************************************************!*\
  !*** ./node_modules/can-observable-object/dist/can-observable-object.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar _require = __webpack_require__(/*! can-observable-mixin */ \"./node_modules/can-observable-mixin/dist/mixins.js\"),\n    createConstructorFunction = _require.createConstructorFunction,\n    makeDefineInstanceKey = _require.makeDefineInstanceKey,\n    mixins = _require.mixins,\n    mixinMapProps = _require.mixinMapProps,\n    mixinProxy = _require.mixinProxy,\n    mixinTypeEvents = _require.mixinTypeEvents;\n\nvar ObservableObject =\n/*#__PURE__*/\nfunction (_mixinProxy) {\n  _inherits(ObservableObject, _mixinProxy);\n\n  function ObservableObject(props) {\n    var _this;\n\n    _classCallCheck(this, ObservableObject);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ObservableObject).call(this));\n    mixins.finalizeClass(_this.constructor);\n    mixins.initialize(_assertThisInitialized(_this), props);\n    return _this;\n  }\n\n  return ObservableObject;\n}(mixinProxy(Object));\n\nObservableObject = mixinTypeEvents(mixinMapProps(ObservableObject));\nmakeDefineInstanceKey(ObservableObject); // Export a constructor function to workaround an issue where ES2015 classes\n// cannot be extended in code that's transpiled by Babel.\n\nmodule.exports = namespace.ObservableObject = createConstructorFunction(ObservableObject);\n\n//# sourceURL=webpack:///./node_modules/can-observable-object/dist/can-observable-object.js?");

/***/ }),

/***/ "./node_modules/can-observation-recorder/can-observation-recorder.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-observation-recorder/can-observation-recorder.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\n// Contains stack of observation records created by pushing with `.start`\n// and popping with `.stop()`.\n// The top of the stack is the \"target\" observation record - the record that calls\n// to `ObservationRecorder.add` get added to.\nvar stack = [];\n\nvar addParentSymbol = canSymbol.for(\"can.addParent\"),\n\tgetValueSymbol = canSymbol.for(\"can.getValue\");\n\nvar ObservationRecorder = {\n\tstack: stack,\n\tstart: function(name) {\n\t\tvar deps = {\n\t\t\tkeyDependencies: new Map(),\n\t\t\tvalueDependencies: new Set(),\n\t\t\tchildDependencies: new Set(),\n\n\t\t\t// `traps` and `ignore` are here only for performance\n\t\t\t// reasons. They work with `ObservationRecorder.ignore` and `ObservationRecorder.trap`.\n\t\t\ttraps: null,\n\t\t\tignore: 0,\n\t\t\tname: name\n\t\t};\n\n\t\tstack.push(deps);\n\n\t\treturn deps;\n\t},\n\tstop: function() {\n\t\treturn stack.pop();\n\t},\n\n\tadd: function(obj, event) {\n\t\tvar top = stack[stack.length - 1];\n\t\tif (top && top.ignore === 0) {\n\n\t\t\tif (top.traps) {\n\t\t\t\ttop.traps.push([obj, event]);\n\t\t\t} else {\n\t\t\t\t// Use `=== undefined` instead of `arguments.length` for performance.\n\t\t\t\tif (event === undefined) {\n\t\t\t\t\ttop.valueDependencies.add(obj);\n\t\t\t\t} else {\n\t\t\t\t\tvar eventSet = top.keyDependencies.get(obj);\n\t\t\t\t\tif (!eventSet) {\n\t\t\t\t\t\teventSet = new Set();\n\t\t\t\t\t\ttop.keyDependencies.set(obj, eventSet);\n\t\t\t\t\t}\n\t\t\t\t\teventSet.add(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\taddMany: function(observes) {\n\t\tvar top = stack[stack.length - 1];\n\t\tif (top) {\n\t\t\tif (top.traps) {\n\t\t\t\ttop.traps.push.apply(top.traps, observes);\n\t\t\t} else {\n\t\t\t\tfor (var i = 0, len = observes.length; i < len; i++) {\n\t\t\t\t\tthis.add(observes[i][0], observes[i][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcreated: function(obs) {\n\t\tvar top = stack[stack.length - 1];\n\t\tif (top) {\n\t\t\ttop.childDependencies.add(obs);\n\t\t\tif (obs[addParentSymbol]) {\n\t\t\t\tobs[addParentSymbol](top);\n\t\t\t}\n\t\t}\n\t},\n\tignore: function(fn) {\n\t\treturn function() {\n\t\t\tif (stack.length) {\n\t\t\t\tvar top = stack[stack.length - 1];\n\t\t\t\ttop.ignore++;\n\t\t\t\tvar res = fn.apply(this, arguments);\n\t\t\t\ttop.ignore--;\n\t\t\t\treturn res;\n\t\t\t} else {\n\t\t\t\treturn fn.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t},\n\tpeekValue: function(value) {\n\t\tif(!value || !value[getValueSymbol]) {\n\t\t\treturn value;\n\t\t}\n\t\tif (stack.length) {\n\t\t\tvar top = stack[stack.length - 1];\n\t\t\ttop.ignore++;\n\t\t\tvar res = value[getValueSymbol]();\n\t\t\ttop.ignore--;\n\t\t\treturn res;\n\t\t} else {\n\t\t\treturn value[getValueSymbol]();\n\t\t}\n\t},\n\tisRecording: function() {\n\t\tvar len = stack.length;\n\t\tvar last = len && stack[len - 1];\n\t\treturn last && (last.ignore === 0) && last;\n\t},\n\t// `can-observation` uses this to do diffs more easily.\n\tmakeDependenciesRecord: function(name) {\n\t\treturn {\n\t\t\ttraps: null,\n\t\t\tkeyDependencies: new Map(),\n\t\t\tvalueDependencies: new Set(),\n\t\t\t//childDependencies: new Set(),\n\t\t\tignore: 0,\n\t\t\tname: name\n\t\t};\n\t},\n\t// The following are legacy methods we should do away with.\n\tmakeDependenciesRecorder: function() {\n\t\treturn ObservationRecorder.makeDependenciesRecord();\n\t},\n\t// Traps should be replace by calling `.start()` and `.stop()`.\n\t// To do this, we'd need a method that accepts a dependency record.\n\ttrap: function() {\n\t\tif (stack.length) {\n\t\t\tvar top = stack[stack.length - 1];\n\t\t\tvar oldTraps = top.traps;\n\t\t\tvar traps = top.traps = [];\n\t\t\treturn function() {\n\t\t\t\ttop.traps = oldTraps;\n\t\t\t\treturn traps;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function() {\n\t\t\t\treturn [];\n\t\t\t};\n\t\t}\n\t},\n\ttrapsCount: function() {\n\t\tif (stack.length) {\n\t\t\tvar top = stack[stack.length - 1];\n\t\t\treturn top.traps.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n};\n\nif (namespace.ObservationRecorder) {\n\tthrow new Error(\"You can't have two versions of can-observation-recorder, check your dependencies\");\n} else {\n\tmodule.exports = namespace.ObservationRecorder = ObservationRecorder;\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-observation-recorder/can-observation-recorder.js?");

/***/ }),

/***/ "./node_modules/can-observation/can-observation.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-observation/can-observation.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* global require */\n// # can-observation\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"./node_modules/can-event-queue/value/value.js\");\n\nvar recorderHelpers = __webpack_require__(/*! ./recorder-dependency-helpers */ \"./node_modules/can-observation/recorder-dependency-helpers.js\");\nvar temporarilyBind = __webpack_require__(/*! ./temporarily-bind */ \"./node_modules/can-observation/temporarily-bind.js\");\n\nvar dispatchSymbol = canSymbol.for(\"can.dispatch\");\nvar getChangesSymbol = canSymbol.for(\"can.getChangesDependencyRecord\");\nvar getValueDependenciesSymbol = canSymbol.for(\"can.getValueDependencies\");\n\n// ## Observation constructor\nfunction Observation(func, context, options){\n\tthis.deriveQueue = queues.deriveQueue;\n\n\tthis.func = func;\n\tthis.context = context;\n\tthis.options = options || {priority: 0, isObservable: true};\n\t// A flag if we are bound or not\n\tthis.bound = false;\n\n\t// Set _value to undefined so can-view-scope & can-compute can check for it\n\tthis._value = undefined;\n\n\t// These properties will manage what our new and old dependencies are.\n\tthis.newDependencies = ObservationRecorder.makeDependenciesRecord();\n\tthis.oldDependencies = null;\n\n\t// Make functions we need to pass around and maintain `this`.\n\tvar self = this;\n\tthis.onDependencyChange = function(newVal){\n\t\tself.dependencyChange(this, newVal);\n\t};\n\tthis.update = this.update.bind(this);\n\n\n\t// Add debugging names.\n\t//!steal-remove-start\n\tif (true) {\n\t\tthis.onDependencyChange[getChangesSymbol] = function getChanges() {\n\t\t\tvar s = new Set();\n\t\t\ts.add(self);\n\t\t\treturn {\n\t\t\t\tvalueDependencies: s\n\t\t\t};\n\t\t};\n\t\tObject.defineProperty(this.onDependencyChange, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".onDependencyChange\",\n\t\t});\n\t\tObject.defineProperty(this.update, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".update\",\n\t\t});\n\t\tthis._name = canReflect.getName(this); // cached for performance\n\t}\n\t//!steal-remove-end\n}\n\n// ## Observation prototype methods\n\n// Mixin value event bindings. This is where the following are added:\n// - `.handlers` which call `onBound` and `onUnbound`\n// - `.on` / `.off`\n// - `can.onValue` `can.offValue`\n// - `can.getWhatIChange`\nvalueEventBindings(Observation.prototype);\n\ncanReflect.assign(Observation.prototype, {\n\t// Starts observing changes and adds event listeners.\n\tonBound: function(){\n\t\tthis.bound = true;\n\n\t\t// Store the old dependencies\n\t\tthis.oldDependencies = this.newDependencies;\n\t\t// Start recording dependencies.\n\t\tObservationRecorder.start(this._name);\n\t\t// Call the observation's function and update the new value.\n\t\tthis._value = this.func.call(this.context);\n\t\t// Get the new dependencies.\n\t\tthis.newDependencies = ObservationRecorder.stop();\n\n\t\t// Diff and update the bindings. On change, everything will call\n\t\t// `this.onDependencyChange`, which calls `this.dependencyChange`.\n\t\trecorderHelpers.updateObservations(this);\n\t},\n\t// This is called when any of the dependencies change.\n\t// It queues up an update in the `deriveQueue` to be run after all source\n\t// observables have had time to notify all observables that \"derive\" their value.\n\tdependencyChange: function(context, args){\n\t\tif(this.bound === true) {\n\t\t\tvar queuesArgs = [];\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.update,\n\t\t\t\tthis,\n\t\t\t\t[],\n\t\t\t\t{\n\t\t\t\t\tpriority: this.options.priority,\n\t\t\t\t\telement: this.options.element\n\t\t\t\t}\n\t\t\t];\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tqueuesArgs = [\n\t\t\t\t\tthis.update,\n\t\t\t\t\tthis,\n\t\t\t\t\t[],\n\t\t\t\t\t{\n\t\t\t\t\t\tpriority: this.options.priority,\n\t\t\t\t\t\telement: this.options.element\n\t\t\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t\t\t, log: [ canReflect.getName(this.update) ]\n\t\t\t\t\t\t/* jshint laxcomma: false */\n\t\t\t\t\t}\n\t\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t\t, [canReflect.getName(context), \"changed\"]\n\t\t\t\t\t/* jshint laxcomma: false */\n\t\t\t\t];\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t// Update this observation after all `notify` tasks have been run.\n\t\t\tthis.deriveQueue.enqueue.apply(this.deriveQueue, queuesArgs);\n\t\t}\n\t},\n\t// Called to update its value as part of the `derive` queue.\n\tupdate: function() {\n\t\tif (this.bound === true) {\n\t\t\t// Keep the old value.\n\t\t\tvar oldValue = this._value;\n\t\t\tthis.oldValue = null;\n\t\t\t// Re-run `this.func` and update dependency bindings.\n\t\t\tthis.onBound();\n\t\t\t// If our value changed, call the `dispatch` method provided by `can-event-queue/value/value`.\n\t\t\tif (oldValue !== this._value) {\n\t\t\t\tthis[dispatchSymbol](this._value, oldValue);\n\t\t\t}\n\t\t}\n\t},\n\t// Called when nothing is bound to this observation.\n\t// Removes all event listeners on all dependency observables.\n\tonUnbound: function(){\n\t\tthis.bound = false;\n\t\trecorderHelpers.stopObserving(this.newDependencies, this.onDependencyChange);\n\t\t// Setup newDependencies in case someone binds again to this observable.\n\t\tthis.newDependencies = ObservationRecorder.makeDependenciesRecord();\n\t},\n\t// Reads the value of the observation.\n\tget: function(){\n\n\t\t// If an external observation is tracking observables and\n\t\t// this compute can be listened to by \"function\" based computes ....\n\t\tif( this.options.isObservable && ObservationRecorder.isRecording() ) {\n\n\t\t\t// ... tell the tracking compute to listen to change on this observation.\n\t\t\tObservationRecorder.add(this);\n\t\t\t// ... if we are not bound, we should bind so that\n\t\t\t// we don't have to re-read to get the value of this observation.\n\t\t\tif (this.bound === false) {\n\t\t\t\tObservation.temporarilyBind(this);\n\t\t\t}\n\n\t\t}\n\n\n\t\tif(this.bound === true ) {\n\t\t\t// It's possible that a child dependency of this observable might be queued\n\t\t\t// to change. Check all child dependencies and make sure they are up-to-date by\n\t\t\t// possibly running what they have registered in the derive queue.\n\t\t\tif(this.deriveQueue.tasksRemainingCount() > 0) {\n\t\t\t\tObservation.updateChildrenAndSelf(this);\n\t\t\t}\n\n\t\t\treturn this._value;\n\t\t} else {\n\t\t\t// If we are not bound, just call the function.\n\t\t\treturn this.func.call(this.context);\n\t\t}\n\t},\n\n\thasDependencies: function(){\n\t\tvar newDependencies = this.newDependencies;\n\t\treturn this.bound ?\n\t\t\t(newDependencies.valueDependencies.size + newDependencies.keyDependencies.size) > 0  :\n\t\t\tundefined;\n\t},\n\tlog: function() {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tvar quoteString = function quoteString(x) {\n\t\t\t\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n\t\t\t};\n\t\t\tthis._log = function(previous, current) {\n\t\t\t\tdev.log(\n\t\t\t\t\tcanReflect.getName(this),\n\t\t\t\t\t\"\\n is  \", quoteString(current),\n\t\t\t\t\t\"\\n was \", quoteString(previous)\n\t\t\t\t);\n\t\t\t};\n\t\t}\n\t\t//!steal-remove-end\n\t}\n});\n\nObject.defineProperty(Observation.prototype, \"value\", {\n\tget: function() {\n\t\treturn this.get();\n\t}\n});\n\nvar observationProto = {\n\t\"can.getValue\": Observation.prototype.get,\n\t\"can.isValueLike\": true,\n\t\"can.isMapLike\": false,\n\t\"can.isListLike\": false,\n\t\"can.valueHasDependencies\": Observation.prototype.hasDependencies,\n\t\"can.getValueDependencies\": function(){\n\t\tif (this.bound === true) {\n\t\t\t// Only provide `keyDependencies` and `valueDependencies` properties\n\t\t\t// if there's actually something there.\n\t\t\tvar deps = this.newDependencies,\n\t\t\t\tresult = {};\n\n\t\t\tif (deps.keyDependencies.size) {\n\t\t\t\tresult.keyDependencies = deps.keyDependencies;\n\t\t\t}\n\n\t\t\tif (deps.valueDependencies.size) {\n\t\t\t\tresult.valueDependencies = deps.valueDependencies;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\treturn undefined;\n\t},\n\t\"can.getPriority\": function(){\n\t\treturn this.options.priority;\n\t},\n\t\"can.setPriority\": function(priority){\n\t\tthis.options.priority = priority;\n\t},\n\t\"can.setElement\": function(element) {\n\t\tthis.options.element = element;\n\t\tthis.deriveQueue = queues.domQueue || queues.deriveQueue;\n\t}\n};\n\n//!steal-remove-start\nif (true) {\n\tobservationProto[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"<\" + canReflect.getName(this.func) + \">\";\n\t};\n}\n//!steal-remove-end\ncanReflect.assignSymbols(Observation.prototype, observationProto);\n\n// ## Observation.updateChildrenAndSelf\n// This recursively checks if an observation's dependencies might be in the `derive` queue.\n// If it is, we need to update that value so the reading of this value will be correct.\n// This can happen if an observation suddenly switches to depending on something that has higher\n// priority than itself.  We need to make sure that value is completely updated.\nObservation.updateChildrenAndSelf = function(observation){\n\t// If the observable has an `update` method and it's enqueued, flush that task immediately so\n\t// the value is right.\n\t// > NOTE: This only works for `Observation` right now.  We need a way of knowing how\n\t// > to find what an observable might have in the `deriveQueue`.\n\tif(observation.update !== undefined && observation.deriveQueue.isEnqueued( observation.update ) === true) {\n\t\t// TODO: In the future, we should be able to send log information\n\t\t// to explain why this needed to be updated.\n\t\tobservation.deriveQueue.flushQueuedTask(observation.update);\n\t\treturn true;\n\t}\n\n\t// If we can get dependency values from this observable ...\n\tif(observation[getValueDependenciesSymbol]) {\n\t\t// ... Loop through each dependency and see if any of them (or their children) needed an update.\n\t\tvar childHasChanged = false;\n\t\tvar valueDependencies = observation[getValueDependenciesSymbol]().valueDependencies || [];\n\t\tvalueDependencies.forEach(function(observable){\n\t\t\tif( Observation.updateChildrenAndSelf( observable ) === true) {\n\t\t\t\tchildHasChanged = true;\n\t\t\t}\n\t\t});\n\t\treturn childHasChanged;\n\t} else {\n\t\treturn false;\n\t}\n};\n\n// ## Legacy Stuff\n// Warn when `ObservationRecorder` methods are called on `Observation`.\nvar alias = {addAll: \"addMany\"};\n[\"add\",\"addAll\",\"ignore\",\"trap\",\"trapsCount\",\"isRecording\"].forEach(function(methodName){\n\tObservation[methodName] = function(){\n\t\tvar name = alias[methodName] ? alias[methodName] : methodName;\n\t\tconsole.warn(\"can-observation: Call \"+name+\"() on can-observation-recorder.\");\n\t\treturn ObservationRecorder[name].apply(this, arguments);\n\t};\n});\nObservation.prototype.start = function(){\n\tconsole.warn(\"can-observation: Use .on and .off to bind.\");\n\treturn this.onBound();\n};\nObservation.prototype.stop = function(){\n\tconsole.warn(\"can-observation: Use .on and .off to bind.\");\n\treturn this.onUnbound();\n};\n\n// ### temporarilyBind\n// Will bind an observable value temporarily.  This should be part of queues probably.\nObservation.temporarilyBind = temporarilyBind;\n\n\nmodule.exports = namespace.Observation = Observation;\n\n\n//# sourceURL=webpack:///./node_modules/can-observation/can-observation.js?");

/***/ }),

/***/ "./node_modules/can-observation/recorder-dependency-helpers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-observation/recorder-dependency-helpers.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # Recorder Dependency Helpers\n// This exposes two helpers:\n// - `updateObservations` - binds and unbinds a diff of two observation records\n//   (see can-observation-recorder for details on this data type).\n// - `stopObserving` - unbinds an observation record.\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\n\n\n// ## Helpers\n// The following helpers all use `this` to pass additional arguments. This\n// is for performance reasons as it avoids creating new functions.\n\nfunction addNewKeyDependenciesIfNotInOld(event) {\n    // Expects `this` to have:\n    // - `.observable` - the observable we might be binding to.\n    // - `.oldEventSet` - the bound keys on the old dependency record for `observable`.\n    // - `.onDependencyChange` - the handler we will call back when the key is changed.\n    // If there wasn't any keys, or when we tried to delete we couldn't because the key\n    // wasn't in the set, start binding.\n    if(this.oldEventSet === undefined || this.oldEventSet[\"delete\"](event) === false) {\n        canReflect.onKeyValue(this.observable, event, this.onDependencyChange,\"notify\");\n    }\n}\n\n// ### addObservablesNewKeyDependenciesIfNotInOld\n// For each event in the `eventSet` of new observables,\n// setup a binding (or delete the key).\nfunction addObservablesNewKeyDependenciesIfNotInOld(eventSet, observable){\n    eventSet.forEach(addNewKeyDependenciesIfNotInOld, {\n        onDependencyChange: this.onDependencyChange,\n        observable: observable,\n        oldEventSet: this.oldDependencies.keyDependencies.get(observable)\n    });\n}\n\nfunction removeKeyDependencies(event) {\n    canReflect.offKeyValue(this.observable, event, this.onDependencyChange,\"notify\");\n}\n\nfunction removeObservablesKeyDependencies(oldEventSet, observable){\n    oldEventSet.forEach(removeKeyDependencies, {onDependencyChange: this.onDependencyChange, observable: observable});\n}\n\nfunction addValueDependencies(observable) {\n    // If we were unable to delete the key in the old set, setup a binding.\n    if(this.oldDependencies.valueDependencies.delete(observable) === false) {\n        canReflect.onValue(observable, this.onDependencyChange,\"notify\");\n    }\n}\nfunction removeValueDependencies(observable) {\n    canReflect.offValue(observable, this.onDependencyChange,\"notify\");\n}\n\n\nmodule.exports = {\n    // ## updateObservations\n    //\n    // Binds `observationData.onDependencyChange` to dependencies in `observationData.newDependencies` that are not currently in\n    // `observationData.oldDependencies`.  Anything in `observationData.oldDependencies`\n    // left over is unbound.\n    //\n    // The algorthim works by:\n    // 1. Loop through the `new` dependencies, checking if an equivalent is in the `old` bindings.\n    //    - If there is an equivalent binding, delete that dependency from `old`.\n    //    - If there is __not__ an equivalent binding, setup a binding from that dependency to `.onDependencyChange`.\n    // 2. Loop through the remaining `old` dependencies, teardown bindings.\n    //\n    // For performance, this method mutates the values in `.oldDependencies`.\n    updateObservations: function(observationData){\n        observationData.newDependencies.keyDependencies.forEach(addObservablesNewKeyDependenciesIfNotInOld, observationData);\n        observationData.oldDependencies.keyDependencies.forEach(removeObservablesKeyDependencies, observationData);\n        observationData.newDependencies.valueDependencies.forEach(addValueDependencies, observationData);\n        observationData.oldDependencies.valueDependencies.forEach(removeValueDependencies, observationData);\n    },\n    stopObserving: function(observationReciever, onDependencyChange){\n        observationReciever.keyDependencies.forEach(removeObservablesKeyDependencies, {onDependencyChange: onDependencyChange});\n        observationReciever.valueDependencies.forEach(removeValueDependencies, {onDependencyChange: onDependencyChange});\n    }\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-observation/recorder-dependency-helpers.js?");

/***/ }),

/***/ "./node_modules/can-observation/temporarily-bind.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-observation/temporarily-bind.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar temporarilyBoundNoOperation = function(){};\n// A list of temporarily bound computes\nvar observables;\n// Unbinds all temporarily bound computes.\nvar unbindTemporarilyBoundValue = function () {\n\tfor (var i = 0, len = observables.length; i < len; i++) {\n\t\tcanReflect.offValue(observables[i], temporarilyBoundNoOperation);\n\t}\n\tobservables = null;\n};\n\n// ### temporarilyBind\n// Binds computes for a moment to cache their value and prevent re-calculating it.\nfunction temporarilyBind(compute) {\n\tvar computeInstance = compute.computeInstance || compute;\n\tcanReflect.onValue(computeInstance, temporarilyBoundNoOperation);\n\tif (!observables) {\n\t\tobservables = [];\n\t\tsetTimeout(unbindTemporarilyBoundValue, 10);\n\t}\n\tobservables.push(computeInstance);\n}\n\nmodule.exports = temporarilyBind;\n\n\n//# sourceURL=webpack:///./node_modules/can-observation/temporarily-bind.js?");

/***/ }),

/***/ "./node_modules/can-observe/array/array.js":
/*!*************************************************!*\
  !*** ./node_modules/can-observe/array/array.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ## can-observe/array/array\n//\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar makeArray = __webpack_require__(/*! ../src/-make-array */ \"./node_modules/can-observe/src/-make-array.js\");\nvar makeObserve = __webpack_require__(/*! ../src/-make-observe */ \"./node_modules/can-observe/src/-make-observe.js\");\nvar eventMixin = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar typeEventMixin = __webpack_require__(/*! can-event-queue/type/type */ \"./node_modules/can-event-queue/type/type.js\");\nvar helpers = __webpack_require__(/*! ../src/-helpers */ \"./node_modules/can-observe/src/-helpers.js\");\nvar observableStore = __webpack_require__(/*! ../src/-observable-store */ \"./node_modules/can-observe/src/-observable-store.js\");\nvar computedHelpers = __webpack_require__(/*! ../src/-computed-helpers */ \"./node_modules/can-observe/src/-computed-helpers.js\");\nvar typeHelpers = __webpack_require__(/*! ../src/-type-helpers */ \"./node_modules/can-observe/src/-type-helpers.js\");\n\nvar definitionsSymbol = canSymbol.for(\"can.typeDefinitions\");\n\n// Setup proxyKeys to look for observations when doing onKeyValue and offKeyValue\nvar proxyKeys = helpers.assignEverything({},makeArray.proxyKeys());\n\nvar ObserveArray;\nif ( /*helpers.supportsClass*/ false) {} else {\n\n    var ObserveArray = function(items) {\n        var prototype = Object.getPrototypeOf(this);\n\n        computedHelpers.ensureDefinition(prototype);\n        typeHelpers.ensureDefinition(prototype);\n\n        var instance = this;\n        var definitions = prototype[definitionsSymbol] || {};\n        for (var key in definitions) {\n            Object.defineProperty(instance, key, definitions[key]);\n        }\n        this.push.apply(this, items || []);\n\n        var localProxyKeys = Object.create(proxyKeys);\n        localProxyKeys.constructor = this.constructor;\n\n        var observable = makeArray.observable(instance, {\n            observe: makeObserve.observe,\n            proxyKeys: localProxyKeys,\n            shouldRecordObservation: typeHelpers.shouldRecordObservationOnAllKeysExceptFunctionsOnProto\n        });\n        observableStore.proxiedObjects.set(instance, observable);\n        observableStore.proxies.add(observable);\n        return observable;\n    };\n    ObserveArray.prototype = Object.create(Array.prototype);\n}\n\neventMixin(ObserveArray.prototype);\ntypeEventMixin(ObserveArray);\ncomputedHelpers.addMethodsAndSymbols(ObserveArray);\ntypeHelpers.addMethodsAndSymbols(ObserveArray);\n\nObserveArray.extend = helpers.makeSimpleExtender(ObserveArray);\n\n\n\nmodule.exports = ObserveArray;\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/array/array.js?");

/***/ }),

/***/ "./node_modules/can-observe/can-observe.js":
/*!*************************************************!*\
  !*** ./node_modules/can-observe/can-observe.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # can-observe.js\n// Assembles the final observe export.\nvar makeObject = __webpack_require__(/*! ./src/-make-object */ \"./node_modules/can-observe/src/-make-object.js\");\nvar makeArray = __webpack_require__(/*! ./src/-make-array */ \"./node_modules/can-observe/src/-make-array.js\");\nvar makeFunction = __webpack_require__(/*! ./src/-make-function */ \"./node_modules/can-observe/src/-make-function.js\");\nvar makeObserve = __webpack_require__(/*! ./src/-make-observe */ \"./node_modules/can-observe/src/-make-observe.js\");\nvar makePrototype = __webpack_require__(/*! ./src/-make-prototype */ \"./node_modules/can-observe/src/-make-prototype.js\");\nvar ObserveObject = __webpack_require__(/*! ./object/object */ \"./node_modules/can-observe/object/object.js\");\nvar ObserveArray = __webpack_require__(/*! ./array/array */ \"./node_modules/can-observe/array/array.js\");\n\nvar computedHelpers = __webpack_require__(/*! ./src/-computed-helpers */ \"./node_modules/can-observe/src/-computed-helpers.js\");\nvar decorators = __webpack_require__(/*! ./decorators/decorators */ \"./node_modules/can-observe/decorators/decorators.js\");\n\nmakeObserve.object = function(object) {\n\treturn makeObject.observable(object, makeObserve);\n};\nmakeObserve.prototype = function(proto) {\n\treturn makePrototype.observable(proto, makeObserve);\n};\nmakeObserve.array = function(array) {\n\treturn makeArray.observable(array, makeObserve);\n};\nmakeObserve.function = function(fn) {\n\treturn makeFunction.observable(fn, makeObserve);\n};\nmakeObserve.observe.Object = ObserveObject;\nmakeObserve.observe.Array = ObserveArray;\n\nmodule.exports = makeObserve.observe;\n\nmodule.exports.defineProperty = function(prototype, prop, makeObservable) {\n\tcomputedHelpers.ensureDefinition(prototype)[prop] = makeObservable;\n};\n\nfor (var key in decorators) {\n\tmodule.exports[key] = decorators[key];\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/can-observe.js?");

/***/ }),

/***/ "./node_modules/can-observe/decorators/decorators.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-observe/decorators/decorators.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar AsyncObservable = __webpack_require__(/*! can-simple-observable/async/async */ \"./node_modules/can-simple-observable/async/async.js\");\nvar ResolverObservable = __webpack_require__(/*! can-simple-observable/resolver/resolver */ \"./node_modules/can-simple-observable/resolver/resolver.js\");\n\nvar computedHelpers = __webpack_require__(/*! ../src/-computed-helpers */ \"./node_modules/can-observe/src/-computed-helpers.js\");\nfunction defineProperty(prototype, prop, makeObservable) {\n\tcomputedHelpers.ensureDefinition(prototype)[prop] = makeObservable;\n}\n\nfunction asyncBase(config) {\n\treturn function(target, key, descriptor) {\n\t\tif (descriptor.get !== undefined) {\n\t\t\tvar getter = descriptor.get;\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tif (getter.length !== 0) {\n\t\t\t\t\tthrow new Error(\"async decorated \" + key + \" on \" + canReflect.getName(target) + \": getters should take no arguments.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn defineProperty(target, key, function(instance, property) {\n\t\t\t\tfunction fn(lastSet, resolve) {\n\t\t\t\t\tif (!resolve) {\n\t\t\t\t\t\treturn config.default;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar promise = getter.call(this, true);\n\t\t\t\t\tif (canReflect.isPromise(promise)) {\n\t\t\t\t\t\tpromise.then(resolve);\n\t\t\t\t\t\treturn config.default;\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\telse if (promise !== undefined) {\n\t\t\t\t\t\tif(true) {\n\t\t\t\t\t\t\tthrow new Error(\"async decorated \" + key + \" on \" + canReflect.getName(target) + \": getters must return undefined or a promise.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t}\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tcanReflect.assignSymbols(fn, {\n\t\t\t\t\t\t\"can.getName\": function() {\n\t\t\t\t\t\t\treturn canReflect.getName(getter) + \": getter\";\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\treturn new AsyncObservable(fn, instance, config.default);\n\t\t\t});\n\t\t}\n\n\t\tif (descriptor.value !== undefined) {\n\t\t\tvar method = descriptor.value;\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tif (method.length !== 1) {\n\t\t\t\t\tthrow new Error(\"async decorated \" + key + \" on \" + canReflect.getName(target) + \": methods should take 1 argument (resolve).\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn defineProperty(target, key, function(instance, property) {\n\t\t\t\treturn new AsyncObservable(function(lastSet, resolve) {\n\t\t\t\t\treturn method.call(this, resolve);\n\t\t\t\t}, instance, config.default);\n\t\t\t});\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthrow new Error(\"async decorated \" + key + \" on \" + canReflect.getName(target) + \": Unrecognized descriptor.\");\n\t\t}\n\t\t//!steal-remove-end\n\t};\n}\n\nfunction resolverBase(config) {\n\treturn function(target, key, descriptor) {\n\t\tif (descriptor.value !== undefined) {\n\t\t\tvar method = descriptor.value;\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tif (method.length !== 1) {\n\t\t\t\t\tthrow new Error(\"resolver decorated \" + key + \" on \" + canReflect.getName(target) + \": methods should take 1 argument (value).\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn defineProperty(target, key, function(instance, property) {\n\t\t\t\treturn new ResolverObservable(method, instance);\n\t\t\t});\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthrow new Error(\"resolver decorated \" + key + \" on \" + canReflect.getName(target) + \": Unrecognized descriptor.\");\n\t\t}\n\t\t//!steal-remove-end\n\t};\n}\n\nfunction optionalConfig(decorator) {\n\tfunction wrapper(config) {\n\t\tif (arguments.length === 3) {\n\t\t\treturn decorator({}).apply(null, arguments);\n\t\t}\n\n\t\treturn decorator(config);\n\t}\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tObject.defineProperty(wrapper, \"name\", {\n\t\t\tvalue: canReflect.getName(decorator.name)\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\treturn wrapper;\n}\n\nmodule.exports = {\n\tasync: optionalConfig(asyncBase),\n\tresolver: optionalConfig(resolverBase),\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/decorators/decorators.js?");

/***/ }),

/***/ "./node_modules/can-observe/object/object.js":
/*!***************************************************!*\
  !*** ./node_modules/can-observe/object/object.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar makeObserve = __webpack_require__(/*! ../src/-make-observe */ \"./node_modules/can-observe/src/-make-observe.js\");\nvar eventMixin = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar typeEventMixin = __webpack_require__(/*! can-event-queue/type/type */ \"./node_modules/can-event-queue/type/type.js\");\nvar helpers = __webpack_require__(/*! ../src/-helpers */ \"./node_modules/can-observe/src/-helpers.js\");\nvar makeObject = __webpack_require__(/*! ../src/-make-object */ \"./node_modules/can-observe/src/-make-object.js\");\nvar observableStore = __webpack_require__(/*! ../src/-observable-store */ \"./node_modules/can-observe/src/-observable-store.js\");\nvar definitionsSymbol = canSymbol.for(\"can.typeDefinitions\");\nvar computedHelpers = __webpack_require__(/*! ../src/-computed-helpers */ \"./node_modules/can-observe/src/-computed-helpers.js\");\nvar typeHelpers = __webpack_require__(/*! ../src/-type-helpers */ \"./node_modules/can-observe/src/-type-helpers.js\");\n\n// Setup proxyKeys to look for observations when doing onKeyValue and offKeyValue\nvar proxyKeys = helpers.assignEverything({},makeObject.proxyKeys());\ncomputedHelpers.addKeyDependencies(proxyKeys);\n\n// ## ObserveObject constructor function\n// Works by returning the proxy-wrapped instance.\nvar ObserveObject = function(props) {\n    var prototype = Object.getPrototypeOf(this);\n\n    computedHelpers.ensureDefinition(prototype);\n    typeHelpers.ensureDefinition(prototype);\n\n    // Define expando properties from `can.defineInstanceProperty`\n    var sourceInstance = this;\n    var definitions = prototype[definitionsSymbol] || {};\n    for (var key in definitions) {\n        Object.defineProperty(sourceInstance, key, definitions[key]);\n    }\n    // Add properties passed to the constructor.\n    if (props !== undefined) {\n        canReflect.assign(sourceInstance, props);\n    }\n    // Create a copy of the proxy keys\n    var localProxyKeys = Object.create(proxyKeys);\n\n    // Make sure that the .constructor property isn't proxied.  If it was,\n    // `this.constructor` would not be the type.\n    localProxyKeys.constructor = this.constructor;\n\n    // Wrap the sourceInstance\n    var observable = makeObject.observable(sourceInstance, {\n        observe: makeObserve.observe,\n        proxyKeys: localProxyKeys,\n        shouldRecordObservation: typeHelpers.shouldRecordObservationOnAllKeysExceptFunctionsOnProto\n    });\n    // Add the proxy to the stores.\n    observableStore.proxiedObjects.set(sourceInstance, observable);\n    observableStore.proxies.add(observable);\n    return observable;\n};\n\neventMixin(ObserveObject.prototype);\ntypeEventMixin(ObserveObject);\ncomputedHelpers.addMethodsAndSymbols(ObserveObject);\ntypeHelpers.addMethodsAndSymbols(ObserveObject);\n\n// Allows this to be extended w/o `class`\nObserveObject.extend = helpers.makeSimpleExtender(ObserveObject);\n\n\n\nmodule.exports = ObserveObject;\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/object/object.js?");

/***/ }),

/***/ "./node_modules/can-observe/src/-computed-helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-observe/src/-computed-helpers.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar mapBindings = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canMeta = canSymbol.for(\"can.meta\");\nvar computedPropertyDefinitionSymbol = canSymbol.for(\"can.computedPropertyDefinitions\");\nvar onKeyValueSymbol = canSymbol.for(\"can.onKeyValue\");\nvar offKeyValueSymbol = canSymbol.for(\"can.offKeyValue\");\n// var getKeyDependenciesSymbol = canSymbol.for(\"can.getKeyDependencies\");\n\n// ## ComputedObjectObservationData\n// Instances of this are created to wrap the observation.\n// The `.bind` and `.unbind` methods should be called when the\n// instance's prop is bound or unbound.\nfunction ComputedObjectObservationData(instance, prop, observation){\n\tthis.instance = instance;\n    this.prop = prop;\n    this.observation = observation;\n\tthis.forward = this.forward.bind(this);\n}\n\nComputedObjectObservationData.prototype.bind = function(){\n    this.bindingCount++;\n    if(this.bindingCount === 1) {\n        this.observation.on(this.forward, \"notify\");\n    }\n};\n\nComputedObjectObservationData.prototype.unbind = function(){\n    this.bindingCount--;\n    if(this.bindingCount === 0) {\n        this.observation.off(this.forward, \"notify\");\n    }\n};\n\nComputedObjectObservationData.prototype.forward = function(newValue, oldValue){\n\tmapBindings.dispatch.call(this.instance, {\n\t\ttype: this.prop,\n\t\ttarget: this.instance\n\n\t\t// patches: [{\n\t\t// \tkey: this.prop,\n\t\t// \ttype: \"set\",\n\t\t// \tvalue: newValue\n\t\t// }]\n\t\t// keyChanged: undefined\n\t}, [newValue, oldValue]);\n};\n\nComputedObjectObservationData.prototype.bindingCount = 0;\n\nfunction findComputed(instance, key) {\n\tvar meta = instance[canMeta];\n\tvar target = meta.target;\n\n\tvar computedPropertyDefinitions = target[computedPropertyDefinitionSymbol];\n\tif (computedPropertyDefinitions === undefined) {\n\t\treturn;\n\t}\n\tvar computedPropertyDefinition = computedPropertyDefinitions[key];\n\tif (computedPropertyDefinition === undefined) {\n\t\treturn;\n\t}\n\n\tif (meta.computedKeys[key] === undefined) {\n\t\tmeta.computedKeys[key] = new ComputedObjectObservationData(\n\t\t\tinstance, key,\n\t\t\tcomputedPropertyDefinition(instance, key)\n\t\t);\n\t}\n\n\treturn meta.computedKeys[key];\n}\n\nvar computedHelpers = module.exports = {\n\tget: function(instance, key) {\n\t\tvar computedObj = findComputed(instance, key);\n\t\tif (computedObj === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tObservationRecorder.add(instance, key.toString());\n\t\tif(computedObj.bindingCount === 0 && ObservationRecorder.isRecording()) {\n\t\t\tObservation.temporarilyBind(computedObj.observation);\n\t\t}\n\n\t\treturn {\n\t\t\tvalue: canReflect.getValue(computedObj.observation),\n\t\t};\n\t},\n\tset: function(instance, key, value) {\n\t\tvar computedObj = findComputed(instance, key);\n\t\tif (computedObj === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif (computedObj.observation[canSymbol.for(\"can.setValue\")] === undefined) {\n\t\t\t\tthrow new Error(\"Cannot set \\\"\" + key + \"\\\" on \" + canReflect.getName(instance));\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tcanReflect.setValue(computedObj.observation, value);\n\t\treturn true;\n\t},\n\tbind: function(instance, key) {\n\t\tvar computedObj = findComputed(instance, key);\n\t\tif (computedObj === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tcomputedObj.bind();\n\t},\n\tunbind: function(instance, key) {\n\t\tvar computedObj = findComputed(instance, key);\n\t\tif (computedObj === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tcomputedObj.unbind();\n\t},\n\taddKeyDependencies: function(proxyKeys) {\n\t\tvar onKeyValue = proxyKeys[onKeyValueSymbol];\n\t\tvar offKeyValue = proxyKeys[offKeyValueSymbol];\n\t\t// var getKeyDependencies = proxyKeys[getKeyDependenciesSymbol];\n\n\t\tcanReflect.assignSymbols(proxyKeys, {\n\t\t\t\"can.onKeyValue\": function(key, handler, queue) {\n\t\t\t\tcomputedHelpers.bind(this, key);\n\n\t\t\t\t// var handlers = this[canMeta].handlers;\n\t\t\t\t// handlers.add([ key, \"onKeyValue\", queue || \"notify\", handler ]);\n\n\t\t\t\treturn onKeyValue.apply(this, arguments);\n\t\t\t},\n\t\t\t\"can.offKeyValue\": function(key, handler, queue) {\n\t\t\t\tcomputedHelpers.unbind(this, key);\n\n\t\t\t\t// var handlers = this[canMeta].handlers;\n\t\t\t\t// handlers.delete([ key, \"onKeyValue\", queue || \"notify\", handler ]);\n\n\t\t\t\treturn offKeyValue.apply(this, arguments);\n\t\t\t},\n\t\t\t\"can.getKeyDependencies\": function(key) {\n\t\t\t\tvar computedObj = findComputed(this, key);\n\t\t\t\tif (computedObj === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: new Set([ computedObj.observation ])\n\t\t\t\t};\n\t\t\t},\n\t\t});\n\t},\n\taddMethodsAndSymbols: function(Type) {\n\t\tType.prototype.addEventListener = function(key, handler, queue) {\n\t\t\tcomputedHelpers.bind(this, key);\n\t\t\treturn mapBindings.addEventListener.call(this, key, handler, queue);\n\t\t};\n\n\t\tType.prototype.removeEventListener = function(key, handler, queue) {\n\t\t\tcomputedHelpers.unbind(this, key);\n\t\t\treturn mapBindings.removeEventListener.call(this, key, handler, queue);\n\t\t};\n\t},\n\tensureDefinition: function(prototype) {\n\t\tif (!prototype.hasOwnProperty(computedPropertyDefinitionSymbol)) {\n\t\t\tvar parent = prototype[computedPropertyDefinitionSymbol];\n\t\t\tvar definitions = prototype[computedPropertyDefinitionSymbol] = Object.create(parent || null);\n\n\t\t\tObject.getOwnPropertyNames(prototype).forEach(function(prop) {\n\t\t\t\tif (prop === \"constructor\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// auto-binding for getters\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(prototype, prop);\n\t\t\t\tif(descriptor.get !== undefined) {\n\t\t\t\t\tvar getter = descriptor.get;\n\t\t\t\t\tdefinitions[prop] = function(instance, property) {\n\t\t\t\t\t\treturn new Observation(getter, instance);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn prototype[computedPropertyDefinitionSymbol];\n\t},\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/src/-computed-helpers.js?");

/***/ }),

/***/ "./node_modules/can-observe/src/-helpers.js":
/*!**************************************************!*\
  !*** ./node_modules/can-observe/src/-helpers.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar getGlobal = __webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar metaSymbol = canSymbol.for(\"can.meta\");\nvar classTest = /^\\s*class\\s+/;\n\nvar helpers = {\n\tassignEverything: function(d, s) {\n\t\tObject.getOwnPropertyNames(s).concat(Object.getOwnPropertySymbols(s)).forEach(function(key) {\n\t\t\tObject.defineProperty(d, key, Object.getOwnPropertyDescriptor(s, key));\n\t\t});\n\t\treturn d;\n\t},\n\tisBuiltInButNotArrayOrPlainObjectOrElement: function(obj) {\n\t\tif (obj instanceof getGlobal().Element) {\n\t\t\treturn false;\n\t\t}\n\t\treturn helpers.isBuiltInButNotArrayOrPlainObject(obj);\n\t},\n\tisBuiltInButNotArrayOrPlainObject: function(obj) {\n\t\tif (Array.isArray(obj)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof obj === \"function\") {\n\t\t\tvar fnCode = obj.toString();\n\t\t\tif (fnCode.indexOf(\"[native code]\") > 0) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tvar toString = Object.prototype.toString.call(obj);\n\t\t\treturn toString !== '[object Object]' && toString.indexOf('[object ') !== -1;\n\t\t}\n\n\t},\n\tinheritsFromArray: function(obj) {\n\t\tvar cur = obj;\n\t\tdo {\n\t\t\tif (Array.isArray(cur)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcur = Object.getPrototypeOf(cur);\n\t\t} while (cur);\n\t\treturn false;\n\t},\n\tisClass: function(obj) {\n\t\treturn typeof obj === 'function' && classTest.test(obj.toString());\n\t},\n\tsupportsClass: (function() {\n\t\ttry {\n\t\t\teval('\"use strict\"; class A{};');\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t})(),\n\tmakeSimpleExtender: function(BaseType) {\n\t\treturn function extend(name, staticProps, prototypeProps) {\n\t\t    var Type = function() {\n\t\t        var source = this;\n\t\t\t\tvar instance = BaseType.apply(this, arguments);\n\t\t        if(source.init) {\n\t\t            // makes sure nothing can leak out\n\t\t            instance[metaSymbol].preventSideEffects++;\n\t\t            source.init.apply(instance, arguments);\n\t\t            instance[metaSymbol].preventSideEffects--;\n\t\t        }\n\t\t        return instance;\n\t\t\t};\n\n\n\t\t\thelpers.assignEverything(Type,BaseType);\n\t\t\thelpers.assignEverything(Type, staticProps || {});\n\t\t\tType.extend = helpers.makeSimpleExtender(Type);\n\t\t\tType.prototype = Object.create( BaseType.prototype );\n\t\t\thelpers.assignEverything(Type.prototype, prototypeProps || {});\n\t\t\tType.prototype.constructor = Type;\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tObject.defineProperty(Type, \"name\", {\n\t\t\t\t\tvalue: name\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn Type;\n\t\t};\n\t},\n\tassignNonEnumerable: function(obj, key, value) {\n\t\treturn Object.defineProperty(obj, key, {\n\t\t    enumerable: false,\n\t\t    writable: true,\n\t\t    configurable: true,\n\t\t    value: value\n\t\t});\n\t}\n};\n\n\nmodule.exports = helpers;\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/src/-helpers.js?");

/***/ }),

/***/ "./node_modules/can-observe/src/-make-array.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-observe/src/-make-array.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # -make-array.js\n// This module's `.observable` method proxies an Array to make it observable.\n// The other exports are not used elsewhere.\n// `.set` is the only proxy method that differs from `make-object`'s.\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar mapBindings = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar makeObject = __webpack_require__(/*! ./-make-object */ \"./node_modules/can-observe/src/-make-object.js\");\nvar symbols = __webpack_require__(/*! ./-symbols */ \"./node_modules/can-observe/src/-symbols.js\");\nvar observableStore = __webpack_require__(/*! ./-observable-store */ \"./node_modules/can-observe/src/-observable-store.js\");\nvar helpers = __webpack_require__(/*! ./-helpers */ \"./node_modules/can-observe/src/-helpers.js\");\nvar computedHelpers = __webpack_require__(/*! ./-computed-helpers */ \"./node_modules/can-observe/src/-computed-helpers.js\");\n\nvar isSymbolLike = canReflect.isSymbolLike;\n\n// Returns if prop is an integer\nvar isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n// Returns `true` if the length was set and it deleted indexed\n// properties.\nfunction didLengthChangeCauseDeletions(key, value, old) {\n\treturn key === \"length\" && value < old;\n}\n\n\n// ## Rewrite array methods\n// The following rewrites array methods to generate events and\n// for performance reasons.\n//\n// Array's methods that mutate are rewritten to generate patch events.\n// Other methods on array are rewritten to:\n// - Avoid calling `ObservationRecorder.add` on every property.\n// - Make the returned result observable.\n//\n// ### Rewrite mutating methods\n// The following defines a relationship between an array\n// mutation method and the patch events that should be dispatched\n// for that mutation.\nvar mutateMethods = {\n\t\"push\": function(arr, args) {\n\t\treturn [{\n\t\t\tindex: arr.length - args.length,\n\t\t\tdeleteCount: 0,\n\t\t\tinsert: args,\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"pop\": function(arr) {\n\t\treturn [{\n\t\t\tindex: arr.length,\n\t\t\tdeleteCount: 1,\n\t\t\tinsert: [],\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"shift\": function() {\n\t\treturn [{\n\t\t\tindex: 0,\n\t\t\tdeleteCount: 1,\n\t\t\tinsert: [],\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"unshift\": function(arr, args) {\n\t\treturn [{\n\t\t\tindex: 0,\n\t\t\tdeleteCount: 0,\n\t\t\tinsert: args,\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"splice\": function(arr, args) {\n\t\treturn [{\n\t\t\tindex: args[0],\n\t\t\tdeleteCount: args[1],\n\t\t\tinsert: args.slice(2),\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"sort\": function(arr) {\n\t\t// The array replaced everything.\n\t\treturn [{\n\t\t\tindex: 0,\n\t\t\tdeleteCount: arr.length,\n\t\t\tinsert: arr,\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"reverse\": function(arr, args, old) {\n\t\t// The array replaced everything.\n\t\treturn [{\n\t\t\tindex: 0,\n\t\t\tdeleteCount: arr.length,\n\t\t\tinsert: arr,\n\t\t\ttype: \"splice\"\n\t\t}];\n\t}\n};\n// Overwrite Array's methods that mutate to:\n// - prevent other events from being fired off (index events and length events.)\n// - dispatch patches events.\ncanReflect.eachKey(mutateMethods, function(makePatches, prop){\n\tvar protoFn = Array.prototype[prop];\n\tvar mutateMethod = function() {\n\t\tvar meta = this[symbols.metaSymbol],\n\t\t\t// Capture if this function should be making sideEffects\n\t\t\tmakeSideEffects = meta.preventSideEffects === 0,\n\t\t\toldLength = meta.target.length;\n\n\t\t// Prevent proxy from calling ObservationRecorder and sending events.\n\t\tmeta.preventSideEffects++;\n\n\t\t// Call the function -- note that *this* is the Proxy here, so\n\t\t// accesses in the function still go through `get()` and `set()`.\n\t\tvar ret = protoFn.apply(meta.target, arguments);\n\t\tvar patches = makePatches(meta.target, Array.from(arguments), oldLength);\n\n\t\tif (makeSideEffects === true) {\n\t\t\t//!steal-remove-start\n\t\t\tvar reasonLog = [canReflect.getName(meta.proxy)+\".\"+prop+\" called with\", arguments];\n\t\t\t//!steal-remove-end\n\t\t\tvar dispatchArgs = {\n\t\t\t\ttype: \"length\",\n\t\t\t\tpatches: patches\n\t\t\t};\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tdispatchArgs.reasonLog = reasonLog;\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tmapBindings.dispatch.call( meta.proxy, dispatchArgs , [meta.target.length, oldLength]);\n\t\t}\n\n\t\tmeta.preventSideEffects--;\n\t\treturn ret;\n\t};\n\t//!steal-remove-start\n\tif(true) {\n\t\tObject.defineProperty(mutateMethod, \"name\", {\n\t\t\tvalue: prop\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\t// Store the proxied method so it will be used instead of the\n\t// prototype method.\n\tobservableStore.proxiedObjects.set(protoFn, mutateMethod);\n\tobservableStore.proxies.add(mutateMethod);\n});\n\n// ### Rewrite non-mutating methods\n// The following rewrites the Array methods to signal\n// to `ObservationRecorder` to bind on patches events.\n// It also prevents the proxy handlers calling `ObservationRecorder`\n// themselves.\nObject.getOwnPropertyNames(Array.prototype).forEach(function(prop) {\n\tvar protoFn = Array.prototype[prop];\n\tif (observableStore.proxiedObjects.has(protoFn)) {\n\t\treturn;\n\t}\n\n\tif (prop !== \"constructor\" && typeof protoFn === \"function\") {\n\t\tvar arrayMethod = function() {\n\t\t\tObservationRecorder.add(this, symbols.patchesSymbol);\n\t\t\tvar meta = this[symbols.metaSymbol];\n\t\t\tmeta.preventSideEffects++;\n\t\t\tvar ret = protoFn.apply(this, arguments);\n\t\t\tmeta.preventSideEffects--;\n\t\t\treturn meta.options.observe(ret);\n\t\t};\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tObject.defineProperty(arrayMethod, \"name\", {\n\t\t\t\tvalue: prop\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\t\tobservableStore.proxiedObjects.set(protoFn, arrayMethod);\n\t\tobservableStore.proxies.add(arrayMethod);\n\t}\n});\n\n\n// Array's have the same proxy keys as objects.\nvar proxyKeys = helpers.assignEverything(Object.create(null), makeObject.proxyKeys());\n\n\nvar makeArray = {\n\t// Returns a proxied version of the array.\n\t// - `array` - An array to proxy.\n\t// - `options` - Configurable behaviors.\n\t//   - `proxyKeys` - Keys that will override any keys on `array`. Defaults to `makeObject.proxyKeys`.\n\t//   - `observe(nonObservable)` - A function that converts a nested value to an observable.\n\t//   - `shouldRecordObservation(keyInfo, meta)` - Returns if `ObservationRecorder`\n\t//     should be called.  Defaults to `makeObject.shouldRecordObservationOnOwnAndMissingKeys`.\n\tobservable: function(array, options) {\n\t\tif(options.shouldRecordObservation === undefined) {\n\t\t\toptions.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;\n\t\t}\n\t\tvar meta = {\n\t\t\ttarget: array,\n\t\t\tproxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeArray.proxyKeys()),\n\t\t\tcomputedKeys: Object.create(null),\n\t\t\toptions: options,\n\t\t\t// `preventSideEffects` is a counter used to \"turn off\" the proxy.  This is incremented when some\n\t\t\t// function (like `Array.splice`) wants to handle event dispatching and/or calling\n\t\t\t// `ObservationRecorder` itself for performance reasons.\n\t\t\tpreventSideEffects: 0\n\t\t};\n\t\tmeta.proxyKeys[symbols.metaSymbol] = meta;\n\t\tmeta.proxy = new Proxy(array, {\n\t\t\tget: makeObject.get.bind(meta),\n\t\t\tset: makeArray.set.bind(meta),\n\t\t\townKeys: makeObject.ownKeys.bind(meta),\n\t\t\tdeleteProperty: makeObject.deleteProperty.bind(meta),\n\t\t\tmeta: meta\n\t\t});\n\t\tmapBindings.addHandlers(meta.proxy, meta);\n\t\treturn meta.proxy;\n\t},\n\tproxyKeys: function() {\n\t\treturn proxyKeys;\n\t},\n\t// `set` is called when a property is set on the proxy or an object\n\t// that has the proxy on its prototype.\n\tset: function(target, key, value, receiver) {\n\t\t// If the receiver is not this observable (the observable might be on the proto chain),\n\t\t// set the key on the reciever.\n\t\tif (receiver !== this.proxy) {\n\t\t\treturn makeObject.setKey(receiver, key, value, this);\n\t\t}\n\n\t\t// If it has a defined property definiition\n\t\tvar computedValue = computedHelpers.set(receiver, key, value);\n\t\tif(computedValue === true ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Gets the observable value to set.\n\t\tvalue = makeObject.getValueToSet(key, value, this);\n\t\tvar startingLength = target.length;\n\n\t\t// Sets the value on the target.  If there\n\t\t// is a change, calls the callback.\n\t\tmakeObject.setValueAndOnChange(key, value, this, function(key, value, meta, hadOwn, old) {\n\n\t\t\t// Determine the patches this change should dispatch\n\t\t\tvar patches = [{\n\t\t\t\tkey: key,\n\t\t\t\ttype: hadOwn ? \"set\" : \"add\",\n\t\t\t\tvalue: value\n\t\t\t}];\n\n\t\t\tvar numberKey = !isSymbolLike(key) && +key;\n\n\t\t\t// If we are adding an indexed value like `arr[5] =value` ...\n\t\t\tif ( isInteger(numberKey) ) {\n\t\t\t\t// If we set an enumerable property after the length ...\n\t\t\t\tif (!hadOwn && numberKey > startingLength) {\n\t\t\t\t\t// ... add patches for those values.\n\t\t\t\t\tpatches.push({\n\t\t\t\t\t\tindex: startingLength,\n\t\t\t\t\t\tdeleteCount: 0,\n\t\t\t\t\t\tinsert: target.slice(startingLength),\n\t\t\t\t\t\ttype: \"splice\"\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, splice the value into the array.\n\t\t\t\t\tpatches.push.apply(patches, mutateMethods.splice(target, [numberKey, 1, value]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In the case of deleting items by setting the length of the array,\n\t\t\t// add patches that splice the items removed.\n\t\t\t// (deleting individual items from an array doesn't change the length; it just creates holes)\n\t\t\tif (didLengthChangeCauseDeletions(key, value, old, meta)) {\n\t\t\t\tpatches.push({\n\t\t\t\t\tindex: value,\n\t\t\t\t\tdeleteCount: old - value,\n\t\t\t\t\tinsert: [],\n\t\t\t\t\ttype: \"splice\"\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-start\n\t\t\tvar reasonLog = [canReflect.getName(meta.proxy)+\" set\", key,\"to\", value];\n\t\t\t//!steal-remove-end\n\n\t\t\tvar dispatchArgs = {\n\t\t\t\ttype: key,\n\t\t\t\tpatches: patches,\n\t\t\t\tkeyChanged: !hadOwn ? key : undefined\n\t\t\t};\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tdispatchArgs.reasonLog = reasonLog;\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tmapBindings.dispatch.call( meta.proxy, dispatchArgs, [value, old]);\n\n\t\t});\n\n\t\treturn true;\n\t}\n};\n\n\nmodule.exports = makeArray;\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/src/-make-array.js?");

/***/ }),

/***/ "./node_modules/can-observe/src/-make-function.js":
/*!********************************************************!*\
  !*** ./node_modules/can-observe/src/-make-function.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # -make-function.js\n// This module's `.observable` method proxies an function to make it an any instances\n// created by it observable.\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar makeObject = __webpack_require__(/*! ./-make-object */ \"./node_modules/can-observe/src/-make-object.js\");\nvar makeObserve = __webpack_require__(/*! ./-make-observe */ \"./node_modules/can-observe/src/-make-observe.js\");\nvar symbols = __webpack_require__(/*! ./-symbols */ \"./node_modules/can-observe/src/-symbols.js\");\nvar observableStore = __webpack_require__(/*! ./-observable-store */ \"./node_modules/can-observe/src/-observable-store.js\");\nvar mapBindings = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar typeBindings = __webpack_require__(/*! can-event-queue/type/type */ \"./node_modules/can-event-queue/type/type.js\");\nvar helpers = __webpack_require__(/*! ./-helpers */ \"./node_modules/can-observe/src/-helpers.js\");\n\n// ## proxyKeys\n// A function's proxyKeys is a combination of:\n// - object's symbols (`.onKeyValue`)\n// - type event symbols (`.onInstancePatches`, `.onInstanceBound`)\n// - type definition symbols (`.defineInstanceKey`)\nvar proxyKeys = helpers.assignEverything(Object.create(null), makeObject.proxyKeys());\ntypeBindings(proxyKeys);\ncanReflect.assignSymbols(proxyKeys, {\n\t\"can.defineInstanceKey\": function(prop, value) {\n\t\tthis[symbols.metaSymbol].definitions[prop] = value;\n\t}\n});\n\nvar makeFunction = {\n\n\tobservable: function(object, options) {\n\n\t\tif(options.shouldRecordObservation === undefined) {\n\t\t\toptions.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;\n\t\t}\n\t\tvar proxyKeys = Object.create(makeFunction.proxyKeys());\n\n\t\tvar meta = {\n\t\t\ttarget: object,\n\t\t\tproxyKeys: proxyKeys,\n\t\t\tcomputedKeys: Object.create(null),\n\t\t\toptions: options,\n\t\t\tdefinitions: {},\n\t\t\tisClass: helpers.isClass(object),\n\t\t\tpreventSideEffects: 0\n\t\t};\n\n\t\tproxyKeys[symbols.metaSymbol] = meta;\n\t\tmeta.proxy = new Proxy(object, {\n\t\t\tget: makeObject.get.bind(meta),\n\t\t\tset: makeObject.set.bind(meta),\n\t\t\townKeys: makeObject.ownKeys.bind(meta),\n\t\t\tdeleteProperty: makeObject.deleteProperty.bind(meta),\n\t\t\tconstruct: makeFunction.construct.bind(meta),\n\t\t\tapply: makeFunction.apply.bind(meta),\n\t\t\tmeta: meta\n\t\t});\n\n\t\tmapBindings.addHandlers(meta.proxy, meta);\n\t\ttypeBindings.addHandlers(meta.proxy, meta);\n\n\t\t// Store the function and its proxy now, before we\n\t\t// convert the prototype and its constructor to proxies.\n\t\tobservableStore.proxiedObjects.set(object, meta.proxy);\n\t\tobservableStore.proxies.add(meta.proxy);\n\n\t\t// Change prototype and its constructor\n\t\tif (meta.target.prototype && meta.target.prototype.constructor === meta.target) {\n\t\t\tvar newPrototype = makeObject.observable(meta.target.prototype, {\n\t\t\t\tgetPrototypeOf: function(){\n\t\t\t\t\treturn meta.target.prototype;\n\t\t\t\t},\n\t\t\t\tobserve: makeObserve.observe\n\t\t\t});\n\n\t\t\tobservableStore.proxiedObjects.set(meta.target.prototype, newPrototype);\n\t\t\tobservableStore.proxies.add(newPrototype);\n\n\t\t\tvar prototype = meta.proxy.prototype;\n\t\t\tprototype.constructor = meta.proxy;\n\t\t}\n\n\t\treturn meta.proxy;\n\t},\n\t// `construct` is called when the `new` operator is used.\n\t// It needs to return an observable instance.\n\tconstruct: function(target, argumentsList, newTarget) {\n\t\tvar instanceTarget, key;\n\t\tif (this.isClass) {\n\t\t\t// If the `target` a class, we can't call the function without new. We\n\t\t\t// can create the instance with `Reflect.construct`.\n\t\t\tinstanceTarget = Reflect.construct(target, argumentsList, newTarget);\n\t\t\t// Support `can.defineInstanceKey`.\n\t\t\tfor (key in this.definitions) {\n\t\t\t\tObject.defineProperty(instanceTarget, key, this.definitions[key]);\n\t\t\t}\n\t\t\treturn this.options.observe(instanceTarget);\n\t\t} else {\n\t\t\t// Create an empty object that inherits from the constructor function.\n\t\t\tinstanceTarget = Object.create(this.proxy.prototype);\n\t\t\t// Support `can.defineInstanceKey`.\n\t\t\tfor (key in this.definitions) {\n\t\t\t\tObject.defineProperty(instanceTarget, key, this.definitions[key]);\n\t\t\t}\n\t\t\tvar instance = this.options.observe(instanceTarget);\n\t\t\tinstance[symbols.metaSymbol].preventSideEffects++;\n\t\t\tvar res = target.apply(instance, argumentsList);\n\t\t\tinstance[symbols.metaSymbol].preventSideEffects--;\n\t\t\tif (res) {\n\t\t\t\treturn res;\n\t\t\t} else {\n\t\t\t\treturn instance;\n\t\t\t}\n\t\t}\n\t},\n\t// `apply` makes sure the function returns an observable.\n\tapply: function(target, thisArg, argumentsList) {\n\t\tvar ret = this.target.apply(thisArg, argumentsList);\n\t\treturn this.options.observe(ret);\n\t},\n\tproxyKeys: function() {\n\t\treturn proxyKeys;\n\t}\n};\n\nmodule.exports = makeFunction;\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/src/-make-function.js?");

/***/ }),

/***/ "./node_modules/can-observe/src/-make-object.js":
/*!******************************************************!*\
  !*** ./node_modules/can-observe/src/-make-object.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # -make-object.js\n// This module's `.observable` method proxies an object to make it observable.\n// The other exports are used by other make-TYPE modules.\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar mapBindings = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\n\nvar symbols = __webpack_require__(/*! ./-symbols */ \"./node_modules/can-observe/src/-symbols.js\");\nvar observableStore = __webpack_require__(/*! ./-observable-store */ \"./node_modules/can-observe/src/-observable-store.js\");\nvar helpers = __webpack_require__(/*! ./-helpers */ \"./node_modules/can-observe/src/-helpers.js\");\nvar computedHelpers = __webpack_require__(/*! ./-computed-helpers */ \"./node_modules/can-observe/src/-computed-helpers.js\");\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar isSymbolLike = canReflect.isSymbolLike;\n\n// These are the \"overwrites\" for the proxy.\n// Copy the symbols from the map bindings mixin.\nvar proxyKeys = Object.create(null);\nObject.getOwnPropertySymbols(mapBindings).forEach(function(symbol){\n\thelpers.assignNonEnumerable(proxyKeys, symbol, mapBindings[symbol]);\n});\n\ncomputedHelpers.addKeyDependencies(proxyKeys);\n\nvar makeObject = {\n\t// Returns a proxied version of the object.\n\t// - `object` - An object to proxy.\n\t// - `options` - Configurable behaviors.\n\t//   - `proxyKeys` - Keys that will override any keys on `object`. Defaults to `makeObject.proxyKeys`.\n\t//   - `observe(nonObservable)` - A function that converts a nested value to an observable.\n\t//   - `shouldRecordObservation(keyInfo, meta)` - Returns if `ObservationRecorder`\n\t//     should be called.  Defaults to `makeObject.shouldRecordObservationOnOwnAndMissingKeys`.\n\tobservable: function(object, options) {\n\t\tif(options.shouldRecordObservation === undefined) {\n\t\t\toptions.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;\n\t\t}\n\n\t\tvar meta = {\n\t\t\ttarget: object,\n\t\t\tproxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeObject.proxyKeys()),\n\t\t\tcomputedKeys: Object.create(null),\n\t\t\toptions: options,\n\t\t\t// `preventSideEffects` is a counter used to \"turn off\" the proxy.  This is incremented when some\n\t\t\t// function (like `Array.splice`) wants to handle event dispatching and/or calling\n\t\t\t// `ObservationRecorder` itself for performance reasons.\n\t\t\tpreventSideEffects: 0\n\t\t};\n\n\t\thelpers.assignNonEnumerable(meta.proxyKeys, symbols.metaSymbol, meta);\n\n\t\t// We `bind` so the `meta` is immediately available as `this`.\n\t\tvar traps = {\n\t\t\tget: makeObject.get.bind(meta),\n\t\t\tset: makeObject.set.bind(meta),\n\t\t\townKeys: makeObject.ownKeys.bind(meta),\n\t\t\tdeleteProperty: makeObject.deleteProperty.bind(meta),\n\t\t\tgetOwnPropertyDescriptor: makeObject.getOwnPropertyDescriptor.bind(meta),\n\t\t\tmeta: meta\n\t\t};\n\n\t\tif(options.getPrototypeOf) {\n\t\t\ttraps.getPrototypeOf = options.getPrototypeOf;\n\t\t}\n\n\t\tmeta.proxy = new Proxy(object, traps);\n\t\tmapBindings.addHandlers(meta.proxy, meta);\n\t\treturn meta.proxy;\n\t},\n\tproxyKeys: function() {\n\t\treturn proxyKeys;\n\t},\n\t// `get` checks the target for un-proxied objects.\n\t// If it finds an un-proxied object:\n\t//   - it creates one (which registers itself in the observableStore) and\n\t//   - returns the proxied value without modifying the underlying target\n\tget: function(target, key, receiver) {\n\t\t// If getting a key for the proxy, return that value.\n\t\tvar proxyKey = this.proxyKeys[key];\n\t\tif (proxyKey !== undefined) {\n\t\t\treturn proxyKey;\n\t\t}\n\n\t\t// Symbols are not observable and their values are not made observable.\n\t\tif (isSymbolLike(key)) {\n\t\t\treturn target[key];\n\t\t}\n\n\t\t// If it has a defined property definiition\n\t\tvar computedValue = computedHelpers.get(receiver, key);\n\t\tif(computedValue !== undefined ) {\n\t\t\treturn computedValue.value;\n\t\t}\n\n\t\t// Gets information about the key on `target` or on `target`'s prototype.\n\t\tvar keyInfo = makeObject.getKeyInfo(target, key, receiver, this);\n\t\tvar value = keyInfo.targetValue;\n\n\t\t// If the return value can be changed ...\n\t\tif (!keyInfo.valueIsInvariant) {\n\t\t\t// Convert the value into an observable\n\t\t\t// or get it if already converted from the store.\n\t\t\tvalue = makeObject.getValueFromStore(key, value, this);\n\t\t}\n\n\t\tif (this.options.shouldRecordObservation(keyInfo, this)) {\n\t\t\tObservationRecorder.add(this.proxy, key.toString());\n\t\t}\n\n\t\t// if the parent object is observable, we need to observe there too.\n\t\tif (keyInfo.parentObservableGetCalledOn) {\n\t\t\tObservationRecorder.add(keyInfo.parentObservableGetCalledOn, key.toString());\n\t\t}\n\t\treturn value;\n\t},\n\t// `set` is called when a property is set on the proxy or an object\n\t// that has the proxy on its prototype.\n\tset: function(target, key, value, receiver) {\n\t\t// If the receiver is not this observable (the observable might be on the proto chain),\n\t\t// set the key on the reciever.\n\t\tif (receiver !== this.proxy && this.options.proxiedPrototype !== true) {\n\t\t\treturn makeObject.setKey(receiver, key, value, this);\n\t\t}\n\n\t\t// If it has a defined property definiition\n\t\tvar computedValue = computedHelpers.set(receiver, key, value);\n\t\tif(computedValue === true ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Gets the observable value to set.\n\t\tvalue = makeObject.getValueToSet(key, value, this);\n\n\t\t// Sets the value on the target.  If there\n\t\t// is a change, calls the callback.\n\t\tmakeObject.setValueAndOnChange(key, value, this, function(key, value, meta, hadOwn, old) {\n\n\t\t\t//!steal-remove-start\n\t\t\tvar reasonLog = [canReflect.getName(meta.proxy) + \" set\", key, \"to\", value];\n\t\t\t//!steal-remove-end\n\n\t\t\tvar dispatchArgs = {\n\t\t\t\ttype: key,\n\t\t\t\tpatches: [{\n\t\t\t\t\tkey: key,\n\t\t\t\t\ttype: hadOwn ? \"set\" : \"add\",\n\t\t\t\t\tvalue: value\n\t\t\t\t}],\n\t\t\t\tkeyChanged: !hadOwn ? key : undefined\n\t\t\t};\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tdispatchArgs.reasonLog = reasonLog;\n\t\t\t}\t\t\t\t\n\t\t\t//!steal-remove-end\n\n\t\t\t// Fire event handlers for this key change.\n\t\t\tmapBindings.dispatch.call(meta.proxy, dispatchArgs, [value, old]);\n\n\t\t});\n\n\t\treturn true;\n\t},\n\t// `deleteProperty` is called when a property is deleted on the proxy.\n\tdeleteProperty: function(target, key) {\n\n\t\tvar old = this.target[key],\n\t\t\tdeleteSuccessful = delete this.target[key];\n\n\t\t// Fire event handlers if we were able to delete and the value changed.\n\t\tif (deleteSuccessful && this.preventSideEffects === 0 && old !== undefined) {\n\t\t\t//!steal-remove-start\n\t\t\tvar reasonLog = [canReflect.getName(this.proxy)+\" deleted\", key];\n\t\t\t//!steal-remove-end\n\t\t\t// wrapping in process.env.NODE_ENV !== 'production' causes out of scope error\n\t\t\tvar dispatchArgs = {\n\t\t\t\ttype: key,\n\t\t\t\tpatches: [{\n\t\t\t\t\tkey: key,\n\t\t\t\t\ttype: \"delete\"\n\t\t\t\t}],\n\t\t\t\tkeyChanged: key\n\t\t\t};\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tdispatchArgs.reasonLog = reasonLog;\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tmapBindings.dispatch.call( this.proxy, dispatchArgs,[undefined, old]);\n\n\t\t}\n\t\treturn deleteSuccessful;\n\t},\n\t// `ownKeys` returns the proxies keys.\n\t// Proxies should return the keys and symbols from proxyOnly\n\t// as well as from the target, so operators like `in` and\n\t// functions like `hasOwnProperty` can be used to determine\n\t// that the Proxy is observable.\n\townKeys: function(target) {\n\t\tObservationRecorder.add(this.proxy, symbols.keysSymbol);\n\n\t\treturn Object.getOwnPropertyNames(this.target)\n\t\t\t.concat(Object.getOwnPropertySymbols(this.target))\n\t\t\t.concat(Object.getOwnPropertySymbols(this.proxyKeys));\n\t},\n\tgetOwnPropertyDescriptor: function(target, key) {\n\t\tvar desc = Object.getOwnPropertyDescriptor(target, key);\n\n\t\tif(!desc && (key in this.proxyKeys)) {\n\t\t\treturn Object.getOwnPropertyDescriptor(this.proxyKeys, key);\n\t\t}\n\n\t\treturn desc;\n\t},\n\t// Returns a `keyInfo` object with useful information about the key\n\t// and its value.  This function is _heavily_ optimized.\n\tgetKeyInfo: function(target, key, receiver, meta) {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(target, key);\n\t\tvar propertyInfo = {\n\t\t\t// The key being read.\n\t\t\tkey: key,\n\t\t\t// The property descriptor.\n\t\t\tdescriptor: descriptor,\n\t\t\t// If the `target` has the key.\n\t\t\ttargetHasOwnKey: Boolean(descriptor),\n\t\t\t// If the proxy is on the proto chain.\n\t\t\tgetCalledOnParent: receiver !== meta.proxy,\n\t\t\t// If the prototype of the target has this key.\n\t\t\tprotoHasKey: false,\n\t\t\t// If the property is sealed or not.\n\t\t\tvalueIsInvariant: false,\n\t\t\t// The value of the key wherever it is found.\n\t\t\ttargetValue: undefined,\n\t\t\t// If reading the key went through a getter.\n\t\t\tisAccessor: false\n\t\t};\n\t\tif (propertyInfo.getCalledOnParent === true) {\n\t\t\tpropertyInfo.parentObservableGetCalledOn = observableStore.proxiedObjects.get(receiver);\n\t\t}\n\t\tif (descriptor !== undefined) {\n\t\t\tpropertyInfo.valueIsInvariant = descriptor.writable === false;\n\t\t\tif (descriptor.get !== undefined) {\n\t\t\t\tpropertyInfo.targetValue = descriptor.get.call( propertyInfo.parentObservableGetCalledOn || receiver);\n\t\t\t\tpropertyInfo.isAccessor = true;\n\t\t\t} else {\n\t\t\t\tpropertyInfo.targetValue = descriptor.value;\n\t\t\t}\n\t\t} else {\n\t\t\tpropertyInfo.targetValue = meta.target[key];\n\t\t\tpropertyInfo.protoHasKey = propertyInfo.targetValue !== undefined ? true : (key in target);\n\t\t}\n\n\t\treturn propertyInfo;\n\t},\n\t// Returns `true` if `ObservationRecorder.add` should be called.\n\t// This is the default `options.shouldRecordObservation` behavior.\n\t// `observe.Object` changes this to record all keys except functions on the\n\t// proto chain.\n\tshouldRecordObservationOnOwnAndMissingKeys: function(keyInfo, meta) {\n\t\treturn meta.preventSideEffects === 0 &&\n\t\t\t// The read is not a getter AND ...\n\t\t\t!keyInfo.isAccessor &&\n\t\t\t(\n\t\t\t\t// (the read is on the proxy OR\n\t\t\t\t(// it's not on the proto chain and we are not sealed).\n                keyInfo.targetHasOwnKey || !keyInfo.protoHasKey && !Object.isSealed(meta.target))\n\t\t\t);\n\t},\n\t// `setKey` sets a value on an object. Use `Object.defineProperty`\n\t// because it won't try setting up the proto chain.\n\tsetKey: function(receiver, key, value) {\n\t\tObject.defineProperty(receiver, key, {\n\t\t\tvalue: value,\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\twritable: true\n\t\t});\n\t\treturn true;\n\t},\n\t// `getValueToSet` gets the value we will set on the object.  It only\n\t// converts set values to observables if we have actually bound.\n\tgetValueToSet: function(key, value, meta) {\n\t\tif (!canReflect.isSymbolLike(key) && meta.handlers.getNode([key])) {\n\t\t\treturn makeObject.getValueFromStore(key, value, meta);\n\t\t}\n\t\treturn value;\n\t},\n\t// Get a value from the store if we can.\n\tgetValueFromStore: function(key, value, meta) {\n\t\t// We never convert primitives or things that are already observable.\n\t\t// However, there are some builtIns that we premptively convert, namely\n\t\t// Array.prototype methods.\n\t\tif (!canReflect.isPrimitive(value) &&\n\t\t\t!canReflect.isObservableLike(value) &&\n\t\t\t// Do nothing if the value is already a converted proxy.\n\t\t\t!observableStore.proxies.has(value)) {\n\n\t\t\t// If the `value` already been made into a proxy, use the value.\n\t\t\tif (observableStore.proxiedObjects.has(value)) {\n\t\t\t\tvalue = observableStore.proxiedObjects.get(value);\n\t\t\t}\n\t\t\telse if (!helpers.isBuiltInButNotArrayOrPlainObject(value)) {\n\t\t\t\tvalue = meta.options.observe(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t},\n\n\t// `setValueAndOnChange` sets the value.  If the value changed,\n\t// calls the `onChange` callback.\n\tsetValueAndOnChange: function(key, value, data, onChange) {\n\t\tvar old, change;\n\t\tvar hadOwn = hasOwn.call(data.target, key);\n\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(data.target, key);\n\t\t// call the setter on the Proxy to properly do any side-effect sets (and run corresponding handlers)\n\t\t// -- setters do not return values, so it is unnecessary to check for changes.\n\t\tif (descriptor && descriptor.set) {\n\t\t\tdescriptor.set.call(data.proxy, value);\n\t\t} else {\n\t\t\t// otherwise check for a changed value\n\t\t\told = data.target[key];\n\t\t\tchange = old !== value;\n\t\t\tif (change) {\n\t\t\t\tdata.target[key] = value;\n\t\t\t\tif (data.preventSideEffects === 0) {\n\t\t\t\t\tonChange(key, value, data, hadOwn, old);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nmodule.exports = makeObject;\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/src/-make-object.js?");

/***/ }),

/***/ "./node_modules/can-observe/src/-make-observe.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-observe/src/-make-observe.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar getGlobal = __webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar observables = __webpack_require__(/*! ./-observable-store */ \"./node_modules/can-observe/src/-observable-store.js\");\nvar helpers = __webpack_require__(/*! ./-helpers */ \"./node_modules/can-observe/src/-helpers.js\");\n\nvar makeObserve = {\n\tobserve: function(value) {\n\t\tif (canReflect.isPrimitive(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tvar observable = observables.proxiedObjects.get(value);\n\t\tif (observable) {\n\t\t\treturn observable;\n\t\t}\n\t\tif (observables.proxies.has(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tif (helpers.isBuiltInButNotArrayOrPlainObjectOrElement(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tif (typeof value === \"function\") {\n\t\t\tobservable = makeObserve.function(value);\n\t\t} else if (helpers.inheritsFromArray(value)) {\n\t\t\tobservable = makeObserve.array(value);\n\t\t} else if (value instanceof getGlobal().Element) {\n\t\t\tobservable = makeObserve.prototype(value);\n\t\t} else {\n\t\t\tobservable = makeObserve.object(value);\n\t\t}\n\t\tobservables.proxiedObjects.set(value, observable);\n\t\tobservables.proxies.add(observable);\n\t\treturn observable;\n\t},\n\t// Set to a function that converts non-observable\n\t// objects to observable objects\n\t\"object\": null,\n\t// Set to a function that converts non-observable\n\t// arrays to observable arrays\n\t\"array\": null,\n\t// Set to a function that converts non-observable\n\t// functions to observable functions\n\t\"function\": null\n};\n\nmodule.exports = makeObserve;\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/src/-make-observe.js?");

/***/ }),

/***/ "./node_modules/can-observe/src/-make-prototype.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-observe/src/-make-prototype.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar makeObject = __webpack_require__(/*! ./-make-object */ \"./node_modules/can-observe/src/-make-object.js\");\nvar helpers = __webpack_require__(/*! ./-helpers */ \"./node_modules/can-observe/src/-helpers.js\");\nvar symbols = __webpack_require__(/*! ./-symbols */ \"./node_modules/can-observe/src/-symbols.js\");\nvar mapBindings = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar isSymbolLike = canReflect.isSymbolLike;\nvar proxyMetaSymbol = canSymbol.for(\"can.proxyMeta\");\n\nfunction getMetadata(instance, options) {\n\tif (instance.hasOwnProperty(proxyMetaSymbol)) {\n\t\treturn instance[proxyMetaSymbol];\n\t}\n\n\tif(options.shouldRecordObservation === undefined) {\n\t\toptions.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;\n\t}\n\n\t// tell makeObject.set to allow setting on meta.target\n\t// when the receiver is the prototype of meta.instance\n\toptions.proxiedPrototype = true;\n\n\tvar meta = {\n\t\t// store keys on a side-object instead of directly on the instance\n\t\t// so that gets and sets will always hit the prototype\n\t\ttarget: makeObject.observable({}, options),\n\t\tproxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeObject.proxyKeys()),\n\t\tcomputedKeys: Object.create(null),\n\t\toptions: options,\n\t\t// `preventSideEffects` is a counter used to \"turn off\" the proxy.  This is incremented when some\n\t\t// function (like `Array.splice`) wants to handle event dispatching and/or calling\n\t\t// `ObservationRecorder` itself for performance reasons.\n\t\tpreventSideEffects: 0,\n\t\tproxy: instance\n\t};\n\n\t// add can.meta symbol to proxyKeys so reading can.meta from the instance\n\t// will return the meta object (makeObject.get checks proxyKeys first)\n\thelpers.assignNonEnumerable(meta.proxyKeys, symbols.metaSymbol, meta);\n\n\t// set up handlers\n\tmapBindings.addHandlers(meta.proxy, meta);\n\n\t// store meta so it can be retrieved next time\n\tinstance[proxyMetaSymbol] = meta;\n\n\treturn meta;\n}\n\n// # -make-element.js\n// This module's `.observable` method proxies a prototype\n// in order to make all instances observable.\nvar makePrototype = {\n\tobservable: function(proto, options) {\n\t\tvar protoProxy = new Proxy(proto, {\n\t\t\tset: function(target, key, value, receiver) {\n\t\t\t\t// setting symbols should not trigger events\n\t\t\t\t// (since that would cause infinite loops becase getMetadata sets symbols)\n\t\t\t\t//\n\t\t\t\t// keys in the prototype should just be set (things like innerHTML)\n\t\t\t\tif (isSymbolLike(key) || key in target) {\n\t\t\t\t\treturn Reflect.set(target, key, value, receiver);\n\t\t\t\t}\n\n\t\t\t\tvar meta = getMetadata(receiver, options);\n\t\t\t\treturn makeObject.set.call(meta, target, key, value, receiver);\n\t\t\t},\n\t\t\tget: function(target, key, receiver) {\n\t\t\t\t// keys on the prototype should just be returned (things like appendChild, etc)\n\t\t\t\tif (key in target) {\n\t\t\t\t\treturn Reflect.get(target, key, receiver);\n\t\t\t\t}\n\n\t\t\t\tvar meta = getMetadata(receiver, options);\n\t\t\t\treturn makeObject.get.call(meta, target, key, receiver);\n\t\t\t}\n\t\t});\n\n\t\treturn protoProxy;\n\t}\n};\n\nmodule.exports = makePrototype;\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/src/-make-prototype.js?");

/***/ }),

/***/ "./node_modules/can-observe/src/-observable-store.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-observe/src/-observable-store.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = {\n\tproxiedObjects: new WeakMap(),\n\tproxies: new WeakSet()\n};\n\n//# sourceURL=webpack:///./node_modules/can-observe/src/-observable-store.js?");

/***/ }),

/***/ "./node_modules/can-observe/src/-symbols.js":
/*!**************************************************!*\
  !*** ./node_modules/can-observe/src/-symbols.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nmodule.exports = {\n\tmetaSymbol: canSymbol.for(\"can.meta\"),\n\t// not an actual symbol. This is so it can be enumerable\n\t// by default. We could create a KeyTree with a type where symbols are\n\t// enumerable.\n\tpatchesSymbol: \"can.patches\",\n\tkeysSymbol: \"can.keys\"\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/src/-symbols.js?");

/***/ }),

/***/ "./node_modules/can-observe/src/-type-helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-observe/src/-type-helpers.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canMeta = canSymbol.for(\"can.meta\");\nvar typeDefinitionsSymbol = canSymbol.for(\"can.typeDefinitions\");\n\nvar helpers = module.exports = {\n\tensureDefinition: function(prototype) {\n\t\tvar typeDefs = prototype[typeDefinitionsSymbol];\n\t\tif (!typeDefs) {\n\t\t\tvar parent = prototype[typeDefinitionsSymbol];\n\t\t\ttypeDefs = prototype[typeDefinitionsSymbol] = Object.create(parent || null);\n\t\t}\n\n\t\treturn typeDefs;\n\t},\n\taddMethodsAndSymbols: function(Type) {\n\t\tcanReflect.assignSymbols(Type, {\n\t\t\t\"can.defineInstanceKey\": function(prop, value) {\n\t\t\t\thelpers.ensureDefinition(this.prototype)[prop] = value;\n\t\t\t},\n\t\t\t\"can.dispatchInstanceBoundChange\": function(obj, isBound) {\n\t\t\t\tvar meta = this[canMeta];\n\t\t\t\tif (meta) {\n\t\t\t\t\tvar lifecycleHandlers = meta.lifecycleHandlers;\n\t\t\t\t\tif (lifecycleHandlers) {\n\t\t\t\t\t\tqueues.enqueueByQueue(lifecycleHandlers.getNode([]), this, [obj, isBound]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\tshouldRecordObservationOnAllKeysExceptFunctionsOnProto: function(keyInfo, meta){\n\t\treturn meta.preventSideEffects === 0 && !keyInfo.isAccessor && (\n\t\t\t// it's on us\n\t\t\t(// it's on our proto, but not a function\n            (keyInfo.targetHasOwnKey ) ||\n\t\t\t// it's \"missing\", and we are not sealed\n\t\t\t(!keyInfo.protoHasKey && !Object.isSealed(meta.target)) || keyInfo.protoHasKey && (typeof targetValue !== \"function\"))\n\t\t);\n\t},\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-observe/src/-type-helpers.js?");

/***/ }),

/***/ "./node_modules/can-param/can-param.js":
/*!*********************************************!*\
  !*** ./node_modules/can-param/can-param.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nfunction buildParam(prefix, obj, add) {\n\tif (Array.isArray(obj)) {\n\t\tfor (var i = 0, l = obj.length; i < l; ++i) {\n\t\t\tvar inner = obj[i];\n\t\t\tvar shouldIncludeIndex = typeof inner === 'object';\n\t\t\tvar arrayIndex = shouldIncludeIndex ? '[' + i + ']' : '[]';\n\t\t\tbuildParam(prefix + arrayIndex, inner, add);\n\t\t}\n\t} else if ( obj && typeof obj === \"object\" ) {\n\t\tfor (var name in obj) {\n\t\t\tbuildParam(prefix + '[' + name + ']', obj[name], add);\n\t\t}\n\t} else {\n\t\tadd(prefix, obj);\n\t}\n}\n\nmodule.exports = namespace.param = function param(object) {\n\tvar pairs = [],\n\t\tadd = function (key, value) {\n\t\t\tpairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n\t\t};\n\tfor (var name in object) {\n\t\tbuildParam(name, object[name], add);\n\t}\n\treturn pairs.join('&')\n\t\t.replace(/%20/g, '+');\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-param/can-param.js?");

/***/ }),

/***/ "./node_modules/can-parse-uri/can-parse-uri.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-parse-uri/can-parse-uri.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-parse-uri can-parse-uri\n * @parent can-js-utilities\n * @collection can-infrastructure\n * @package ./package.json\n * @signature `parseURI(url)`\n *\n * Parse a URI into its components.\n *\n * ```js\n * import {parseURI} from \"can\"\n * parseURI(\"http://foo:8080/bar.html?query#change\")\n * //-> {\n * //  authority: \"//foo:8080\",\n * //  hash: \"#change\",\n * //  host: \"foo:8080\",\n * //  hostname: \"foo\",\n * //  href: \"http://foo:8080/bar.html?query#change\",\n * //  pathname: \"/bar.html\",\n * //  port: \"8080\",\n * //  protocol: \"http:\",\n * //  search: \"?query\"\n * // }\n * ```\n *\n * @param {String} url The URL you want to parse.\n *\n * @return {Object} Returns an object with properties for each part of the URL. `null`\n * is returned if the url can not be parsed.\n */\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nmodule.exports = namespace.parseURI = function(url){\n\t\tvar m = String(url).replace(/^\\s+|\\s+$/g, '').match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);\n\t\t\t// authority = '//' + user + ':' + pass '@' + hostname + ':' port\n\t\treturn (m ? {\n\t\t\thref     : m[0] || '',\n\t\t\tprotocol : m[1] || '',\n\t\t\tauthority: m[2] || '',\n\t\t\thost     : m[3] || '',\n\t\t\thostname : m[4] || '',\n\t\t\tport     : m[5] || '',\n\t\t\tpathname : m[6] || '',\n\t\t\tsearch   : m[7] || '',\n\t\t\thash     : m[8] || ''\n\t\t} : null);\n\t};\n\n\n//# sourceURL=webpack:///./node_modules/can-parse-uri/can-parse-uri.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/can-query-logic.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-query-logic/can-query-logic.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var set = __webpack_require__(/*! ./src/set */ \"./node_modules/can-query-logic/src/set.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar makeBasicQueryConvert = __webpack_require__(/*! ./src/serializers/basic-query */ \"./node_modules/can-query-logic/src/serializers/basic-query.js\");\nvar BasicQuery = __webpack_require__(/*! ./src/types/basic-query */ \"./node_modules/can-query-logic/src/types/basic-query.js\");\nvar valueComparisons = __webpack_require__(/*! ./src/types/comparisons */ \"./node_modules/can-query-logic/src/types/comparisons.js\");\nvar schemaSymbol = canSymbol.for(\"can.getSchema\");\nvar newSymbol = canSymbol.for(\"can.new\");\nvar makeEnum = __webpack_require__(/*! ./src/types/make-enum */ \"./node_modules/can-query-logic/src/types/make-enum.js\");\n\n\n// Creates an algebra used to convert primitives to types and back\nfunction QueryLogic(Type, options){\n    Type = Type || {};\n    var passedHydrator = options && options.toQuery;\n    var passedSerializer = options && options.toParams;\n    var schema;\n    if(Type[schemaSymbol]) {\n        schema = Type[schemaSymbol]();\n    } else {\n        schema = Type;\n    }\n\n    // check that the basics are here\n\n    var id = schema.identity && schema.identity[0];\n    if(!id) {\n        //console.warn(\"can-query given a type without an identity schema.  Using `id` as the identity id.\");\n        schema.identity = [\"id\"];\n    }\n\n    var converter = makeBasicQueryConvert(schema),\n        hydrate,\n        serialize;\n\n    if(passedHydrator) {\n        hydrate = function(query){\n            return converter.hydrate(passedHydrator(query));\n        };\n    } else {\n        hydrate = converter.hydrate;\n    }\n\n    if(passedSerializer) {\n        serialize = function(query){\n            return passedSerializer(converter.serializer.serialize(query));\n        };\n    } else {\n        serialize = converter.serializer.serialize;\n    }\n    this.hydrate = hydrate;\n    this.serialize = serialize;\n    this.schema = schema;\n\n}\n\nfunction makeNewSet(prop){\n    return function(qA, qB){\n        var queryA = this.hydrate(qA),\n            queryB = this.hydrate(qB);\n        var unionQuery = set[prop](queryA , queryB );\n        return this.serialize( unionQuery );\n    };\n}\n\nfunction makeReturnValue(prop) {\n    return function(qA, qB){\n        var queryA = this.hydrate(qA),\n            queryB = this.hydrate(qB);\n        return set[prop](queryA , queryB );\n    };\n}\n\ncanReflect.assignSymbols(QueryLogic.prototype,{\n    \"can.getSchema\": function(){\n        return this.schema;\n    }\n});\n\ncanReflect.assign(QueryLogic.prototype,{\n    union: makeNewSet(\"union\"),\n    difference: makeNewSet(\"difference\"),\n    intersection: makeNewSet(\"intersection\"),\n\n    isEqual: makeReturnValue(\"isEqual\"),\n    isProperSubset: makeReturnValue(\"isProperSubset\"),\n    isSubset: makeReturnValue(\"isSubset\"),\n\n    isSpecial: set.isSpecial,\n    isDefinedAndHasMembers: set.isDefinedAndHasMembers,\n\n    count: function(a){\n        var queryA = this.hydrate(a);\n        return queryA.page.end - queryA.page.start + 1;\n    },\n\n    // identity keys\n    identityKeys: function(){\n        //console.warn(\"you probably can get the identity keys some other way\");\n        return this.schema.identity;\n    },\n\n    filterMembers: function(a, b, bData){\n        var queryA = this.hydrate(a);\n        if(arguments.length >= 3) {\n            var queryB = this.hydrate(b);\n            return queryA.filterFrom(bData, queryB);\n        } else {\n            return queryA.filterFrom(b);\n        }\n\n    },\n    // filterMembersAndGetCount\n    filterMembersAndGetCount: function(a, b, bData) {\n        var queryA = this.hydrate(a),\n            queryB = this.hydrate(b);\n        return queryA.filterMembersAndGetCount(bData, queryB);\n    },\n    // unionMembers\n    unionMembers: function(a, b, aData, bData) {\n        var queryA = this.hydrate(a),\n            queryB = this.hydrate(b);\n\n        var schema = this.schema;\n        return queryA.merge(queryB, aData, bData, function(obj){\n            return canReflect.getIdentity(obj, schema);\n        });\n    },\n    // isMember\n    isMember: function(query, props) {\n        return this.hydrate(query).isMember(props);\n    },\n\n    memberIdentity: function(props) {\n        // console.warn(\"you probably can get the member identity some other way\");\n        return canReflect.getIdentity(props, this.schema);\n    },\n    index: function(query, items, props){\n        return this.hydrate(query).index(props, items);\n    },\n\n    insert: function(query, items, item){\n    \tvar index = this.index(query, items, item);\n    \tif(index === undefined) {\n    \t\tindex = items.length;\n    \t}\n\n    \tvar copy = items.slice(0);\n    \tcopy.splice(index, 0, item);\n\n    \treturn copy;\n    },\n\n    isPaginated: function(query) {\n        var basicQuery = this.hydrate(query);\n        return !set.isEqual(basicQuery.page, set.UNIVERSAL);\n    },\n    removePagination: function(query) {\n        var basicQuery = this.hydrate(query);\n        basicQuery.removePagination();\n        return this.serialize( basicQuery );\n    },\n\n});\n\n// Copy everything on `set` to QueryLogic\nfor(var prop in set) {\n    if(QueryLogic[prop] === undefined) {\n        QueryLogic[prop] = set[prop];\n    }\n}\n\n\n\nQueryLogic.makeEnum = function(values){\n    var Type = function(){};\n\t\tType[newSymbol] = function(val) { return val; };\n    makeEnum(Type, values);\n    return Type;\n};\n\n\n\nQueryLogic.KeysAnd = BasicQuery.KeysAnd;\nQueryLogic.ValuesOr = BasicQuery.Or;\n\n\n\nQueryLogic.In = valueComparisons.In;\nQueryLogic.NotIn = valueComparisons.NotIn;\nQueryLogic.GreaterThan = valueComparisons.GreaterThan;\nQueryLogic.GreaterThanEqual = valueComparisons.GreaterThanEqual;\nQueryLogic.LessThan = valueComparisons.LessThan;\nQueryLogic.LessThanEqual = valueComparisons.LessThanEqual;\nQueryLogic.ValueAnd = valueComparisons.And;\nQueryLogic.ValueOr = valueComparisons.Or;\n\nmodule.exports = QueryLogic;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/can-query-logic.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/array-union-intersection-difference.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/can-query-logic/src/array-union-intersection-difference.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var SET = __webpack_require__(/*! ./set */ \"./node_modules/can-query-logic/src/set.js\");\n\n\nfunction getValue(value){\n    return value == null ? value : value.valueOf();\n}\n\nmodule.exports = function arrayUnionIntersectionDifference(arr1, arr2){\n    var set = new Set();\n\n    var intersection = [];\n    var union = [];\n    var difference = arr1.slice(0);\n\n\n    arr1.forEach(function(value){\n        set.add(getValue(value));\n        union.push(value);\n    });\n\n    arr2.forEach(function(value){\n        if(set.has(getValue(value))) {\n            intersection.push(value);\n            var index = SET.indexWithEqual(difference, value);\n            if(index !== -1) {\n                difference.splice(index, 1);\n            }\n        } else {\n            union.push(value);\n        }\n    });\n\n    return {\n        intersection: intersection,\n        union: union,\n        difference: difference\n    };\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/array-union-intersection-difference.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/helpers.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-query-logic/src/helpers.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\n// mongo puts these first https://docs.mongodb.com/manual/reference/bson-type-comparison-order/#bson-types-comparison-order\nvar typeNumber = {\"undefined\": 0, \"null\": 1, \"number\": 3, \"string\": 4, \"object\": 5, \"boolean\": 6};\nvar getTypeNumber = function(obj) {\n\tvar type = typeof obj;\n\tif(obj === null) {\n\t\ttype = \"null\";\n\t}\n\treturn typeNumber[type];\n};\n\nvar typeCompare = {\n\t$gt: function(valueA, valueB) {\n\t\treturn getTypeNumber(valueA) > getTypeNumber(valueB);\n\t},\n\t$lt: function(valueA, valueB) {\n\t\treturn getTypeNumber(valueA) < getTypeNumber(valueB);\n\t}\n};\n\nvar defaultCompare = {\n\t$gt: function(valueA, valueB) {\n\t\tif(valueA == null || valueB == null) {\n\t\t\treturn typeCompare.$gt(valueA, valueB);\n\t\t}\n\t\treturn valueA > valueB;\n\t},\n\t$lt: function(valueA, valueB) {\n\t\tif(valueA == null || valueB == null) {\n\t\t\treturn typeCompare.$gt(valueA, valueB);\n\t\t}\n\t\treturn valueA < valueB;\n\t}\n};\n\nvar helpers = {\n\n\t// given two arrays of items, combines and only returns the unique ones\n\tuniqueConcat: function(itemsA, itemsB, getId) {\n\t\tvar ids = new Set();\n\t\treturn itemsA.concat(itemsB).filter(function(item) {\n\t\t\tvar id = getId(item);\n\t\t\tif (!ids.has(id)) {\n\t\t\t\tids.add(id);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t},\n\t// Get the index of an item by it's identity\n\t// Starting from the middle of the items\n\t// return the index of match in the right direction\n\t// or in the left direction\n\t// otherwise return the last index\n\t// see getIdentityIndexByDirection\n\tgetIdentityIndex: function(compare, items, props, startIndex, schema) {\n\t\tvar identity = canReflect.getIdentity(props, schema),\n\t\t\tstarterItem = items[startIndex];\n\t\t// check if the middle has a match\n\t\tif (compare(props, starterItem) === 0) {\n\t\t\tif (identity === canReflect.getIdentity(starterItem, schema)) {\n\t\t\t\treturn startIndex;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar rightResult = this.getIdentityIndexByDirection(compare, items, props, startIndex+1, 1, schema),\n\t\t\tleftResult;\n\t\tif(rightResult.index) {\n\t\t\treturn rightResult.index;\n\t\t} else {\n\t\t\tleftResult = this.getIdentityIndexByDirection(compare, items, props, startIndex-1, -1, schema);\n\t\t}\n\t\tif(leftResult.index !== undefined) {\n\t\t\treturn leftResult.index;\n\t\t}\n\t\t// put at the last index item that doesn't match an identity\n\t\treturn rightResult.lastIndex;\n\t},\n\t// Get the index of an item by it's identity\n\t// for a given direction (right or left)\n\t// 1 for right\n\t// -1 for left\n\tgetIdentityIndexByDirection: function(compare, items, props, startIndex, direction, schema) {\n\t\tvar currentIndex = startIndex;\n\t\tvar identity = canReflect.getIdentity(props, schema);\n\t\twhile(currentIndex >= 0 && currentIndex < items.length) {\n\t\t\tvar currentItem = items[currentIndex];\n\t\t\tvar computed = compare(props, currentItem);\n\t\t\tif(computed === 0) {\n\t\t\t\tif( identity === canReflect.getIdentity(currentItem, schema)) {\n\t\t\t\t\treturn {index: currentIndex};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn {lastIndex: currentIndex - direction};\n\t\t\t}\n\t\t\tcurrentIndex = currentIndex + direction;\n\t\t}\n\t\treturn {lastIndex: currentIndex - direction};\n\t},\n\t//\n\tgetIndex: function(compare, items, props, schema) {\n\t\tif (!items || !items.length) {\n\t\t\treturn undefined;\n\t\t}\n\t\t// check the start and the end\n\t\tif (compare(props, items[0]) === -1) {\n\t\t\treturn 0;\n\t\t} else if (compare(props, items[items.length - 1]) === 1) {\n\t\t\treturn items.length;\n\t\t}\n\n\t\tvar low = 0,\n\t\t\thigh = items.length;\n\n\t\t// From lodash lodash 4.6.1 <https://lodash.com/>\n\t\t// Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n\t\twhile (low < high) {\n\t\t\tvar mid = (low + high) >>> 1,\n\t\t\t\titem = items[mid],\n\t\t\t\tcomputed = compare(props, item);\n\t\t\tif (computed === 0) {\n\t\t\t\treturn this.getIdentityIndex(compare, items, props, mid, schema);\n\t\t\t} else if (computed === -1) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn high;\n\t\t// bisect by calling sortFunc\n\t},\n\tsortData: function(sortPropValue) {\n\t\tif (sortPropValue[0] === \"-\") {\n\t\t\treturn {\n\t\t\t\tprop: sortPropValue.slice(1),\n\t\t\t\tdesc: true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tprop: sortPropValue,\n\t\t\t\tdesc: false\n\t\t\t};\n\t\t}\n\t},\n\tdefaultCompare: defaultCompare,\n\ttypeCompare: typeCompare,\n\tsorter: function(sortPropValue, sorters) {\n\t\tvar data = helpers.sortData(sortPropValue);\n\t\tvar compare;\n\t\tif (sorters && sorters[data.prop]) {\n\t\t\tcompare = sorters[data.prop];\n\t\t} else {\n\t\t\tcompare = defaultCompare;\n\t\t}\n\t\treturn function(item1, item2) {\n\t\t\tvar item1Value = canReflect.getKeyValue(item1, data.prop);\n\t\t\tvar item2Value = canReflect.getKeyValue(item2, data.prop);\n\t\t\tvar temp;\n\n\t\t\tif (data.desc) {\n\t\t\t\ttemp = item1Value;\n\t\t\t\titem1Value = item2Value;\n\t\t\t\titem2Value = temp;\n\t\t\t}\n\n\t\t\tif (compare.$lt(item1Value, item2Value)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (compare.$gt(item1Value, item2Value)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t};\n\t},\n\tvalueHydrator: function(value) {\n\t\tif (canReflect.isBuiltIn(value)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tthrow new Error(\"can-query-logic doesn't support comparison operator: \" + JSON.stringify(value));\n\t\t}\n\t}\n};\nmodule.exports = helpers;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/helpers.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/schema-helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/can-query-logic/src/schema-helpers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar set = __webpack_require__(/*! ./set */ \"./node_modules/can-query-logic/src/set.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar schemaHelpers;\nmodule.exports = schemaHelpers = {\n\n    // Number is a ranged type\n    isRangedType: function(Type){\n        return Type && canReflect.isConstructorLike(Type) &&\n            !set.hasComparisons(Type) &&\n            !Type[canSymbol.for(\"can.SetType\")] &&\n            Type.prototype.valueOf && Type.prototype.valueOf !== Object.prototype.valueOf;\n    },\n    categorizeOrValues: function categorizeOrValues(values){\n\n    \tvar categories = {\n    \t\tprimitives: [],\n    \t\tvalueOfTypes: [],\n    \t\tothers: []\n    \t};\n\n    \tvalues.forEach(function(value){\n    \t\tif( canReflect.isPrimitive( value ) ) {\n    \t\t\tcategories.primitives.push(value);\n    \t\t}\n    \t\telse if( schemaHelpers.isRangedType(value) ) {\n    \t\t\tcategories.valueOfTypes.push(value);\n    \t\t}\n    \t\telse {\n    \t\t\tcategories.others.push(value);\n    \t\t}\n    \t});\n    \treturn categories;\n    }\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/schema-helpers.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/serializer.js":
/*!********************************************************!*\
  !*** ./node_modules/can-query-logic/src/serializer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar Serializer = function(entries){\n\tvar serializers = this.serializers = new Map();\n\tif (entries) {\n\t\tentries.forEach(function(entry) {\n\t\t\tvar key = entry[0], value = entry[1];\n\t\t\tserializers.set(key, value);\n\t\t});\n\t}\n    this.serialize = this.serialize.bind(this);\n};\nSerializer.prototype.add = function(serializers){\n    canReflect.assign( this.serializers, serializers instanceof Serializer ? serializers.serializers : serializers );\n};\n\n\nSerializer.prototype.serialize = function(item) {\n    if(!item) {\n        return item;\n    }\n    var Type = item.constructor;\n    var serializer = this.serializers.get(Type);\n    if(!serializer) {\n        return canReflect.serialize(item);\n    } else {\n        return serializer(item, this.serialize);\n    }\n};\n\nmodule.exports = Serializer;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/serializer.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/serializers/basic-query.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-query-logic/src/serializers/basic-query.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar BasicQuery = __webpack_require__(/*! ../types/basic-query */ \"./node_modules/can-query-logic/src/types/basic-query.js\");\nvar set = __webpack_require__(/*! ../set */ \"./node_modules/can-query-logic/src/set.js\");\nvar comparisonsConverter = __webpack_require__(/*! ../serializers/comparisons */ \"./node_modules/can-query-logic/src/serializers/comparisons.js\");\nvar Serializer = __webpack_require__(/*! ../serializer */ \"./node_modules/can-query-logic/src/serializer.js\");\nvar is = __webpack_require__(/*! ../types/comparisons */ \"./node_modules/can-query-logic/src/types/comparisons.js\");\nvar makeMaybe = __webpack_require__(/*! ../types/make-maybe */ \"./node_modules/can-query-logic/src/types/make-maybe.js\");\nvar makeEnum = __webpack_require__(/*! ../types/make-enum */ \"./node_modules/can-query-logic/src/types/make-enum.js\");\nvar logDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/can-query-logic/src/helpers.js\");\n\nvar setTypeSymbol = canSymbol.for(\"can.SetType\");\nvar schemaSymbol = canSymbol.for(\"can.getSchema\");\n\nvar defaultQuery = new BasicQuery({});\n\n\nfunction getSchemaProperties(value) {\n\tvar constructor = value.constructor;\n\tif (constructor && constructor[schemaSymbol]) {\n\t\tvar schema = constructor[schemaSymbol]();\n\t\treturn schema.keys || {};\n\t} else {\n\t\treturn {};\n\t}\n}\n\nfunction hydrateFilter(values, schemaProperties, hydrateUnknown) {\n\tvar valuesIsObject = values && typeof values === \"object\";\n\tif (valuesIsObject && (\"$or\" in values)) {\n\t\treturn hydrateOrs(values.$or, schemaProperties, hydrateUnknown);\n\t} else if(valuesIsObject && (\"$and\" in values)) {\n\t\treturn hydrateAnds(values.$and, schemaProperties, hydrateUnknown);\n\t} else {\n\t\treturn hydrateAndValues(values, schemaProperties, hydrateUnknown);\n\t}\n}\n\nvar setTypeMap = new WeakMap();\n\n// This is used to hydrate a value directly within a `filter`'s And.\nfunction hydrateAndValue(value, prop, SchemaType, hydrateChild) {\n\t// The `SchemaType` is the type of value on `instances` of\n\t// the schema. `Instances` values are different from `Set` values.\n\tif (SchemaType) {\n\t\t// If there's a `SetType`, we will use that\n\t\tvar SetType = SchemaType[setTypeSymbol];\n\t\tif (SetType) {\n\t\t\t/// If it exposes a hydrate, this means it can use the current hydrator to\n\t\t\t// hydrate its children.\n\t\t\t// I'm not sure why it's not taking the `unknown` hydrator instead.\n\t\t\tif (SetType.hydrate) {\n\t\t\t\treturn SetType.hydrate(value, comparisonsConverter.hydrate);\n\t\t\t}\n\t\t\t// If the SetType implemented `union`, `intersection`, `difference`\n\t\t\t// We can create instances of it directly.\n\t\t\telse if (set.hasComparisons(SetType)) {\n\t\t\t\t// Todo ... canReflect.new\n\t\t\t\treturn new SetType(value);\n\t\t\t}\n\t\t\t// If the SetType did not implement the comparison methods,\n\t\t\t// it's probably just a \"Value\" comparison type. We will hydrate\n\t\t\t// as a comparison converter, but create an instance of this `\"Value\"`\n\t\t\t// comparison type within the comparison converter.\n\t\t\telse {\n\t\t\t\t// inner types\n\t\t\t\treturn comparisonsConverter.hydrate(value, function(value) {\n\t\t\t\t\treturn new SetType(value);\n\t\t\t\t});\n\t\t\t}\n\n\t\t} else {\n\t\t\t// There is a `SchemaType`, but it doesn't have a `SetType`.\n\t\t\t// Can we create the SetType from the `SchemaType`?\n\t\t\tif (makeEnum.canMakeEnumSetType(SchemaType)) {\n\t\t\t\tif (!setTypeMap.has(SchemaType)) {\n\t\t\t\t\tsetTypeMap.set(SchemaType, makeEnum.makeEnumSetType(SchemaType));\n\t\t\t\t}\n\t\t\t\tSetType = setTypeMap.get(SchemaType);\n\t\t\t\treturn new SetType(value);\n\t\t\t}\n\t\t\t// It could also have a `ComparisonSetType` which are the values\n\t\t\t// within the Maybe type.\n\t\t\telse if (makeMaybe.canMakeMaybeSetType(SchemaType)) {\n\t\t\t\tif (!setTypeMap.has(SchemaType)) {\n\t\t\t\t\tsetTypeMap.set(SchemaType, makeMaybe.makeMaybeSetTypes(SchemaType));\n\t\t\t\t}\n\t\t\t\tSetType = setTypeMap.get(SchemaType).Maybe;\n\t\t\t\treturn SetType.hydrate(value, comparisonsConverter.hydrate);\n\t\t\t}\n\t\t\t// We can't create the `SetType`, so lets hydrate with the default behavior.\n\t\t\telse {\n\t\t\t\treturn comparisonsConverter.hydrate(value, hydrateChild);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// HERE {$gt: 1} -> new is.GreaterThan(1)\n\t\treturn comparisonsConverter.hydrate(value, hydrateChild);\n\t}\n}\n\nfunction hydrateAndValues(values, schemaProperties, hydrateUnknown) {\n\tschemaProperties = schemaProperties || {};\n\n\tfunction hydrateChild(value) {\n\t\tif (value) {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn value.map(hydrateUnknown);\n\t\t\t} else if (canReflect.isPlainObject(value)) {\n\t\t\t\t// lets try to get the schema ...\n\t\t\t\treturn hydrateAndValues(value, getSchemaProperties(value));\n\t\t\t}\n\t\t}\n\t\tif (hydrateUnknown) {\n\t\t\treturn hydrateUnknown(value);\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n\tvar clone = {};\n\tcanReflect.eachKey(values, function(value, prop) {\n\t\tclone[prop] = hydrateAndValue(value, prop, schemaProperties[prop], hydrateChild);\n\t});\n\n\treturn new BasicQuery.KeysAnd(clone);\n\n}\n// This tries to combine a bunch of OR-ed ANDS into a single AND.\n// Example: [{name: \"j\", age: 3},{name: \"j\", age: 4}] //-> {name: \"j\", age: in[3,4]}\nfunction combineAnds(ands) {\n\tvar firstKeys = Object.keys(ands[0].values);\n\tvar keys = {};\n\n\tvar keysCompare = new is.In(firstKeys);\n\n\tfirstKeys.map(function(key) {\n\t\tkeys[key] = [];\n\t});\n\n\tvar sameKeys = ands.every(function(and) {\n\t\t// have to have the same keys\n\t\tif (!set.isEqual(keysCompare, new is.In(Object.keys(and.values)))) {\n\t\t\treturn false;\n\t\t}\n\t\tcanReflect.eachKey(and.values, function(value, key) {\n\t\t\tkeys[key].push(value);\n\t\t});\n\t\treturn true;\n\t});\n\tif (!sameKeys) {\n\t\treturn;\n\t}\n\t// now try to union everything and see if it simplifies ...\n\tvar unequalKeys = [];\n\tfirstKeys.forEach(function(key) {\n\t\tvar isEqual = keys[key].reduce(function(newSet, lastSetOrFalse) {\n\t\t\tif (lastSetOrFalse === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (lastSetOrFalse === undefined) {\n\t\t\t\treturn newSet;\n\t\t\t}\n\t\t\tvar res = set.isEqual(newSet, lastSetOrFalse);\n\t\t\treturn res ? newSet : false;\n\t\t});\n\t\tif (!isEqual) {\n\t\t\tunequalKeys.push(key);\n\t\t}\n\t});\n\n\tif (unequalKeys.length !== 1) {\n\t\treturn;\n\t}\n\tvar unionKey = unequalKeys[0];\n\t// lets see if we can union that one value\n\tvar unioned = keys[unionKey].reduce(function(cur, last) {\n\t\treturn set.union(cur, last);\n\t}, set.EMPTY);\n\n\tvar result = {};\n\tfirstKeys.map(function(key) {\n\t\tresult[key] = keys[key][0];\n\t});\n\tresult[unionKey] = unioned;\n\treturn new BasicQuery.KeysAnd(result);\n}\n\nfunction hydrateOrs(values, schemaProperties, hydrateUnknown) {\n\tvar comparisons = values.map(function(value) {\n\t\treturn hydrateAndValues(value, schemaProperties, hydrateUnknown);\n\t});\n\tvar combined = combineAnds(comparisons);\n\tif (combined) {\n\t\treturn combined;\n\t}\n\treturn new BasicQuery.Or(comparisons);\n}\n\nfunction hydrateAnds(values, schemaProperties, hydrateUnknown) {\n\tvar comparisons = values.map(function(value) {\n\t\treturn hydrateAndValues(value, schemaProperties, hydrateUnknown);\n\t});\n\treturn new BasicQuery.And(comparisons);\n}\n\nfunction recursivelyAddOrs(ors, value, serializer, key){\n    value.orValues().forEach(function(orValue){\n        if(typeof orValue.orValues === \"function\") {\n            recursivelyAddOrs(ors, orValue, serializer, key);\n        } else {\n            var result = {};\n            result[key] = serializer(orValue);\n            ors.push( result );\n        }\n    });\n}\n\nmodule.exports = function(schema) {\n\n\tvar id = schema.identity && schema.identity[0];\n\tvar keys = schema.keys;\n\n\tvar serializeMap = [\n\t\t[BasicQuery.Or, function(or, serializer) {\n\t\t\treturn or.values.map(function(value) {\n\t\t\t\treturn serializer(value);\n\t\t\t});\n\t\t}],\n\t\t[BasicQuery.And, function(and, serializer) {\n\t\t\treturn { $and: and.values.map(function(value) {\n\t\t\t\treturn serializer(value);\n\t\t\t}) };\n\t\t}],\n\t\t[BasicQuery.Not, function(nots, serializer) {\n\t\t\treturn { $not: serializer(nots.value) };\n\t\t}],\n\t\t// this destructures ANDs with OR-like clauses\n\t\t[BasicQuery.KeysAnd, function(and, serializer) {\n\t\t\tvar ors = [];\n\t\t\tvar result = {};\n\t\t\tcanReflect.eachKey(and.values, function(value, key) {\n\t\t\t\t// is value universal ... if not, we don't need to add anything\n\n\t\t\t\tif (typeof value.orValues === \"function\") {\n\t\t\t\t\trecursivelyAddOrs(ors, value, serializer, key);\n\t\t\t\t} else {\n\t\t\t\t\tresult[key] = serializer(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (ors.length) {\n\t\t\t\tif (ors.length === 1) {\n\t\t\t\t\treturn ors[0];\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t$or: ors.map(function(orPart) {\n\t\t\t\t\t\t\treturn canReflect.assign(canReflect.serialize(result), orPart);\n\t\t\t\t\t\t})\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t}],\n\t\t[BasicQuery.RecordRange, function(range) {\n\t\t\treturn {\n\t\t\t\tstart: range.start,\n\t\t\t\tend: range.end\n\t\t\t};\n\t\t}],\n\t\t[BasicQuery, function(basicQuery, childSerializer) {\n\n\t\t\tvar filter = set.isEqual(basicQuery.filter, set.UNIVERSAL) ? {} : childSerializer(basicQuery.filter);\n\n\t\t\tvar res = {};\n\t\t\tif (canReflect.size(filter) !== 0) {\n\t\t\t\tres.filter = filter;\n\t\t\t}\n\n\t\t\tif (!set.isEqual(basicQuery.page, defaultQuery.page)) {\n\t\t\t\t// we always provide the start, even if it's 0\n\t\t\t\tres.page = {\n\t\t\t\t\tstart: basicQuery.page.start\n\t\t\t\t};\n\t\t\t\tif (basicQuery.page.end !== defaultQuery.page.end) {\n\t\t\t\t\tres.page.end = basicQuery.page.end;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (basicQuery.sort.key !== id) {\n\t\t\t\tres.sort = basicQuery.sort.key;\n\t\t\t}\n\t\t\treturn res;\n\n\t\t}]\n\t];\n\n\n\n\t// Makes a sort type that can make a compare function using the SetType\n\tvar Sort = BasicQuery.makeSort(schema, hydrateAndValue);\n\tvar serializer = new Serializer(serializeMap);\n\tserializer.add(comparisonsConverter.serializer);\n\n\treturn {\n\t\thydrate: function(data) {\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tvar AcceptedFields = makeEnum(function() {}, [\"filter\", \"sort\", \"page\"]);\n\t\t\t\tvar diff = set.difference(new AcceptedFields(Object.keys(data)), AcceptedFields.UNIVERSAL);\n\t\t\t\tif (diff.values && diff.values.length) {\n\t\t\t\t\tlogDev.warn(\n\t\t\t\t\t\t\"can-query-logic: Ignoring keys: \" + diff.values.join(\", \") + \".\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\n\t\t\tvar filter = canReflect.serialize(data.filter);\n\n\t\t\t// this mutates\n\t\t\tvar filterAnd = hydrateFilter(filter, keys, helpers.valueHydrator);\n\n\t\t\t// Conver the filter arguments\n\n\t\t\tvar query = {\n\t\t\t\tfilter: filterAnd\n\t\t\t};\n\t\t\tif (data.page) {\n\t\t\t\tquery.page = new BasicQuery.RecordRange(data.page.start, data.page.end);\n\t\t\t}\n\t\t\tif (data.sort) {\n\t\t\t\tquery.sort = new Sort(data.sort);\n\t\t\t} else {\n\t\t\t\tquery.sort = new Sort(id);\n\t\t\t}\n\t\t\treturn new BasicQuery(query);\n\t\t},\n\t\tserializer: serializer\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/serializers/basic-query.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/serializers/comparisons.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-query-logic/src/serializers/comparisons.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var is = __webpack_require__(/*! ../types/comparisons */ \"./node_modules/can-query-logic/src/types/comparisons.js\");\nvar Serializer = __webpack_require__(/*! ../serializer */ \"./node_modules/can-query-logic/src/serializer.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar ValuesNot = __webpack_require__(/*! ../types/values-not */ \"./node_modules/can-query-logic/src/types/values-not.js\");\n\nfunction makeNew(Constructor) {\n\treturn function(value) {\n\t\treturn new Constructor(value);\n\t};\n}\nvar hydrateMap = {};\nfunction addHydrateFrom(key, hydrate) {\n\thydrateMap[key] = function(value, unknownHydrator) {\n\t\treturn hydrate( unknownHydrator ? unknownHydrator(value[key]) : value[key]);\n\t};\n\tObject.defineProperty(hydrateMap[key], \"name\", {\n\t\tvalue: \"hydrate \"+key,\n\t\twritable: true\n\t});\n}\n\nfunction addHydrateFromValues(key, hydrate) {\n\thydrateMap[key] = function(value, unknownHydrator) {\n\t\tvar clones = value[key];\n\t\tif(unknownHydrator) {\n\t\t\tclones = clones.map(function(value) {\n\t\t\t\treturn unknownHydrator(value);\n\t\t\t});\n\t\t}\n\t\treturn hydrate( clones );\n\t};\n\tObject.defineProperty(hydrateMap[key], \"name\", {\n\t\tvalue: \"hydrate \"+key,\n\t\twritable: true\n\t});\n}\n\n// https://docs.mongodb.com/manual/reference/operator/query-comparison/\naddHydrateFrom(\"$eq\", function(value) {\n\treturn new is.In([value]);\n});\naddHydrateFrom(\"$ne\", function(value) {\n\treturn new is.NotIn([value]);\n});\n\naddHydrateFrom(\"$gt\", makeNew(is.GreaterThan));\naddHydrateFrom(\"$gte\", makeNew(is.GreaterThanEqual));\naddHydrateFromValues(\"$in\", makeNew(is.In));\naddHydrateFrom(\"$lt\", makeNew(is.LessThan));\naddHydrateFrom(\"$lte\", makeNew(is.LessThanEqual));\n\naddHydrateFromValues(\"$all\", makeNew(is.All));\n\n// This is a mapping of types to their opposite. The $not hydrator\n// uses this to create a more specific type, since they are logical opposites.\nvar oppositeTypeMap = {\n\tLessThan: { Type: is.GreaterThanEqual, prop: \"value\" },\n\tLessThanEqual: { Type: is.GreaterThan, prop: \"value\" },\n\tGreaterThan: { Type: is.LessThanEqual, prop: \"value\" },\n\tGreaterThanEqual: { Type: is.LessThan, prop: \"value\" },\n\tIn: { Type: is.NotIn, prop: \"values\" },\n\tNotIn: { Type: is.In, prop: \"values\" }\n};\n\nhydrateMap.$not = function(value, unknownHydrator) {\n\t// Many nots can be hydrated to their opposite.\n\tvar hydratedValue = hydrateValue(value.$not, unknownHydrator);\n\tvar typeName = hydratedValue.constructor.name || hydratedValue.constructor.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n\n\tif(oppositeTypeMap[typeName]) {\n\t\tvar options = oppositeTypeMap[typeName];\n\t\tvar OppositeConstructor = options.Type;\n\t\tvar prop = options.prop;\n\n\t\treturn new OppositeConstructor(hydratedValue[prop]);\n\t}\n\n\treturn new ValuesNot(hydratedValue);\n};\n\naddHydrateFromValues(\"$nin\", makeNew(is.NotIn));\n\n\nvar serializer = new Serializer([\n\t[is.In,function(isIn, serialize) {\n\t\treturn isIn.values.length === 1 ?\n\t\t\tserialize(isIn.values[0]) :\n\t\t\t{$in: isIn.values.map(serialize)};\n\t}],\n\t[is.NotIn,function(notIn, serialize) {\n\t\treturn notIn.values.length === 1 ?\n\t\t\t{$ne: serialize(notIn.values[0])} : {$nin: notIn.values.map(serialize)};\n\t}],\n\t[is.GreaterThan, function(gt, serialize) { return {$gt: serialize(gt.value) }; }],\n\t[is.GreaterThanEqual, function(gte, serialize) { return {$gte: serialize(gte.value) }; }],\n\t[is.LessThan, function(lt, serialize) { return {$lt: serialize(lt.value) }; }],\n\t[is.LessThanEqual, function(lt, serialize) { return {$lte: serialize(lt.value) }; }],\n\t[is.And, function(and, serialize) {\n\t\tvar obj = {};\n\t\tand.values.forEach(function(clause) {\n\t\t\tcanReflect.assignMap(obj, serialize(clause) );\n\t\t});\n\t\treturn obj;\n\t}],\n\t[is.All, function(all, serialize) {\n\t\treturn {\n\t\t\t$all: serialize(all.values)\n\t\t};\n\t}]\n\t/*[is.Or, function(or, serialize) {\n\t\treturn {\n\t\t\t$or: or.values.map(function(value) {\n\t\t\t\treturn serialize(value, serialize);\n\t\t\t})\n\t\t};\n\t}]*/\n]);\n\nfunction hydrateValue(value, hydrateUnknown) {\n\tif(!hydrateUnknown) {\n\t\thydrateUnknown = function() {\n\t\t\tthrow new Error(\"can-query-logic doesn't recognize operator: \"+JSON.stringify(value));\n\t\t};\n\t}\n\tif(Array.isArray(value)) {\n\t\treturn new is.In(value.map(function(value) {\n\t\t\treturn hydrateUnknown(value);\n\t\t}));\n\t}\n\telse if(value && typeof value === \"object\") {\n\t\tvar keys = Object.keys(value);\n\t\tvar allKeysAreComparisons = keys.every(function(key) {\n\t\t\treturn hydrateMap[key];\n\t\t});\n\t\tif(allKeysAreComparisons) {\n\t\t\tvar andClauses = keys.map(function(key) {\n\t\t\t\tvar part = {};\n\t\t\t\tpart[key] = value[key];\n\t\t\t\tvar hydrator = hydrateMap[key];\n\t\t\t\treturn hydrator(part, hydrateUnknown);\n\t\t\t});\n\t\t\tif(andClauses.length > 1) {\n\t\t\t\treturn new is.And(andClauses);\n\t\t\t} else {\n\t\t\t\treturn andClauses[0];\n\t\t\t}\n\t\t} else {\n\t\t\treturn hydrateUnknown(value);\n\t\t}\n\t} else {\n\t\treturn new is.In([hydrateUnknown(value)]);\n\t}\n}\n\nmodule.exports = {\n\t// value - something from a query, for example {$in: [1,2]}\n\thydrate: hydrateValue,\n\tserializer: serializer\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/serializers/comparisons.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/set.js":
/*!*************************************************!*\
  !*** ./node_modules/can-query-logic/src/set.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// # can-query-logic/set.js\n// This file defines the set mechanics of types.\n// It provides ways for types to define how to perform\n// `union`, `difference`, `intersection` operations.\n//\n// It also derives other operators (`isEqual`, `isSubset`, etc) from these\n// core operators.\n//\n// `.memberOf` is a property that defines if a value is within the set. It's\n// currently a different thing.\n\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\n\n// This is what we are defining\nvar set;\n\n// ## HELPERS =========\n//\n// Used to make sure an object serializes to itself.\n// This makes sure the empty object won't try to clone itself.\nvar addSerializeToThis = function(obj) {\n\treturn canReflect.assignSymbols(obj, {\n\t\t\"can.serialize\": function() {\n\t\t\treturn this;\n\t\t}\n\t});\n};\n\n// Reverses the arguments of a function.\nfunction reverseArgs(fn) {\n\treturn function(first, second) {\n\t\treturn fn.call(this, second, first);\n\t};\n}\n\n// This symbol is put on constructor functions to track the comparator operators\n// available to that type.\nvar setComparisonsSymbol = canSymbol.for(\"can.setComparisons\");\n\n// Adds comparators to a type. They are stored like:\n// Type[@can.setComparisons] = Map({\n//    [type1]: Map({[type2]: {union, different, intersection}})\n// })\n//\n// Why do we need the outer object?\nfunction addComparators(type1, type2, comparators) {\n\tvar comparisons = type1[setComparisonsSymbol];\n\tif (!type1[setComparisonsSymbol]) {\n\t\tcomparisons = type1[setComparisonsSymbol] = new Map();\n\t}\n\tvar subMap = comparisons.get(type1);\n\n\tif (!subMap) {\n\t\tsubMap = new Map();\n\t\tcomparisons.set(type1, subMap);\n\t}\n\tvar existingComparators = subMap.get(type2);\n\tif (existingComparators) {\n\t\tfor (var prop in comparators) {\n\t\t\tif (existingComparators.hasOwnProperty(prop)) {\n\t\t\t\tconsole.warn(\"Overwriting \" + type1.name + \" \" + prop + \" \" + type2.name + \" comparitor\");\n\t\t\t}\n\t\t\texistingComparators[prop] = comparators[prop];\n\t\t}\n\t} else {\n\t\tsubMap.set(type2, comparators);\n\t}\n}\n\n\n// This type is used for primitives in JS, but it can be used for\n// any value that should only === itself.\nfunction Identity() {}\n\nvar typeMap = {\n\t\"number\": Identity,\n\t\"string\": Identity,\n\t\"undefined\": Identity,\n\t\"boolean\": Identity\n};\n\n// `get.intersection`, etc is used to look within the types\n// maps and get the right comparator operators.\nvar get = {};\n/*\nvar algebraSymbol = {\n    \"intersection\": \"âˆ©\",\n    \"union\": \"âˆª\",\n    \"difference\": \"\\\\\"\n};\n*/\n\n[\"intersection\", \"difference\", \"union\"].forEach(function(prop) {\n\tget[prop] = function(forwardComparators, value1, value2) {\n\n\t\tif (value2 === set.UNIVERSAL) {\n\t\t\tif (prop === \"intersection\") {\n\t\t\t\treturn value1;\n\t\t\t}\n\t\t\tif (prop === \"union\") {\n\t\t\t\treturn set.UNIVERSAL;\n\t\t\t}\n\t\t\tif (prop === \"difference\") {\n\t\t\t\treturn set.EMPTY;\n\t\t\t}\n\t\t}\n\t\tif (value1 === set.UNIVERSAL) {\n\t\t\tif (prop === \"intersection\") {\n\t\t\t\treturn value1;\n\t\t\t}\n\t\t\tif (prop === \"union\") {\n\t\t\t\treturn set.UNIVERSAL;\n\t\t\t}\n\t\t}\n\n\t\tif (forwardComparators && forwardComparators[prop]) {\n\t\t\tvar result = forwardComparators[prop](value1, value2);\n\t\t\t// console.log(\"\",/*name1,*/ value1, algebraSymbol[prop], /*name2,*/ value2,\"=\", result);\n\t\t\tif (result === undefined && forwardComparators.undefinedIsEmptySet === true) {\n\t\t\t\treturn set.EMPTY;\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"Unable to perform \" + prop + \" between \" + set.getType(value1).name + \" and \" + set.getType(value2).name);\n\t\t}\n\n\t};\n});\n\n\n\nset = {\n\t// The special types\n\n\t// All values within the \"universe\". Other sets can equal UNIVERSAL.\n\tUNIVERSAL: canReflect.assignSymbols({\n\t\tname: \"UNIVERSAL\"\n\t}, {\n\t\t\"can.serialize\": function() {\n\t\t\treturn this;\n\t\t},\n\t\t\"can.isMember\": function(){\n\t\t\treturn true;\n\t\t}\n\t}),\n\t// Nothing\n\tEMPTY: canReflect.assignSymbols({\n\t\tname: \"EMPTY\"\n\t}, {\n\t\t\"can.serialize\": function() {\n\t\t\treturn this;\n\t\t},\n\t\t\"can.isMember\": function(){\n\t\t\treturn false;\n\t\t}\n\t}),\n\t// The set exists, but we lack the language to represent it.\n\tUNDEFINABLE: addSerializeToThis({\n\t\tname: \"UNDEFINABLE\"\n\t}),\n\t// We don't know if this exists. Intersection between two paginated sets.\n\tUNKNOWABLE: addSerializeToThis({\n\t\tname: \"UNKNOWABLE\"\n\t}),\n\tIdentity: Identity,\n\tisSpecial: function(setA) {\n\t\treturn setA === set.UNIVERSAL || setA === set.EMPTY ||\n\t\t\tsetA === set.UNDEFINABLE || setA === set.UNKNOWABLE;\n\t},\n\tisDefinedAndHasMembers: function(setA) {\n\t\tif (setA !== set.EMPTY && setA !== set.UNDEFINABLE && setA !== set.UNKNOWABLE) {\n\t\t\treturn !!setA;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t},\n\tgetType: function(value) {\n\t\tif (value === set.UNIVERSAL) {\n\t\t\treturn set.UNIVERSAL;\n\t\t}\n\t\tif (value === set.EMPTY) {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t\tif (value === set.UNKNOWABLE) {\n\t\t\treturn set.UNKNOWABLE;\n\t\t}\n\t\tif (value === null) {\n\t\t\treturn Identity;\n\t\t}\n\t\tif (typeMap.hasOwnProperty(typeof value)) {\n\t\t\treturn typeMap[typeof value];\n\t\t}\n\t\treturn value.constructor;\n\t},\n\t// This tries to get two comparable values from objects.\n\t// In many ways this is similar to what JavaScript does if it sees\n\t// `new Date() > new Date()`, it tries to coerce one value into the other value.\n\townAndMemberValue: function(startOwnValue, startMemberValue) {\n\t\t// If either side has a value, then try to type-coerse.\n\t\tif (startOwnValue != null || startMemberValue != null) {\n\t\t\t// First try to get `.valueOf` from either side\n\t\t\tvar ownValue = startOwnValue != null ? startOwnValue.valueOf() : startOwnValue,\n\t\t\t\tmemberValue = startMemberValue != null ? startMemberValue.valueOf() : startMemberValue;\n\n\t\t\t// If we ot passed a null on either side, return extracted values\n\t\t\tif (startOwnValue == null || startMemberValue == null) {\n\t\t\t\treturn {\n\t\t\t\t\town: ownValue,\n\t\t\t\t\tmember: memberValue\n\t\t\t\t};\n\t\t\t}\n\t\t\t// If we read the values, but they aren't the same type ...\n\t\t\t// we will try to convert the member to the same type as the `startOwnValue`'s type.\n\t\t\t// And then read `.valueOf()` from that.\n\t\t\tif (ownValue == null || ownValue.constructor !== memberValue.constructor) {\n\t\t\t\tmemberValue = new startOwnValue.constructor(memberValue).valueOf();\n\t\t\t}\n\t\t\treturn {\n\t\t\t\town: ownValue,\n\t\t\t\tmember: memberValue\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\town: startMemberValue,\n\t\t\tmember: startOwnValue\n\t\t};\n\t},\n\tgetComparisons: function(Type1, Type2) {\n\t\tvar comparisons = Type1[setComparisonsSymbol];\n\t\tif (comparisons) {\n\t\t\tvar subMap = comparisons.get(Type1);\n\n\t\t\tif (subMap) {\n\t\t\t\treturn subMap.get(Type2);\n\t\t\t}\n\t\t}\n\t},\n\thasComparisons: function(Type) {\n\t\treturn !!Type[setComparisonsSymbol];\n\t},\n\tdefineComparison: function(type1, type2, comparators) {\n\t\taddComparators(type1, type2, comparators);\n\t\tif (type1 !== type2) {\n\t\t\tvar reverse = {};\n\t\t\tfor (var prop in comparators) {\n\t\t\t\t// difference can not be reversed\n\t\t\t\tif (prop !== \"difference\") {\n\t\t\t\t\treverse[prop] = reverseArgs(comparators[prop]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\taddComparators(type2, type1, reverse);\n\t\t}\n\t},\n\t/**\n\t * Checks if A is a subset of B.  If A is a subset of B if:\n\t * - A \\ B = EMPTY (A has nothing outside what's in B)\n\t * - A âˆ© B = defined\n\t */\n\tisSubset: function(value1, value2) {\n\t\t// check primary direction\n\t\tif (value1 === value2) {\n\t\t\treturn true;\n\t\t}\n\t\tvar Type1 = set.getType(value1),\n\t\t\tType2 = set.getType(value2);\n\t\tvar forwardComparators = set.getComparisons(Type1, Type2);\n\t\tif (forwardComparators) {\n\t\t\t// A set is a subset, if it intersects with the set, and it has nothing\n\t\t\t// outside the other set.\n\t\t\tvar intersection = get.intersection(forwardComparators, value1, value2);\n\t\t\t// [a, b] \\ [a, b, c]\n\t\t\tvar difference = get.difference(forwardComparators, value1, value2);\n\t\t\t// they intersect, but value2 has nothing value1 outside value2\n\t\t\tif (intersection === set.UNKNOWABLE || difference === set.UNKNOWABLE) {\n\t\t\t\t// {sort: \"a\", page: 0-2} E {sort: \"b\", page: 2-3}\n\t\t\t\treturn undefined;\n\t\t\t} else if (intersection !== set.EMPTY && difference === set.EMPTY) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"Unable to perform subset comparison between \" + Type1.name + \" and \" + Type2.name);\n\t\t}\n\t},\n\tisProperSubset: function(setA, setB) {\n\t\treturn set.isSubset(setA, setB) && !set.isEqual(setA, setB);\n\t},\n\tisEqual: function(value1, value2) {\n\t\tif (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {\n\t\t\treturn set.UNKNOWABLE;\n\t\t}\n\t\t//console.group(\"is\", value1, \"==\", value2);\n\t\tvar isSpecial1 = set.isSpecial(value1),\n\t\t\tisSpecial2 = set.isSpecial(value2);\n\n\t\t// Both have to be specail because some other sets will be equal to UNIVERSAL without being UNIVERSAL\n\t\tif (isSpecial1 && isSpecial2) {\n\t\t\treturn isSpecial1 === isSpecial2;\n\t\t}\n\t\tvar Type1 = set.getType(value1),\n\t\t\tType2 = set.getType(value2);\n\t\tif (value1 === value2) {\n\t\t\treturn true;\n\t\t}\n\t\tvar forwardComparators = set.getComparisons(Type1, Type2);\n\t\tvar reverseComparators = set.getComparisons(Type2, Type1);\n\t\tif (forwardComparators && reverseComparators) {\n\n\t\t\t// Two sets are equal if there's an intersection, but not difference\n\t\t\tvar intersection = get.intersection(forwardComparators, value1, value2);\n\t\t\tvar difference = get.difference(forwardComparators, value1, value2);\n\t\t\tif (intersection !== set.EMPTY && difference === set.EMPTY) {\n\t\t\t\tvar reverseIntersection = get.intersection(reverseComparators, value2, value1);\n\t\t\t\tvar reverseDifference = get.difference(reverseComparators, value2, value1);\n\t\t\t\t//console.groupEnd();\n\t\t\t\treturn reverseIntersection !== set.EMPTY && reverseDifference === set.EMPTY;\n\t\t\t} else {\n\t\t\t\t//console.groupEnd();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tvar values = set.ownAndMemberValue(value1, value2);\n\t\t\tif (canReflect.isPrimitive(values.own) && canReflect.isPrimitive(values.member)) {\n\t\t\t\treturn values.own === values.member;\n\t\t\t} else {\n\t\t\t\t// try to convert ...\n\t\t\t\tthrow new Error(\"Unable to perform equal comparison between \" + Type1.name + \" and \" + Type2.name);\n\t\t\t}\n\n\t\t}\n\t},\n\n\tunion: function(value1, value2) {\n\t\tif (value1 === set.UNIVERSAL || value2 === set.UNIVERSAL) {\n\t\t\treturn set.UNIVERSAL;\n\t\t}\n\t\tif (value1 === set.EMPTY) {\n\t\t\treturn value2;\n\t\t} else if (value2 === set.EMPTY) {\n\t\t\treturn value1;\n\t\t}\n\t\tif (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {\n\t\t\treturn set.UNKNOWABLE;\n\t\t}\n\t\tvar Type1 = set.getType(value1),\n\t\t\tType2 = set.getType(value2);\n\t\tvar forwardComparators = set.getComparisons(Type1, Type2);\n\t\treturn get.union(forwardComparators, value1, value2);\n\t},\n\n\tintersection: function(value1, value2) {\n\t\tif (value1 === set.UNIVERSAL) {\n\t\t\treturn value2;\n\t\t}\n\t\tif (value2 === set.UNIVERSAL) {\n\t\t\treturn value1;\n\t\t}\n\t\tif (value1 === set.EMPTY || value2 === set.EMPTY) {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t\tif (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {\n\t\t\treturn set.UNKNOWABLE;\n\t\t}\n\t\tvar Type1 = set.getType(value1),\n\t\t\tType2 = set.getType(value2);\n\t\tvar forwardComparators = set.getComparisons(Type1, Type2);\n\t\tif (forwardComparators) {\n\t\t\treturn get.intersection(forwardComparators, value1, value2);\n\t\t} else {\n\t\t\tthrow new Error(\"Unable to perform intersection comparison between \" + Type1.name + \" and \" + Type2.name);\n\t\t}\n\t},\n\tdifference: function(value1, value2) {\n\t\tif (value1 === set.EMPTY) {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t\tif (value2 === set.EMPTY) {\n\t\t\treturn value1;\n\t\t}\n\t\tif (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {\n\t\t\treturn set.UNKNOWABLE;\n\t\t}\n\t\tvar Type1 = set.getType(value1),\n\t\t\tType2 = set.getType(value2);\n\t\tvar forwardComparators = set.getComparisons(Type1, Type2);\n\t\tif (forwardComparators) {\n\t\t\treturn get.difference(forwardComparators, value1, value2);\n\t\t} else {\n\t\t\tthrow new Error(\"Unable to perform difference comparison between \" + Type1.name + \" and \" + Type2.name);\n\t\t}\n\t},\n\n\tindexWithEqual: function(arr, value) {\n\t\tfor (var i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (set.isEqual(arr[i], value)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n};\n\n\n\nfunction identityIntersection(v1, v2) {\n\treturn v1 === v2 ? v1 : set.EMPTY;\n}\n\nfunction identityDifference(v1, v2) {\n\treturn v1 === v2 ? set.EMPTY : v1;\n}\n\nfunction identityUnion(v1, v2) {\n\treturn v1 === v2 ? v1 : set.UNDEFINABLE;\n}\nvar identityComparitor = {\n\tintersection: identityIntersection,\n\tdifference: identityDifference,\n\tunion: identityUnion\n};\nset.defineComparison(Identity, Identity, identityComparitor);\n\nset.defineComparison(set.UNIVERSAL, set.UNIVERSAL, identityComparitor);\n\nmodule.exports = set;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/set.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/and-or-not.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/and-or-not.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ValuesOr = __webpack_require__(/*! ./values-or */ \"./node_modules/can-query-logic/src/types/values-or.js\");\nvar ValuesNot = __webpack_require__(/*! ./values-not */ \"./node_modules/can-query-logic/src/types/values-not.js\");\nvar ValuesAnd = __webpack_require__(/*! ./values-and */ \"./node_modules/can-query-logic/src/types/values-and.js\");\nvar KeysAnd = __webpack_require__(/*! ./keys-and */ \"./node_modules/can-query-logic/src/types/keys-and.js\");\n\nmodule.exports = {\n    KeysAnd: KeysAnd,\n    ValuesOr: ValuesOr,\n    ValuesNot: ValuesNot,\n\tValuesAnd: ValuesAnd\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/and-or-not.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/array-comparisons.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/array-comparisons.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var common = __webpack_require__(/*! ./comparisons-common */ \"./node_modules/can-query-logic/src/types/comparisons-common.js\");\nvar set = __webpack_require__(/*! ../set */ \"./node_modules/can-query-logic/src/set.js\");\nvar ValuesNot = __webpack_require__(/*! ./values-not */ \"./node_modules/can-query-logic/src/types/values-not.js\");\n\nvar comparisons = {\n\tAll: function(values){\n\t\tthis.values = values;\n\t}\n};\n\ncomparisons.All.prototype.isMember = common.isMemberThatUsesTestOnValues;\n\nvar is = comparisons;\n\ncomparisons.All.test = function(allValues, recordValues) {\n\treturn allValues.every(function(allValue) {\n\t\treturn recordValues.some(function(recordValue){\n\t\t\tvar values = set.ownAndMemberValue(allValue, recordValue);\n\t\t\treturn values.own === values.member;\n\t\t});\n\t});\n};\n\nfunction makeThrowCannotCompare(type, left, right) {\n\treturn function() {\n\t\tthrow new Error(\"can-query-logic: Cannot perform \" + type + \" between \" + left + \" and \" + right);\n\t};\n}\n\nfunction throwComparatorAllTypes(type1, type2) {\n\treturn {\n\t\tunion: makeThrowCannotCompare(\"union\", type1,  type2),\n\t\tdifference: makeThrowCannotCompare(\"difference\", type1, type2),\n\t\tintersection: makeThrowCannotCompare(\"intersection\", type1, type2)\n\t};\n}\n\nfunction throwComparatorDifference(type1, type2) {\n\treturn {\n\t\tdifference: makeThrowCannotCompare(\"difference\", type1, type2)\n\t};\n}\n\nvar comparators = {\n\tUNIVERSAL_All: {\n\t\tdifference: function(universe, all) {\n\t\t\treturn new ValuesNot(all);\n\t\t}\n\t},\n\tAll_UNIVERSAL: {\n\t\tdifference: function() {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t},\n\tAll_All: {\n\t\tunion: function(a, b) {\n\t\t\treturn new is.Or([a, b]);\n\t\t}\n\t},\n\tIn_All: throwComparatorDifference(\"In\", \"All\"),\n\tAll_In: throwComparatorAllTypes(\"All\", \"In\"),\n\tNotIn_All: throwComparatorDifference(\"NotIn\", \"All\"),\n\tAll_NotIn: throwComparatorAllTypes(\"All\", \"NotIn\"),\n\tGreaterThan_All: throwComparatorDifference(\"GreaterThan\", \"All\"),\n\tAll_GreaterThan: throwComparatorAllTypes(\"All\", \"GreaterThan\"),\n\tGreaterThanEqual_All: throwComparatorDifference(\"GreaterThanEqual\", \"All\"),\n\tAll_GreaterThanEqual: throwComparatorAllTypes(\"All\", \"GreaterThanEqual\"),\n\tLessThan_All: throwComparatorDifference(\"LessThan\", \"All\"),\n\tAll_LessThan: throwComparatorAllTypes(\"All\", \"LessThan\"),\n\tLessThanEqual_All: throwComparatorDifference(\"LessThanEqual\", \"All\"),\n\tAll_LessThanEqual: throwComparatorAllTypes(\"All\", \"LessThanEqual\"),\n\tAll_And: throwComparatorDifference(\"All\", \"And\"),\n\tAnd_All: throwComparatorAllTypes(\"And\",\t \"All\"),\n\tAll_Or: throwComparatorDifference(\"All\", \"Or\"),\n\tOr_All: throwComparatorAllTypes(\"Or\", \"All\")\n};\n\nexports.comparisons = comparisons;\nexports.comparators = comparators;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/array-comparisons.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/basic-query.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/basic-query.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var set = __webpack_require__(/*! ../set */ \"./node_modules/can-query-logic/src/set.js\");\nvar makeRealNumberRangeInclusive = __webpack_require__(/*! ./make-real-number-range-inclusive */ \"./node_modules/can-query-logic/src/types/make-real-number-range-inclusive.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar andOrNot = __webpack_require__(/*! ./and-or-not */ \"./node_modules/can-query-logic/src/types/and-or-not.js\");\nvar helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/can-query-logic/src/helpers.js\");\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"./node_modules/can-define-lazy-value/define-lazy-value.js\");\n\n// TYPES FOR FILTERING\nvar KeysAnd = andOrNot.KeysAnd,\n\tOr = andOrNot.ValuesOr,\n\tNot = andOrNot.ValuesNot,\n\tAnd = andOrNot.ValuesAnd;\n\n// TYPES FOR PAGINATION\nvar RecordRange = makeRealNumberRangeInclusive(0, Infinity);\n\n\n// ## makeSort\n// Takes:\n// - `schemaKeys` - a schema\n// - `hydrateAndValue` - Useful to create something like `new GreaterThan( new MaybeDate(\"10-20-82\") )`\n//\n// Makes a `new Sort(key)` constructor function. This constructor function is used like:\n//\n// ```\n// new Sort(\"dueDate\")\n// ```\n//\n// That constructor function has all the comparison methods (union, intersection, difference)\n// built to compare against the `key` value.\n//\n// Instances of `Sort` have a `compare` method that will\n// return a function that can be passed to `Array.prototype.sort`.\n//\n// That compare function will read the right property and return `-1` or `1`\n\n// WILL MAKE A TYPE FOR SORTING\nfunction makeSort(schema, hydrateAndValue) {\n\tvar schemaKeys = schema.keys;\n\t// Makes gt and lt functions that `helpers.sorter` can use\n\t// to make a `compare` function for `Array.sort(compare)`.`\n\tvar sorters = {};\n\tcanReflect.eachKey(schemaKeys, function(schemaProp, key) {\n\n\t\tsorters[key] = {\n\t\t\t// valueA is GT valueB\n\t\t\t$gt: function(valueA, valueB) {\n\t\t\t\t// handle sorting with null / undefined values\n\t\t\t\tif(valueA == null || valueB == null) {\n\t\t\t\t\treturn helpers.typeCompare.$gt(valueA, valueB);\n\t\t\t\t}\n\t\t\t\t// The following can certainly be done faster\n\t\t\t\tvar $gt = hydrateAndValue({\n\t\t\t\t\t\t$gt: valueB\n\t\t\t\t\t}, key, schemaProp,\n\t\t\t\t\thelpers.valueHydrator);\n\n\t\t\t\tvar $eq = hydrateAndValue({\n\t\t\t\t\t\t$eq: valueA\n\t\t\t\t\t}, key, schemaProp,\n\t\t\t\t\thelpers.valueHydrator);\n\n\t\t\t\treturn set.isEqual( set.union($gt, $eq), $gt );\n\t\t\t\t/*\n\t\t\t\tvar hydratedIn =  hydrateAndValue({\n\t\t\t\t\t\t$eq: valueA\n\t\t\t\t\t}, key, schemaProp,\n\t\t\t\t\thelpers.valueHydrator);\n\t\t\t\treturn $gt[require(\"can-symbol\").for(\"can.isMember\")](hydratedIn.values[0]);*/\n\t\t\t},\n\t\t\t$lt: function(valueA, valueB) {\n\t\t\t\tif(valueA == null || valueB == null) {\n\t\t\t\t\treturn helpers.typeCompare.$lt(valueA, valueB);\n\t\t\t\t}\n\n\n\t\t\t\tvar $lt = hydrateAndValue({\n\t\t\t\t\t\t$lt: valueB\n\t\t\t\t\t}, key, schemaProp,\n\t\t\t\t\thelpers.valueHydrator);\n\n\t\t\t\tvar $eq = hydrateAndValue({\n\t\t\t\t\t\t$eq: valueA\n\t\t\t\t\t}, key, schemaProp,\n\t\t\t\t\thelpers.valueHydrator);\n\n\t\t\t\treturn set.isEqual( set.union($lt, $eq), $lt );\n\t\t\t\t/*\n\t\t\t\t// This doesn't work because it will try to create new SetType(new In([]))\n\t\t\t\tvar hydratedValue =  hydrateAndValue({\n\t\t\t\t\t\t$eq: valueA\n\t\t\t\t\t}, key, schemaProp,\n\t\t\t\t\thelpers.valueHydrator);\n\t\t\t\treturn $lt[require(\"can-symbol\").for(\"can.isMember\")](hydratedValue);*/\n\n\t\t\t\t/*\n\t\t\t\t// This doesn't work because of maybe types.\n\t\t\t\tvar hydratedIn =  hydrateAndValue({\n\t\t\t\t\t\t$eq: valueA\n\t\t\t\t\t}, key, schemaProp,\n\t\t\t\t\thelpers.valueHydrator);\n\t\t\t\treturn $lt[require(\"can-symbol\").for(\"can.isMember\")](hydratedIn.values[0]); */\n\t\t\t}\n\t\t};\n\t});\n\n\tfunction Sort(key) {\n\t\tthis.key = key;\n\t\tthis.schema = schema;\n\t\tthis.compare = helpers.sorter(key, sorters);\n\t}\n\n\tfunction identityIntersection(v1, v2) {\n\t\treturn v1.key === v2.key ? v1 : set.EMPTY;\n\t}\n\n\tfunction identityDifference(v1, v2) {\n\t\treturn v1.key === v2.key ? set.EMPTY : v1;\n\t}\n\n\tfunction identityUnion(v1, v2) {\n\t\treturn v1.key === v2.key ? v1 : set.UNDEFINABLE;\n\t}\n\tset.defineComparison(Sort, Sort, {\n\t\tintersection: identityIntersection,\n\t\tdifference: identityDifference,\n\t\tunion: identityUnion\n\t});\n\treturn Sort;\n}\n\nvar DefaultSort = makeSort({ keys: {}, identity: [\"id\"] });\n\n\n// Define the BasicQuery type\nfunction BasicQuery(query) {\n\tassign(this, query);\n\tif (!this.filter) {\n\t\tthis.filter = set.UNIVERSAL;\n\t}\n\tif (!this.page) {\n\t\tthis.page = new RecordRange();\n\t}\n\tif (!this.sort) {\n\t\tthis.sort = \"id\";\n\t}\n\tif (typeof this.sort === \"string\") {\n\t\tthis.sort = new DefaultSort(this.sort);\n\t}\n}\n\n// BasicQuery's static properties\nBasicQuery.KeysAnd = KeysAnd;\nBasicQuery.Or = Or;\nBasicQuery.Not = Not;\nBasicQuery.And = And;\nBasicQuery.RecordRange = RecordRange;\nBasicQuery.makeSort = makeSort;\n\n// BasicQuery's prototype methods.\n// These are \"additional\" features beyond what `set` provides.\n// These typically pertain to actual data results of a query.\ncanReflect.assignMap(BasicQuery.prototype, {\n\tcount: function() {\n\t\treturn this.page.end - this.page.start + 1;\n\t},\n\tsortData: function(data) {\n\t\treturn data.slice(0).sort(this.sort.compare);\n\t},\n\tfilterMembersAndGetCount: function(bData, parentQuery) {\n\t\tvar parentIsUniversal;\n\t\tif (parentQuery) {\n\t\t\tparentIsUniversal = set.isEqual(parentQuery.page, set.UNIVERSAL);\n\t\t\tif ((parentIsUniversal &&\n\t\t\t\t!set.isEqual(parentQuery.filter, set.UNIVERSAL)) &&\n\t\t\t\t!set.isSubset(this, parentQuery)) {\n\t\t\t\tthrow new Error(\"can-query-logic: Unable to get members from a set that is not a superset of the current set.\");\n\t\t\t}\n\t\t} else {\n\t\t\tparentQuery = new BasicQuery();\n\t\t}\n\n\t\t// reduce response to items in data that meet where criteria\n\t\tvar aData = bData.filter(function(data) {\n\t\t\treturn this.filter.isMember(data);\n\t\t}, this);\n\n\t\tvar count = aData.length;\n\n\t\t// sort the data if needed\n\t\tif (count && (this.sort.key !== parentQuery.sort.key)) {\n\t\t\taData = this.sortData(aData);\n\t\t}\n\n\t\tvar thisIsUniversal = set.isEqual(this.page, set.UNIVERSAL);\n\t\tif(parentIsUniversal == null) {\n\t\t\tparentIsUniversal = set.isEqual(parentQuery.page, set.UNIVERSAL);\n\t\t}\n\n\t\tif (parentIsUniversal) {\n\t\t\tif (thisIsUniversal) {\n\t\t\t\treturn {\n\t\t\t\t\tdata: aData,\n\t\t\t\t\tcount: count\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tdata: aData.slice(this.page.start, this.page.end + 1),\n\t\t\t\t\tcount: count\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\t// everything but range is equal\n\t\telse if (this.sort.key === parentQuery.sort.key && set.isEqual(parentQuery.filter, this.filter)) {\n\t\t\treturn {\n\t\t\t\tdata: aData.slice(this.page.start - parentQuery.page.start, this.page.end - parentQuery.page.start + 1),\n\t\t\t\tcount: count\n\t\t\t};\n\t\t} else {\n\t\t\t// parent starts at something ...\n\t\t\tthrow new Error(\"can-query-logic: Unable to get members from the parent set for this subset.\");\n\t\t}\n\t},\n\tfilterFrom: function(bData, parentQuery) {\n\t\treturn this.filterMembersAndGetCount(bData, parentQuery).data;\n\t},\n\tmerge: function(b, aItems, bItems, getId) {\n\t\tvar union = set.union(this, b);\n\n\t\tif (union === set.UNDEFINABLE) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tvar combined = helpers.uniqueConcat(aItems, bItems, getId);\n\t\t\treturn union.sortData(combined);\n\t\t}\n\t},\n\tindex: function(props, items) {\n\t\t// make sure we have the property\n\t\tvar data = helpers.sortData(this.sort.key);\n\t\tif (!canReflect.hasOwnKey(props, data.prop)) {\n\t\t\treturn undefined;\n\t\t}\n\t\t// use the passed sort's compare function\n\t\treturn helpers.getIndex(this.sort.compare, items, props, this.sort.schema);\n\t},\n\tisMember: function(props) {\n\t\t// Use the AND type for it's isMember method\n\t\treturn this.filter.isMember(props);\n\t},\n\tremovePagination: function() {\n\t\tthis.page = new RecordRange();\n\t}\n});\n\n// Helpers used for the `set` comparators\nvar CLAUSE_TYPES = [\"filter\", \"page\", \"sort\"];\n\nfunction getDifferentClauseTypes(queryA, queryB) {\n\tvar differentTypes = [];\n\n\tCLAUSE_TYPES.forEach(function(clause) {\n\t\tif (!set.isEqual(queryA[clause], queryB[clause])) {\n\t\t\tdifferentTypes.push(clause);\n\t\t}\n\t});\n\n\treturn differentTypes;\n}\n\nfunction isSubset(subLetter, superLetter, meta) {\n\tif (meta[subLetter + \"FilterIsSubset\"]) {\n\t\tif (meta[superLetter + \"PageIsUniversal\"]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn meta[subLetter + \"PageIsSubset\"] && meta.sortIsEqual;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}\n\n// This type contains a bunch of lazy getters that\n// cache their value after being read.\n// This helps performance.\nfunction MetaInformation(queryA, queryB) {\n\tthis.queryA = queryA;\n\tthis.queryB = queryB;\n}\n\ncanReflect.eachKey({\n\t\"pageIsEqual\": function() {\n\t\treturn set.isEqual(this.queryA.page, this.queryB.page);\n\t},\n\t\"aPageIsUniversal\": function() {\n\t\treturn set.isEqual(this.queryA.page, set.UNIVERSAL);\n\t},\n\t\"bPageIsUniversal\": function() {\n\t\treturn set.isEqual(this.queryB.page, set.UNIVERSAL);\n\t},\n\t\"pagesAreUniversal\": function() {\n\t\treturn this.pageIsEqual && this.aPageIsUniversal;\n\t},\n\t\"sortIsEqual\": function() {\n\t\treturn this.queryA.sort.key === this.queryB.sort.key;\n\t},\n\t\"aFilterIsSubset\": function() {\n\t\treturn set.isSubset(this.queryA.filter, this.queryB.filter);\n\t},\n\t\"bFilterIsSubset\": function() {\n\t\treturn set.isSubset(this.queryB.filter, this.queryA.filter);\n\t},\n\t\"aPageIsSubset\": function() {\n\t\treturn set.isSubset(this.queryA.page, this.queryB.page);\n\t},\n\t\"bPageIsSubset\": function() {\n\t\treturn set.isSubset(this.queryB.page, this.queryA.page);\n\t},\n\t\"filterIsEqual\": function() {\n\t\treturn set.isEqual(this.queryA.filter, this.queryB.filter);\n\t},\n\t\"aIsSubset\": function() {\n\t\treturn isSubset(\"a\", \"b\", this);\n\t},\n\t\"bIsSubset\": function() {\n\t\treturn isSubset(\"b\", \"a\", this);\n\t}\n}, function(def, prop) {\n\tdefineLazyValue(MetaInformation.prototype, prop, def);\n});\n\nfunction metaInformation(queryA, queryB) {\n\tvar meta = new MetaInformation(queryA, queryB);\n\treturn meta;\n}\n\n\n// Define comparators\nset.defineComparison(BasicQuery, BasicQuery, {\n\tunion: function(queryA, queryB) {\n\n\t\tvar meta = metaInformation(queryA, queryB);\n\n\n\t\tvar filterUnion = set.union(queryA.filter, queryB.filter);\n\n\t\tif (meta.pagesAreUniversal) {\n\t\t\t// We ignore the sort.\n\t\t\treturn new BasicQuery({\n\t\t\t\tfilter: filterUnion,\n\t\t\t\tsort: meta.sortIsEqual ? queryA.sort.key : undefined\n\t\t\t});\n\t\t}\n\n\n\t\tif (meta.filterIsEqual) {\n\t\t\tif (meta.sortIsEqual) {\n\t\t\t\treturn new BasicQuery({\n\t\t\t\t\tfilter: queryA.filter,\n\t\t\t\t\tsort: queryA.sort.key,\n\t\t\t\t\tpage: set.union(queryA.page, queryB.page)\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (meta.aIsSubset) {\n\t\t\t\t\treturn queryB;\n\t\t\t\t} else if (meta.bIsSubset) {\n\t\t\t\t\treturn queryA;\n\t\t\t\t}\n\t\t\t\t// we can't specify which pagination would bring in everything.\n\t\t\t\t// but a union does exist.\n\t\t\t\treturn set.UNDEFINABLE;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"different filters, non-universal pages\");\n\t\t}\n\t},\n\tintersection: function(queryA, queryB) {\n\n\t\t// {age: 35} U {name: \"JBM\"} -> {age: 35, name: \"JBM\"}\n\n\t\t// { filter: {age: 35},\n\t\t//   page: {0, 10},\n\t\t//   sort: \"foo\" }\n\t\t// U\n\t\t// { filter: {name: \"JBM\"},\n\t\t//   page: {0, 10},\n\t\t//   sort: \"foo\" }\n\n\t\tvar meta = metaInformation(queryA, queryB);\n\n\t\tif (meta.pagesAreUniversal) {\n\t\t\t// We ignore the sort.\n\t\t\tvar filterResult = set.intersection(queryA.filter, queryB.filter);\n\t\t\tif (set.isDefinedAndHasMembers(filterResult)) {\n\t\t\t\treturn new BasicQuery({\n\t\t\t\t\tfilter: filterResult,\n\t\t\t\t\tsort: meta.sortIsEqual ? queryA.sort.key : undefined\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\treturn filterResult;\n\t\t\t}\n\t\t}\n\n\n\n\t\t// check if disjoint wheres\n\t\tif (set.intersection(queryA.filter, queryB.filter) === set.EMPTY) {\n\t\t\treturn set.EMPTY;\n\t\t}\n\n\t\tif (meta.filterIsEqual) {\n\t\t\tif (meta.sortIsEqual) {\n\t\t\t\treturn new BasicQuery({\n\t\t\t\t\tfilter: queryA.filter,\n\t\t\t\t\tsort: queryA.sort.key,\n\t\t\t\t\tpage: set.intersection(queryA.page, queryB.page)\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (meta.aIsSubset) {\n\t\t\t\t\treturn queryA;\n\t\t\t\t} else if (meta.bIsSubset) {\n\t\t\t\t\treturn queryB;\n\t\t\t\t}\n\t\t\t\treturn set.UNKNOWABLE;\n\t\t\t\t//throw new Error(\"same filter, different sorts, non universal pages\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (meta.aIsSubset) {\n\t\t\t\treturn queryA;\n\t\t\t} else if (meta.bIsSubset) {\n\t\t\t\treturn queryB;\n\t\t\t} else {\n\t\t\t\t// filters are different, both pagination isn't universal\n\t\t\t\treturn set.UNDEFINABLE;\n\t\t\t}\n\n\t\t}\n\n\t},\n\tdifference: function(queryA, queryB) {\n\n\t\tvar differentClauses = getDifferentClauseTypes(queryA, queryB);\n\t\tvar meta = metaInformation(queryA, queryB);\n\t\tvar clause;\n\t\tif (differentClauses.length > 1) {\n\t\t\tif (meta.aIsSubset) {\n\t\t\t\treturn set.EMPTY;\n\t\t\t}\n\t\t\tif (meta.pagesAreUniversal) {\n\t\t\t\treturn new BasicQuery({\n\t\t\t\t\tfilter: set.difference(queryA.filter, queryB.filter),\n\t\t\t\t\tsort: queryA.sort.key\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn set.UNDEFINABLE;\n\t\t} else {\n\t\t\tswitch (clause = differentClauses[0]) {\n\t\t\t\t// if all the clauses are the same, then there can't be a difference\n\t\t\t\tcase undefined:\n\t\t\t\t\t{\n\t\t\t\t\t\treturn set.EMPTY;\n\t\t\t\t\t}\n\t\t\t\tcase \"sort\":\n\t\t\t\t\t{\n\t\t\t\t\t\t// if order is the only difference, then there can't be a difference\n\t\t\t\t\t\t// if items are paged but the order is different, though, the sets are not comparable\n\t\t\t\t\t\t// Either way, the result is false\n\t\t\t\t\t\tif (meta.pagesAreUniversal) {\n\t\t\t\t\t\t\treturn set.EMPTY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn set.UNKNOWABLE;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"page\":\n\t\t\t\tcase \"filter\":\n\t\t\t\t\t{\n\t\t\t\t\t\t// if there's only one clause to evaluate or the clauses are where + id,\n\t\t\t\t\t\t// then we can try to determine the difference set.\n\t\t\t\t\t\t// Note that any difference in the ID clause will cause the result to be\n\t\t\t\t\t\t// true (if A has no ID but B has ID) or false (any case where A has ID)\n\t\t\t\t\t\tvar result = set.difference(queryA[clause],\n\t\t\t\t\t\t\tqueryB[clause]);\n\n\t\t\t\t\t\tif (set.isSpecial(result)) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar query = {\n\t\t\t\t\t\t\t\tfilter: queryA.filter,\n\t\t\t\t\t\t\t\tpage: queryA.page,\n\t\t\t\t\t\t\t\tsort: queryA.sort.key\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tquery[clause] = result;\n\t\t\t\t\t\t\treturn new BasicQuery(query);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n\nmodule.exports = BasicQuery;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/basic-query.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/comparisons-common.js":
/*!**********************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/comparisons-common.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function isMemberThatUsesTestOnValues(value) {\n\treturn this.constructor.test(this.values, value);\n}\n\nexports.isMemberThatUsesTestOnValues = isMemberThatUsesTestOnValues;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/comparisons-common.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/comparisons.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/comparisons.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var set = __webpack_require__(/*! ../set */ \"./node_modules/can-query-logic/src/set.js\");\nvar arrayUnionIntersectionDifference = __webpack_require__(/*! ../array-union-intersection-difference */ \"./node_modules/can-query-logic/src/array-union-intersection-difference.js\");\nvar common = __webpack_require__(/*! ./comparisons-common */ \"./node_modules/can-query-logic/src/types/comparisons-common.js\");\nvar arrayComparisons = __webpack_require__(/*! ./array-comparisons */ \"./node_modules/can-query-logic/src/types/array-comparisons.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar isMemberSymbol = canSymbol.for(\"can.isMember\");\n// $ne\tMatches all values that are not equal to a specified value.\n// $eq\tMatches values that are equal to a specified value.\n//\n// $gt\tMatches values that are greater than a specified value.\n// $gte\tMatches values that are greater than or equal to a specified value.\n\n// $lt\tMatches values that are less than a specified value.\n// $lte\tMatches values that are less than or equal to a specified value.\n\n// $in\tMatches any of the values specified in an array.\n// $nin\tMatches none of the values specified in an array.\n\nvar comparisons = canReflect.assign(arrayComparisons.comparisons, {\n\tIn: function In(values) {\n\t\t// TODO: change this to store as `Set` later.\n\t\tthis.values = values;\n\t},\n\tNotIn: function NotIn(values) {\n\t\tthis.values = values;\n\t},\n\tGreaterThan: function GreaterThan(value) {\n\t\tthis.value = value;\n\t},\n\tGreaterThanEqual: function GreaterThanEqual(value) {\n\t\tthis.value = value;\n\t},\n\tLessThan: function LessThan(value) {\n\t\tthis.value = value;\n\t},\n\tLessThanEqual: function LessThanEqual(value) {\n\t\tthis.value = value;\n\t},\n\t// This is used to And something like `GT(3)` n `LT(4)`.\n\t// These are all value comparisons.\n\tAnd: function ValueAnd(ands) {\n\t\tthis.values = ands;\n\t},\n\t// This is used to OR something like `GT(4)` n `LT(3)`.\n\t// These are all value comparisons.\n\tOr: function ValueOr(ors) {\n\t\tthis.values = ors;\n\t}\n});\n\ncomparisons.Or.prototype.orValues = function() {\n\treturn this.values;\n};\n\ncomparisons.In.test = function(values, b) {\n\treturn values.some(function(value) {\n\t\tvar values = set.ownAndMemberValue(value, b);\n\t\treturn values.own === values.member;\n\t});\n};\n\ncomparisons.NotIn.test = function(values, b) {\n\treturn !comparisons.In.test(values, b);\n};\ncomparisons.NotIn.testValue = function(value, b) {\n\treturn !comparisons.In.testValue(value, b);\n};\n\nfunction nullIsFalse(test) {\n\treturn function(arg1, arg2) {\n\t\tif (arg1 == null || arg2 == null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn test(arg1, arg2);\n\t\t}\n\t};\n}\n\nfunction nullIsFalseTwoIsOk(test) {\n\treturn function(arg1, arg2) {\n\t\tif (arg1 === arg2) {\n\t\t\treturn true;\n\t\t} else if (arg1 == null || arg2 == null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn test(arg1, arg2);\n\t\t}\n\t};\n}\n\ncomparisons.GreaterThan.test = nullIsFalse(function(a, b) {\n\treturn a > b;\n});\ncomparisons.GreaterThanEqual.test = nullIsFalseTwoIsOk(function(a, b) {\n\treturn a >= b;\n});\ncomparisons.LessThan.test = nullIsFalse(function(a, b) {\n\treturn a < b;\n});\ncomparisons.LessThanEqual.test = nullIsFalseTwoIsOk(function(a, b) {\n\treturn a <= b;\n});\n\nfunction isMemberThatUsesTest(value) {\n\tvar values = set.ownAndMemberValue(this.value, value);\n\treturn this.constructor.test(values.member, values.own);\n}\n[comparisons.GreaterThan, comparisons.GreaterThanEqual, comparisons.LessThan, comparisons.LessThanEqual, comparisons.LessThan].forEach(function(Type) {\n\tType.prototype.isMember = isMemberThatUsesTest;\n});\n\n[comparisons.In, comparisons.NotIn].forEach(function(Type) {\n\tType.prototype.isMember = common.isMemberThatUsesTestOnValues;\n});\n\ncomparisons.And.prototype.isMember = function(value) {\n\treturn this.values.every(function(and) {\n\t\treturn and.isMember(value);\n\t});\n};\ncomparisons.Or.prototype.isMember = function(value) {\n\treturn this.values.some(function(and) {\n\t\treturn and.isMember(value);\n\t});\n};\nObject.keys(comparisons).forEach(function(name) {\n\tcomparisons[name].prototype[isMemberSymbol] = comparisons[name].prototype.isMember;\n});\n\nvar is = comparisons;\n\nfunction makeNot(Type) {\n\treturn {\n\t\ttest: function(vA, vB) {\n\t\t\treturn !Type.test(vA, vB);\n\t\t}\n\t};\n}\n\n\nfunction makeEnum(type, Type, emptyResult) {\n\treturn function(a, b) {\n\t\tvar result = arrayUnionIntersectionDifference(a.values, b.values);\n\t\tif (result[type].length) {\n\t\t\treturn new Type(result[type]);\n\t\t} else {\n\t\t\treturn emptyResult || set.EMPTY;\n\t\t}\n\t};\n}\n\nfunction swapArgs(fn) {\n\treturn function(a, b) {\n\t\treturn fn(b, a);\n\t};\n}\n\n\nfunction makeSecondValue(Type, prop) {\n\treturn function(universe, value) {\n\t\treturn new Type(value[prop || \"value\"]);\n\t};\n}\n\nfunction returnBiggerValue(gtA, gtB) {\n\tif (gtA.value < gtB.value) {\n\t\treturn gtB;\n\t} else {\n\t\treturn gtA;\n\t}\n}\n\nfunction returnSmallerValue(gtA, gtB) {\n\tif (gtA.value > gtB.value) {\n\t\treturn gtB;\n\t} else {\n\t\treturn gtA;\n\t}\n}\n\nfunction makeAndIf(Comparison, Type) {\n\treturn function(ltA, ltB) {\n\t\tif (Comparison.test(ltA.value, ltB.value)) {\n\t\t\treturn makeAnd([ltA, new Type(ltB.value)]);\n\t\t} else {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t};\n}\n\nfunction make_InIfEqual_else_andIf(Comparison, Type) {\n\tvar elseCase = makeAndIf(Comparison, Type);\n\treturn function(a, b) {\n\t\tif (a.value === b.value) {\n\t\t\treturn new is.In([a.value]);\n\t\t} else {\n\t\t\treturn elseCase(a, b);\n\t\t}\n\t};\n}\n\nfunction make_filterFirstValueAgainstSecond(Comparison, Type, defaultReturn) {\n\treturn function(inSet, gt) {\n\t\tvar values = inSet.values.filter(function(value) {\n\t\t\treturn Comparison.test(gt, value);\n\t\t});\n\t\treturn values.length ?\n\t\t\tnew Type(values) : defaultReturn || set.EMPTY;\n\t};\n}\n\nvar isMemberTest = {\n\ttest: function isMemberTest(set, value) {\n\t\treturn set.isMember(value);\n\t}\n};\n\nfunction isOr(value) {\n\treturn (value instanceof is.Or);\n}\n\nfunction isAnd(value) {\n\treturn (value instanceof is.And);\n}\n\nfunction isAndOrOr(value) {\n\treturn isAnd(value) || isOr(value);\n}\n\n\n// `value` - has a test function to check values\n// `with` - the type we use to combined with the \"other\" value.\n// `combinedUsing` - If there are values, how do we stick it together with `with`\n\nfunction combineFilterFirstValuesAgainstSecond(options) {\n\treturn function(inSet, gt) {\n\t\tvar values = inSet.values.filter(function(value) {\n\t\t\treturn options.values.test(gt, value);\n\t\t});\n\t\tvar range;\n\t\tif (options.complement) {\n\t\t\trange = set.difference(set.UNIVERSAL, gt);\n\t\t} else if (options.with) {\n\t\t\trange = new options.with(gt.value);\n\t\t} else {\n\t\t\trange = gt;\n\t\t}\n\t\treturn values.length ?\n\t\t\toptions.combinedUsing([new options.arePut(values), range]) : range;\n\t};\n}\n\nfunction makeOrUnless(Comparison, result) {\n\treturn function(setA, setB) {\n\t\tif (Comparison.test(setA.value, setB.value)) {\n\t\t\treturn result || set.UNIVERSAL;\n\t\t} else {\n\t\t\treturn makeOr([setA, setB]);\n\t\t}\n\t};\n}\n\nfunction makeAndUnless(Comparison, result) {\n\treturn function(setA, setB) {\n\t\tif (Comparison.test(setA.value, setB.value)) {\n\t\t\treturn result || set.EMPTY;\n\t\t} else {\n\t\t\treturn makeAnd([setA, setB]);\n\t\t}\n\t};\n}\n\nfunction makeComplementSecondArgIf(Comparison) {\n\treturn function(setA, setB) {\n\t\tif (Comparison.test(setA.value, setB.value)) {\n\t\t\treturn set.difference(set.UNIVERSAL, setB);\n\t\t} else {\n\t\t\treturn setA;\n\t\t}\n\t};\n}\n\n\nfunction makeAnd(ands) {\n\treturn comparisons.And ? new comparisons.And(ands) : set.UNDEFINABLE;\n}\n\nfunction makeOr(ors) {\n\treturn comparisons.Or ? new comparisons.Or(ors) : set.UNDEFINABLE;\n}\n\nfunction combineValueWithRangeCheck(inSet, rangeSet, RangeOrEqType) {\n\tvar gte = new RangeOrEqType(rangeSet.value);\n\tvar leftValues = inSet.values.filter(function(value) {\n\t\treturn !gte.isMember(value);\n\t});\n\tif (!leftValues.length) {\n\t\treturn gte;\n\t}\n\n\tif (leftValues.length < inSet.values.length) {\n\t\treturn makeOr([new is.In(leftValues), gte]);\n\t} else {\n\t\treturn makeOr([inSet, rangeSet]);\n\t}\n}\n\n// This tries to unify In([1]) with GT(1) -> GTE(1)\nfunction makeOrWithInAndRange(inSet, rangeSet) {\n\tif (rangeSet instanceof is.Or) {\n\t\tvar firstResult = makeOrWithInAndRange(inSet, rangeSet.values[0]);\n\t\tif ( !(firstResult instanceof is.Or) ) {\n\t\t\treturn set.union(firstResult, rangeSet.values[1]);\n\t\t}\n\t\tvar secondResult = makeOrWithInAndRange(inSet, rangeSet.values[1]);\n\t\tif ( !(secondResult instanceof is.Or) ) {\n\t\t\treturn set.union(secondResult, rangeSet.values[0]);\n\t\t}\n\t\treturn makeOr([inSet, rangeSet]);\n\t} else {\n\t\tif (rangeSet instanceof is.GreaterThan) {\n\t\t\treturn combineValueWithRangeCheck(inSet, rangeSet, is.GreaterThanEqual);\n\t\t}\n\t\tif (rangeSet instanceof is.LessThan) {\n\t\t\treturn combineValueWithRangeCheck(inSet, rangeSet, is.LessThanEqual);\n\t\t}\n\t\treturn makeOr([inSet, rangeSet]);\n\t}\n}\n\nvar In_RANGE = {\n\tunion: combineFilterFirstValuesAgainstSecond({\n\t\tvalues: makeNot(isMemberTest),\n\t\tarePut: is.In,\n\t\tcombinedUsing: function(ors) {\n\t\t\treturn makeOrWithInAndRange(ors[0], ors[1]);\n\t\t}\n\t}),\n\tintersection: make_filterFirstValueAgainstSecond(isMemberTest, is.In, set.EMPTY),\n\tdifference: make_filterFirstValueAgainstSecond(makeNot(isMemberTest), is.In, set.EMPTY)\n};\nvar RANGE_IN = {\n\tdifference: swapArgs(combineFilterFirstValuesAgainstSecond({\n\t\tvalues: isMemberTest,\n\t\tarePut: is.NotIn,\n\t\tcombinedUsing: makeAnd\n\t}))\n};\n\nvar NotIn_RANGE = function() {\n\treturn {\n\t\tunion: make_filterFirstValueAgainstSecond(makeNot(isMemberTest), is.NotIn, set.UNIVERSAL),\n\t\tintersection: combineFilterFirstValuesAgainstSecond({\n\t\t\tvalues: isMemberTest,\n\t\t\tarePut: is.NotIn,\n\t\t\tcombinedUsing: makeAnd\n\t\t}),\n\t\tdifference: combineFilterFirstValuesAgainstSecond({\n\t\t\tvalues: makeNot(isMemberTest),\n\t\t\tarePut: is.NotIn,\n\t\t\tcombinedUsing: makeAnd,\n\t\t\tcomplement: true\n\t\t})\n\t};\n};\nvar RANGE_NotIn = {\n\tdifference: swapArgs(make_filterFirstValueAgainstSecond(isMemberTest, is.In, set.EMPTY))\n};\n\nvar RANGE_And_Union = function(gt, and) {\n\n\tvar union1 = set.union(gt, and.values[0]);\n\tvar union2 = set.union(gt, and.values[1]);\n\n\tif (!isAndOrOr(union1) && !isAndOrOr(union2)) {\n\t\treturn set.intersection(union1, union2);\n\t} else {\n\t\treturn new is.Or([gt, and]);\n\t}\n};\nvar RANGE_And_Intersection = function(gt, and) {\n\tvar and1 = and.values[0],\n\t\tand2 = and.values[1];\n\tvar intersection1 = set.intersection(gt, and1);\n\tvar intersection2 = set.intersection(gt, and2);\n\tif (intersection1 === set.EMPTY || intersection2 === set.EMPTY) {\n\t\treturn set.EMPTY;\n\t}\n\tif (!isAndOrOr(intersection1)) {\n\t\treturn new set.intersection(intersection1, and2);\n\t}\n\n\tif (!isAndOrOr(intersection2)) {\n\t\treturn new set.intersection(intersection2, and1);\n\t} else {\n\t\treturn new is.And([gt, and]);\n\t}\n\n};\n\nvar RANGE_And_Difference = function(gt, and) {\n\tvar and1 = and.values[0],\n\t\tand2 = and.values[1];\n\tvar difference1 = set.difference(gt, and1);\n\tvar difference2 = set.difference(gt, and2);\n\tif (difference1 === set.EMPTY) {\n\t\treturn difference2;\n\t}\n\tif (difference2 === set.EMPTY) {\n\t\treturn difference1;\n\t}\n\treturn new is.Or([difference1, difference2]);\n};\n\nvar And_RANGE_Difference = function(and, gt) {\n\tvar and1 = and.values[0],\n\t\tand2 = and.values[1];\n\tvar difference1 = set.difference(and1, gt);\n\tvar difference2 = set.difference(and2, gt);\n\n\treturn set.intersection(difference1, difference2);\n};\n\nvar RANGE_Or = {\n\tunion: function(gt, or) {\n\t\tvar or1 = or.values[0],\n\t\t\tor2 = or.values[1];\n\t\tvar union1 = set.union(gt, or1);\n\t\tif (!isAndOrOr(union1)) {\n\t\t\treturn set.union(union1, or2);\n\t\t}\n\t\tvar union2 = set.union(gt, or2);\n\t\tif (!isAndOrOr(union2)) {\n\t\t\treturn set.union(or1, union2);\n\t\t} else {\n\t\t\treturn new is.Or([gt, or]);\n\t\t}\n\t},\n\tintersection: function(gt, or) {\n\t\tvar or1 = or.values[0],\n\t\t\tor2 = or.values[1];\n\t\tvar intersection1 = set.intersection(gt, or1);\n\t\tvar intersection2 = set.intersection(gt, or2);\n\t\tif (intersection1 === set.EMPTY) {\n\t\t\treturn intersection2;\n\t\t}\n\t\tif (intersection2 === set.EMPTY) {\n\t\t\treturn intersection1;\n\t\t}\n\t\treturn set.union(intersection1, intersection2);\n\t},\n\t// v \\ (a || b) -> (v \\ a) n (v \\ b)\n\tdifference: function(gt, or) {\n\n\t\tvar or1 = or.values[0],\n\t\t\tor2 = or.values[1];\n\t\tvar difference1 = set.difference(gt, or1);\n\t\tvar difference2 = set.difference(gt, or2);\n\t\treturn set.intersection(difference1, difference2);\n\t}\n};\n\nvar Or_RANGE = {\n\t// ( a || b ) \\ v -> (a \\ v) U (b \\ v)\n\tdifference: function(or, gt) {\n\t\tvar or1 = or.values[0],\n\t\t\tor2 = or.values[1];\n\t\tvar difference1 = set.difference(or1, gt);\n\t\tvar difference2 = set.difference(or2, gt);\n\t\treturn set.union(difference1, difference2);\n\t}\n};\n\nvar comparators = canReflect.assign(arrayComparisons.comparators, {\n\t// In\n\tIn_In: {\n\t\tunion: makeEnum(\"union\", is.In),\n\t\tintersection: makeEnum(\"intersection\", is.In),\n\t\tdifference: makeEnum(\"difference\", is.In)\n\t},\n\tUNIVERSAL_In: {\n\t\tdifference: makeSecondValue(is.NotIn, \"values\")\n\t},\n\n\tIn_NotIn: {\n\t\tunion: swapArgs(makeEnum(\"difference\", is.NotIn, set.UNIVERSAL)),\n\t\t// what does In have on its own\n\t\tintersection: makeEnum(\"difference\", is.In),\n\t\tdifference: makeEnum(\"intersection\", is.In)\n\t},\n\tNotIn_In: {\n\t\tdifference: makeEnum(\"union\", is.NotIn)\n\t},\n\n\tIn_GreaterThan: In_RANGE,\n\tGreaterThan_In: RANGE_IN,\n\n\tIn_GreaterThanEqual: In_RANGE,\n\tGreaterThanEqual_In: RANGE_IN,\n\n\tIn_LessThan: In_RANGE,\n\tLessThan_In: RANGE_IN,\n\n\tIn_LessThanEqual: In_RANGE,\n\tLessThanEqual_In: RANGE_IN,\n\tIn_And: In_RANGE,\n\tAnd_In: RANGE_IN,\n\n\tIn_Or: In_RANGE,\n\tOr_In: RANGE_IN,\n\n\t// NotIn ===============================\n\tNotIn_NotIn: {\n\t\tunion: makeEnum(\"intersection\", is.NotIn, set.UNIVERSAL),\n\t\tintersection: makeEnum(\"union\", is.NotIn),\n\t\tdifference: makeEnum(\"difference\", is.In)\n\t},\n\tUNIVERSAL_NotIn: {\n\t\tdifference: makeSecondValue(is.In, \"values\")\n\t},\n\n\tNotIn_GreaterThan: NotIn_RANGE(),\n\tGreaterThan_NotIn: RANGE_NotIn,\n\n\tNotIn_GreaterThanEqual: NotIn_RANGE(),\n\tGreaterThanEqual_NotIn: RANGE_NotIn,\n\n\tNotIn_LessThan: NotIn_RANGE(),\n\tLessThan_NotIn: RANGE_NotIn,\n\n\tNotIn_LessThanEqual: NotIn_RANGE(),\n\tLessThanEqual_NotIn: RANGE_NotIn,\n\n\tNotIn_And: NotIn_RANGE(),\n\tAnd_NotIn: RANGE_NotIn,\n\n\tNotIn_Or: NotIn_RANGE(),\n\tOr_NotIn: RANGE_NotIn,\n\n\t// GreaterThan ===============================\n\tGreaterThan_GreaterThan: {\n\t\tunion: returnSmallerValue,\n\t\tintersection: returnBiggerValue,\n\t\t// {$gt:5} \\ {gt: 6} -> AND( {$gt:5}, {$lte: 6} )\n\t\tdifference: makeAndIf(is.LessThan, is.LessThanEqual)\n\t},\n\tUNIVERSAL_GreaterThan: {\n\t\tdifference: makeSecondValue(is.LessThanEqual)\n\t},\n\n\tGreaterThan_GreaterThanEqual: {\n\t\tunion: returnSmallerValue,\n\t\tintersection: returnBiggerValue,\n\t\t// {$gt:5} \\ {gte: 6} -> AND( {$gt:5}, {$lt: 6} )\n\t\tdifference: makeAndIf(is.LessThan, is.LessThan)\n\t},\n\tGreaterThanEqual_GreaterThan: {\n\t\tdifference: make_InIfEqual_else_andIf(is.LessThan, is.LessThanEqual)\n\t},\n\n\tGreaterThan_LessThan: {\n\t\tunion: (function() {\n\t\t\tvar makeOrUnlessLessThan = makeOrUnless(is.LessThan);\n\t\t\treturn function greaterThan_lessThan_union(a, b) {\n\t\t\t\tif ( comparisons.In.test([a.value], b.value) ) {\n\t\t\t\t\treturn new is.NotIn([a.value]);\n\t\t\t\t} else {\n\t\t\t\t\treturn makeOrUnlessLessThan(a, b);\n\t\t\t\t}\n\t\t\t};\n\t\t})(),\n\t\tintersection: makeAndUnless(is.GreaterThan),\n\t\tdifference: makeComplementSecondArgIf(is.LessThan)\n\t},\n\tLessThan_GreaterThan: {\n\t\tdifference: makeComplementSecondArgIf(is.GreaterThan)\n\t},\n\n\tGreaterThan_LessThanEqual: {\n\t\tunion: makeOrUnless(is.LessThanEqual),\n\t\tintersection: makeAndUnless(is.GreaterThanEqual),\n\t\tdifference: makeComplementSecondArgIf(is.LessThanEqual)\n\t},\n\tLessThanEqual_GreaterThan: {\n\t\tdifference: makeComplementSecondArgIf(is.GreaterThanEqual)\n\t},\n\n\tGreaterThan_And: {\n\t\tunion: RANGE_And_Union,\n\t\tintersection: RANGE_And_Intersection,\n\t\tdifference: RANGE_And_Difference\n\t},\n\tAnd_GreaterThan: {\n\t\tdifference: And_RANGE_Difference\n\t},\n\tGreaterThan_Or: RANGE_Or,\n\tOr_GreaterThan: Or_RANGE,\n\n\t// GreaterThanEqual =========\n\tGreaterThanEqual_GreaterThanEqual: {\n\t\tunion: returnSmallerValue,\n\t\tintersection: returnBiggerValue,\n\t\t// {gte: 2} \\ {gte: 3} = {gte: 2} AND {lt: 3}\n\t\tdifference: makeAndIf(is.LessThan, is.LessThan)\n\t},\n\tUNIVERSAL_GreaterThanEqual: {\n\t\tdifference: makeSecondValue(is.LessThan)\n\t},\n\n\tGreaterThanEqual_LessThan: {\n\t\tunion: makeOrUnless(is.LessThanEqual),\n\t\tintersection: makeAndUnless(is.GreaterThanEqual),\n\t\tdifference: makeComplementSecondArgIf(is.LessThanEqual)\n\t},\n\tLessThan_GreaterThanEqual: {\n\t\tdifference: makeComplementSecondArgIf(is.GreaterThanEqual)\n\t},\n\n\tGreaterThanEqual_LessThanEqual: {\n\t\tunion: makeOrUnless(is.LessThanEqual),\n\t\t// intersect on a number\n\t\tintersection: (function() {\n\t\t\tvar makeAnd = makeAndUnless(is.GreaterThan);\n\t\t\treturn function gte_lte_intersection(gte, lte) {\n\t\t\t\tvar inSet = new is.In([gte.value]);\n\t\t\t\tif (inSet.isMember(lte.value)) {\n\t\t\t\t\treturn inSet;\n\t\t\t\t} else {\n\t\t\t\t\treturn makeAnd(gte, lte);\n\t\t\t\t}\n\t\t\t};\n\t\t})(),\n\t\tdifference: makeComplementSecondArgIf(is.LessThanEqual)\n\t},\n\tLessThanEqual_GreaterThanEqual: {\n\t\tdifference: makeComplementSecondArgIf(is.GreaterThanEqual)\n\t},\n\n\tGreaterThanEqual_And: {\n\t\tunion: RANGE_And_Union,\n\t\tintersection: RANGE_And_Intersection,\n\t\tdifference: RANGE_And_Difference\n\t},\n\tAnd_GreaterThanEqual: {\n\t\tdifference: And_RANGE_Difference\n\t},\n\tGreaterThanEqual_Or: RANGE_Or,\n\tOr_GreaterThanEqual: Or_RANGE,\n\n\t// LessThan\n\tLessThan_LessThan: {\n\t\tunion: returnBiggerValue,\n\t\tintersection: returnSmallerValue,\n\t\tdifference: makeAndIf(is.GreaterThan, is.GreaterThanEqual)\n\t},\n\tUNIVERSAL_LessThan: {\n\t\tdifference: makeSecondValue(is.GreaterThanEqual)\n\t},\n\n\tLessThan_LessThanEqual: {\n\t\tunion: returnBiggerValue,\n\t\tintersection: returnSmallerValue,\n\t\t// {lt: 3} \\ {lte: 2} -> {lt: 3} AND {gt: 2}\n\t\tdifference: makeAndIf(is.GreaterThan, is.GreaterThan)\n\t},\n\tLessThanEqual_LessThan: {\n\t\tdifference: make_InIfEqual_else_andIf(is.GreaterThanEqual, is.GreaterThanEqual)\n\t},\n\n\tLessThan_And: {\n\t\tunion: RANGE_And_Union,\n\t\tintersection: RANGE_And_Intersection,\n\t\tdifference: RANGE_And_Difference\n\t},\n\tAnd_LessThan: {\n\t\tdifference: And_RANGE_Difference\n\t},\n\tLessThan_Or: RANGE_Or,\n\tOr_LessThan: Or_RANGE,\n\n\t// LessThanEqual\n\tLessThanEqual_LessThanEqual: {\n\t\tunion: returnBiggerValue,\n\t\tintersection: returnSmallerValue,\n\t\tdifference: function(lteA, lteB) {\n\t\t\tif (lteA.value >= lteB.value) {\n\t\t\t\treturn makeAnd([lteA, new is.GreaterThan(lteB.value)]);\n\t\t\t} else {\n\t\t\t\treturn set.EMPTY;\n\t\t\t}\n\t\t}\n\t},\n\tUNIVERSAL_LessThanEqual: {\n\t\tdifference: makeSecondValue(is.GreaterThan)\n\t},\n\n\tLessThanEqual_And: {\n\t\tunion: RANGE_And_Union,\n\t\tintersection: RANGE_And_Intersection,\n\t\tdifference: RANGE_And_Difference\n\t},\n\tAnd_LessThanEqual: {\n\t\tdifference: And_RANGE_Difference\n\t},\n\tLessThanEqual_Or: RANGE_Or,\n\tOr_LessThanEqual: Or_RANGE,\n\n\t// AND =====\n\tAnd_And: {\n\t\t// (a n b) U (c n d) => (a U c) n (b U d)?\n\t\t// union both ways ... if one is unviersal, the other is the result.\n\t\t// (a âˆ© b) âˆª (c âˆ© d) where Z = (a âˆ© b)\n\t\t// -> Z âˆª (c âˆ© d)\n\t\t// -> (Z âˆª c) âˆ© (Z âˆª d)\n\t\t// -> ((a âˆ© b) âˆª c) âˆª ((a âˆ© b) âˆª d)\n\t\tunion: function(and1, and2) {\n\t\t\tvar union1 = set.union(and1, and2.values[0]);\n\t\t\tvar union2 = set.union(and1, and2.values[1]);\n\n\t\t\tif (isAndOrOr(union1) || isAndOrOr(union2)) {\n\t\t\t\t// try the other direction\n\t\t\t\tunion1 = set.union(and2, and1.values[0]);\n\t\t\t\tunion2 = set.union(and2, and1.values[1]);\n\t\t\t}\n\t\t\tif (isAndOrOr(union1) || isAndOrOr(union2)) {\n\t\t\t\treturn new is.Or([and1, and2]);\n\t\t\t} else {\n\t\t\t\treturn set.intersection(union1, union2);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tvar combo1 = [\n\t\t\t\t\tset.union(and1.values[0], and2.values[0]),\n\t\t\t\t\tset.union(and1.values[1], and2.values[1])\n\t\t\t\t],\n\t\t\t\tcombo2 = [\n\t\t\t\t\tset.union(and1.values[0], and2.values[1]),\n\t\t\t\t\tset.union(and1.values[1], and2.values[0])\n\t\t\t\t];\n\t\t\tif (combo1.every(function(aSet) {\n\t\t\t\treturn set.isEqual(set.UNIVERSAL, aSet);\n\t\t\t})) {\n\t\t\t\treturn set.intersection.apply(set, combo2);\n\t\t\t}\n\t\t\tif (combo2.every(function(aSet) {\n\t\t\t\treturn set.isEqual(set.UNIVERSAL, aSet);\n\t\t\t})) {\n\t\t\t\treturn set.intersection.apply(set, combo1);\n\t\t\t}\n\t\t\treturn new is.Or([and1, and2]);*/\n\t\t},\n\n\t\tintersection: function(and1, and2) {\n\t\t\tvar intersection1 = set.intersection(and1.values[0], and2.values[0]);\n\t\t\tvar intersection2 = set.intersection(and1.values[1], and2.values[1]);\n\n\t\t\tif (!isAndOrOr(intersection1) || !isAndOrOr(intersection2)) {\n\t\t\t\treturn set.intersection(intersection1, intersection2);\n\t\t\t}\n\t\t\tintersection1 = set.intersection(and1.values[0], and2.values[1]);\n\t\t\tintersection2 = set.intersection(and1.values[1], and2.values[0]);\n\n\t\t\tif (!isAndOrOr(intersection1) || !isAndOrOr(intersection2)) {\n\t\t\t\treturn set.intersection(intersection1, intersection2);\n\t\t\t} else {\n\t\t\t\treturn new is.And([and1, and2]);\n\t\t\t}\n\t\t},\n\t\t// (a âˆ© b) \\ (c âˆ© d) where Z = (a âˆ© b)\n\t\t// -> Z \\ (c âˆ© d)\n\t\t// -> (Z \\ c) âˆª (Z \\ d)\n\t\t// -> ((a âˆ© b) \\ c) âˆª ((a âˆ© b) \\ d)\n\t\tdifference: (function() {\n\n\t\t\treturn function(and1, and2) {\n\t\t\t\tvar d1 = set.difference(and1, and2.values[0]);\n\t\t\t\tvar d2 = set.difference(and1, and2.values[1]);\n\t\t\t\treturn set.union(d1, d2);\n\t\t\t};\n\t\t\t/*\n\t\t\tfunction getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(inOrderDiffs, reverseOrderDiffs, diffedAnd) {\n\t\t\t\tvar diff;\n\t\t\t\tif (inOrderDiffs[0] === set.EMPTY) {\n\t\t\t\t\tdiff = inOrderDiffs[1];\n\t\t\t\t}\n\t\t\t\tif (inOrderDiffs[1] === set.EMPTY) {\n\t\t\t\t\tdiff = inOrderDiffs[0];\n\t\t\t\t}\n\t\t\t\tif (diff) {\n\t\t\t\t\t// check if a diff equals itself (and therefor is disjoint)\n\n\t\t\t\t\tif (set.isEqual(diffedAnd.values[0], reverseOrderDiffs[0] ) ) {\n\t\t\t\t\t\t// is disjoint\n\t\t\t\t\t\treturn diffedAnd;\n\t\t\t\t\t}\n\t\t\t\t\tif ( set.isEqual(diffedAnd.values[1], reverseOrderDiffs[1] ) ) {\n\t\t\t\t\t\treturn diffedAnd;\n\t\t\t\t\t}\n\t\t\t\t\treturn diff;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function(and1, and2) {\n\t\t\t\tvar inOrderDiffs = [\n\t\t\t\t\t\tset.difference(and1.values[0], and2.values[0]),\n\t\t\t\t\t\tset.difference(and1.values[1], and2.values[1])\n\t\t\t\t\t],\n\t\t\t\t\treverseOrderDiffs = [\n\t\t\t\t\t\tset.difference(and1.values[0], and2.values[1]),\n\t\t\t\t\t\tset.difference(and1.values[1], and2.values[0])\n\t\t\t\t\t];\n\n\t\t\t\tvar diff = getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(inOrderDiffs, reverseOrderDiffs, and1);\n\t\t\t\tif (diff) {\n\t\t\t\t\treturn diff;\n\t\t\t\t}\n\t\t\t\tdiff = getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(reverseOrderDiffs, inOrderDiffs, and1);\n\t\t\t\tif (diff) {\n\t\t\t\t\treturn diff;\n\t\t\t\t} else {\n\t\t\t\t\t// if one is a double And ... that's the outer \\\\ inner\n\t\t\t\t\tif (isAndOrOr(inOrderDiffs[0]) && isAndOrOr(inOrderDiffs[1])) {\n\t\t\t\t\t\treturn new is.Or([inOrderDiffs[0], inOrderDiffs[1]]);\n\t\t\t\t\t} else if ( isAndOrOr(reverseOrderDiffs[0]) && isAndOrOr(reverseOrderDiffs[1]) ) {\n\t\t\t\t\t\treturn new is.Or([reverseOrderDiffs[0], reverseOrderDiffs[1]]);\n\t\t\t\t\t}\n\t\t\t\t\treturn set.UNKNOWABLE;\n\t\t\t\t}\n\t\t\t};*/\n\t\t})()\n\t},\n\tAnd_Or: {\n\t\t// (a âˆ© b) âˆª (c u d) where Z = (c u d)\n\t\t// -> Z u (a âˆ© b)\n\t\t// -> (Z u a) âˆ© (Z u b)\n\t\t// -> ((c u d) u a) âˆ© ((c u d) u b)\n\t\tunion: function(and, or) {\n\t\t\tvar aUnion = set.union(and.values[0], or);\n\t\t\tvar bUnion = set.union(and.values[1], or);\n\n\t\t\tif (!isAndOrOr(aUnion) || !isAndOrOr(bUnion)) {\n\t\t\t\treturn set.intersection(aUnion, bUnion);\n\t\t\t}\n\n\t\t\treturn new is.Or([and, or]);\n\t\t},\n\t\t// (a âˆ© b) âˆ© (c u d) where Z = (a âˆ© b)\n\t\t// -> Z âˆ© (c u d)\n\t\t// -> (Z âˆ© c) u (Z âˆ© d)\n\t\t// -> (a âˆ© b âˆ© c) u (a âˆ© b âˆ© d)\n\t\tintersection: function(and, or) {\n\t\t\tvar aIntersection = set.intersection(and, or.values[0]);\n\t\t\tvar bIntersection = set.intersection(and, or.values[1]);\n\t\t\tif (!isOr(aIntersection) && !isOr(bIntersection)) {\n\t\t\t\treturn set.union(aIntersection, bIntersection);\n\t\t\t}\n\t\t\treturn new is.And([and, or]);\n\t\t},\n\t\t// (a âˆ© b) \\ (c u d) where Z = (a âˆ© b)\n\t\t// -> Z \\ (c u d)\n\t\t// -> (Z \\ c) âˆ© (Z \\ d)\n\t\t// -> ((a âˆ© b) \\ c) âˆ© ((a âˆ© b) \\ d)\n\t\tdifference: function(and, or) {\n\t\t\tvar aDiff = set.difference(and, or.values[0]);\n\t\t\tvar bDiff = set.difference(and, or.values[1]);\n\t\t\treturn set.intersection(aDiff, bDiff);\n\t\t}\n\t},\n\tOr_And: {\n\t\t// (a âˆª b) \\ (c âˆ© d) where Z = (a âˆª b)\n\t\t// -> Z \\ (c âˆ© d)\n\t\t// -> (Z \\ c) âˆª (Z \\ d)\n\t\t// -> ((a âˆª b) \\ c) âˆª ((a âˆª b) \\ d)\n\t\tdifference: function(or, and) {\n\t\t\tvar aDiff = set.difference(or, and.values[0]);\n\t\t\tvar bDiff = set.difference(or, and.values[1]);\n\t\t\treturn set.union(aDiff, bDiff);\n\t\t}\n\t},\n\tUNIVERSAL_And: {\n\t\tdifference: function(universe, and) {\n\t\t\tvar inverseFirst = set.difference(universe, and.values[0]),\n\t\t\t\tinverseSecond = set.difference(universe, and.values[1]);\n\t\t\treturn set.union(inverseFirst, inverseSecond);\n\t\t}\n\t},\n\tOr_Or: {\n\t\t// (a âˆª b) âˆª (c âˆª d)\n\t\tunion: function(or1, or2) {\n\t\t\tvar union1 = set.union(or1.values[0], or2.values[0]);\n\t\t\tvar union2 = set.union(or1.values[1], or2.values[1]);\n\n\t\t\tif (!isAndOrOr(union1) || !isAndOrOr(union2)) {\n\t\t\t\treturn set.union(union1, union2);\n\t\t\t}\n\t\t\tunion1 = set.union(or1.values[0], or2.values[1]);\n\t\t\tunion2 = set.union(or1.values[1], or2.values[0]);\n\n\t\t\tif (!isAndOrOr(union1) || !isAndOrOr(union2)) {\n\t\t\t\treturn set.union(union1, union2);\n\t\t\t} else {\n\t\t\t\treturn new is.Or([or1, or2]);\n\t\t\t}\n\t\t},\n\t\t// (a âˆª b) âˆ© (c âˆª d) where Z = (a âˆª b)\n\t\t// -> Z âˆ© (c âˆª d)\n\t\t// -> (Z âˆ© c) âˆª (Z âˆª d)\n\t\t// -> ((a âˆª b) âˆ© c) âˆª ((a âˆª b) âˆ© d)\n\t\tintersection: function(or1, or2) {\n\t\t\tvar c = or2.values[0],\n\t\t\t\td = or2.values[1];\n\n\t\t\tvar intersection1 = set.intersection(or1, c);\n\t\t\tvar intersection2 = set.intersection(or1, d);\n\n\t\t\tif (!isOr(intersection1) || !isOr(intersection2)) {\n\t\t\t\treturn set.union(intersection1, intersection2);\n\t\t\t}\n\t\t\tintersection1 = set.union(or2, or1.values[0]);\n\t\t\tintersection2 = set.union(or2, or1.values[1]);\n\n\t\t\tif (!isOr(intersection1) || !isOr(intersection2)) {\n\t\t\t\treturn set.union(intersection1, intersection2);\n\t\t\t} else {\n\t\t\t\treturn new is.Or([or1, or2]);\n\t\t\t}\n\t\t},\n\t\t// (a âˆª b) \\ (c âˆª d) where Z = (a âˆª b)\n\t\t// -> Z \\ (c âˆª d)\n\t\t// -> (Z \\ c) âˆ© (Z \\ d)\n\t\t// -> ((a âˆª b) \\ c) âˆ© ((a âˆª b) \\ d)\n\t\tdifference: function(or1, or2) {\n\t\t\tvar d1 = set.difference(or1, or2.values[0]);\n\t\t\tvar d2 = set.difference(or1, or2.values[1]);\n\t\t\treturn set.intersection(d1, d2);\n\t\t}\n\t},\n\tUNIVERSAL_Or: {\n\t\tdifference: function(universe, or) {\n\t\t\tvar inverseFirst = set.difference(universe, or.values[0]),\n\t\t\t\tinverseSecond = set.difference(universe, or.values[1]);\n\t\t\treturn set.intersection(inverseFirst, inverseSecond);\n\t\t}\n\t}\n});\n\n// Registers all the comparisons above\nvar names = Object.keys(comparisons);\nnames.forEach(function(name1, i) {\n\tif (!comparators[name1 + \"_\" + name1]) {\n\t\tconsole.warn(\"no \" + name1 + \"_\" + name1);\n\t} else {\n\t\tset.defineComparison(comparisons[name1], comparisons[name1], comparators[name1 + \"_\" + name1]);\n\t}\n\n\tif (!comparators[\"UNIVERSAL_\" + name1]) {\n\t\tconsole.warn(\"no UNIVERSAL_\" + name1);\n\t} else {\n\t\tset.defineComparison(set.UNIVERSAL, comparisons[name1], comparators[\"UNIVERSAL_\" + name1]);\n\t}\n\n\tfor (var j = i + 1; j < names.length; j++) {\n\t\tvar name2 = names[j];\n\t\tif (!comparators[name1 + \"_\" + name2]) {\n\t\t\tconsole.warn(\"no \" + name1 + \"_\" + name2);\n\t\t} else {\n\t\t\tset.defineComparison(comparisons[name1], comparisons[name2], comparators[name1 + \"_\" + name2]);\n\t\t}\n\t\tif (!comparators[name2 + \"_\" + name1]) {\n\t\t\tconsole.warn(\"no \" + name2 + \"_\" + name1);\n\t\t} else {\n\t\t\tset.defineComparison(comparisons[name2], comparisons[name1], comparators[name2 + \"_\" + name1]);\n\t\t}\n\t}\n});\n\nmodule.exports = comparisons;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/comparisons.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/keys-and.js":
/*!************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/keys-and.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var set = __webpack_require__(/*! ../set */ \"./node_modules/can-query-logic/src/set.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar arrayUnionIntersectionDifference = __webpack_require__(/*! ../array-union-intersection-difference */ \"./node_modules/can-query-logic/src/array-union-intersection-difference.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canGet = __webpack_require__(/*! can-key/get/get */ \"./node_modules/can-key/get/get.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar keysLogic = __webpack_require__(/*! ./types */ \"./node_modules/can-query-logic/src/types/types.js\");\n\n// Define the sub-types that BasicQuery will use\nfunction KeysAnd(values) {\n\tvar vals = this.values = {};\n\tcanReflect.eachKey(values, function(value, key) {\n\t\tif (canReflect.isPlainObject(value) && !set.isSpecial(value)) {\n\t\t\tvals[key] = new KeysAnd(value);\n\t\t} else {\n\t\t\tvals[key] = value;\n\t\t}\n\t});\n}\n\nvar isMemberSymbol = canSymbol.for(\"can.isMember\");\n\n\nKeysAnd.prototype.isMember = function(props, root, rootKey) {\n\tvar equal = true;\n\tvar preKey = rootKey ? rootKey + \".\" : \"\";\n\tcanReflect.eachKey(this.values, function(value, key) {\n\t\tvar isMember = value && (value[isMemberSymbol] || value.isMember);\n\t\tif (isMember) {\n\t\t\tif (!isMember.call(value, canGet(props, key), root || props, preKey + key)) {\n\t\t\t\tequal = false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (value !== canGet(props, key)) {\n\t\t\t\tequal = false;\n\t\t\t}\n\t\t}\n\t});\n\treturn equal;\n};\n\n\n// ====== DEFINE COMPARISONS ========\n\n// Helpers ----------------------------\nfunction checkIfUniversalAndReturnUniversal(setA) {\n\treturn set.isEqual(setA, set.UNIVERSAL) ? set.UNIVERSAL : setA;\n}\n\nvar MISSING = {};\n\nfunction eachInUnique(a, acb, b, bcb, defaultReturn) {\n\tvar bCopy = assign({}, b),\n\t\tres;\n\tfor (var prop in a) {\n\t\tres = acb(prop, a[prop], (prop in b) ? b[prop] : MISSING, a, b);\n\t\tif (res !== undefined) {\n\t\t\treturn res;\n\t\t}\n\t\tdelete bCopy[prop];\n\t}\n\tfor (prop in bCopy) {\n\t\tres = bcb(prop, MISSING, b[prop], a, b);\n\t\tif (res !== undefined) {\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn defaultReturn;\n}\n\nfunction keyDiff(valuesA, valuesB) {\n\tvar keyResults = arrayUnionIntersectionDifference(\n\t\tObject.keys(valuesA),\n\t\tObject.keys(valuesB));\n\treturn {\n\t\taOnlyKeys: keyResults.difference,\n\t\taAndBKeys: keyResults.intersection,\n\t\tbOnlyKeys: arrayUnionIntersectionDifference(\n\t\t\tObject.keys(valuesB),\n\t\t\tObject.keys(valuesA)).difference\n\t};\n}\n\nfunction notEmpty(value) {\n\treturn value !== set.EMPTY;\n}\n\n// Difference of two ANDs is used two places\nfunction difference(objA, objB) {\n\n\tvar valuesA = objA.values,\n\t\tvaluesB = objB.values,\n\t\tdiff = keyDiff(valuesA, valuesB),\n\t\taOnlyKeys = diff.aOnlyKeys,\n\t\taAndBKeys = diff.aAndBKeys,\n\t\tbOnlyKeys = diff.bOnlyKeys;\n\n\t// check if all aAndB are equal\n\n\t// With the shared keys, perform vA \\ vB difference. If the DIFFERENCE is:\n\t// - EMPTY: vA has nothing outside vB. vA is equal or subset of vB.\n\t//   - IF sB has keys not in sA, the shared keys will be part of the result;\n\t//     OTHERWISE, if all empty, sA is subset of sB, EMPTY will be returned\n\t//                (even if sA has some extra own keys)\n\t// - NON-EMPTY: something in sA that is not in sB\n\t//   Now we need to figure out if it's \"product-able\" or not.\n\t//   Product-able -> some part of B is in A.\n\t//   Perform B âˆ© A intersection.  INTERSECTION is:\n\t//   - EMPTY: NOT \"product-able\". DISJOINT.  Must return something.\n\t//   - non-EMPTY: Use to performa  product (in the future.)\n\tvar sharedKeysAndValues = {},\n\t\tproductAbleKeysAndData = {},\n\t\tdisjointKeysAndValues = {};\n\taAndBKeys.forEach(function(key) {\n\t\tvar difference = set.difference(valuesA[key], valuesB[key]);\n\t\tif (difference === set.EMPTY) {\n\t\t\tsharedKeysAndValues[key] = valuesA[key];\n\t\t} else {\n\t\t\tvar intersection = set.intersection(valuesA[key], valuesB[key]);\n\t\t\tvar isProductable = intersection !== set.EMPTY;\n\t\t\tif (isProductable) {\n\t\t\t\tproductAbleKeysAndData[key] = {\n\t\t\t\t\t// Products with `difference U intersection` would be subtracted\n\t\t\t\t\t// from produts with `intersection`\n\t\t\t\t\tdifference: difference,\n\t\t\t\t\tintersection: intersection\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tdisjointKeysAndValues[key] = valuesA[key];\n\t\t\t}\n\t\t}\n\t});\n\tvar productAbleKeys = Object.keys(productAbleKeysAndData);\n\tvar singleProductKeyAndValue;\n\tif (productAbleKeys.length === 1) {\n\t\tsingleProductKeyAndValue = {};\n\t\tsingleProductKeyAndValue[productAbleKeys[0]] = productAbleKeysAndData[productAbleKeys[0]].difference;\n\t}\n\n\t// Now that we've got the shared keys organized\n\t// we can make decisions based on this information\n\t// and A-only and B-only keys.\n\n\t// if we have any disjoint keys, these sets can not intersect\n\t// {age: 21, ...} \\ {age: 22, ...} ->  {age: 21, ...}\n\tif (Object.keys(disjointKeysAndValues).length) {\n\t\treturn objA;\n\t}\n\n\t// contain all the same keys\n\tif ((aOnlyKeys.length === 0) && (bOnlyKeys.length === 0)) {\n\t\tif (productAbleKeys.length > 1) {\n\t\t\treturn set.UNDEFINABLE;\n\t\t}\n\t\t// {color: [RED, GREEN], ...X...} \\ {color: [RED], ...X...} -> {color: [GREEN], ...X...}\n\t\telse if (productAbleKeys.length === 1) {\n\t\t\tassign(sharedKeysAndValues, singleProductKeyAndValue);\n\t\t\treturn new KeysAnd(sharedKeysAndValues);\n\t\t} else {\n\t\t\t// {...X...} \\ {...X...} -> EMPTY\n\t\t\treturn set.EMPTY;\n\t\t}\n\t}\n\t// sA is likely a subset of sB\n\tif (aOnlyKeys.length > 0 && bOnlyKeys.length === 0) {\n\t\tif (productAbleKeys.length > 1) {\n\t\t\treturn set.UNDEFINABLE;\n\t\t}\n\t\t// {age: 35, color: [RED, GREEN], ...X...} \\ {color: [RED], ...X...} -> {age: 35, color: [GREEN], ...X...}\n\t\telse if (productAbleKeys.length === 1) {\n\t\t\tassign(sharedKeysAndValues, singleProductKeyAndValue);\n\t\t\taOnlyKeys.forEach(function(key) {\n\t\t\t\tsharedKeysAndValues[key] = valuesA[key];\n\t\t\t});\n\t\t\treturn new KeysAnd(sharedKeysAndValues);\n\t\t} else {\n\t\t\t// sharedKeysAndValues\n\t\t\treturn set.EMPTY;\n\t\t}\n\t}\n\t// sB is likely subset of sA\n\t// {}, {foo: \"bar\"} -> {foo: NOT(\"bar\")}\n\tif (aOnlyKeys.length === 0 && bOnlyKeys.length > 0) {\n\t\t// Lets not figure out productAbleKeys right now.\n\t\t// Example:\n\t\t// {color: [RED, GREEN], ...X...}\n\t\t// \\ {age: 35, color: [RED], ...X...}\n\t\t// = OR( {color: [GREEN], ...X...}, {age: NOT(35), color: [RED], ...X...} )\n\t\tif (productAbleKeys.length > 1) {\n\t\t\treturn set.UNDEFINABLE;\n\t\t}\n\t\tvar productAbleOr;\n\t\tif (productAbleKeys.length === 1) {\n\t\t\t// we add the intersection to the AND\n\t\t\t// the difference is the or\n\t\t\tvar productableKey = productAbleKeys[0];\n\t\t\tproductAbleOr = assign({}, sharedKeysAndValues);\n\t\t\tproductAbleOr[productableKey] = productAbleKeysAndData[productableKey].difference;\n\t\t\tsharedKeysAndValues[productableKey] = productAbleKeysAndData[productableKey].intersection;\n\t\t}\n\n\t\tvar ands = bOnlyKeys.map(function(key) {\n\t\t\tvar shared = assign({}, sharedKeysAndValues);\n\t\t\tvar result = shared[key] = set.difference(set.UNIVERSAL, valuesB[key]);\n\t\t\treturn result === set.EMPTY ? result : new KeysAnd(shared);\n\t\t}).filter(notEmpty);\n\n\t\tif (productAbleOr) {\n\t\t\tands.push(new KeysAnd(productAbleOr));\n\t\t}\n\n\t\t// {c: \"g\"}\n\t\t// \\ {c: \"g\", age: 22, name: \"justin\"}\n\t\t// = OR[ AND(name: NOT(\"justin\"), c:\"g\"), AND(age: NOT(22), c: \"g\") ]\n\t\tif (ands.length > 1) {\n\t\t\treturn new keysLogic.ValuesOr(ands);\n\t\t} else if (ands.length === 1) {\n\t\t\t// {c: \"g\"}\n\t\t\t// \\ {c: \"g\", age: 22}\n\t\t\t// = AND(age: NOT(22), c: \"g\")\n\t\t\treturn ands[0];\n\t\t} else {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t}\n\n\t// {name: \"Justin\"} \\\\ {age: 35} -> {name: \"Justin\", age: NOT(35)}\n\tif (aOnlyKeys.length > 0 && bOnlyKeys.length > 0) {\n\t\tif (productAbleKeys.length) {\n\t\t\tthrow new Error(\"Can't handle any productable keys right now\");\n\t\t}\n\t\t// add everything in sA into the result:\n\t\taOnlyKeys.forEach(function(key) {\n\t\t\tsharedKeysAndValues[key] = valuesA[key];\n\t\t});\n\n\t\tif (bOnlyKeys.length === 1) {\n\t\t\t// TODO: de-duplicate below\n\t\t\tvar key = bOnlyKeys[0];\n\t\t\tvar shared = assign({}, sharedKeysAndValues);\n\t\t\tshared[key] = set.difference(set.UNIVERSAL, valuesB[key]);\n\t\t\treturn new KeysAnd(shared);\n\t\t}\n\t\t// {foo: \"bar\"} \\\\ {name: \"Justin\", age: 35} -> UNDEFINABLE\n\t\telse {\n\t\t\treturn set.UNDEFINABLE;\n\t\t}\n\n\t}\n}\n\n// KeysAnd comaprisons\n\n\n\n\nset.defineComparison(KeysAnd, KeysAnd, {\n\t// {name: \"Justin\"} or {age: 35} -> new OR[{name: \"Justin\"},{age: 35}]\n\t// {age: 2} or {age: 3} -> {age: new OR[2,3]}\n\t// {age: 3, name: \"Justin\"} OR {age: 4} -> {age: 3, name: \"Justin\"} OR {age: 4}\n\tunion: function(objA, objB) {\n\t\t// first see if we can union a single property\n\t\t// {age: 21, color: [\"R\"]} U {age: 21, color: [\"B\"]} -> {age: 21, color: [\"R\",\"B\"]}\n\n\t\tvar diff = keyDiff(objA.values, objB.values);\n\n\n\t\t// find the different keys\n\t\tvar aAndBKeysThatAreNotEqual = [],\n\t\t\tsameKeys = {};\n\n\t\tdiff.aAndBKeys.forEach(function(key) {\n\t\t\tif (!set.isEqual(objA.values[key], objB.values[key])) {\n\t\t\t\taAndBKeysThatAreNotEqual.push(key);\n\t\t\t} else {\n\t\t\t\tsameKeys[key] = objA.values[key];\n\t\t\t}\n\t\t});\n\t\tvar aUnequal = {}, bUnequal = {};\n\t\taAndBKeysThatAreNotEqual.forEach(function(key){\n\t\t\taUnequal[key] = objA.values[key];\n\t\t\tbUnequal[key] = objB.values[key];\n\t\t});\n\n\t\t// if all keys are shared\n\t\tif (!diff.aOnlyKeys.length && !diff.bOnlyKeys.length) {\n\n\t\t\tif (aAndBKeysThatAreNotEqual.length === 1) {\n\t\t\t\tvar keyValue = aAndBKeysThatAreNotEqual[0];\n\n\t\t\t\tvar result = sameKeys[keyValue] = set.union(objA.values[keyValue], objB.values[keyValue]);\n\n\t\t\t\t// if there is only one property, we can just return the universal set\n\t\t\t\treturn canReflect.size(sameKeys) === 1 && set.isEqual(result, set.UNIVERSAL) ?\n\t\t\t\t\tset.UNIVERSAL : new KeysAnd(sameKeys);\n\t\t\t} else if (aAndBKeysThatAreNotEqual.length === 0) {\n\t\t\t\t// these things are equal\n\t\t\t\treturn objA;\n\t\t\t}\n\t\t}\n\t\t// If everything shared is the same\n\t\tif (aAndBKeysThatAreNotEqual.length === 0) {\n\t\t\t// the set with the extra keys is a subset\n\t\t\tif (diff.aOnlyKeys.length > 0 && diff.bOnlyKeys.length === 0) {\n\t\t\t\treturn checkIfUniversalAndReturnUniversal(objB);\n\t\t\t} else if (diff.aOnlyKeys.length === 0 && diff.bOnlyKeys.length > 0) {\n\t\t\t\treturn checkIfUniversalAndReturnUniversal(objA);\n\t\t\t}\n\t\t}\n\t\t// (count > 5 && age > 25 ) || (count > 7 && age > 35 && name > \"Justin\" )\n\t\t//\n\t\t// ( age > 25 ) || ( name > \"Justin\" && age > 35)  A U (B & C) => (A U B) & (A U C)\n\t\t// ( age > 25 || name > \"Justin\" ) && (age > 25)\n\t\t// lets see if one side is different\n\t\tif (diff.aOnlyKeys.length > 0 && diff.bOnlyKeys.length === 0) {\n\t\t\t// collect shared value\n\t\t\tif( set.isSubset(new KeysAnd(aUnequal), new KeysAnd(bUnequal) )) {\n\t\t\t\treturn objB;\n\t\t\t}\n\t\t}\n\t\tif (diff.bOnlyKeys.length > 0 && diff.aOnlyKeys.length === 0) {\n\t\t\t// collect shared value\n\t\t\tif( set.isSubset(new KeysAnd(bUnequal),  new KeysAnd(aUnequal) )) {\n\t\t\t\treturn objA;\n\t\t\t}\n\t\t}\n\n\t\treturn new keysLogic.ValuesOr([objA, objB]);\n\t},\n\t// {foo: zed, abc: d}\n\tintersection: function(objA, objB) {\n\t\t// combine all properties ... if the same property, try to take\n\t\t// an intersection ... if an intersection isn't possible ... freak out?\n\t\tvar valuesA = objA.values,\n\t\t\tvaluesB = objB.values,\n\t\t\tfoundEmpty = false;\n\t\tvar resultValues = {};\n\t\teachInUnique(valuesA,\n\t\t\tfunction(prop, aVal, bVal) {\n\t\t\t\tresultValues[prop] = bVal === MISSING ? aVal : set.intersection(aVal, bVal);\n\t\t\t\tif (resultValues[prop] === set.EMPTY) {\n\t\t\t\t\tfoundEmpty = true;\n\t\t\t\t}\n\t\t\t},\n\t\t\tvaluesB,\n\t\t\tfunction(prop, aVal, bVal) {\n\t\t\t\tresultValues[prop] = bVal;\n\t\t\t\tif (resultValues[prop] === set.EMPTY) {\n\t\t\t\t\tfoundEmpty = true;\n\t\t\t\t}\n\t\t\t});\n\t\tif (foundEmpty) {\n\t\t\treturn set.EMPTY;\n\t\t} else {\n\t\t\treturn new KeysAnd(resultValues);\n\t\t}\n\n\t},\n\t// A \\ B -> what's in A, but not in B\n\tdifference: difference\n});\n\nset.defineComparison(set.UNIVERSAL, KeysAnd, {\n\t// A \\ B -> what's in A, but not in B\n\tdifference: function(universe, and) {\n\t\treturn difference({\n\t\t\tvalues: {}\n\t\t}, and);\n\t}\n});\n\n\nmodule.exports = keysLogic.KeysAnd = KeysAnd;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/keys-and.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/make-enum.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/make-enum.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var set = __webpack_require__(/*! ../set */ \"./node_modules/can-query-logic/src/set.js\");\nvar arrayUnionIntersectionDifference = __webpack_require__(/*! ../array-union-intersection-difference */ \"./node_modules/can-query-logic/src/array-union-intersection-difference.js\");\nvar schemaHelpers = __webpack_require__(/*! ../schema-helpers */ \"./node_modules/can-query-logic/src/schema-helpers.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar setTypeSymbol = canSymbol.for(\"can.SetType\"),\n\tisMemberSymbol = canSymbol.for(\"can.isMember\"),\n\tnewSymbol = canSymbol.for(\"can.new\");\n\nfunction makeEnumSetType(allValues, hydrate) {\n\tfunction Enum(values) {\n\t\tvar arr = Array.isArray(values) ? values : [values];\n\t\tthis.values = hydrate ? arr.map(hydrate) : arr;\n\t}\n\tcanReflect.assignSymbols(Enum.prototype, {\n\t\t\"can.serialize\": function() {\n\t\t\treturn this.values.length === 1 ? this.values[0] : this.values;\n\t\t}\n\t});\n\n\tEnum.prototype[isMemberSymbol] = function(value) {\n\t\treturn this.values.some(function(val) {\n\t\t\treturn set.isEqual(val, value);\n\t\t});\n\t};\n\n\tEnum.UNIVERSAL = new Enum(allValues);\n\n\tvar difference = function(enum1, enum2) {\n\t\tvar result = arrayUnionIntersectionDifference(enum1.values, enum2.values);\n\t\tif (result.difference.length) {\n\t\t\treturn new Enum(result.difference);\n\t\t} else {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t};\n\n\tset.defineComparison(Enum, Enum, {\n\t\tunion: function(enum1, enum2) {\n\t\t\tvar result = arrayUnionIntersectionDifference(enum1.values, enum2.values);\n\t\t\tif (result.union.length) {\n\t\t\t\treturn new Enum(result.union);\n\t\t\t} else {\n\t\t\t\treturn set.EMPTY;\n\t\t\t}\n\t\t},\n\t\tintersection: function(enum1, enum2) {\n\t\t\tvar result = arrayUnionIntersectionDifference(enum1.values, enum2.values);\n\t\t\tif (result.intersection.length) {\n\t\t\t\treturn new Enum(result.intersection);\n\t\t\t} else {\n\t\t\t\treturn set.EMPTY;\n\t\t\t}\n\t\t},\n\t\tdifference: difference\n\t});\n\n\tset.defineComparison(Enum, set.UNIVERSAL, {\n\t\tdifference: function(enumA) {\n\t\t\treturn difference(enumA, {\n\t\t\t\tvalues: allValues.slice(0)\n\t\t\t});\n\t\t}\n\t});\n\n\tset.defineComparison(set.UNIVERSAL, Enum, {\n\t\tdifference: function(universe, enumB) {\n\t\t\treturn difference({\n\t\t\t\tvalues: allValues.slice(0)\n\t\t\t}, enumB);\n\t\t}\n\t});\n\n\treturn Enum;\n}\n\nfunction makeEnum(Type, allValues, hydrate) {\n\n\tvar Enum = makeEnumSetType(allValues, hydrate);\n\n\tType[setTypeSymbol] = Enum;\n\tType[isMemberSymbol] = function(value) {\n\t\treturn allValues.some(function(val) {\n\t\t\treturn set.isEqual(val, value);\n\t\t});\n\t};\n\n\treturn Enum;\n}\n\nmakeEnum.canMakeEnumSetType = function(Type) {\n\tvar schema = canReflect.getSchema(Type);\n\tif (schema && schema.type === \"Or\") {\n\t\tvar categories = schemaHelpers.categorizeOrValues(schema.values);\n\t\treturn categories.primitives.length === schema.values.length;\n\t}\n\treturn false;\n};\n\nmakeEnum.makeEnumSetType = function(Type) {\n\tvar schema = canReflect.getSchema(Type);\n\tvar categories = schemaHelpers.categorizeOrValues(schema.values);\n\tvar hydrate = Type[newSymbol] ? Type[newSymbol].bind(Type) : undefined;\n\treturn makeEnumSetType(categories.primitives, hydrate);\n};\n\nmodule.exports = makeEnum;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/make-enum.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/make-maybe.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/make-maybe.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var set = __webpack_require__(/*! ../set */ \"./node_modules/can-query-logic/src/set.js\");\nvar is = __webpack_require__(/*! ./comparisons */ \"./node_modules/can-query-logic/src/types/comparisons.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar schemaHelpers = __webpack_require__(/*! ../schema-helpers */ \"./node_modules/can-query-logic/src/schema-helpers.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar comparisonSetTypeSymbol = canSymbol.for(\"can.ComparisonSetType\");\nvar isMemberSymbol = canSymbol.for(\"can.isMember\");\n\n// This helper function seperates out sets that relate to the \"maybe\" values\n// like `null` or `undefined`. For example, if `rangeToBeSplit`\n// is `In([null, 3])`, it will produce `{enum: In([null]), range: In(3)}`\nfunction splitByRangeAndEnum(maybeUniverse, rangeToBeSplit) {\n\tvar enumSet;\n\n\t// If it's an AND\n\tif (rangeToBeSplit instanceof is.And) {\n\t\t// recursively split each value\n\t\tvar sets = rangeToBeSplit.values.map(function(setInAnd) {\n\t\t\treturn splitByRangeAndEnum(maybeUniverse, setInAnd);\n\t\t});\n\t\t// take the intersections\n\t\treturn sets.reduce(function(last, maybe) {\n\t\t\treturn {\n\t\t\t\trange: set.intersection(last.range, maybe.range),\n\t\t\t\tenum: set.intersection(last.enum, maybe.enum)\n\t\t\t};\n\t\t}, {\n\t\t\trange: set.UNIVERSAL,\n\t\t\tenum: maybeUniverse\n\t\t});\n\n\t} else if (rangeToBeSplit instanceof is.In) {\n\n\t\tvar shouldBeInValues = rangeToBeSplit.values.filter(function(value) {\n\t\t\treturn maybeUniverse.isMember(value);\n\t\t});\n\t\tif (shouldBeInValues.length) {\n\t\t\tvar valuesCopy = rangeToBeSplit.values.slice(0);\n\t\t\tcanReflect.removeValues(valuesCopy, shouldBeInValues);\n\n\t\t\treturn {\n\t\t\t\tenum: new is.In(shouldBeInValues),\n\t\t\t\trange: valuesCopy.length ? new is.In(valuesCopy) : set.EMPTY\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tenum: set.EMPTY,\n\t\t\t\trange: rangeToBeSplit\n\t\t\t};\n\t\t}\n\t} else if (rangeToBeSplit instanceof is.NotIn) {\n\n\t\t// Gets the 'maybe' values in the range\n\t\tenumSet = set.intersection(maybeUniverse, rangeToBeSplit);\n\n\t\t// We should remove all the values within $in matching an in values.\n\t\tvar rangeValues = rangeToBeSplit.values.filter(function(value) {\n\t\t\treturn !maybeUniverse.isMember(value);\n\t\t});\n\t\treturn {\n\t\t\trange: rangeValues.length ? new is.NotIn(rangeValues) : set.UNIVERSAL,\n\t\t\tenum: enumSet\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\tenum: set.EMPTY,\n\t\t\trange: rangeToBeSplit\n\t\t};\n\t}\n}\n\n// Builds a type for ranged values plus some other enum values.\n// This is great for 'maybe' values. For example, it might be a string OR `null` OR `undefined`\n// `makeMaybe([null, undefined])`\nfunction makeMaybe(inValues, makeChildType) {\n\n\n\tvar maybeUniverse = new is.In(inValues);\n\n\tfunction Maybe(values) {\n\n\t\t// Maybe has two sub-sets:\n\t\t// - `.range` - Selects the non-enum values. Ex: `GreaterThan(3)`\n\t\t// - `.enum` - Selects the enum values. This is ALWAYS an `In`. Ex: `In([null])`.\n\t\t// Maybe is effectively an OR with these two properties.\n\t\tvar result = splitByRangeAndEnum(maybeUniverse, values.range);\n\t\tthis.range = result.range || set.EMPTY;\n\t\tif (values.enum) {\n\t\t\tif (result.enum !== set.EMPTY) {\n\t\t\t\tthis.enum = set.union(result.enum, values.enum);\n\t\t\t} else {\n\t\t\t\tthis.enum = values.enum;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.enum = result.enum;\n\t\t}\n\t\tif(this.enum === set.EMPTY && this.range === set.EMPTY) {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t}\n\tMaybe.prototype.orValues = function() {\n\t\tvar values = [];\n\t\tif( this.range !== set.EMPTY ) {\n\t\t\tvalues.push(this.range);\n\t\t}\n\t\tif( this.enum !== set.EMPTY ) {\n\t\t\tvalues.push(this.enum);\n\t\t}\n\t\treturn values;\n\t};\n\tMaybe.prototype[isMemberSymbol] = function isMember() {\n\t\tvar rangeIsMember = this.range[isMemberSymbol] || this.range.isMember,\n\t\t\tenumIsMember = this.enum[isMemberSymbol] || this.enum.isMember;\n\t\treturn rangeIsMember.apply(this.range, arguments) || enumIsMember.apply(this.enum, arguments);\n\t};\n\n\n\n\tset.defineComparison(Maybe, Maybe, {\n\t\tunion: function(maybeA, maybeB) {\n\t\t\tvar enumSet = set.union(maybeA.enum, maybeB.enum);\n\t\t\tvar range = set.union(maybeA.range, maybeB.range);\n\n\t\t\treturn new Maybe({\n\t\t\t\tenum: enumSet,\n\t\t\t\trange: range\n\t\t\t});\n\t\t},\n\t\tdifference: function(maybeA, maybeB) {\n\t\t\tvar enumSet = set.difference(maybeA.enum, maybeB.enum);\n\t\t\tvar range = set.difference(maybeA.range, maybeB.range);\n\n\t\t\treturn new Maybe({\n\t\t\t\tenum: enumSet,\n\t\t\t\trange: range\n\t\t\t});\n\t\t},\n\t\tintersection: function(maybeA, maybeB) {\n\t\t\tvar enumSet = set.intersection(maybeA.enum, maybeB.enum);\n\t\t\tvar range = set.intersection(maybeA.range, maybeB.range);\n\n\t\t\treturn new Maybe({\n\t\t\t\tenum: enumSet,\n\t\t\t\trange: range\n\t\t\t});\n\t\t}\n\t});\n\tMaybe.inValues = inValues;\n\n\tset.defineComparison(set.UNIVERSAL, Maybe, {\n\t\tdifference: function(universe, maybe) {\n\t\t\tvar primary,\n\t\t\t\tsecondary;\n\n\t\t\tif (maybe.range === set.UNIVERSAL) {\n\t\t\t\t// there is only the enum\n\t\t\t\treturn new Maybe({\n\t\t\t\t\trange: maybe.range,\n\t\t\t\t\tenum: set.difference(maybeUniverse, maybe.enum)\n\t\t\t\t});\n\t\t\t}\n\t\t\t// there is only a primary\n\t\t\tif (maybe.enum === set.EMPTY) {\n\t\t\t\tvar rangeSet = set.difference(set.UNIVERSAL, maybe.range);\n\t\t\t\tvar notPresent = set.difference(maybeUniverse, maybe.range);\n\t\t\t\t// make sure they are included\n\t\t\t\tvar enumSet = set.difference(notPresent, rangeSet);\n\n\n\t\t\t\treturn new Maybe({\n\t\t\t\t\trange: rangeSet,\n\t\t\t\t\tenum: enumSet\n\t\t\t\t});\n\t\t\t\t// check enum things that aren't included in primary\n\n\t\t\t} else {\n\t\t\t\tprimary = set.difference(universe, maybe.range);\n\t\t\t\tsecondary = set.difference(maybeUniverse, maybe.enum);\n\t\t\t}\n\t\t\treturn new Maybe({\n\t\t\t\tenum: secondary,\n\t\t\t\trange: primary\n\t\t\t});\n\t\t}\n\t});\n\tmakeChildType = makeChildType || function(v) {\n\t\treturn v;\n\t};\n\n\tMaybe.hydrate = function(value, childHydrate) {\n\t\treturn new Maybe({\n\t\t\trange: childHydrate(value, makeChildType)\n\t\t});\n\t};\n\n\treturn Maybe;\n}\n\n\n\nmakeMaybe.canMakeMaybeSetType = function(Type) {\n\tvar schema = canReflect.getSchema(Type);\n\tif (schema && schema.type === \"Or\") {\n\t\tvar categories = schemaHelpers.categorizeOrValues(schema.values);\n\n\t\treturn categories.valueOfTypes.length === 1 &&\n\t\t\t(categories.valueOfTypes.length + categories.primitives.length === schema.values.length);\n\t}\n\treturn false;\n};\n\n// Given an __Or__ type like:\n// ```\n// var MaybeString = {\n//   \"can.new\"(val){ ... },\n// \t \"can.getSchema\"(){ return  { type: \"Or\", values: [String, undefined, null] }\n// });\n// ```\n//\n// This creates two types:\n// - `Value` - A value type used for what's within `GreaterThan`, etc.\n// - `Maybe` - A SetType for this property. It will have `GreaterThan` within its\n//            `{enum, range}` sub values.\n//\n// This creates the outer `SetType` and the innermost `Value` type while the Comparisons\n// are used inbetween.\n//\n// The `MaybeString` could probably be directly used to hydrate values to what they should be.\nmakeMaybe.makeMaybeSetTypes = function(Type) {\n\tvar schema = canReflect.getSchema(Type);\n\tvar categories = schemaHelpers.categorizeOrValues(schema.values);\n\tvar ComparisonSetType;\n\n\t// No need to build the comparison type if we are given it.\n\tif (Type[comparisonSetTypeSymbol]) {\n\t\tComparisonSetType = Type[comparisonSetTypeSymbol];\n\t} else {\n\n\t\tComparisonSetType = function(value) {\n\t\t\tthis.value = canReflect.new(Type, value);\n\t\t};\n\t\tComparisonSetType.prototype.valueOf = function() {\n\t\t\treturn this.value;\n\t\t};\n\t\tcanReflect.assignSymbols(ComparisonSetType.prototype, {\n\t\t\t\"can.serialize\": function() {\n\t\t\t\treturn this.value;\n\t\t\t}\n\t\t});\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tObject.defineProperty(ComparisonSetType, \"name\", {\n\t\t\t\tvalue: \"Or[\" + categories.valueOfTypes[0].name + \",\" + categories.primitives.map(String).join(\" \") + \"]\"\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\t}\n\n\treturn {\n\t\tMaybe: makeMaybe(categories.primitives, function hydrateMaybesValueType(value) {\n\t\t\treturn new ComparisonSetType(value);\n\t\t}),\n\t\tComparisonSetType: ComparisonSetType\n\t};\n};\n\n\nmodule.exports = makeMaybe;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/make-maybe.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/make-real-number-range-inclusive.js":
/*!************************************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/make-real-number-range-inclusive.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var set = __webpack_require__(/*! ../set */ \"./node_modules/can-query-logic/src/set.js\");\nvar is = __webpack_require__(/*! ./comparisons */ \"./node_modules/can-query-logic/src/types/comparisons.js\");\n\n// THIS IS REALLY INTEGERS!!!\n\nmodule.exports = function(min, max) {\n\n\n\n\n    function RealNumberRangeInclusive(start, end){\n\n        this.start =  arguments.length > 0 ? +start : min;\n        this.end = arguments.length > 1 ? +end : max;\n\t\tthis.range = new is.And([\n\t\t\tnew is.GreaterThanEqual( this.start ),\n\t\t\tnew is.LessThanEqual( this.end )\n\t\t]);\n    }\n\n\tvar universeRange = new RealNumberRangeInclusive( min , max );\n\n    function isUniversal(range) {\n        return set.isSubset(universeRange.range, range.range);\n    }\n\n\tfunction rangeFromAnd(aSet) {\n\t\tvar values = {};\n\t\taSet.values.forEach(function(value){\n\t\t\tif(value instanceof is.GreaterThanEqual) {\n\t\t\t\tvalues.start = value.value;\n\t\t\t}\n\t\t\tif(value instanceof is.GreaterThan) {\n\t\t\t\tvalues.start = value.value+1;\n\t\t\t}\n\t\t\tif(value instanceof is.LessThanEqual) {\n\t\t\t\tvalues.end = value.value;\n\t\t\t}\n\t\t\tif(value instanceof is.LessThan) {\n\t\t\t\tvalues.end = value.value-1;\n\t\t\t}\n\t\t});\n\t\tif(\"start\" in values && \"end\" in values) {\n\t\t\treturn new RealNumberRangeInclusive(values.start, values.end );\n\t\t}\n\t}\n\n\tfunction toRange(aSet) {\n\t\tvar range;\n\t\tif(aSet instanceof is.And) {\n\t\t\trange = rangeFromAnd(aSet);\n\t\t}\n\t\tif(aSet instanceof is.Or) {\n\t\t\t// check if next to each other ...\n\t\t\tvar first = rangeFromAnd(aSet.values[0]),\n\t\t\t\tsecond = rangeFromAnd(aSet.values[1]);\n\t\t\tif(first && second) {\n\t\t\t\tvar firstValues = first.range.values,\n\t\t\t\t\tsecondValues = second.range.values;\n\t\t\t\tif(firstValues[1].value + 1 === secondValues[0].value) {\n\t\t\t\t\trange = new RealNumberRangeInclusive(firstValues[0].value, secondValues[1].value );\n\t\t\t\t}\n\t\t\t\telse if(secondValues[1].value + 1 === firstValues[0].value) {\n\t\t\t\t\trange = new RealNumberRangeInclusive(secondValues[0].value, firstValues[1].value );\n\t\t\t\t} else {\n\t\t\t\t\treturn set.UNDEFINABLE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn set.UNDEFINABLE;\n\t\t\t}\n\t\t}\n\t\tif(range && isUniversal(range)) {\n\t\t\treturn set.UNIVERSAL;\n\t\t} else {\n\t\t\treturn range;\n\t\t}\n\t}\n\n    function intersection(range1, range2){\n\t\tvar intersection = toRange(set.intersection(range1.range, range2.range));\n\t\tif(intersection) {\n\t\t\treturn intersection;\n\t\t} else {\n            return set.EMPTY;\n        }\n    }\n\n    function difference(range1, range2){\n\n\t\tvar difference = toRange( set.difference(range1.range, range2.range) );\n\t\tif(difference) {\n\t\t\treturn difference;\n\t\t} else {\n            return set.EMPTY;\n        }\n    }\n\n    set.defineComparison(RealNumberRangeInclusive, RealNumberRangeInclusive,{\n        union: function(range1, range2){\n\t\t\tvar union = toRange( set.union(range1.range, range2.range) );\n\t\t\tif(union) {\n\t\t\t\treturn union;\n\t\t\t} else {\n\t            return set.EMPTY;\n\t        }\n        },\n        intersection: intersection,\n        difference: difference\n    });\n\n    set.defineComparison(set.UNIVERSAL,RealNumberRangeInclusive, {\n        difference: function(universe, range){\n            if(isUniversal(range)) {\n                return set.EMPTY;\n            } else {\n                return difference(universeRange, range);\n            }\n        }\n    });\n\n    return RealNumberRangeInclusive;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/make-real-number-range-inclusive.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/types.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n * # types\n * This folder is for SetTypes that are used to compare against a single value.\n * For example, `new comparisons.GreaterThan(5)` is used to compare against \n */\n\n\n\n// this is a placeholder for types that have cycle dependencies\nmodule.exports = {};\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/types.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/values-and.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/values-and.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var keysLogic = __webpack_require__(/*! ./types */ \"./node_modules/can-query-logic/src/types/types.js\");\nvar set = __webpack_require__(/*! ../set */ \"./node_modules/can-query-logic/src/set.js\");\n\nfunction ValuesAnd(values) {\n\tthis.values = values;\n}\n\nValuesAnd.prototype.isMember = function(props) {\n\treturn this.values.every(function(value){\n            return value && value.isMember ?\n                value.isMember( props ) : value === props;\n    });\n};\n\n// Or comparisons\nset.defineComparison(set.UNIVERSAL, ValuesAnd, {\n    difference: function(){\n        return set.UNDEFINABLE;\n    }\n});\n\nmodule.exports = keysLogic.ValuesAnd = ValuesAnd;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/values-and.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/values-not.js":
/*!**************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/values-not.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var set = __webpack_require__(/*! ../set */ \"./node_modules/can-query-logic/src/set.js\");\nvar keysLogic = __webpack_require__(/*! ./types */ \"./node_modules/can-query-logic/src/types/types.js\");\n\nfunction NotIdentity(value) {\n    this.value = value;\n}\n\n// Not comparisons ---------\nvar Identity = set.Identity;\n\n// Only difference is needed w/ universal\nset.defineComparison(set.UNIVERSAL, Identity,{\n    // A \\ B -> what's in b, but not in A\n    difference: function(universe, value){\n        return new NotIdentity(value);\n    }\n});\n\n// Only difference is needed w/ universal\nset.defineComparison(set.UNIVERSAL, NotIdentity,{\n    // A \\ B -> what's in b, but not in A\n    difference: function(universe, not){\n        return not.value;\n    }\n});\n\nset.defineComparison(NotIdentity, NotIdentity,{\n    /*\n    // not 5 and not 6\n    union: function(obj1, obj2){\n        // must unroll the value\n\n    },\n    // {foo: zed, abc: d}\n    intersection: function(obj1, obj2){\n\n    },\n    // A \\ B -> what's in b, but not in A\n    difference: function(obj1, obj2){\n\n    }\n    */\n});\n\n\n\nset.defineComparison(NotIdentity, Identity,{\n    // not 5 and not 6\n    union: function(not, primitive){\n        // NOT(5) U 5\n        if( set.isEqual( not.value, primitive) ) {\n            return set.UNIVERSAL;\n        }\n        // NOT(4) U 6\n        else {\n            throw new Error(\"Not,Identity Union is not filled out\");\n        }\n    },\n    // {foo: zed, abc: d}\n    intersection: function(not, primitive){\n        return set.isEqual( !not.value, primitive ) ? primitive: set.EMPTY;\n    },\n    // A \\ B -> what's in b, but not in A\n    difference: function difference(not, primitive){\n        // NOT(5) \\ 3 -> UNDEFINABLE\n        // NOT(3) \\ 3 -> NOT(3)\n        if(set.isEqual( not.value, primitive )) {\n            return not;\n        } else {\n            return set.UNDEFINABLE;\n        }\n    }\n});\n\nset.defineComparison(Identity, NotIdentity,{\n    difference: function(primitive, not){\n        if(set.isEqual(primitive, not.value)) {\n            return primitive;\n        } else {\n            return set.UNDEFINABLE;\n        }\n    }\n});\n\nNotIdentity.prototype.isMember = function(value){\n\tif(this.value  && typeof this.value.isMember === \"function\") {\n\t\treturn !this.value.isMember(value);\n\t} else {\n\t\tvar values = set.ownAndMemberValue(this.value, value);\n\t\treturn values.own !== values.member;\n\t}\n\n};\n\nmodule.exports = keysLogic.Not = NotIdentity;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/values-not.js?");

/***/ }),

/***/ "./node_modules/can-query-logic/src/types/values-or.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-query-logic/src/types/values-or.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar set = __webpack_require__(/*! ../set */ \"./node_modules/can-query-logic/src/set.js\");\nvar types = __webpack_require__(/*! ./types */ \"./node_modules/can-query-logic/src/types/types.js\");\n\n// this is intended to be used for $or ... it\n// ors expected key values\n// `{age: 22}` U `{name: \"Justin\"}`\nfunction ValuesOr(values) {\n    // the if values can be unioned into a single value\n    this.values = values;\n}\n\nValuesOr.prototype.isMember = function(props){\n    return this.values.some(function(value){\n            return value && value.isMember ?\n                value.isMember( props ) : value === props;\n    });\n};\n\n\n// Or comparisons\nset.defineComparison(set.UNIVERSAL, ValuesOr,{\n    difference: function(){\n        return set.UNDEFINABLE;\n    }\n});\n\n\nmodule.exports = types.ValuesOr = ValuesOr;\n\n\n//# sourceURL=webpack:///./node_modules/can-query-logic/src/types/values-or.js?");

/***/ }),

/***/ "./node_modules/can-queues/can-queues.js":
/*!***********************************************!*\
  !*** ./node_modules/can-queues/can-queues.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canDev = __webpack_require__( /*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\" );\nvar Queue = __webpack_require__( /*! ./queue */ \"./node_modules/can-queues/queue.js\" );\nvar PriorityQueue = __webpack_require__( /*! ./priority-queue */ \"./node_modules/can-queues/priority-queue.js\" );\nvar queueState = __webpack_require__( /*! ./queue-state */ \"./node_modules/can-queues/queue-state.js\" );\nvar CompletionQueue = __webpack_require__( /*! ./completion-queue */ \"./node_modules/can-queues/completion-queue.js\" );\nvar DomOrderQueue = __webpack_require__(/*! ./dom-order-queue */ \"./node_modules/can-queues/dom-order-queue.js\");\nvar ns = __webpack_require__( /*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\" );\n\n// How many `batch.start` - `batch.stop` calls have been made.\nvar batchStartCounter = 0;\n// If a task was added since the last flush caused by `batch.stop`.\nvar addedTask = false;\n// If we are flushing due to a `batch.stop`.\nvar isFlushing = false;\n\n// Legacy values for the old batchNum.\nvar batchNum = 0;\nvar batchData;\n\n// Used by `.enqueueByQueue` to know the property names that might be passed.\nvar queueNames = [\"notify\", \"derive\", \"domUI\", \"dom\",\"mutate\"];\n// Create all the queues so that when one is complete,\n// the next queue is flushed.\nvar NOTIFY_QUEUE,\n\tDERIVE_QUEUE,\n\tDOM_UI_QUEUE,\n\tDOM_QUEUE,\n\tMUTATE_QUEUE;\n\n// This is for immediate notification. This is where we teardown (remove childNodes)\n// immediately.\nNOTIFY_QUEUE = new Queue( \"NOTIFY\", {\n\tonComplete: function () {\n\t\tDERIVE_QUEUE.flush();\n\t},\n\tonFirstTask: function () {\n\t\t// Flush right away if we aren't in a batch.\n\t\tif ( !batchStartCounter ) {\n\t\t\tNOTIFY_QUEUE.flush();\n\t\t} else {\n\t\t\taddedTask = true;\n\t\t}\n\t}\n});\n\n// For observations not connected to the DOM\nDERIVE_QUEUE = new PriorityQueue( \"DERIVE\", {\n\tonComplete: function () {\n\t\tDOM_QUEUE.flush();\n\t},\n\tonFirstTask: function () {\n\t\taddedTask = true;\n\t}\n});\n\n// DOM_DERIVE comes next so that any prior derives have a chance\n// to settle before the derives that actually affect the DOM\n// are re-caculated.\n// See the `Child bindings are called before the parent` can-stache test.\n// All stache-related observables should update in DOM order.\n\n// Observations that are given an element update their value here.\nDOM_QUEUE = new DomOrderQueue( \"DOM   \" ,{\n\tonComplete: function () {\n\t\tDOM_UI_QUEUE.flush();\n\t},\n\tonFirstTask: function () {\n\t\taddedTask = true;\n\t}\n});\n\n// The old DOM_UI queue ... we should seek to remove this.\nDOM_UI_QUEUE = new CompletionQueue( \"DOM_UI\", {\n\tonComplete: function () {\n\t\tMUTATE_QUEUE.flush();\n\t},\n\tonFirstTask: function () {\n\t\taddedTask = true;\n\t}\n});\n\n// Update\nMUTATE_QUEUE = new Queue( \"MUTATE\", {\n\tonComplete: function () {\n\t\tqueueState.lastTask = null;\n\t\tisFlushing = false;\n\t},\n\tonFirstTask: function () {\n\t\taddedTask = true;\n\t}\n});\n\nvar queues = {\n\tQueue: Queue,\n\tPriorityQueue: PriorityQueue,\n\tCompletionQueue: CompletionQueue,\n\tDomOrderQueue: DomOrderQueue,\n\tnotifyQueue: NOTIFY_QUEUE,\n\tderiveQueue: DERIVE_QUEUE,\n\tdomQueue: DOM_QUEUE,\n\tdomUIQueue: DOM_UI_QUEUE,\n\tmutateQueue: MUTATE_QUEUE,\n\tbatch: {\n\t\tstart: function () {\n\t\t\tbatchStartCounter++;\n\t\t\tif ( batchStartCounter === 1 ) {\n\t\t\t\tbatchNum++;\n\t\t\t\tbatchData = {number: batchNum};\n\t\t\t}\n\t\t},\n\t\tstop: function () {\n\t\t\tbatchStartCounter--;\n\t\t\tif ( batchStartCounter === 0 ) {\n\t\t\t\tif ( addedTask ) {\n\t\t\t\t\taddedTask = false;\n\t\t\t\t\tisFlushing = true;\n\t\t\t\t\tNOTIFY_QUEUE.flush();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Legacy method to return if we are between start and stop calls.\n\t\tisCollecting: function () {\n\t\t\treturn batchStartCounter > 0;\n\t\t},\n\t\t// Legacy method provide a number for each batch.\n\t\tnumber: function () {\n\t\t\treturn batchNum;\n\t\t},\n\t\t// Legacy method to provide batch information.\n\t\tdata: function () {\n\t\t\treturn batchData;\n\t\t}\n\t},\n\trunAsTask: function(fn, reasonLog){\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\treturn function(){\n\t\t\t\tqueueState.lastTask = {\n\t\t\t\t\tfn: fn,\n\t\t\t\t\tcontext: this,\n\t\t\t\t\targs: arguments,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\treasonLog: typeof reasonLog === \"function\" ? reasonLog.apply(this, arguments): reasonLog,\n\t\t\t\t\t\tparentTask: queueState.lastTask,\n\t\t\t\t\t\tstack: {name: \"RUN_AS\"}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tvar ret = fn.apply(this, arguments);\n\t\t\t\tqueueState.lastTask = queueState.lastTask && queueState.lastTask.meta.parentTask;\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn fn;\n\t},\n\tenqueueByQueue: function enqueueByQueue ( fnByQueue, context, args, makeMeta, reasonLog ) {\n\t\tif ( fnByQueue ) {\n\t\t\tqueues.batch.start();\n\t\t\t// For each queue, check if there are tasks for it.\n\t\t\tqueueNames.forEach( function ( queueName ) {\n\t\t\t\tvar name = queueName + \"Queue\";\n\t\t\t\tvar QUEUE = queues[name];\n\t\t\t\tvar tasks = fnByQueue[queueName];\n\t\t\t\tif ( tasks !== undefined ) {\n\t\t\t\t\t// For each task function, setup the meta and enqueue it.\n\t\t\t\t\ttasks.forEach( function ( fn ) {\n\t\t\t\t\t\tvar meta = makeMeta != null ? makeMeta( fn, context, args ) : {};\n\t\t\t\t\t\tmeta.reasonLog = reasonLog;\n\t\t\t\t\t\tQUEUE.enqueue( fn, context, args, meta );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tqueues.batch.stop();\n\t\t}\n\t},\n\tlastTask: function(){\n\t\treturn queueState.lastTask;\n\t},\n\t// Currently an internal method that provides the task stack.\n\t// Returns an array with the first task as the first item.\n\tstack: function (task) {\n\t\tvar current = task || queueState.lastTask;\n\t\tvar stack = [];\n\t\twhile ( current ) {\n\t\t\tstack.unshift( current );\n\t\t\t// Queue.prototype._logEnqueue ensures\n\t\t\t// that the `parentTask` is always set.\n\t\t\tcurrent = current.meta.parentTask;\n\t\t}\n\t\treturn stack;\n\t},\n\tlogStack: function (task) {\n\t\tvar stack = this.stack(task);\n\t\tstack.forEach( function ( task, i ) {\n\t\t\tvar meta = task.meta;\n\t\t\tif( i === 0 && meta && meta.reasonLog) {\n\t\t\t\tcanDev.log.apply( canDev, meta.reasonLog);\n\t\t\t}\n\t\t\tvar log = meta && meta.log ? meta.log : [task.fn.name, task];\n\t\t\tcanDev.log.apply( canDev, [task.meta.stack.name + \" ran task:\"].concat( log ));\n\t\t});\n\t},\n\t// A method that is not used.  It should return the number of tasks\n\t// remaining, but doesn't seem to actually work.\n\ttaskCount: function () {\n\t\treturn NOTIFY_QUEUE.tasks.length + DERIVE_QUEUE.tasks.length + DOM_UI_QUEUE.tasks.length + MUTATE_QUEUE.tasks.length;\n\t},\n\t// A shortcut for flushign the notify queue.  `batch.start` and `batch.stop` should be\n\t// used instead.\n\tflush: function () {\n\t\tNOTIFY_QUEUE.flush();\n\t},\n\tlog: function () {\n\t\tNOTIFY_QUEUE.log.apply( NOTIFY_QUEUE, arguments );\n\t\tDERIVE_QUEUE.log.apply( DERIVE_QUEUE, arguments );\n\t\tDOM_UI_QUEUE.log.apply( DOM_UI_QUEUE, arguments );\n\t\tDOM_QUEUE.log.apply( DOM_QUEUE, arguments );\n\t\tMUTATE_QUEUE.log.apply( MUTATE_QUEUE, arguments );\n\t}\n};\n\nif ( ns.queues ) {\n\tthrow new Error( \"You can't have two versions of can-queues, check your dependencies\" );\n} else {\n\tmodule.exports = ns.queues = queues;\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-queues/can-queues.js?");

/***/ }),

/***/ "./node_modules/can-queues/completion-queue.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-queues/completion-queue.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Queue = __webpack_require__( /*! ./queue */ \"./node_modules/can-queues/queue.js\" );\n\n// This queue does not allow another task to run until this one is complete\nvar CompletionQueue = function () {\n\tQueue.apply( this, arguments );\n\tthis.flushCount = 0;\n};\nCompletionQueue.prototype = Object.create( Queue.prototype );\nCompletionQueue.prototype.constructor = CompletionQueue;\n\nCompletionQueue.prototype.flush = function () {\n\tif ( this.flushCount === 0 ) {\n\t\tthis.flushCount ++;\n\t\twhile ( this.index < this.tasks.length ) {\n\t\t\tvar task = this.tasks[this.index++];\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tthis._logFlush( task );\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\ttask.fn.apply( task.context, task.args );\n\t\t}\n\t\tthis.index = 0;\n\t\tthis.tasks = [];\n\t\tthis.flushCount--;\n\t\tthis.callbacks.onComplete( this );\n\t}\n};\n\nmodule.exports = CompletionQueue;\n\n\n//# sourceURL=webpack:///./node_modules/can-queues/completion-queue.js?");

/***/ }),

/***/ "./node_modules/can-queues/dom-order-queue.js":
/*!****************************************************!*\
  !*** ./node_modules/can-queues/dom-order-queue.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Queue = __webpack_require__( /*! ./queue */ \"./node_modules/can-queues/queue.js\" );\nvar sortedIndexBy = __webpack_require__(/*! ./sorted-index-by */ \"./node_modules/can-queues/sorted-index-by.js\");\nvar elementSort = __webpack_require__(/*! ./element-sort */ \"./node_modules/can-queues/element-sort.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar canElementSymbol = canSymbol.for(\"can.element\");\n\n// TODO: call sortable queue and take how it should be sorted ...\nfunction sortTasks(taskA, taskB){\n\t// taskA - in the document?\n\t// taskA - given a number?\n\t//\n\treturn elementSort.sortOrder(taskA.meta.element, taskB.meta.element);\n}\n\nvar DomOrderQueue = function () {\n\tQueue.apply( this, arguments );\n\t// A map of a task's function to the task for that function.\n\t// This is so we can prevent duplicate functions from being enqueued\n\t// and so `flushQueuedTask` can find the task and run it.\n\tthis.taskMap = new Map();\n\n\tthis.unsortable = [];\n\tthis.isFlushing = false;\n};\nDomOrderQueue.prototype = Object.create( Queue.prototype );\nDomOrderQueue.prototype.constructor = DomOrderQueue;\n\nDomOrderQueue.prototype.enqueue = function ( fn, context, args, meta ) {\n\tvar task;\n\t// Only allow the enqueing of a given function once.\n\tif ( !this.taskMap.has( fn ) ) {\n\n\t\tif(!meta) {\n\t\t\tmeta = {};\n\t\t}\n\t\tif(!meta.element) {\n\t\t\tmeta.element = fn[canElementSymbol];\n\t\t}\n\n\t\ttask = {\n\t\t\tfn: fn,\n\t\t\tcontext: context,\n\t\t\targs: args,\n\t\t\tmeta: meta\n\t\t};\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif( !meta.element ) {\n\t\t\t\tthrow new Error(\"DomOrderQueue tasks must be created with a meta.element.\");\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tthis.taskMap.set( fn, task );\n\n\t\tvar index = sortedIndexBy(sortTasks, this.tasks, task);\n\n\t\tthis.tasks.splice(index, 0, task);\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logEnqueue( task );\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif ( this.tasks.length === 1 ) {\n\t\t\tthis.callbacks.onFirstTask( this );\n\t\t}\n\t} else {\n\t\t// update the task with the new data\n\t\t// TODO: ideally this would key off the mutation instead of the function.\n\t\t// We could make it key off the element and function,  not just function.\n\t\ttask = this.taskMap.get( fn );\n\t\ttask.context = context;\n\t\ttask.args = args;\n\n\t\tif(!meta) {\n\t\t\tmeta = {};\n\t\t}\n\n\t\tif(!meta.element) {\n\t\t\tmeta.element = fn[canElementSymbol];\n\t\t}\n\n\t\ttask.meta = meta;\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logEnqueue( task );\n\t\t}\n\t\t//!steal-remove-end\n\t}\n};\n\n\nDomOrderQueue.prototype.flush = function () {\n\t// Only allow one task to run at a time.\n\tif ( this.isFlushing ) {\n\t\treturn;\n\t}\n\tthis.isFlushing = true;\n\n\twhile ( this.tasks.length ) {\n\t\tvar task = this.tasks.shift();\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logFlush( task );\n\t\t}\n\t\t//!steal-remove-end\n\t\tthis.taskMap[\"delete\"]( task.fn );\n\t\ttask.fn.apply( task.context, task.args );\n\t}\n\tthis.isFlushing = false;\n\tthis.callbacks.onComplete( this );\n};\n\nDomOrderQueue.prototype.isEnqueued = function ( fn ) {\n\treturn this.taskMap.has( fn );\n};\n\nDomOrderQueue.prototype.flushQueuedTask = function ( fn ) {\n\tvar task = this.dequeue(fn);\n\tif(task) {\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logFlush( task );\n\t\t}\n\t\t//!steal-remove-end\n\t\ttask.fn.apply( task.context, task.args );\n\t}\n};\nDomOrderQueue.prototype.dequeue = function(fn){\n\tvar task = this.taskMap.get( fn );\n\tif ( task ) {\n\n\t\tvar index = this.tasks.indexOf(task);\n\n\t\tif ( index >= 0 ) {\n\t\t\tthis.tasks.splice( index, 1 );\n\t\t\tthis.taskMap[\"delete\"]( task.fn );\n\t\t\treturn task;\n\t\t} else {\n\t\t\tconsole.warn(\"Task\", fn, \"has already run\");\n\t\t}\n\t}\n};\n\nDomOrderQueue.prototype.tasksRemainingCount = function () {\n\treturn this.tasks.length;\n};\n\nmodule.exports = DomOrderQueue;\n\n\n//# sourceURL=webpack:///./node_modules/can-queues/dom-order-queue.js?");

/***/ }),

/***/ "./node_modules/can-queues/element-sort.js":
/*!*************************************************!*\
  !*** ./node_modules/can-queues/element-sort.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Taken from jQuery\nvar hasDuplicate,\n\tsortInput,\n\tsortStable = true,\n\tindexOf = Array.prototype.indexOf;\n\nfunction sortOrder( a, b ) {\n\n\t// Flag for duplicate removal\n\tif ( a === b ) {\n\t\thasDuplicate = true;\n\t\treturn 0;\n\t}\n\n\t// Sort on method existence if only one input has compareDocumentPosition\n\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\tif ( compare ) {\n\t\treturn compare;\n\t}\n\n\t// Calculate position if both inputs belong to the same document\n\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\ta.compareDocumentPosition( b ) :\n\n\t\t// Otherwise we know they are disconnected\n\t\t1;\n\n\t// Disconnected nodes\n\tif ( compare & 1 ) {\n\n\t\t// Choose the first element that is related to our preferred document\n\t\tif ( a === document || a.ownerDocument === document &&\n\t\t\tdocument.documentElement.contains(a) ) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ( b === document || b.ownerDocument === document &&\n\t\t\tdocument.documentElement.contains(b) ) {\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Maintain original order\n\t\treturn sortInput ?\n\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t0;\n\t}\n\n\treturn compare & 4 ? -1 : 1;\n}\n\nfunction uniqueSort( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\thasDuplicate = false;\n\tsortInput = !sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n}\n\nmodule.exports = {\n\tuniqueSort: uniqueSort,\n\tsortOrder: sortOrder\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-queues/element-sort.js?");

/***/ }),

/***/ "./node_modules/can-queues/priority-queue.js":
/*!***************************************************!*\
  !*** ./node_modules/can-queues/priority-queue.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Queue = __webpack_require__( /*! ./queue */ \"./node_modules/can-queues/queue.js\" );\n\nvar PriorityQueue = function () {\n\tQueue.apply( this, arguments );\n\t// A map of a task's function to the task for that function.\n\t// This is so we can prevent duplicate functions from being enqueued\n\t// and so `flushQueuedTask` can find the task and run it.\n\tthis.taskMap = new Map();\n\t// An \"array-of-arrays\"-ish data structure that stores\n\t// each task organized by its priority.  Each object in this list\n\t// looks like `{tasks: [...], index: 0}` where:\n\t// - `tasks` - the tasks for a particular priority.\n\t// - `index` - the index of the task waiting to be prioritized.\n\tthis.taskContainersByPriority = [];\n\n\t// The index within `taskContainersByPriority` of the first `taskContainer`\n\t// which has tasks that have not been run.\n\tthis.curPriorityIndex = Infinity;\n\t// The index within `taskContainersByPriority` of the last `taskContainer`\n\t// which has tasks that have not been run.\n\tthis.curPriorityMax = 0;\n\n\tthis.isFlushing = false;\n\n\t// Manage the number of tasks remaining to keep\n\t// this lookup fast.\n\tthis.tasksRemaining = 0;\n};\nPriorityQueue.prototype = Object.create( Queue.prototype );\nPriorityQueue.prototype.constructor = PriorityQueue;\n\nPriorityQueue.prototype.enqueue = function ( fn, context, args, meta ) {\n\t// Only allow the enqueing of a given function once.\n\tif ( !this.taskMap.has( fn ) ) {\n\n\t\tthis.tasksRemaining++;\n\n\t\tvar isFirst = this.taskContainersByPriority.length === 0;\n\n\t\tvar task = {\n\t\t\tfn: fn,\n\t\t\tcontext: context,\n\t\t\targs: args,\n\t\t\tmeta: meta || {}\n\t\t};\n\n\t\tvar taskContainer = this.getTaskContainerAndUpdateRange( task );\n\t\ttaskContainer.tasks.push( task );\n\t\tthis.taskMap.set( fn, task );\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logEnqueue( task );\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif ( isFirst ) {\n\t\t\tthis.callbacks.onFirstTask( this );\n\t\t}\n\t}\n};\n\n// Given a task, updates the queue's cursors so that `flush`\n// will be able to run the task.\nPriorityQueue.prototype.getTaskContainerAndUpdateRange = function ( task ) {\n\tvar priority = task.meta.priority || 0;\n\n\tif ( priority < this.curPriorityIndex ) {\n\t\tthis.curPriorityIndex = priority;\n\t}\n\n\tif ( priority > this.curPriorityMax ) {\n\t\tthis.curPriorityMax = priority;\n\t}\n\n\tvar tcByPriority = this.taskContainersByPriority;\n\tvar taskContainer = tcByPriority[priority];\n\tif ( !taskContainer ) {\n\t\ttaskContainer = tcByPriority[priority] = {tasks: [], index: 0};\n\t}\n\treturn taskContainer;\n};\n\nPriorityQueue.prototype.flush = function () {\n\t// Only allow one task to run at a time.\n\tif ( this.isFlushing ) {\n\t\treturn;\n\t}\n\tthis.isFlushing = true;\n\twhile ( true ) {\n\t\t// If the first prioritized taskContainer with tasks remaining\n\t\t// is before the last prioritized taskContainer ...\n\t\tif ( this.curPriorityIndex <= this.curPriorityMax ) {\n\t\t\tvar taskContainer = this.taskContainersByPriority[this.curPriorityIndex];\n\n\t\t\t// If that task container actually has tasks remaining ...\n\t\t\tif ( taskContainer && ( taskContainer.tasks.length > taskContainer.index ) ) {\n\n\t\t\t\t// Run the task.\n\t\t\t\tvar task = taskContainer.tasks[taskContainer.index++];\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tthis._logFlush( task );\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\tthis.tasksRemaining--;\n\t\t\t\tthis.taskMap[\"delete\"]( task.fn );\n\t\t\t\ttask.fn.apply( task.context, task.args );\n\n\t\t\t} else {\n\t\t\t\t// Otherwise, move to the next taskContainer.\n\t\t\t\tthis.curPriorityIndex++;\n\t\t\t}\n\t\t} else {\n\t\t\t// Otherwise, reset the state for the next `.flush()`.\n\t\t\tthis.taskMap = new Map();\n\t\t\tthis.curPriorityIndex = Infinity;\n\t\t\tthis.curPriorityMax = 0;\n\t\t\tthis.taskContainersByPriority = [];\n\t\t\tthis.isFlushing = false;\n\t\t\tthis.callbacks.onComplete( this );\n\t\t\treturn;\n\t\t}\n\t}\n};\n\nPriorityQueue.prototype.isEnqueued = function ( fn ) {\n\treturn this.taskMap.has( fn );\n};\n\nPriorityQueue.prototype.flushQueuedTask = function ( fn ) {\n\tvar task = this.dequeue(fn);\n\tif(task) {\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logFlush( task );\n\t\t}\n\t\t//!steal-remove-end\n\t\ttask.fn.apply( task.context, task.args );\n\t}\n};\nPriorityQueue.prototype.dequeue = function(fn){\n\tvar task = this.taskMap.get( fn );\n\tif ( task ) {\n\t\tvar priority = task.meta.priority || 0;\n\t\tvar taskContainer = this.taskContainersByPriority[priority];\n\t\tvar index = taskContainer.tasks.indexOf( task, taskContainer.index );\n\n\t\tif ( index >= 0 ) {\n\t\t\ttaskContainer.tasks.splice( index, 1 );\n\t\t\tthis.tasksRemaining--;\n\t\t\tthis.taskMap[\"delete\"]( task.fn );\n\t\t\treturn task;\n\t\t} else {\n\t\t\tconsole.warn(\"Task\", fn, \"has already run\");\n\t\t}\n\t}\n};\n\nPriorityQueue.prototype.tasksRemainingCount = function () {\n\treturn this.tasksRemaining;\n};\n\nmodule.exports = PriorityQueue;\n\n\n//# sourceURL=webpack:///./node_modules/can-queues/priority-queue.js?");

/***/ }),

/***/ "./node_modules/can-queues/queue-state.js":
/*!************************************************!*\
  !*** ./node_modules/can-queues/queue-state.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = {\n\tlastTask: null\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-queues/queue-state.js?");

/***/ }),

/***/ "./node_modules/can-queues/queue.js":
/*!******************************************!*\
  !*** ./node_modules/can-queues/queue.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar queueState = __webpack_require__(/*! ./queue-state */ \"./node_modules/can-queues/queue-state.js\");\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\nfunction noOperation () {}\n\nvar Queue = function ( name, callbacks ) {\n\tthis.callbacks = assign( {\n\t\tonFirstTask: noOperation,\n\t\t// The default behavior is to clear the lastTask state.\n\t\t// This is overwritten by `can-queues.js`.\n\t\tonComplete: function () {\n\t\t\tqueueState.lastTask = null;\n\t\t}\n\t}, callbacks || {});\n\tthis.name = name;\n\tthis.index = 0;\n\tthis.tasks = [];\n\tthis._log = false;\n};\n\nQueue.prototype.constructor = Queue;\n\nQueue.noop = noOperation;\n\nQueue.prototype.enqueue = function ( fn, context, args, meta ) {\n\tvar len = this.tasks.push({\n\t\tfn: fn,\n\t\tcontext: context,\n\t\targs: args,\n\t\tmeta: meta || {}\n\t});\n\t//!steal-remove-start\n\tif(true) {\n\t\tthis._logEnqueue( this.tasks[len - 1] );\n\t}\n\t//!steal-remove-end\n\n\tif ( len === 1 ) {\n\t\tthis.callbacks.onFirstTask( this );\n\t}\n};\n\nQueue.prototype.flush = function () {\n\twhile ( this.index < this.tasks.length ) {\n\t\tvar task = this.tasks[this.index++];\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logFlush( task );\n\t\t}\n\n\t\t//!steal-remove-end\n\t\ttask.fn.apply( task.context, task.args );\n\t}\n\tthis.index = 0;\n\tthis.tasks = [];\n\tthis.callbacks.onComplete( this );\n};\n\nQueue.prototype.log = function () {\n\tthis._log = arguments.length ? arguments[0] : true;\n};\n\n//The following are removed in production.\n//!steal-remove-start\nif(true) {\n\tQueue.prototype._logEnqueue = function ( task ) {\n\t\t// For debugging, set the parentTask to the last\n\t\t// run task.\n\t\ttask.meta.parentTask = queueState.lastTask;\n\t\t// Also let the task know which stack it was run within.\n\t\ttask.meta.stack = this;\n\n\t\tif ( this._log === true || this._log === \"enqueue\" ) {\n\t\t\tvar log = task.meta.log ? task.meta.log.concat( task ) : [task.fn.name, task];\n\t\t\tcanDev.log.apply( canDev, [this.name + \" enqueuing:\"].concat( log ));\n\t\t}\n\t};\n\t// `_logFlush` MUST be called by all queues prior to flushing in\n\t// development.\n\tQueue.prototype._logFlush = function ( task ) {\n\t\tif ( this._log === true || this._log === \"flush\" ) {\n\t\t\tvar log = task.meta.log ? task.meta.log.concat( task ) : [task.fn.name, task];\n\t\t\tcanDev.log.apply( canDev, [this.name + \" running  :\"].concat( log ));\n\t\t}\n\t\t// Update the state to mark this as the task that was run last.\n\t\tqueueState.lastTask = task;\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack:///./node_modules/can-queues/queue.js?");

/***/ }),

/***/ "./node_modules/can-queues/sorted-index-by.js":
/*!****************************************************!*\
  !*** ./node_modules/can-queues/sorted-index-by.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(compare, array, value) {\n\tif (!array || !array.length) {\n\t\treturn undefined;\n\t}\n\t// check the start and the end\n\tif (compare(value, array[0]) === -1) {\n\t\treturn 0;\n\t} else if (compare(value, array[array.length - 1]) === 1) {\n\t\treturn array.length;\n\t}\n\tvar low = 0,\n\t\thigh = array.length;\n\n\t// From lodash lodash 4.6.1 <https://lodash.com/>\n\t// Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n\twhile (low < high) {\n\t\tvar mid = (low + high) >>> 1,\n\t\t\titem = array[mid],\n\t\t\tcomputed = compare(value, item);\n\t\tif (computed === -1) {\n\t\t\thigh = mid;\n\t\t} else {\n\t\t\tlow = mid + 1;\n\t\t}\n\t}\n\treturn high;\n\t// bisect by calling sortFunc\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-queues/sorted-index-by.js?");

/***/ }),

/***/ "./node_modules/can-realtime-rest-model/can-realtime-rest-model.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-realtime-rest-model/can-realtime-rest-model.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var connect = __webpack_require__(/*! can-connect */ \"./node_modules/can-connect/can-connect.js\");\n\nvar constructor = __webpack_require__(/*! can-connect/constructor/constructor */ \"./node_modules/can-connect/constructor/constructor.js\");\nvar canMap = __webpack_require__(/*! can-connect/can/map/map */ \"./node_modules/can-connect/can/map/map.js\");\nvar constructorStore = __webpack_require__(/*! can-connect/constructor/store/store */ \"./node_modules/can-connect/constructor/store/store.js\");\nvar dataCallbacks = __webpack_require__(/*! can-connect/data/callbacks/callbacks */ \"./node_modules/can-connect/data/callbacks/callbacks.js\");\nvar dataParse = __webpack_require__(/*! can-connect/data/parse/parse */ \"./node_modules/can-connect/data/parse/parse.js\");\nvar dataUrl = __webpack_require__(/*! can-connect/data/url/url */ \"./node_modules/can-connect/data/url/url.js\");\nvar ObservableArray = __webpack_require__(/*! can-observable-array */ \"./node_modules/can-observable-array/dist/can-observable-array.js\");\nvar ObservableObject = __webpack_require__(/*! can-observable-object */ \"./node_modules/can-observable-object/dist/can-observable-object.js\");\nvar realTime = __webpack_require__(/*! can-connect/real-time/real-time */ \"./node_modules/can-connect/real-time/real-time.js\");\nvar callbacksOnce = __webpack_require__(/*! can-connect/constructor/callbacks-once/callbacks-once */ \"./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar type = __webpack_require__(/*! can-type */ \"./node_modules/can-type/can-type.js\");\n\nfunction realtimeRestModel(optionsOrUrl) {\n\n\t// If optionsOrUrl is a string, make options = {url: optionsOrUrl}\n\tvar options = (typeof optionsOrUrl === \"string\") ? {url: optionsOrUrl} : optionsOrUrl;\n\n\t// If options.ObjectType or .ArrayType arenâ€™t provided, define them\n\tif (typeof options.ObjectType === \"undefined\") {\n\t\toptions.ObjectType = class DefaultObjectType extends ObservableObject {};\n\t}\n\tif (typeof options.ArrayType === \"undefined\") {\n\t\toptions.ArrayType = class DefaultArrayType extends ObservableArray {\n\t\t\tstatic get items() {\n\t\t\t\treturn type.convert(options.ObjectType);\n\t\t\t}\n\t\t};\n\t}\n\n\tvar behaviors = [\n\t\tconstructor,\n\t\tcanMap,\n\t\tconstructorStore,\n\t\tdataCallbacks,\n\t\tdataParse,\n\t\tdataUrl,\n\t\trealTime,\n\t\tcallbacksOnce\n\t];\n\n\treturn connect(behaviors,options);\n}\n\nmodule.exports = namespace.realtimeRestModel = realtimeRestModel;\n\n\n//# sourceURL=webpack:///./node_modules/can-realtime-rest-model/can-realtime-rest-model.js?");

/***/ }),

/***/ "./node_modules/can-reflect-dependencies/can-reflect-dependencies.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-reflect-dependencies/can-reflect-dependencies.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar addMutatedBy = __webpack_require__(/*! ./src/add-mutated-by */ \"./node_modules/can-reflect-dependencies/src/add-mutated-by.js\");\nvar deleteMutatedBy = __webpack_require__(/*! ./src/delete-mutated-by */ \"./node_modules/can-reflect-dependencies/src/delete-mutated-by.js\");\nvar getDependencyDataOf = __webpack_require__(/*! ./src/get-dependency-data-of */ \"./node_modules/can-reflect-dependencies/src/get-dependency-data-of.js\");\n\n// mutatedByMap :: WeakMap<obj, {\n//\tmutateDependenciesForKey:   Map<key, DependencyRecord>,\n//\tmutateDependenciesForValue: DependencyRecord\n// }>\nvar mutatedByMap = new WeakMap();\n\nmodule.exports = {\n\t// Track mutations between observable as dependencies\n\t// addMutatedBy(obs, obs2);\n\t// addMutatedBy(obs, key, obs2);\n\t// addMutatedBy(obs, { valueDependencies: Set, keyDependencies: Map })\n\t// addMutatedBy(obs, key, { valueDependencies: Set, keyDependencies: Map })\n\taddMutatedBy: addMutatedBy(mutatedByMap),\n\n\t// Call this method with the same arguments as `addMutatedBy`\n\t// to unregister the mutation dependency\n\tdeleteMutatedBy: deleteMutatedBy(mutatedByMap),\n\n\t// Returns an object with the dependecies of the given argument\n\t//\t{\n\t//\t\twhatIChange: { mutate: DependencyRecord, derive: DependencyRecord },\n\t//\t\twhatChangesMe: { mutate: DependencyRecord, derive: DependencyRecord }\n\t//\t}\n\tgetDependencyDataOf: getDependencyDataOf(mutatedByMap)\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect-dependencies/can-reflect-dependencies.js?");

/***/ }),

/***/ "./node_modules/can-reflect-dependencies/src/add-mutated-by.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-reflect-dependencies/src/add-mutated-by.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\n// DependencyRecord :: { keyDependencies: Map, valueDependencies: Set }\nvar makeDependencyRecord = function makeDependencyRecord() {\n\treturn {\n\t\tkeyDependencies: new Map(),\n\t\tvalueDependencies: new Set()\n\t};\n};\n\nvar makeRootRecord = function makeRootRecord() {\n\treturn {\n\t\t// holds mutated key dependencies of a key-value like object, e.g:\n\t\t// if person.first is mutated by other observable, this map will have a\n\t\t// key `first` (the mutated property) mapped to a DependencyRecord\n\t\tmutateDependenciesForKey: new Map(),\n\n\t\t// holds mutated value dependencies of value-like objects\n\t\tmutateDependenciesForValue: makeDependencyRecord()\n\t};\n};\n\nmodule.exports = function(mutatedByMap) {\n\treturn function addMutatedBy(mutated, key, mutator) {\n\t\tvar gotKey = arguments.length === 3;\n\n\t\t// normalize arguments\n\t\tif (arguments.length === 2) {\n\t\t\tmutator = key;\n\t\t\tkey = undefined;\n\t\t}\n\n\t\t// normalize mutator when shorthand is used\n\t\tif (!mutator.keyDependencies && !mutator.valueDependencies) {\n\t\t\tvar s = new Set();\n\t\t\ts.add(mutator);\n\t\t\tmutator = { valueDependencies:s };\n\t\t}\n\n\t\t// retrieve root record from the state map or create a new one\n\t\tvar root = mutatedByMap.get(mutated);\n\t\tif (!root) {\n\t\t\troot = makeRootRecord();\n\t\t\tmutatedByMap.set(mutated, root);\n\t\t}\n\n\t\t// create a [key] DependencyRecord if [key] was provided\n\t\t// and Record does not already exist\n\t\tif (gotKey && !root.mutateDependenciesForKey.get(key)) {\n\t\t\troot.mutateDependenciesForKey.set(key, makeDependencyRecord());\n\t\t}\n\n\t\t// retrieve DependencyRecord\n\t\tvar dependencyRecord = gotKey ?\n\t\t\troot.mutateDependenciesForKey.get(key) :\n\t\t\troot.mutateDependenciesForValue;\n\n\t\tif (mutator.valueDependencies) {\n\t\t\tcanReflect.addValues(\n\t\t\t\tdependencyRecord.valueDependencies,\n\t\t\t\tmutator.valueDependencies\n\t\t\t);\n\t\t}\n\n\t\tif (mutator.keyDependencies) {\n\t\t\tcanReflect.each(mutator.keyDependencies, function(keysSet, obj) {\n\t\t\t\tvar entry = dependencyRecord.keyDependencies.get(obj);\n\n\t\t\t\tif (!entry) {\n\t\t\t\t\tentry = new Set();\n\t\t\t\t\tdependencyRecord.keyDependencies.set(obj, entry);\n\t\t\t\t}\n\n\t\t\t\tcanReflect.addValues(entry, keysSet);\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect-dependencies/src/add-mutated-by.js?");

/***/ }),

/***/ "./node_modules/can-reflect-dependencies/src/delete-mutated-by.js":
/*!************************************************************************!*\
  !*** ./node_modules/can-reflect-dependencies/src/delete-mutated-by.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nmodule.exports = function(mutatedByMap) {\n\treturn function deleteMutatedBy(mutated, key, mutator) {\n\t\tvar gotKey = arguments.length === 3;\n\t\tvar root = mutatedByMap.get(mutated);\n\n\t\t// normalize arguments\n\t\tif (arguments.length === 2) {\n\t\t\tmutator = key;\n\t\t\tkey = undefined;\n\t\t}\n\n\t\t// normalize mutator when shorthand is used\n\t\tif (!mutator.keyDependencies && !mutator.valueDependencies) {\n\t\t\tvar s = new Set();\n\t\t\ts.add(mutator);\n\t\t\tmutator = { valueDependencies: s };\n\t\t}\n\n\t\tvar dependencyRecord = gotKey ?\n\t\t\troot.mutateDependenciesForKey.get(key) :\n\t\t\troot.mutateDependenciesForValue;\n\n\t\tif (mutator.valueDependencies) {\n\t\t\tcanReflect.removeValues(\n\t\t\t\tdependencyRecord.valueDependencies,\n\t\t\t\tmutator.valueDependencies\n\t\t\t);\n\t\t}\n\n\t\tif (mutator.keyDependencies) {\n\t\t\tcanReflect.each(mutator.keyDependencies, function(keysSet, obj) {\n\t\t\t\tvar entry = dependencyRecord.keyDependencies.get(obj);\n\n\t\t\t\tif (entry) {\n\t\t\t\t\tcanReflect.removeValues(entry, keysSet);\n\t\t\t\t\tif (!entry.size) {\n\t\t\t\t\t\tdependencyRecord.keyDependencies.delete(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect-dependencies/src/delete-mutated-by.js?");

/***/ }),

/***/ "./node_modules/can-reflect-dependencies/src/get-dependency-data-of.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/can-reflect-dependencies/src/get-dependency-data-of.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar isFunction = __webpack_require__(/*! ./is-function */ \"./node_modules/can-reflect-dependencies/src/is-function.js\");\nvar canAssign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\nvar getWhatIChangeSymbol = canSymbol.for(\"can.getWhatIChange\");\nvar getKeyDependenciesSymbol = canSymbol.for(\"can.getKeyDependencies\");\nvar getValueDependenciesSymbol = canSymbol.for(\"can.getValueDependencies\");\n\nvar getKeyDependencies = function getKeyDependencies(obj, key) {\n\tif (isFunction(obj[getKeyDependenciesSymbol])) {\n\t\treturn canReflect.getKeyDependencies(obj, key);\n\t}\n};\n\nvar getValueDependencies = function getValueDependencies(obj) {\n\tif (isFunction(obj[getValueDependenciesSymbol])) {\n\t\treturn canReflect.getValueDependencies(obj);\n\t}\n};\n\nvar getMutatedKeyDependencies =\n\tfunction getMutatedKeyDependencies(mutatedByMap, obj, key) {\n\t\tvar root = mutatedByMap.get(obj);\n\t\tvar dependencyRecord;\n\n\t\tif (root && root.mutateDependenciesForKey.has(key)) {\n\t\t\tdependencyRecord = root.mutateDependenciesForKey.get(key);\n\t\t}\n\n\t\treturn dependencyRecord;\n\t};\n\nvar getMutatedValueDependencies =\n\tfunction getMutatedValueDependencies( mutatedByMap, obj) {\n\t\tvar result;\n\t\tvar root = mutatedByMap.get(obj);\n\n\t\tif (root) {\n\t\t\tvar\tdependencyRecord = root.mutateDependenciesForValue;\n\n\t\t\tif (dependencyRecord.keyDependencies.size) {\n\t\t\t\tresult = result || {};\n\t\t\t\tresult.keyDependencies = dependencyRecord.keyDependencies;\n\t\t\t}\n\n\t\t\tif (dependencyRecord.valueDependencies.size) {\n\t\t\t\tresult = result || {};\n\t\t\t\tresult.valueDependencies = dependencyRecord.valueDependencies;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\nvar getWhatIChange = function getWhatIChange(obj, key) {\n\tif (isFunction(obj[getWhatIChangeSymbol])) {\n\t\tvar gotKey = arguments.length === 2;\n\n\t\treturn gotKey ?\n\t\t\tcanReflect.getWhatIChange(obj, key) :\n\t\t\tcanReflect.getWhatIChange(obj);\n\t}\n};\n\nvar isEmptyRecord = function isEmptyRecord(record) {\n\treturn (\n\t\trecord == null ||\n\t\t!Object.keys(record).length ||\n\t\t(record.keyDependencies && !record.keyDependencies.size) &&\n\t\t(record.valueDependencies && !record.valueDependencies.size)\n\t);\n};\n\nvar getWhatChangesMe = function getWhatChangesMe(mutatedByMap, obj, key) {\n\tvar gotKey = arguments.length === 3;\n\n\tvar mutate = gotKey ?\n\t\tgetMutatedKeyDependencies(mutatedByMap, obj, key) :\n\t\tgetMutatedValueDependencies(mutatedByMap, obj);\n\n\tvar derive = gotKey ?\n\t\tgetKeyDependencies(obj, key) :\n\t\tgetValueDependencies(obj);\n\n\tif (!isEmptyRecord(mutate) || !isEmptyRecord(derive)) {\n\t\treturn canAssign(\n\t\t\tcanAssign(\n\t\t\t\t{},\n\t\t\t\tmutate ? { mutate: mutate } : null\n\t\t\t),\n\t\t\tderive ? { derive: derive } : null\n\t\t);\n\t}\n};\n\nmodule.exports = function(mutatedByMap) {\n\treturn function getDependencyDataOf(obj, key) {\n\t\tvar gotKey = arguments.length === 2;\n\n\t\tvar whatChangesMe = gotKey ?\n\t\t\tgetWhatChangesMe(mutatedByMap, obj, key) :\n\t\t\tgetWhatChangesMe(mutatedByMap, obj);\n\n\t\tvar whatIChange = gotKey ? getWhatIChange(obj, key) : getWhatIChange(obj);\n\n\t\tif (whatChangesMe || whatIChange) {\n\t\t\treturn canAssign(\n\t\t\t\tcanAssign(\n\t\t\t\t\t{},\n\t\t\t\t\twhatIChange ? { whatIChange: whatIChange } : null\n\t\t\t\t),\n\t\t\t\twhatChangesMe ? { whatChangesMe: whatChangesMe } : null\n\t\t\t);\n\t\t}\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect-dependencies/src/get-dependency-data-of.js?");

/***/ }),

/***/ "./node_modules/can-reflect-dependencies/src/is-function.js":
/*!******************************************************************!*\
  !*** ./node_modules/can-reflect-dependencies/src/is-function.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function isFunction(value) {\n\treturn typeof value === \"function\";\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect-dependencies/src/is-function.js?");

/***/ }),

/***/ "./node_modules/can-reflect-promise/can-reflect-promise.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-reflect-promise/can-reflect-promise.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"./node_modules/can-key-tree/can-key-tree.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\n\nvar getKeyValueSymbol = canSymbol.for(\"can.getKeyValue\"),\n\tobserveDataSymbol = canSymbol.for(\"can.meta\");\n\nvar promiseDataPrototype = {\n\tisPending: true,\n\tstate: \"pending\",\n\tisResolved: false,\n\tisRejected: false,\n\tvalue: undefined,\n\treason: undefined\n};\n\nfunction setVirtualProp(promise, property, value) {\n\tvar observeData = promise[observeDataSymbol];\n\tvar old = observeData[property];\n\tobserveData[property] = value;\n\tqueues.enqueueByQueue(observeData.handlers.getNode([property]), promise, [value,old], function() {\n\t\treturn {};\n\t},[\"Promise\", promise, \"resolved with value\", value, \"and changed virtual property: \"+property]);\n}\n\nfunction initPromise(promise) {\n\tvar observeData = promise[observeDataSymbol];\n\tif(!observeData) {\n\t\tObject.defineProperty(promise, observeDataSymbol, {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: false,\n\t\t\twritable: false,\n\t\t\tvalue: Object.create(promiseDataPrototype)\n\t\t});\n\t\tobserveData = promise[observeDataSymbol];\n\t\tobserveData.handlers = new KeyTree([Object, Object, Array]);\n\t}\n\tpromise.then(function(value){\n\t\tqueues.batch.start();\n\t\tsetVirtualProp(promise, \"isPending\", false);\n\t\tsetVirtualProp(promise, \"isResolved\", true);\n\t\tsetVirtualProp(promise, \"value\", value);\n\t\tsetVirtualProp(promise, \"state\", \"resolved\");\n\t\tqueues.batch.stop();\n\t}, function(reason){\n\t\tqueues.batch.start();\n\t\tsetVirtualProp(promise, \"isPending\", false);\n\t\tsetVirtualProp(promise, \"isRejected\", true);\n\t\tsetVirtualProp(promise, \"reason\", reason);\n\t\tsetVirtualProp(promise, \"state\", \"rejected\");\n\t\tqueues.batch.stop();\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.error(\"Failed promise:\", reason);\n\t\t}\n\t\t//!steal-remove-end\n\t});\n}\n\nfunction setupPromise(value) {\n\tvar oldPromiseFn;\n\tvar proto = \"getPrototypeOf\" in Object ? Object.getPrototypeOf(value) : value.__proto__; //jshint ignore:line\n\n\tif(value[getKeyValueSymbol] && value[observeDataSymbol]) {\n\t\t// promise has already been set up.  Don't overwrite.\n\t\treturn;\n\t}\n\n\tif(proto === null || proto === Object.prototype) {\n\t\t// promise type is a plain object or dictionary.  Set up object instead of proto.\n\t\tproto = value;\n\n\t\tif(typeof proto.promise === \"function\") {\n\t\t\t// Duck-type identification as a jQuery.Deferred;\n\t\t\t// In that case, the promise() function returns a new object\n\t\t\t//  that needs to be decorated.\n\t\t\toldPromiseFn = proto.promise;\n\t\t\tproto.promise = function() {\n\t\t\t\tvar result = oldPromiseFn.call(proto);\n\t\t\t\tsetupPromise(result);\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t}\n\n\tcanReflect.assignSymbols(proto, {\n\t\t\"can.getKeyValue\": function(key) {\n\t\t\tif(!this[observeDataSymbol]) {\n\t\t\t\tinitPromise(this);\n\t\t\t}\n\n\t\t\tObservationRecorder.add(this, key);\n\t\t\tswitch(key) {\n\t\t\t\tcase \"state\":\n\t\t\t\tcase \"isPending\":\n\t\t\t\tcase \"isResolved\":\n\t\t\t\tcase \"isRejected\":\n\t\t\t\tcase \"value\":\n\t\t\t\tcase \"reason\":\n\t\t\t\treturn this[observeDataSymbol][key];\n\t\t\t\tdefault:\n\t\t\t\treturn this[key];\n\t\t\t}\n\t\t},\n\t\t\"can.getValue\": function() {\n\t\t\treturn this[getKeyValueSymbol](\"value\");\n\t\t},\n\t\t\"can.isValueLike\": false,\n\t\t\"can.onKeyValue\": function(key, handler, queue) {\n\t\t\tif(!this[observeDataSymbol]) {\n\t\t\t\tinitPromise(this);\n\t\t\t}\n\t\t\tthis[observeDataSymbol].handlers.add([key, queue || \"mutate\", handler]);\n\t\t},\n\t\t\"can.offKeyValue\": function(key, handler, queue) {\n\t\t\tif(!this[observeDataSymbol]) {\n\t\t\t\tinitPromise(this);\n\t\t\t}\n\t\t\tthis[observeDataSymbol].handlers.delete([key, queue || \"mutate\", handler]);\n\t\t},\n\t\t\"can.hasOwnKey\": function(key) {\n\t\t\tif (!this[observeDataSymbol]) {\n\t\t\t\tinitPromise(this);\n\t\t\t}\n\t\t\treturn (key in this[observeDataSymbol]);\n\t\t}\n\t});\n}\n\nmodule.exports = setupPromise;\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect-promise/can-reflect-promise.js?");

/***/ }),

/***/ "./node_modules/can-reflect/can-reflect.js":
/*!*************************************************!*\
  !*** ./node_modules/can-reflect/can-reflect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar functionReflections = __webpack_require__(/*! ./reflections/call/call */ \"./node_modules/can-reflect/reflections/call/call.js\");\nvar getSet = __webpack_require__(/*! ./reflections/get-set/get-set */ \"./node_modules/can-reflect/reflections/get-set/get-set.js\");\nvar observe = __webpack_require__(/*! ./reflections/observe/observe */ \"./node_modules/can-reflect/reflections/observe/observe.js\");\nvar shape = __webpack_require__(/*! ./reflections/shape/shape */ \"./node_modules/can-reflect/reflections/shape/shape.js\");\nvar schema = __webpack_require__(/*! ./reflections/shape/schema/schema */ \"./node_modules/can-reflect/reflections/shape/schema/schema.js\");\nvar type = __webpack_require__(/*! ./reflections/type/type */ \"./node_modules/can-reflect/reflections/type/type.js\");\nvar getName = __webpack_require__(/*! ./reflections/get-name/get-name */ \"./node_modules/can-reflect/reflections/get-name/get-name.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar reflect = {};\n[\n\tfunctionReflections,\n\tgetSet,\n\tobserve,\n\tshape,\n\ttype,\n\tgetName,\n\tschema\n].forEach(function(reflections){\n\tfor(var prop in reflections) {\n\t\treflect[prop] = reflections[prop];\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif(typeof reflections[prop] === \"function\") {\n\t\t\t\tvar propDescriptor = Object.getOwnPropertyDescriptor(reflections[prop], 'name');\n\t\t\t\tif (!propDescriptor || propDescriptor.writable && propDescriptor.configurable) {\n\t\t\t\t\tObject.defineProperty(reflections[prop],\"name\",{\n\t\t\t\t\t\tvalue: \"canReflect.\"+prop\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t}\n});\n\n__webpack_require__(/*! ./types/map */ \"./node_modules/can-reflect/types/map.js\");\n__webpack_require__(/*! ./types/set */ \"./node_modules/can-reflect/types/set.js\");\n\nmodule.exports = namespace.Reflect = reflect;\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect/can-reflect.js?");

/***/ }),

/***/ "./node_modules/can-reflect/reflections/call/call.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-reflect/reflections/call/call.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"./node_modules/can-reflect/reflections/type/type.js\");\n\nmodule.exports = {\n\t/**\n\t * @function {function(...), Object, ...} can-reflect/call.call call\n\t * @parent can-reflect/call\n\t * @description  Call a callable, with a context object and parameters\n\t *\n\t * @signature `call(func, context, ...rest)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters\n\t * occurring after `context` set to the positional parameters.\n\t *\n\t * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],\n\t * or have a callable `apply` property to work with `canReflect.call`\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t *\n\t * canReflect.call(compute, null, \"bar\");\n\t * canReflect.call(compute, null); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {function(...)} func the function to call with the supplied arguments\n\t * @param  {Object} context the context object to set as `this` on the function call\n\t * @param  {*} rest any arguments after `context` will be passed to the function call\n\t * @return {*}  return types and values are determined by the call to `func`\n\t */\n\tcall: function(func, context){\n\t\tvar args = [].slice.call(arguments, 2);\n\t\tvar apply = func[canSymbol.for(\"can.apply\")];\n\t\tif(apply) {\n\t\t\treturn apply.call(func, context, args);\n\t\t} else {\n\t\t\treturn func.apply(context, args);\n\t\t}\n\t},\n\t/**\n\t * @function {function(...), Object, ...} can-reflect/call.apply apply\n\t * @parent can-reflect/call\n\t * @description  Call a callable, with a context object and a list of parameters\n\t *\n\t * @signature `apply(func, context, args)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters\n\t * contained in the Array-like `args`\n\t *\n\t * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],\n\t * or have a callable `apply` property to work with `canReflect.apply`\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t *\n\t * canReflect.apply(compute, null, [\"bar\"]);\n\t * canReflect.apply(compute, null, []); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {function(...)} func the function to call\n\t * @param  {Object} context the context object to set as `this` on the function call\n\t * @param  {*} args arguments to be passed to the function call\n\t * @return {*}  return types and values are determined by the call to `func`\n\t */\n\tapply: function(func, context, args){\n\t\tvar apply = func[canSymbol.for(\"can.apply\")];\n\t\tif(apply) {\n\t\t\treturn apply.call(func, context, args);\n\t\t} else {\n\t\t\treturn func.apply(context, args);\n\t\t}\n\t},\n\t/**\n\t * @function {function(...), ...} can-reflect/call.new new\n\t * @parent can-reflect/call\n\t * @description  Construct a new instance of a callable constructor\n\t *\n\t * @signature `new(func, ...rest)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to a new instance of `func`, and with any additional\n\t * parameters occurring after `func` set to the positional parameters.\n\t *\n\t * Note that `func` *must* either implement [can-symbol/symbols/new @@@@can.new],\n\t * or have a callable `apply` property *and* a prototype to work with `canReflect.new`\n\t *\n\t * ```js\n\t * canReflect.new(DefineList, [\"foo\"]); // -> [\"foo\"]<DefineList>\n\t * ```\n\t *\n\t * @param  {function(...)} func a constructor\n\t * @param  {*} rest arguments to be passed to the constructor\n\t * @return {Object}  if `func` returns an Object, that returned Object; otherwise a new instance of `func`\n\t */\n\t\"new\": function(func){\n\t\tvar args = [].slice.call(arguments, 1);\n\t\tvar makeNew = func[canSymbol.for(\"can.new\")];\n\t\tif(makeNew) {\n\t\t\treturn makeNew.apply(func, args);\n\t\t} else {\n\t\t\tvar context = Object.create(func.prototype);\n\t\t\tvar ret = func.apply(context, args);\n\t\t\tif(typeReflections.isPrimitive(ret)) {\n\t\t\t\treturn context;\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect/reflections/call/call.js?");

/***/ }),

/***/ "./node_modules/can-reflect/reflections/get-name/get-name.js":
/*!*******************************************************************!*\
  !*** ./node_modules/can-reflect/reflections/get-name/get-name.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"./node_modules/can-reflect/reflections/type/type.js\");\n\nvar getNameSymbol = canSymbol.for(\"can.getName\");\n\n/**\n * @function {Object, String} can-reflect.setName setName\n * @parent can-reflect/shape\n * @description Set a human-readable name of an object.\n *\n * @signature `setName(obj, value)`\n *\n * ```js\n * var f = function() {};\n *\n * canReflect.setName(f, \"myFunction\")\n * f.name //-> \"myFunction\"\n * ```\n *\n * @param {Object} obj   the object to set on\n * @param {String} value the value to set for the object\n */\nfunction setName(obj, nameGetter) {\n\tif (typeof nameGetter !== \"function\") {\n\t\tvar value = nameGetter;\n\t\tnameGetter = function() {\n\t\t\treturn value;\n\t\t};\n\t}\n\n\tObject.defineProperty(obj, getNameSymbol, {\n\t\tvalue: nameGetter\n\t});\n}\n\n/**\n * @function {Object} can-reflect.getName getName\n * @parent can-reflect/shape\n * @description Get the name of an object.\n *\n * @signature `getValue(obj)`\n *\n * @body\n *\n * The [@@@can.getName](can-symbol/symbols/getName.html) symbol is used to\n * provide objects human readable names; the main goal of these names is to help\n * users get a glance of what the object does and what it is used for.\n *\n * There are no hard rules to define names but CanJS uses the following convention\n * for consistent names across its observable types:\n *\n * - The name starts with the observable constructor name\n * - The constructor name is decorated with the following characters based on its type:\n *\t\t- `<>`: for [value-like](can-reflect.isValueLike.html) observables, e.g: `SimpleObservable<>`\n *\t\t- `[]`: for [list-like](can-reflect.isListLike.html) observables, e.g: `DefineList[]`\n *\t\t- `{}`: for [map-like](can-reflect.isMapLike.html) observables, e.g: `DefineMap{}`\n * - Any property that makes the instance unique (like ids) are printed inside\n *    the chars mentioned before.\n *\n * The example below shows how to implement [@@@can.getName](can-symbol/symbols/getName.html),\n * in a value-like observable (similar to [can-simple-observable]).\n *\n * ```js\n * var canReflect = require(\"can-reflect\");\n *\n * function MySimpleObservable(value) {\n *\t\tthis.value = value;\n * }\n *\n * canReflect.assignSymbols(MySimpleObservable.prototype, {\n *\t\t\"can.getName\": function() {\n *\t\t\t//!steal-remove-start\n *\t\t\tif (process.env.NODE_ENV !== 'production') {\n *\t\t\t\tvar value = JSON.stringify(this.value);\n *\t\t\t\treturn canReflect.getName(this.constructor) + \"<\" + value + \">\";\n *\t\t\t}\n *\t\t\t//!steal-remove-end\n *\t\t}\n * });\n * ```\n *\n * With that in place, `MySimpleObservable` can be used like this:\n *\n * ```js\n * var one = new MySimpleObservable(1);\n * canReflect.getName(one); // MySimpleObservable<1>\n * ```\n *\n * @param  {Object} obj The object to get from\n * @return {String} The human-readable name of the object\n */\nvar anonymousID = 0;\nfunction getName(obj) {\n\tvar type = typeof obj;\n\tif(obj === null || (type !== \"object\" && type !== \"function\")) {\n\t\treturn \"\"+obj;\n\t}\n\tvar nameGetter = obj[getNameSymbol];\n\tif (nameGetter) {\n\t\treturn nameGetter.call(obj);\n\t}\n\n\tif (type === \"function\") {\n\t\tif (!(\"name\" in obj)) {\n\t\t\t// IE doesn't support function.name natively\n\t\t\tobj.name = \"functionIE\" + anonymousID++;\n\t\t}\n\t\treturn obj.name;\n\t}\n\n\tif (obj.constructor && obj !== obj.constructor) {\n\t\tvar parent = getName(obj.constructor);\n\t\tif (parent) {\n\t\t\tif (typeReflections.isValueLike(obj)) {\n\t\t\t\treturn parent + \"<>\";\n\t\t\t}\n\n\t\t\tif (typeReflections.isMoreListLikeThanMapLike(obj)) {\n\t\t\t\treturn parent + \"[]\";\n\t\t\t}\n\n\t\t\tif (typeReflections.isMapLike(obj)) {\n\t\t\t\treturn parent + \"{}\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nmodule.exports = {\n\tsetName: setName,\n\tgetName: getName\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect/reflections/get-name/get-name.js?");

/***/ }),

/***/ "./node_modules/can-reflect/reflections/get-set/get-set.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-reflect/reflections/get-set/get-set.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"./node_modules/can-reflect/reflections/type/type.js\");\n\nvar setKeyValueSymbol = canSymbol.for(\"can.setKeyValue\"),\n\tgetKeyValueSymbol = canSymbol.for(\"can.getKeyValue\"),\n\tgetValueSymbol = canSymbol.for(\"can.getValue\"),\n\tsetValueSymbol = canSymbol.for(\"can.setValue\");\n\nvar reflections = {\n\t/**\n\t * @function {Object, String, *} can-reflect.setKeyValue setKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Set the value of a named property on a MapLike object.\n\t *\n\t * @signature `setKeyValue(obj, key, value)`\n\t *\n\t * Set the property on Map-like `obj`, identified by the String, Symbol or Object value `key`, to the value `value`.\n\t * The default behavior can be overridden on `obj` by implementing [can-symbol/symbols/setKeyValue @@@@can.setKeyValue],\n\t * otherwise native named property access is used for string keys, and `Object.defineProperty` is used to set symbols.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.setKeyValue(foo, \"bar\", \"quux\");\n\t * foo[bar]; // -> \"quux\"\n\t * ```\n\t * @param  {Object} obj   the object to set on\n\t * @param  {String} key   the key for the property to set\n\t * @param  {*} value      the value to set on the object\n\t */\n\tsetKeyValue: function(obj, key, value){\n\t\tif( typeReflections.isSymbolLike(key) ) {\n\t\t\tif(typeof key === \"symbol\") {\n\t\t\t\tobj[key] = value;\n\t\t\t} else {\n\t\t\t\tObject.defineProperty(obj, key, {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\twritable: true\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tvar setKeyValue = obj[setKeyValueSymbol];\n\t\tif(setKeyValue !== undefined) {\n\t\t\treturn setKeyValue.call(obj, key, value);\n\t\t} else {\n\t\t\tobj[key] = value;\n\t\t}\n\t},\n\t/**\n\t * @function {Object, String} can-reflect.getKeyValue getKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Get the value of a named property on a MapLike object.\n\t *\n\t * @signature `getKeyValue(obj, key)`\n\t *\n\t * Retrieve the property on Map-like `obj` identified by the String or Symbol value `key`.  The default behavior\n\t * can be overridden on `obj` by implementing [can-symbol/symbols/getKeyValue @@@@can.getKeyValue],\n\t * otherwise native named property access is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.getKeyValue(foo, \"bar\"); // -> \"baz\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to get from\n\t * @param  {String} key   the key of the property to get\n\t */\n\tgetKeyValue: function(obj, key) {\n\t\tvar getKeyValue = obj[getKeyValueSymbol];\n\t\tif(getKeyValue) {\n\t\t\treturn getKeyValue.call(obj, key);\n\t\t}\n\t\treturn obj[key];\n\t},\n\t/**\n\t * @function {Object, String} can-reflect.deleteKeyValue deleteKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Delete a named property from a MapLike object.\n\t *\n\t * @signature `deleteKeyValue(obj, key)`\n\t *\n\t * Remove the property identified by the String or Symbol `key` from the Map-like object `obj`, if possible.\n\t * Property definitions may interfere with deleting key values; the behavior on `obj` if `obj[key]` cannot\n\t * be deleted is undefined.  The default use of the native `delete` keyword can be overridden by `obj` if it\n\t * implements [can-symbol/symbols/deleteKeyValue @@@@can.deleteKeyValue].\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t * var quux = new CanMap({ thud: \"jeek\" });\n\t *\n\t * canReflect.deleteKeyValue(foo, \"bar\");\n\t * canReflect.deleteKeyValue(quux, \"thud\");\n\t *\n\t * \"bar\" in foo; // ->  true  -- DefineMaps use property defs which cannot be un-defined\n\t * foo.bar // -> undefined    --  but set values to undefined when deleting\n\t *\n\t * \"thud\" in quux; // -> false\n\t * quux.thud; // -> undefined\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to delete on\n\t * @param  {String} key   the key for the property to delete\n\t */\n\tdeleteKeyValue: function(obj, key) {\n\t\tvar deleteKeyValue = obj[canSymbol.for(\"can.deleteKeyValue\")];\n\t\tif(deleteKeyValue) {\n\t\t\treturn deleteKeyValue.call(obj, key);\n\t\t}\n\t\tdelete obj[key];\n\t},\n\t/**\n\t * @function {Object} can-reflect.getValue getValue\n\t * @parent can-reflect/get-set\n\t * @description Get the value of an object with a gettable value\n\t *\n\t * @signature `getValue(obj)`\n\t *\n\t * Return the value of the Value-like object `obj`.  Unless `obj` implements\n\t * [can-symbol/symbols/getValue @@@@can.getValue], the result of `getValue` on\n\t * `obj` will always be `obj`.  Observable Map-like objects may want to implement\n\t * `@@@@can.getValue` to return non-observable or plain representations of themselves.\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t * var primitive = \"bar\";\n\t *\n\t * canReflect.getValue(compute); // -> \"foo\"\n\t * canReflect.getValue(primitive); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to get from\n\t * @return {*} the value of the object via `@@can.getValue`, or the value itself.\n\t */\n\tgetValue: function(value){\n\t\tif(typeReflections.isPrimitive(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tvar getValue = value[getValueSymbol];\n\t\tif(getValue) {\n\t\t\treturn getValue.call(value);\n\t\t}\n\t\treturn value;\n\t},\n\t/**\n\t * @function {Object, *} can-reflect.setValue setValue\n\t * @parent can-reflect/get-set\n\t * @description Set the value of a mutable object.\n\t *\n\t * @signature `setValue(obj, value)`\n\t *\n\t * Set the value of a Value-like object `obj` to the value `value`.  `obj` *must* implement\n\t * [can-symbol/symbols/setValue @@@@can.setValue] to be used with `canReflect.setValue`.\n\t * Map-like objects may want to implement `@@@@can.setValue` to merge objects of properties\n\t * into themselves.\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t * var plain = {};\n\t *\n\t * canReflect.setValue(compute, \"bar\");\n\t * compute(); // -> bar\n\t *\n\t * canReflect.setValue(plain, { quux: \"thud\" }); // throws \"can-reflect.setValue - Can not set value.\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to set on\n\t * @param  {*} value      the value to set for the object\n\t */\n\tsetValue: function(item, value){\n\t\tvar setValue = item && item[setValueSymbol];\n\t\tif(setValue) {\n\t\t\treturn setValue.call(item, value);\n\t\t} else {\n\t\t\tthrow new Error(\"can-reflect.setValue - Can not set value.\");\n\t\t}\n\t},\n\n\tsplice: function(obj, index, removing, adding){\n\t\tvar howMany;\n\t\tif(typeof removing !== \"number\") {\n\t\t\tvar updateValues = obj[canSymbol.for(\"can.updateValues\")];\n\t\t\tif(updateValues) {\n\t\t\t\treturn updateValues.call(obj, index, removing, adding);\n\t\t\t}\n\t\t\thowMany = removing.length;\n\t\t} else {\n\t\t\thowMany = removing;\n\t\t}\n\n\t\tif(arguments.length <= 3){\n\t\t\tadding = [];\n\t\t}\n\n\t\tvar splice = obj[canSymbol.for(\"can.splice\")];\n\t\tif(splice) {\n\t\t\treturn splice.call(obj, index, howMany, adding);\n\t\t}\n\t\treturn [].splice.apply(obj, [index, howMany].concat(adding) );\n\t},\n\taddValues: function(obj, adding, index) {\n\t\tvar add = obj[canSymbol.for(\"can.addValues\")];\n\t\tif(add) {\n\t\t\treturn add.call(obj, adding, index);\n\t\t}\n\t\tif(Array.isArray(obj) && index === undefined) {\n\t\t\treturn obj.push.apply(obj, adding);\n\t\t}\n\t\treturn reflections.splice(obj, index, [], adding);\n\t},\n\tremoveValues: function(obj, removing, index) {\n\t\tvar removeValues = obj[canSymbol.for(\"can.removeValues\")];\n\t\tif(removeValues) {\n\t\t\treturn removeValues.call(obj, removing, index);\n\t\t}\n\t\tif(Array.isArray(obj) && index === undefined) {\n\t\t\tremoving.forEach(function(item){\n\t\t\t\tvar index = obj.indexOf(item);\n\t\t\t\tif(index >=0) {\n\t\t\t\t\tobj.splice(index, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\treturn reflections.splice(obj, index, removing, []);\n\t}\n};\n/**\n * @function {Object, String} can-reflect.get get\n * @hide\n * @description an alias for [can-reflect.getKeyValue getKeyValue]\n */\nreflections.get = reflections.getKeyValue;\n/**\n * @function {Object, String} can-reflect.set set\n * @hide\n * @description an alias for [can-reflect.setKeyValue setKeyValue]\n */\nreflections.set = reflections.setKeyValue;\n/**\n * @function {Object, String} can-reflect.delete delete\n * @hide\n * @description an alias for [can-reflect.deleteKeyValue deleteKeyValue]\n */\nreflections[\"delete\"] = reflections.deleteKeyValue;\n\nmodule.exports = reflections;\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect/reflections/get-set/get-set.js?");

/***/ }),

/***/ "./node_modules/can-reflect/reflections/helpers.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-reflect/reflections/helpers.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nmodule.exports = {\n\tmakeGetFirstSymbolValue: function(symbolNames){\n\t\tvar symbols = symbolNames.map(function(name){\n\t\t\treturn canSymbol.for(name);\n\t\t});\n\t\tvar length = symbols.length;\n\n\t\treturn function getFirstSymbol(obj){\n\t\t\tvar index = -1;\n\n\t\t\twhile (++index < length) {\n\t\t\t\tif(obj[symbols[index]] !== undefined) {\n\t\t\t\t\treturn obj[symbols[index]];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t},\n\t// The `in` check is from jQueryâ€™s fix for an iOS 8 64-bit JIT object length bug:\n\t// https://github.com/jquery/jquery/pull/2185\n\thasLength: function(list){\n\t\tvar type = typeof list;\n\t\tif(type === \"string\" || Array.isArray(list)) {\n\t\t\treturn true;\n\t\t}\n\t\tvar length = list && (type !== 'boolean' && type !== 'number' && \"length\" in list) && list.length;\n\n\t\t// var length = \"length\" in obj && obj.length;\n\t\treturn typeof list !== \"function\" &&\n\t\t\t( length === 0 || typeof length === \"number\" && length > 0 && ( length - 1 ) in list );\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect/reflections/helpers.js?");

/***/ }),

/***/ "./node_modules/can-reflect/reflections/observe/observe.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-reflect/reflections/observe/observe.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar slice = [].slice;\n\nfunction makeFallback(symbolName, fallbackName) {\n\treturn function(obj, event, handler, queueName){\n\t\tvar method = obj[canSymbol.for(symbolName)];\n\t\tif(method !== undefined) {\n\t\t\treturn method.call(obj, event, handler, queueName);\n\t\t}\n\t\treturn this[fallbackName].apply(this, arguments);\n\t};\n}\n\nfunction makeErrorIfMissing(symbolName, errorMessage){\n\treturn function(obj){\n\t\tvar method = obj[canSymbol.for(symbolName)];\n\t\tif(method !== undefined) {\n\t\t\tvar args = slice.call(arguments, 1);\n\t\t\treturn method.apply(obj, args);\n\t\t}\n\t\tthrow new Error(errorMessage);\n\t};\n}\n\nmodule.exports = {\n\t// KEY\n\t/**\n\t * @function {Object, String, function(*, *), String} can-reflect/observe.onKeyValue onKeyValue\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `onKeyValue(obj, key, handler, [queueName])`\n\t *\n\t * Register a handler on the Map-like object `obj` to trigger when the property key `key` changes.\n\t * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onKeyValue] to be compatible with\n\t * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of the property\n\t * as the first argument, and the previous value of the property as the second argument.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeyValue(obj, \"foo\", function(newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * obj.foo = \"baz\";  // -> logs \"foo is now baz , was bar\"\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {String} key  the key to listen to\n\t * @param {function(*, *)} handler a callback function that recieves the new value\n\t * @param {String} [queueName]  the queue to dispatch events to\n\t */\n\tonKeyValue: makeFallback(\"can.onKeyValue\", \"onEvent\"),\n\t/**\n\t * @function {Object, String, function(*), String} can-reflect/observe.offKeyValue offKeyValue\n\t * @parent can-reflect/observe\n\t * @description  Unregister an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `offKeyValue(obj, key, handler, [queueName])`\n\t *\n\t * Unregister a handler from the Map-like object `obj` that had previously been registered with\n\t * [can-reflect/observe.onKeyValue onKeyValue]. The function passed as `handler` will no longer be called\n\t * when the value of `key` on `obj` changes.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * var handler = function(newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onKeyValue(obj, \"foo\", handler);\n\t * canReflect.offKeyValue(obj, \"foo\", handler);\n\t *\n\t * obj.foo = \"baz\";  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {String} key  the key to stop listening to\n\t * @param {function(*)} handler the callback function that should be removed from the event handlers for `key`\n\t * @param {String} [queueName]  the queue that the handler was set to receive events from\n\t */\n\toffKeyValue: makeFallback(\"can.offKeyValue\",\"offEvent\"),\n\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeys onKeys\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on the key set changing\n\t *\n\t * @signature `onKeys(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when `obj`'s keyset changes.\n\t * `obj` *must* implement [can-symbol/symbols/onKeys @@@@can.onKeys] to be compatible with\n\t * can-reflect.onKeys.  The function passed as `handler` will receive an Array of object diffs (see\n\t * [can-util/js/diff-object/diff-object diffObject] for the format) as its one argument.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeys(obj, function(diffs) {\n\t * \tconsole.log(diffs);\n\t * });\n\t *\n\t * obj.set(\"baz\", \"quux\");  // -> logs '[{\"property\": \"baz\", \"type\": \"add\", \"value\": \"quux\"}]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the diffs in the key set\n\t */\n\t// any key change (diff would normally happen)\n\tonKeys: makeErrorIfMissing(\"can.onKeys\",\"can-reflect: can not observe an onKeys event\"),\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeysAdded onKeysAdded\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on new keys being added.\n\t *\n\t * @signature `onKeysAdded(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when a new key or keys are set on\n\t * `obj`. `obj` *must* implement [can-symbol/symbols/onKeysAdded @@@@can.onKeysAdded] to be compatible with\n\t * can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of Strings as its one\n\t * argument.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeysAded(obj, function(newKeys) {\n\t * \tconsole.log(newKeys);\n\t * });\n\t *\n\t * foo.set(\"baz\", \"quux\");  // -> logs '[\"baz\"]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the array of added keys\n\t */\n\t// keys added at a certain point {key: 1}, index\n\tonKeysAdded: makeErrorIfMissing(\"can.onKeysAdded\",\"can-reflect: can not observe an onKeysAdded event\"),\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeysRemoved onKeysRemoved\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on keys being deleted.\n\t *\n\t * @signature `onKeysRemoved(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when a key or keys are removed from\n\t * `obj`'s keyset. `obj` *must* implement [can-symbol/symbols/onKeysRemoved @@@@can.onKeysRemoved] to be\n\t * compatible with can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of\n\t * Strings as its one argument.\n\t *\n\t * ```js\n\t * var obj = new CanMap({ foo: \"bar\" });\n\t * canReflect.onKeys(obj, function(diffs) {\n\t * \tconsole.log(JSON.stringify(diffs));\n\t * });\n\t *\n\t * foo.removeAttr(\"foo\");  // -> logs '[\"foo\"]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the array of removed keys\n\t */\n\tonKeysRemoved: makeErrorIfMissing(\"can.onKeysRemoved\",\"can-reflect: can not unobserve an onKeysRemoved event\"),\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.getKeyDependencies getKeyDependencies\n\t * @parent can-reflect/observe\n\t * @description  Return the observable objects that compute to the value of a named property on an object\n\t *\n\t * @signature `getKeyDependencies(obj, key)`\n\t *\n\t * Return the observable objects that provide input values to generate the computed value of the\n\t * property `key` on Map-like object `obj`.  If `key` does not have dependencies on `obj`, returns `undefined`.\n\t * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that\n\t * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a\n\t * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/getKeyDependencies @@@@can.getKeyDependencies] to work with\n\t * `canReflect.getKeyDependencies`.\n\t *\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = new (DefineMap.extend({\n\t * \t baz: {\n\t * \t   get: function() {\n\t * \t     return foo.bar;\n\t * \t   }\n\t * \t }\n\t * }))();\n\t *\n\t * canReflect.getKeyDependencies(obj, \"baz\");  // -> { valueDependencies: CIDSet }\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for key dependencies\n\t * @param {String} key the key on the object to check\n\t * @return {Object} the observable values that this keyed value depends on\n\t */\n\tgetKeyDependencies: makeErrorIfMissing(\"can.getKeyDependencies\", \"can-reflect: can not determine dependencies\"),\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.getWhatIChange getWhatIChange\n\t * @hide\n\t * @parent can-reflect/observe\n\t * @description Return the observable objects that derive their value from the\n\t * obj, passed in.\n\t *\n\t * @signature `getWhatIChange(obj, key)`\n\t *\n\t * `obj` *must* implement `@@@@can.getWhatIChange` to work with\n\t * `canReflect.getWhatIChange`.\n\t *\n\t * @param {Object} obj the object to check for what it changes\n\t * @param {String} [key] the key on the object to check\n\t * @return {Object} the observable values that derive their value from `obj`\n\t */\n\tgetWhatIChange: makeErrorIfMissing(\n\t\t\"can.getWhatIChange\",\n\t\t\"can-reflect: can not determine dependencies\"\n\t),\n\n\t/**\n\t * @function {Function} can-reflect/observe.getChangesDependencyRecord getChangesDependencyRecord\n\t * @hide\n\t * @parent can-reflect/observe\n\t * @description Return the observable objects that are mutated by the handler\n\t * passed in as argument.\n\t *\n\t * @signature `getChangesDependencyRecord(handler)`\n\t *\n\t * `handler` *must* implement `@@@@can.getChangesDependencyRecord` to work with\n\t * `canReflect.getChangesDependencyRecord`.\n\t *\n\t * ```js\n\t * var one = new SimpleObservable(\"one\");\n\t * var two = new SimpleObservable(\"two\");\n\t *\n\t * var handler = function() {\n\t *\ttwo.set(\"2\");\n\t * };\n\t *\n\t * canReflect.onValue(one, handler);\n\t * canReflect.getChangesDependencyRecord(handler); // -> { valueDependencies: new Set([two]) }\n\t * ```\n\t *\n\t * @param {Function} handler the event handler to check for what it changes\n\t * @return {Object} the observable values that are mutated by the handler\n\t */\n\tgetChangesDependencyRecord: function getChangesDependencyRecord(handler) {\n\t\tvar fn = handler[canSymbol.for(\"can.getChangesDependencyRecord\")];\n\n\t\tif (typeof fn === \"function\") {\n\t\t\treturn fn();\n\t\t}\n\t},\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.keyHasDependencies keyHasDependencies\n\t * @parent can-reflect/observe\n\t * @description  Determine whether the value for a named property on an object is bound to other events\n\t *\n\t * @signature `keyHasDependencies(obj, key)`\n\t *\n\t * Returns `true` if the computed value of the property `key` on Map-like object `obj` derives from other values.\n\t * Returns `false` if `key` is computed on `obj` but does not have dependencies on other objects. If `key` is not\n\t * a computed value on `obj`, returns `undefined`.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/keyHasDependencies @@@@can.keyHasDependencies] to work with\n\t * `canReflect.keyHasDependencies`.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = new (DefineMap.extend({\n\t * \t baz: {\n\t * \t   get: function() {\n\t * \t     return foo.bar;\n\t * \t   }\n\t * \t },\n\t * \t quux: {\n\t * \t \t get: function() {\n\t * \t \t   return \"thud\";\n\t * \t \t }\n\t * \t }\n\t * }))();\n\t *\n\t * canReflect.keyHasDependencies(obj, \"baz\");  // -> true\n\t * canReflect.keyHasDependencies(obj, \"quux\");  // -> false\n\t * canReflect.keyHasDependencies(foo, \"bar\");  // -> undefined\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for key dependencies\n\t * @param {String} key the key on the object to check\n\t * @return {Boolean} `true` if there are other objects that may update the keyed value; `false` otherwise\n\t *\n\t */\n\t// TODO: use getKeyDeps once we know what that needs to look like\n\tkeyHasDependencies: makeErrorIfMissing(\"can.keyHasDependencies\",\"can-reflect: can not determine if this has key dependencies\"),\n\n\t// VALUE\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.onValue onValue\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on an observable ValueLike object, based on a change in its value\n\t *\n\t * @signature `onValue(handler, [queueName])`\n\t *\n\t * Register an event handler on the Value-like object `obj` to trigger when its value changes.\n\t * `obj` *must* implement [can-symbol/symbols/onValue @@@@can.onValue] to be compatible with\n\t * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of `obj`\n\t * as the first argument, and the previous value of `obj` as the second argument.\n\t *\n\t * ```js\n\t * var obj = canCompute(\"foo\");\n\t * canReflect.onValue(obj, function(newVal, oldVal) {\n\t * \tconsole.log(\"compute is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * obj(\"bar\");  // -> logs \"compute is now bar , was foo\"\n\t * ```\n\t *\n\t * @param {*} obj  any object implementing @@can.onValue\n\t * @param {function(*, *)} handler  a callback function that receives the new and old values\n\t */\n\tonValue: makeErrorIfMissing(\"can.onValue\",\"can-reflect: can not observe value change\"),\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.offValue offValue\n\t * @parent can-reflect/observe\n\t * @description  Unregister an value change handler from an observable ValueLike object\n\t *\n\t * @signature `offValue(handler, [queueName])`\n\t *\n\t * Unregister an event handler from the Value-like object `obj` that had previously been registered with\n\t * [can-reflect/observe.onValue onValue]. The function passed as `handler` will no longer be called\n\t * when the value of `obj` changes.\n\t *\n\t * ```js\n\t * var obj = canCompute( \"foo\" );\n\t * var handler = function(newVal, oldVal) {\n\t * \tconsole.log(\"compute is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onKeyValue(obj, handler);\n\t * canReflect.offKeyValue(obj, handler);\n\t *\n\t * obj(\"baz\");  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t */\n\toffValue: makeErrorIfMissing(\"can.offValue\",\"can-reflect: can not unobserve value change\"),\n\n\t/**\n\t * @function {Object} can-reflect/observe.getValueDependencies getValueDependencies\n\t * @parent can-reflect/observe\n\t * @description  Return all the events that bind to the value of an observable, Value-like object\n\t *\n\t * @signature `getValueDependencies(obj)`\n\t *\n\t * Return the observable objects that provide input values to generate the computed value of the\n\t * Value-like object `obj`.  If `obj` does not have dependencies, returns `undefined`.\n\t * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that\n\t * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a\n\t * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/getValueDependencies @@@@can.getValueDependencies] to work with\n\t * `canReflect.getValueDependencies`.\n\t *\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = canCompute(function() {\n\t * \t return foo.bar;\n\t * });\n\t *\n\t * canReflect.getValueDependencies(obj);  // -> { valueDependencies: CIDSet } because `obj` is internally backed by\n\t * a [can-observation]\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for value dependencies\n\t * @return {Object} the observable objects that `obj`'s value depends on\n\t *\n\t */\n\tgetValueDependencies: makeErrorIfMissing(\"can.getValueDependencies\",\"can-reflect: can not determine dependencies\"),\n\n\t/**\n\t * @function {Object} can-reflect/observe.valueHasDependencies valueHasDependencies\n\t * @parent can-reflect/observe\n\t * @description  Determine whether the value of an observable object is bound to other events\n\t *\n\t * @signature `valueHasDependencies(obj)`\n\t *\n\t * Returns `true` if the computed value of the Value-like object `obj` derives from other values.\n\t * Returns `false` if `obj` is computed but does not have dependencies on other objects. If `obj` is not\n\t * a computed value, returns `undefined`.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/valueHasDependencies @@@@can.valueHasDependencies] to work with\n\t * `canReflect.valueHasDependencies`.\n\t *\n\t * ```js\n\t * var foo = canCompute( \"bar\" );\n\t * var baz = canCompute(function() {\n\t * \t return foo();\n\t * });\n\t * var quux = \"thud\";\n\t * var jeek = canCompute(function(plonk) {\n\t * \t if(argument.length) {\n\t * \t \t  quux = plonk;\n\t * \t }\n\t * \t return quux;\n\t * });\n\t *\n\t * canReflect.valueHasDependencies(baz);  // -> true\n\t * canReflect.valueHasDependencies(jeek);  // -> false\n\t * canReflect.valueHasDependencies(foo);  // -> undefined\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for dependencies\n\t * @return {Boolean} `true` if there are other dependencies that may update the object's value; `false` otherwise\n\t *\n\t */\n\tvalueHasDependencies: makeErrorIfMissing(\"can.valueHasDependencies\",\"can-reflect: can not determine if value has dependencies\"),\n\n\t// PATCHES\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.onPatches onPatches\n\t * @parent can-reflect/observe\n\t * @description  Register an handler on an observable that listens to any key changes\n\t *\n\t * @signature `onPatches(obj, handler, [queueName])`\n\t *\n\t * Register an event handler on the object `obj` that fires when anything changes on an object: a key value is added,\n\t * an existing key has is value changed, or a key is deleted from the object.\n\t *\n\t * If object is an array-like and the changed property includes numeric indexes, patch sets will include array-specific\n\t * patches in addition to object-style patches\n\t *\n\t * For more on the patch formats, see [can-util/js/diff-object/diff-object] and [can-util/js/diff-array/diff-array].\n\t *\n\t * ```js\n\t * var obj = new DefineMap({});\n\t * var handler = function(patches) {\n\t * \tconsole.log(patches);\n\t * };\n\t *\n\t * canReflect.onPatches(obj, handler);\n\t * obj.set(\"foo\", \"bar\");  // logs [{ type: \"add\", property: \"foo\", value: \"bar\" }]\n\t * obj.set(\"foo\", \"baz\");  // logs [{ type: \"set\", property: \"foo\", value: \"baz\" }]\n\t *\n\t * var arr = new DefineList([]);\n\t * canReflect.onPatches(arr, handler);\n\t * arr.push(\"foo\");  // logs [{type: \"add\", property:\"0\", value: \"foo\"},\n\t *                            {index: 0, deleteCount: 0, insert: [\"foo\"]}]\n   * arr.pop();  // logs [{type: \"remove\", property:\"0\"},\n\t *                            {index: 0, deleteCount: 1, insert: []}]\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue\n\t */\n\tonPatches: makeErrorIfMissing(\"can.onPatches\", \"can-reflect: can not observe patches on object\"),\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.offPatches offPatches\n\t * @parent can-reflect/observe\n\t * @description  Unregister an object patches handler from an observable object\n\t *\n\t * @signature `offPatches(obj, handler, [queueName])`\n\t *\n\t * Unregister an event handler from the object `obj` that had previously been registered with\n\t * [can-reflect/observe.onPatches onPatches]. The function passed as `handler` will no longer be called\n\t * when `obj` has key or index changes.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({});\n\t * var handler = function(patches) {\n\t * \tconsole.log(patches);\n\t * };\n\t *\n\t * canReflect.onPatches(obj, handler);\n\t * canReflect.offPatches(obj, handler);\n\t *\n\t * obj.set(\"foo\", \"bar\");  // nothing is logged\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under\n\t */\n\toffPatches: makeErrorIfMissing(\"can.offPatches\", \"can-reflect: can not unobserve patches on object\"),\n\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.onInstancePatches onInstancePatches\n\t * @parent can-reflect/observe\n\t *\n\t * @description Registers a handler that listens to patch events on any instance\n\t *\n\t * @signature `onInstancePatches(Type, handler(instance, patches))`\n\t *\n\t * Listens to patch changes on any instance of `Type`. This is used by [can-connect]\n\t * to know when a potentially `unbound` instance's `id` changes. If the `id` changes,\n\t * the instance can be moved into the store while it is being saved. E.g:\n\t *\n\t * ```js\n\t * canReflect.onInstancePatches(Map, function onInstancePatches(instance, patches) {\n\t *\tpatches.forEach(function(patch) {\n\t *\t\tif (\n\t *\t\t\t(patch.type === \"add\" || patch.type === \"set\") &&\n\t *\t\t\tpatch.key === connection.idProp &&\n\t *\t\t\tcanReflect.isBound(instance)\n\t *\t\t) {\n\t *\t\t\tconnection.addInstanceReference(instance);\n\t *\t\t}\n\t *\t});\n\t *});\n\t * ```\n\t *\n\t * @param {*} Type\n\t * @param {function(*)} handler\n\t */\n\tonInstancePatches: makeErrorIfMissing(\n\t\t\"can.onInstancePatches\",\n\t\t\"can-reflect: can not observe onInstancePatches on Type\"\n\t),\n\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.offInstancePatches offInstancePatches\n\t * @parent can-reflect/observe\n\t *\n\t * @description Unregisters a handler registered through [can-reflect/observe.onInstancePatches]\n\t *\n\t * @signature `offInstancePatches(Type, handler(instance, patches))`\n\t *\n\t * ```js\n\t * canReflect.offInstancePatches(Map, onInstancePatches);\n\t * ```\n\t *\n\t * @param {*} Type\n\t * @param {function(*)} handler\n\t */\n\toffInstancePatches: makeErrorIfMissing(\n\t\t\"can.offInstancePatches\",\n\t\t\"can-reflect: can not unobserve onInstancePatches on Type\"\n\t),\n\n\t// HAS BINDINGS VS DOES NOT HAVE BINDINGS\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.onInstanceBoundChange onInstanceBoundChange\n\t * @parent can-reflect/observe\n\t * @description Listen to when observables of a type are bound and unbound.\n\t *\n\t * @signature `onInstanceBoundChange(Type, handler, [queueName])`\n\t *\n\t * Register an event handler on the object `Type` that fires when instances of the type become bound (the first handler is added)\n\t * or unbound (the last remaining handler is removed). The function passed as `handler` will be called\n\t * with the `instance` as the first argument and `true` as the second argument when `instance` gains its first binding,\n\t * and called with `false` when `instance` loses its\n\t * last binding.\n\t *\n\t * ```js\n\t * Person = DefineMap.extend({ ... });\n\t *\n\t * var person = Person({});\n\t * var handler = function(instance, newVal) {\n\t * \tconsole.log(instance, \"bound state is now\", newVal);\n\t * };\n\t * var keyHandler = function() {};\n\t *\n\t * canReflect.onInstanceBoundChange(Person, handler);\n\t * canReflect.onKeyValue(obj, \"name\", keyHandler);  // logs person Bound state is now true\n\t * canReflect.offKeyValue(obj, \"name\", keyHandler);  // logs person Bound state is now false\n\t * ```\n\t *\n\t * @param {function} Type A constructor function\n\t * @param {function(*,Boolean)} handler(instance,isBound) A function called with the `instance` whose bound status changed and the state of the bound status.\n\t * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue\n\t */\n\tonInstanceBoundChange: makeErrorIfMissing(\"can.onInstanceBoundChange\", \"can-reflect: can not observe bound state change in instances.\"),\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.offInstanceBoundChange offInstanceBoundChange\n\t * @parent can-reflect/observe\n\t * @description Stop listening to when observables of a type are bound and unbound.\n\t *\n\t * @signature `offInstanceBoundChange(Type, handler, [queueName])`\n\t *\n\t * Unregister an event handler from the type `Type` that had previously been registered with\n\t * [can-reflect/observe.onInstanceBoundChange onInstanceBoundChange]. The function passed as `handler` will no longer be called\n\t * when instances of `Type` gains its first or loses its last binding.\n\t *\n\t * ```js\n\t * Person = DefineMap.extend({ ... });\n\t *\n\t * var person = Person({});\n\t * var handler = function(instance, newVal) {\n\t * \tconsole.log(instance, \"bound state is now\", newVal);\n\t * };\n\t * var keyHandler = function() {};\n\t *\n\t * canReflect.onInstanceBoundChange(Person, handler);\n\t * canReflect.offInstanceBoundChange(Person, handler);\n\t * canReflect.onKeyValue(obj, \"name\", keyHandler);  // nothing is logged\n\t * canReflect.offKeyValue(obj, \"name\", keyHandler); // nothing is logged\n\t * ```\n\t *\n\t * @param {function} Type A constructor function\n\t * @param {function(*,Boolean)} handler(instance,isBound) The `handler` passed to `canReflect.onInstanceBoundChange`.\n\t * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under\n\t */\n\toffInstanceBoundChange: makeErrorIfMissing(\"can.offInstanceBoundChange\", \"can-reflect: can not unobserve bound state change\"),\n\t/**\n\t * @function {Object} can-reflect/observe.isBound isBound\n\t * @parent can-reflect/observe\n\t * @description  Determine whether any listeners are bound to the observable object\n\t *\n\t * @signature `isBound(obj)`\n\t *\n\t * `isBound` queries an observable object to find out whether any listeners have been set on it using\n\t * [can-reflect/observe.onKeyValue onKeyValue] or [can-reflect/observe.onValue onValue]\n\t *\n\t * ```js\n\t * var obj = new DefineMap({});\n\t * var handler = function() {};\n\t * canReflect.isBound(obj); // -> false\n\t * canReflect.onKeyValue(obj, \"foo\", handler);\n\t * canReflect.isBound(obj); // -> true\n\t * canReflect.offKeyValue(obj, \"foo\", handler);\n\t * canReflect.isBound(obj); // -> false\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @return {Boolean} `true` if obj has at least one key-value or value listener, `false` otherwise\n\t */\n\tisBound: makeErrorIfMissing(\"can.isBound\", \"can-reflect: cannot determine if object is bound\"),\n\n\t// EVENT\n\t/**\n\t * @function {Object, String, function(*)} can-reflect/observe.onEvent onEvent\n\t * @parent can-reflect/observe\n\t * @description  Register a named event handler on an observable object\n\t *\n\t * @signature `onEvent(obj, eventName, callback)`\n\t *\n\t *\n\t * Register an event handler on the object `obj` to trigger when the event `eventName` is dispatched.\n\t * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onEvent] or `.addEventListener()` to be compatible\n\t * with can-reflect.onKeyValue.  The function passed as `callback` will receive the event descriptor as the first\n\t * argument, and any data passed to the event dispatch as subsequent arguments.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onEvent(obj, \"foo\", function(ev, newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * canEvent.dispatch.call(obj, \"foo\", [\"baz\", \"quux\"]);  // -> logs \"foo is now baz , was quux\"\n\t * ```\n\t *\n\t * @param {Object} obj the object to bind a new event handler to\n\t * @param {String} eventName the name of the event to bind the handler to\n\t * @param {function(*)} callback  the handler function to bind to the event\n\t */\n\tonEvent: function(obj, eventName, callback, queue){\n\t\tif(obj) {\n\t\t\tvar onEvent = obj[canSymbol.for(\"can.onEvent\")];\n\t\t\tif(onEvent !== undefined) {\n\t\t\t\treturn onEvent.call(obj, eventName, callback, queue);\n\t\t\t} else if(obj.addEventListener) {\n\t\t\t\tobj.addEventListener(eventName, callback, queue);\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * @function {Object, String, function(*)} can-reflect/observe.offValue offEvent\n\t * @parent can-reflect/observe\n\t * @description  Unregister an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `offEvent(obj, eventName, callback)`\n\t *\n\t * Unregister an event handler from the object `obj` that had previously been registered with\n\t * [can-reflect/observe.onEvent onEvent]. The function passed as `callback` will no longer be called\n\t * when the event named `eventName` is dispatched on `obj`.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * var handler = function(ev, newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onEvent(obj, \"foo\", handler);\n\t * canReflect.offEvent(obj, \"foo\", handler);\n\t *\n\t * canEvent.dispatch.call(obj, \"foo\", [\"baz\", \"quux\"]);  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {Object} obj the object to unbind an event handler from\n\t * @param {String} eventName the name of the event to unbind the handler from\n\t * @param {function(*)} callback the handler function to unbind from the event\n\t */\n\toffEvent: function(obj, eventName, callback, queue){\n\t\tif(obj) {\n\t\t\tvar offEvent = obj[canSymbol.for(\"can.offEvent\")];\n\t\t\tif(offEvent !== undefined) {\n\t\t\t\treturn offEvent.call(obj, eventName, callback, queue);\n\t\t\t}  else if(obj.removeEventListener) {\n\t\t\t\tobj.removeEventListener(eventName, callback, queue);\n\t\t\t}\n\t\t}\n\n\t},\n\t/**\n\t * @function {function} can-reflect/setPriority setPriority\n\t * @parent can-reflect/observe\n\t * @description  Provide a priority for when an observable that derives its\n\t * value should be re-evaluated.\n\t *\n\t * @signature `setPriority(obj, priority)`\n\t *\n\t * Calls an underlying `@@can.setPriority` symbol on `obj` if it exists with `priorty`.\n\t * Returns `true` if a priority was set, `false` if otherwise.\n\t *\n\t * Lower priorities (`0` being the lowest), will be an indication to run earlier than\n\t * higher priorities.\n\t *\n\t * ```js\n\t * var obj = canReflect.assignSymbols({},{\n\t *   \"can.setPriority\": function(priority){\n\t *     return this.priority = priority;\n\t *   }\n\t * });\n\t *\n\t * canReflect.setPriority(obj, 0) //-> true\n\t * obj.priority //-> 0\n\t *\n\t * canReflect.setPriority({},20) //-> false\n\t * ```\n\t *\n\t * @param {Object} obj An observable that will update its priority.\n\t * @param {Number} priority The priority number.  Lower priorities (`0` being the lowest),\n\t * indicate to run earlier than higher priorities.\n\t * @return {Boolean} `true` if a priority was able to be set, `false` if otherwise.\n\t *\n\t * @body\n\t *\n\t * ## Use\n\t *\n\t * There's often a need to specify the order of re-evaluation for\n\t * __observables__ that derive (or compute) their value from other observables.\n\t *\n\t * This is needed by templates to avoid unnecessary re-evaluation.  Say we had the following template:\n\t *\n\t * ```js\n\t * {{#if value}}\n\t *   {{value}}\n\t * {{/if}}\n\t * ```\n\t *\n\t * If `value` became falsey, we'd want the `{{#if}}` to be aware of it before\n\t * the `{{value}}` magic tags updated. We can do that by setting priorities:\n\t *\n\t * ```js\n\t * canReflect.setPriority(magicIfObservable, 0);\n\t * canReflect.setPriority(magicValueObservable,1);\n\t * ```\n\t *\n\t * Internally, those observables will use that `priority` to register their\n\t * re-evaluation with the `derive` queue in [can-queues].\n\t *\n\t */\n\tsetPriority: function(obj, priority) {\n\t\tif(obj) {\n\t\t\tvar setPriority =  obj[canSymbol.for(\"can.setPriority\")];\n\t\t\tif(setPriority !== undefined) {\n\t\t\t\tsetPriority.call(obj, priority);\n\t\t\t \treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\t/**\n\t * @function {function} can-reflect/getPriority getPriority\n\t * @parent can-reflect/observe\n\t * @description  Read the priority for an observable that derives its\n\t * value.\n\t *\n\t * @signature `getPriority(obj)`\n\t *\n\t * Calls an underlying `@@can.getPriority` symbol on `obj` if it exists\n\t * and returns its value. Read [can-reflect/setPriority] for more information.\n\t *\n\t *\n\t *\n\t * @param {Object} obj An observable.\n\t * @return {Undefined|Number} Returns the priority number if\n\t * available, undefined if this object does not support the `can.getPriority`\n\t * symbol.\n\t *\n\t * @body\n\t *\n\t */\n\tgetPriority: function(obj) {\n\t\tif(obj) {\n\t\t\tvar getPriority =  obj[canSymbol.for(\"can.getPriority\")];\n\t\t\tif(getPriority !== undefined) {\n\t\t\t\treturn getPriority.call(obj);\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect/reflections/observe/observe.js?");

/***/ }),

/***/ "./node_modules/can-reflect/reflections/shape/schema/schema.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-reflect/reflections/shape/schema/schema.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../../type/type */ \"./node_modules/can-reflect/reflections/type/type.js\");\nvar getSetReflections = __webpack_require__(/*! ../../get-set/get-set */ \"./node_modules/can-reflect/reflections/get-set/get-set.js\");\nvar shapeReflections = __webpack_require__(/*! ../shape */ \"./node_modules/can-reflect/reflections/shape/shape.js\");\n\nvar getSchemaSymbol = canSymbol.for(\"can.getSchema\"),\n    isMemberSymbol = canSymbol.for(\"can.isMember\"),\n    newSymbol = canSymbol.for(\"can.new\");\n\nfunction comparator(a, b) {\n    return a.localeCompare(b);\n}\n\nfunction sort(obj) {\n    if(typeReflections.isPrimitive(obj) || obj instanceof Date) {\n        return obj;\n    }\n    var out;\n    if (typeReflections.isListLike(obj)) {\n        out = [];\n        shapeReflections.eachKey(obj, function(item){\n            out.push(sort(item));\n        });\n        return out;\n    }\n    if( typeReflections.isMapLike(obj) ) {\n\n        out = {};\n\n        shapeReflections.getOwnKeys(obj).sort(comparator).forEach(function (key) {\n            out[key] = sort( getSetReflections.getKeyValue(obj, key) );\n        });\n\n        return out;\n    }\n\n\n    return obj;\n}\n\nfunction isPrimitiveConverter(Type){\n    return Type === Number || Type === String || Type === Boolean;\n}\n\nvar schemaReflections =  {\n    /**\n\t * @function can-reflect.getSchema getSchema\n\t * @parent can-reflect/shape\n\t * @description Returns the schema for a type or value.\n\t *\n\t * @signature `getSchema(valueOrType)`\n\t *\n     * Calls the `@can.getSchema` property on the `valueOrType` argument. If it's not available and\n     * `valueOrType` has a `constructor` property, calls the `constructor[@can.getSchema]`\n     * and returns the result.\n     *\n     * ```js\n     * import canReflect from \"can-reflect\";\n     *\n     * var Type = DefineMap.extend({\n     *   name: \"string\",\n     *   id: \"number\"\n     * });\n     *\n     * canReflect.getSchema( Type ) //-> {\n     * //   type: \"map\",\n     * //   keys: {\n     * //     name: MaybeString\n     * //     id: MaybeNumber\n     * //   }\n     * // }\n     * ```\n\t *\n\t *\n\t * @param  {Object|Function} valueOrType A value, constructor function, or class to get the schema from.\n\t * @return {Object} A schema. A schema for a [can-reflect.isMapLike] looks like:\n     *\n     *\n     * ```js\n     * {\n     *   type: \"map\",\n     *   identity: [\"id\"],\n     *   keys: {\n     *     id: Number,\n     *     name: String,\n     *     complete: Boolean,\n     *     owner: User\n     *   }\n     * }\n     * ```\n     *\n     * A schema for a list looks like:\n     *\n     * ```js\n     * {\n     *   type: \"list\",\n     *   values: String\n     *   keys: {\n     *     count: Number\n     *   }\n     * }\n     * ```\n     *\n\t */\n    getSchema: function(type){\n        if (type === undefined) {\n            return undefined;\n        }\n        var getSchema = type[getSchemaSymbol];\n        if(getSchema === undefined ) {\n            type = type.constructor;\n            getSchema = type && type[getSchemaSymbol];\n        }\n        return getSchema !== undefined ? getSchema.call(type) : undefined;\n    },\n    /**\n\t * @function can-reflect.getIdentity getIdentity\n\t * @parent can-reflect/shape\n\t * @description Get a unique primitive representing an object.\n\t *\n\t * @signature `getIdentity( object [,schema] )`\n\t *\n\t * This uses the object's schema, or the provided schema to return a unique string or number that\n     * represents the object.\n     *\n     * ```js\n     * import canReflect from \"can-reflect\";\n     *\n     * canReflect.getIdentity({id: 5}, {identity: [\"id\"]}) //-> 5\n     * ```\n     *\n     * If the schema has multiple identity keys, the identity keys and values\n     * are return stringified (and sorted):\n     *\n     * ```js\n     * canReflect.getIdentity(\n     *   {z: \"Z\", a: \"A\", foo: \"bar\"},\n     *   {identity: [\"a\",\"b\"]}) //-> '{\"a\":\"A\",\"b\":\"B\"}'\n     * ```\n\t *\n\t * @param  {Object|Function} object A map-like object.\n     * @param {Object} [schema] A schema object with an `identity` array of the unique\n     * keys of the object like:\n     *   ```js\n     *   {identity: [\"id\"]}\n     *   ```\n\t * @return {Number|String} A value that uniquely represents the object.\n\t */\n    getIdentity: function(value, schema){\n        schema = schema || schemaReflections.getSchema(value);\n        if(schema === undefined) {\n            throw new Error(\"can-reflect.getIdentity - Unable to find a schema for the given value.\");\n        }\n\n        var identity = schema.identity;\n        if(!identity || identity.length === 0) {\n            throw new Error(\"can-reflect.getIdentity - Provided schema lacks an identity property.\");\n        } else if(identity.length === 1) {\n            return getSetReflections.getKeyValue(value, identity[0]);\n        } else {\n            var id = {};\n            identity.forEach(function(key){\n                id[key] = getSetReflections.getKeyValue(value, key);\n            });\n            return JSON.stringify(schemaReflections.cloneKeySort(id));\n        }\n    },\n    /**\n\t * @function can-reflect.cloneKeySort cloneKeySort\n\t * @parent can-reflect/shape\n\t * @description Copy a value while sorting its keys.\n\t *\n\t * @signature `cloneKeySort(value)`\n\t *\n     * `cloneKeySort` returns a copy of `value` with its [can-reflect.isMapLike]\n     * key values sorted. If you just want a copy of a value,\n     * use [can-reflect.serialize].\n     *\n     * ```js\n     * import canRefect from \"can-reflect\";\n     *\n     * canReflect.cloneKeySort({z: \"Z\", a: \"A\"}) //-> {a:\"A\",z:\"Z\"}\n     * ```\n     *\n     * Nested objects are also sorted.\n\t *\n     * This is useful if you need to store a representation of an object that can be used as a\n     * key.\n\t *\n\t * @param  {Object} value An object or array.\n\t * @return {Object} A copy of the object with its keys sorted.\n\t */\n    cloneKeySort: function(obj) {\n        return sort(obj);\n    },\n    /**\n\t * @function can-reflect.convert convert\n\t * @parent can-reflect/shape\n\t * @description Convert one value to another type.\n\t *\n\t * @signature `convert(value, Type)`\n\t *\n     * `convert` attempts to convert `value` to the type specified by `Type`.\n     *\n     * ```js\n     * import canRefect from \"can-reflect\";\n     *\n     * canReflect.convert(\"1\", Number) //-> 1\n     * ```\n     *\n     * `convert` works by performing the following logic:\n     *\n     * 1. If the `Type` is a primitive like `Number`, `String`, `Boolean`, the\n     *    `value` will be passed to the `Type` function and the result returned.\n     *    ```js\n     *    return Type(value);\n     *    ```\n     * 2. The value will be checked if it is already an instance of the type\n     *    by performing the following:\n     *    1. If the `Type` has a `can.isMember` symbol value, that value will be used\n     *       to determine if the `value` is already an instance.\n     *    2. If the `Type` is a [can-reflect.isConstructorLike] function, `instanceof Type`\n     *       will be used to check if `value` is already an instance.\n     * 3. If `value` is already an instance, `value` will be returned.\n     * 4. If `Type` has a `can.new` symbol, `value` will be passed to it and the result\n     *    returned.\n     * 5. If `Type` is a [can-reflect.isConstructorLike] function, `new Type(value)` will be\n     *    called the the result returned.\n     * 6. If `Type` is a regular function, `Type(value)` will be called and the result returned.\n     * 7. If a value hasn't been returned, an error is thrown.\n\t *\n\t * @param  {Object|Primitive} value A value to be converted.\n     * @param  {Object|Function} Type A constructor function or an object that implements the\n     * necessary symbols.\n\t * @return {Object} The `value` converted to a member of `Type`.\n\t */\n    convert: function(value, Type){\n        if(isPrimitiveConverter(Type)) {\n            return Type(value);\n        }\n        // check if value is already a member\n        var isMemberTest = Type[isMemberSymbol],\n            isMember = false,\n            type = typeof Type,\n            createNew = Type[newSymbol];\n        if(isMemberTest !== undefined) {\n            isMember = isMemberTest.call(Type, value);\n        } else if(type === \"function\") {\n            if(typeReflections.isConstructorLike(Type)) {\n                isMember = (value instanceof Type);\n            }\n        }\n        if(isMember) {\n            return value;\n        }\n        if(createNew !== undefined) {\n            return createNew.call(Type, value);\n        } else if(type === \"function\") {\n            if(typeReflections.isConstructorLike(Type)) {\n                return new Type(value);\n            } else {\n                // call it like a normal function\n                return Type(value);\n            }\n        } else {\n            throw new Error(\"can-reflect: Can not convert values into type. Type must provide `can.new` symbol.\");\n        }\n    }\n};\nmodule.exports = schemaReflections;\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect/reflections/shape/schema/schema.js?");

/***/ }),

/***/ "./node_modules/can-reflect/reflections/shape/shape.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-reflect/reflections/shape/shape.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar getSetReflections = __webpack_require__(/*! ../get-set/get-set */ \"./node_modules/can-reflect/reflections/get-set/get-set.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"./node_modules/can-reflect/reflections/type/type.js\");\nvar helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/can-reflect/reflections/helpers.js\");\n\n\n// IE-remove-start\nvar getPrototypeOfWorksWithPrimitives = true;\ntry {\n\tObject.getPrototypeOf(1);\n} catch(e) {\n\tgetPrototypeOfWorksWithPrimitives = false;\n}\n// IE-remove-end\n\nvar ArrayMap;\nif(typeof Map === \"function\") {\n\tArrayMap = Map;\n} else {\n\t// IE-remove-start\n\tvar isEven = function isEven(num) {\n\t\treturn num % 2 === 0;\n\t};\n\n\t// A simple map that stores items in an array.\n\t// like [key, value]\n\t// You can find the value by searching for the key and then +1.\n\tArrayMap = function(){\n\t\tthis.contents = [];\n\t};\n\n\tArrayMap.prototype = {\n\t\t/**\n\t\t * Get an index of a key. Because we store boths keys and values in\n\t\t * a flat array, we ensure we are getting a key by checking that it is an\n\t\t * even number index (all keys are even number indexed).\n\t\t **/\n\t\t_getIndex: function(key) {\n\t\t\tvar idx;\n\t\t\tdo {\n\t\t\t\tidx = this.contents.indexOf(key, idx);\n\t\t\t} while(idx !== -1 && !isEven(idx));\n\t\t\treturn idx;\n\t\t},\n\t\thas: function(key){\n\t\t\treturn this._getIndex(key) !== -1;\n\t\t},\n\t\tget: function(key){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\treturn this.contents[idx + 1];\n\t\t\t}\n\t\t},\n\t\tset: function(key, value){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\t// Key already exists, replace the value.\n\t\t\t\tthis.contents[idx + 1] = value;\n\t\t\t} else {\n\t\t\t\tthis.contents.push(key);\n\t\t\t\tthis.contents.push(value);\n\t\t\t}\n\t\t},\n\t\t\"delete\": function(key){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\t// Key already exists, replace the value.\n\t\t\t\tthis.contents.splice(idx, 2);\n\t\t\t}\n\t\t}\n\t};\n\t// IE-remove-end\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar shapeReflections;\n\nvar shiftFirstArgumentToThis = function(func){\n\treturn function(){\n\t\tvar args = [this];\n\t\targs.push.apply(args, arguments);\n\t\treturn func.apply(null,args);\n\t};\n};\n\nvar getKeyValueSymbol = canSymbol.for(\"can.getKeyValue\");\nvar shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);\nvar setKeyValueSymbol = canSymbol.for(\"can.setKeyValue\");\nvar shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);\n\nvar sizeSymbol = canSymbol.for(\"can.size\");\n\nvar hasUpdateSymbol = helpers.makeGetFirstSymbolValue([\"can.updateDeep\",\"can.assignDeep\",\"can.setKeyValue\"]);\nvar shouldUpdateOrAssign = function(obj){\n\treturn typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);\n};\n\n// is the value itself its serialized value\nfunction isSerializedHelper(obj){\n\tif (typeReflections.isPrimitive(obj)) {\n\t\treturn true;\n\t}\n\tif(hasUpdateSymbol(obj)) {\n\t\treturn false;\n\t}\n\treturn typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj) && !Array.isArray(obj) && !typeReflections.isObservableLike(obj);\n}\n\n// IE11 doesn't support primitives\nvar Object_Keys;\ntry{\n\tObject.keys(1);\n\tObject_Keys = Object.keys;\n} catch(e) {\n\tObject_Keys = function(obj){\n\t\tif(typeReflections.isPrimitive(obj)) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\treturn Object.keys(obj);\n\t\t}\n\t};\n}\n\nfunction createSerializeMap(Type) {\n\tvar MapType = Type || ArrayMap;\n\treturn {\n\t\tunwrap: new MapType(),\n\t\tserialize: new MapType() ,\n\t\tisSerializing: {\n\t\t\tunwrap: new MapType(),\n\t\t\tserialize: new MapType()\n\t\t},\n\t\tcircularReferenceIsSerializing: {\n\t\t\tunwrap: new MapType(),\n\t\t\tserialize: new MapType()\n\t\t}\n\t};\n}\n\nfunction makeSerializer(methodName, symbolsToCheck){\n\t// A local variable that is shared with all operations that occur withing a single\n\t// outer call to serialize()\n\tvar serializeMap = null;\n\n\t// Holds the value of running serialize(), preserving the same map for all\n\t// internal instances.\n\tfunction SerializeOperation(MapType) {\n\t\tthis.first = !serializeMap;\n\n\t\tif(this.first) {\n\t\t\tserializeMap = createSerializeMap(MapType);\n\t\t}\n\n\t\tthis.map = serializeMap;\n\t\tthis.result = null;\n\t}\n\n\tSerializeOperation.prototype.end = function(){\n\t\t// If this is the first, outer call, clean up the serializeMap.\n\t\tif(this.first) {\n\t\t\tserializeMap = null;\n\t\t}\n\t\treturn this.result;\n\t};\n\n\treturn function serializer(value, MapType){\n\t\tif (isSerializedHelper(value)) {\n\t\t\treturn value;\n\t\t}\n\n\t\tvar operation = new SerializeOperation(MapType);\n\n\t\tif(typeReflections.isValueLike(value)) {\n\t\t\toperation.result = this[methodName](getSetReflections.getValue(value));\n\n\t\t} else {\n\t\t\t// Date, RegEx and other Built-ins are handled above\n\t\t\t// only want to do something if it's intended to be serialized\n\t\t\t// or do nothing for a POJO\n\n\t\t\tvar isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);\n\t\t\toperation.result = isListLike ? [] : {};\n\n\t\t\t// handle maping to what is serialized\n\t\t\tif( operation.map[methodName].has(value) ) {\n\t\t\t\t// if we are in the process of serializing the first time, setup circular reference detection.\n\t\t\t\tif(operation.map.isSerializing[methodName].has(value)) {\n\t\t\t\t\toperation.map.circularReferenceIsSerializing[methodName].set(value, true);\n\t\t\t\t}\n\t\t\t\treturn operation.map[methodName].get(value);\n\t\t\t} else {\n\t\t\t\toperation.map[methodName].set(value, operation.result);\n\t\t\t}\n\n\t\t\tfor(var i = 0, len = symbolsToCheck.length ; i< len;i++) {\n\t\t\t\tvar serializer = value[symbolsToCheck[i]];\n\t\t\t\tif(serializer) {\n\t\t\t\t\t// mark that we are serializing\n\t\t\t\t\toperation.map.isSerializing[methodName].set(value, true);\n\t\t\t\t\tvar oldResult = operation.result;\n\t\t\t\t\toperation.result = serializer.call(value, oldResult);\n\t\t\t\t\toperation.map.isSerializing[methodName].delete(value);\n\n\t\t\t\t\t// if the result differs, but this was circular, blow up.\n\t\t\t\t\tif(operation.result !== oldResult) {\n\t\t\t\t\t\t// jshint -W073\n\t\t\t\t\t\tif(operation.map.circularReferenceIsSerializing[methodName].has(value)) {\n\t\t\t\t\t\t\t// Circular references should use a custom serializer\n\t\t\t\t\t\t\t// that sets the serialized value on the object\n\t\t\t\t\t\t\t// passed to it as the first argument e.g.\n\t\t\t\t\t\t\t// function(proto){\n\t\t\t\t\t\t\t//   return proto.a = canReflect.serialize(this.a);\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\toperation.end();\n\t\t\t\t\t\t\tthrow new Error(\"Cannot serialize cirular reference!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\toperation.map[methodName].set(value, operation.result);\n\t\t\t\t\t}\n\t\t\t\t\treturn operation.end();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof obj ==='function') {\n\t\t\t\toperation.map[methodName].set(value, value);\n\n\t\t\t\toperation.result = value;\n\t\t\t} else if( isListLike ) {\n\t\t\t\tthis.eachIndex(value,function(childValue, index){\n\t\t\t\t\toperation.result[index] = this[methodName](childValue);\n\t\t\t\t},this);\n\t\t\t} else {\n\t\t\t\tthis.eachKey(value,function(childValue, prop){\n\t\t\t\t\toperation.result[prop] = this[methodName](childValue);\n\t\t\t\t},this);\n\t\t\t}\n\t\t}\n\n\t\treturn operation.end();\n\t};\n}\n\n// returns a Map type of the keys mapped to true\nvar makeMap;\nif(typeof Map !== \"undefined\") {\n\tmakeMap = function(keys) {\n\t\tvar map = new Map();\n\t\tshapeReflections.eachIndex(keys, function(key){\n\t\t\tmap.set(key, true);\n\t\t});\n\t\treturn map;\n\t};\n} else {\n\tmakeMap = function(keys) {\n\t\tvar map = {};\n\t\tkeys.forEach(function(key){\n\t\t\tmap[key] = true;\n\t\t});\n\n\t\treturn {\n\t\t\tget: function(key){\n\t\t\t\treturn map[key];\n\t\t\t},\n\t\t\tset: function(key, value) {\n\t\t\t\tmap[key] = value;\n\t\t\t},\n\t\t\tkeys: function(){\n\t\t\t\treturn keys;\n\t\t\t}\n\t\t};\n\t};\n}\n\n// creates an optimized hasOwnKey lookup.\n// If the object has hasOwnKey, then we just use that.\n// Otherwise, try to put all keys in a map.\nvar fastHasOwnKey = function(obj){\n\tvar hasOwnKey = obj[canSymbol.for(\"can.hasOwnKey\")];\n\tif(hasOwnKey) {\n\t\treturn hasOwnKey.bind(obj);\n\t} else {\n\t\tvar map = makeMap( shapeReflections.getOwnEnumerableKeys(obj) );\n\t\treturn function(key) {\n\t\t\treturn map.get(key);\n\t\t};\n\t}\n};\n\n\n// combines patches if it makes sense\nfunction addPatch(patches, patch) {\n\tvar lastPatch = patches[patches.length -1];\n\tif(lastPatch) {\n\t\t// same number of deletes and counts as the index is back\n\t\tif(lastPatch.deleteCount === lastPatch.insert.length && (patch.index - lastPatch.index === lastPatch.deleteCount) ) {\n\t\t\tlastPatch.insert.push.apply(lastPatch.insert, patch.insert);\n\t\t\tlastPatch.deleteCount += patch.deleteCount;\n\t\t\treturn;\n\t\t}\n\t}\n\tpatches.push(patch);\n}\n\nfunction updateDeepList(target, source, isAssign) {\n\tvar sourceArray = this.toArray(source); // jshint ignore:line\n\n\tvar patches = [],\n\t\tlastIndex = -1;\n\tthis.eachIndex(target, function(curVal, index){ // jshint ignore:line\n\t\tlastIndex = index;\n\t\t// If target has more items than the source.\n\t\tif(index >= sourceArray.length) {\n\t\t\tif(!isAssign) {\n\t\t\t\t// add a patch that removes the last items\n\t\t\t\taddPatch(patches, {index: index, deleteCount: target.length - index + 1, insert: []});\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tvar newVal = sourceArray[index];\n\t\tif( typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\taddPatch(patches, {index: index, deleteCount: 1, insert: [newVal]});\n\t\t} else {\n\t\t\tif(isAssign === true) {\n\t\t\t\tthis.assignDeep(curVal, newVal);\n\t\t\t} else {\n\t\t\t\tthis.updateDeep(curVal, newVal);\n\t\t\t}\n\n\t\t}\n\t}, this); // jshint ignore:line\n\t// add items at the end\n\tif(sourceArray.length > lastIndex) {\n\t\taddPatch(patches, {index: lastIndex+1, deleteCount: 0, insert: sourceArray.slice(lastIndex+1)});\n\t}\n\tfor(var i = 0, patchLen = patches.length; i < patchLen; i++) {\n\t\tvar patch = patches[i];\n\t\tgetSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);\n\t}\n\treturn target;\n}\n\nshapeReflections = {\n\t/**\n\t * @function {Object, function(*), [Object]} can-reflect.each each\n\t * @parent can-reflect/shape\n\t * @description  Iterate a List-like or Map-like, calling `callback` on each keyed or indexed property\n\t *\n\t * @signature `each(obj, callback, context)`\n\t *\n\t * If `obj` is a List-like or an Iterator-like, `each` functions as [can-reflect.eachIndex eachIndex],\n\t * iterating over numeric indexes from 0 to `obj.length - 1` and calling `callback` with each property and\n\t * index, optionally with `context` as `this` (defaulting to `obj`).  If not, `each` functions as\n\t * [can-reflect.eachKey eachKey],\n\t * iterating over every key on `obj` and calling `callback` on each one.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t * var quux = new DefineList([ \"thud\", \"jeek\" ]);\n\t *\n\t * canReflect.each(foo, console.log, console); // -> logs 'baz bar {foo}'\n\t * canReflect.each(quux, console.log, console); // -> logs 'thud 0 {quux}'; logs 'jeek 1 {quux}'\n\t * ```\n\t *\n\t * @param  {Object}   obj     The object to iterate over\n\t * @param  {Function(*, ValueLike)} callback a function that receives each item in the ListLike or MapLike\n\t * @param  {[Object]}   context  an optional `this` context for calling the callback\n\t * @return {Array} the result of calling [can-reflect.eachIndex `eachIndex`] if `obj` is a ListLike,\n\t * or [can-reflect.eachKey `eachKey`] if a MapLike.\n\t */\n\teach: function(obj, callback, context){\n\n\t\t// if something is more \"list like\" .. use eachIndex\n\t\tif(typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj) ) {\n\t\t\treturn shapeReflections.eachIndex(obj,callback,context);\n\t\t} else {\n\t\t\treturn shapeReflections.eachKey(obj,callback,context);\n\t\t}\n\t},\n\n\t/**\n\t * @function {ListLike, function(*), [Object]} can-reflect.eachIndex eachIndex\n\t * @parent can-reflect/shape\n\t * @description  Iterate a ListLike calling `callback` on each numerically indexed element\n\t *\n\t * @signature `eachIndex(list, callback, context)`\n\t *\n\t * For each numeric index from 0 to `list.length - 1`, call `callback`, passing the current\n\t * property value, the current index, and `list`, and optionally setting `this` as `context`\n\t * if specified (otherwise use the current property value).\n\t *\n\t * ```js\n\t * var foo = new DefineList([ \"bar\", \"baz\" ]);\n\t *\n\t * canReflect.eachIndex(foo, console.log, console); // -> logs 'bar 0 {foo}'; logs 'baz 1 {foo}'\n\t * ```\n\t *\n\t * @param  {ListLike}   list     The list to iterate over\n\t * @param  {Function(*, Number)} callback a function that receives each item\n\t * @param  {[Object]}   context  an optional `this` context for calling the callback\n\t * @return {ListLike}   the original list\n\t */\n\teachIndex: function(list, callback, context){\n\t\t// each index in something list-like. Uses iterator if it has it.\n\t\tif(Array.isArray(list)) {\n\t\t\treturn shapeReflections.eachListLike(list, callback, context);\n\t\t} else {\n\t\t\tvar iter, iterator = list[canSymbol.iterator];\n\t\t\tif(typeReflections.isIteratorLike(list)) {\n\t\t\t\t// we are looping through an iterator\n\t\t\t\titer = list;\n\t\t\t} else if(iterator) {\n\t\t\t\titer = iterator.call(list);\n\t\t\t}\n\t\t\t// fast-path arrays\n\t\t\tif(iter) {\n\t\t\t\tvar res, index = 0;\n\n\t\t\t\twhile(!(res = iter.next()).done) {\n\t\t\t\t\tif( callback.call(context || list, res.value, index++, list) === false ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tshapeReflections.eachListLike(list, callback, context);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t},\n\teachListLike: function(list, callback, context){\n\t\tvar index = -1;\n\t\tvar length = list.length;\n\t\tif( length === undefined ) {\n\t\t\tvar size = list[sizeSymbol];\n\t\t\tif(size) {\n\t\t\t\tlength = size.call(list);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"can-reflect: unable to iterate.\");\n\t\t\t}\n\t\t}\n\n\t\twhile (++index < length) {\n\t\t\tvar item = list[index];\n\t\t\tif (callback.call(context || item, item, index, list) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t},\n\t/**\n\t * @function can-reflect.toArray toArray\n\t * @parent can-reflect/shape\n\t * @description  convert the values of any MapLike or ListLike into an array\n\t *\n\t * @signature `toArray(obj)`\n\t *\n\t * Convert the values of any Map-like or List-like into a JavaScript Array.  If a Map-like,\n\t * key data is discarded and only value data is preserved.\n\t *\n\t * ```js\n\t * var foo = new DefineList([\"bar\", \"baz\"]);\n\t * var quux = new DefineMap({ thud: \"jeek\" });\n\t * ```\n\t *\n\t * canReflect.toArray(foo); // -> [\"bar\", \"baz\"]\n\t * canReflect.toArray(quux): // -> [\"jeek\"]\n\t *\n\t * @param  {Object} obj Any object, whether MapLike or ListLike\n\t * @return {Array}  an array of the values of `obj`\n\t */\n\ttoArray: function(obj){\n\t\tvar arr = [];\n\t\tshapeReflections.each(obj, function(value){\n\t\t\tarr.push(value);\n\t\t});\n\t\treturn arr;\n\t},\n\t/**\n\t * @function can-reflect.eachKey eachKey\n\t * @parent can-reflect/shape\n\t * @description Iterate over a MapLike, calling `callback` on each enumerable property\n\t *\n\t * @signature `eachKey(obj, callback, context)`\n\t *\n\t * Iterate all own enumerable properties on Map-like `obj`\n\t * (using [can-reflect/shape/getOwnEnumerableKeys canReflect.getOwnEnumerableKeys]), and call\n\t * `callback` with the property value, the property key, and `obj`, and optionally setting\n\t * `this` on the callback as `context` if provided, `obj` otherwise.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.eachKey(foo, console.log, console); // logs 'baz bar {foo}'\n\t * ```\n\t *\n\t * @param  {Object}   obj   The object to iterate over\n\t * @param  {Function(*, String)} callback The callback to call on each enumerable property value\n\t * @param  {[Object]}   context  an optional `this` context for calling `callback`\n\t * @return {Array}    the enumerable keys of `obj` as an Array\n\t */\n\teachKey: function(obj, callback, context){\n\t\t// each key in something map like\n\t\t// eachOwnEnumerableKey\n\t\tif(obj) {\n\t\t\tvar enumerableKeys = shapeReflections.getOwnEnumerableKeys(obj);\n\n\t\t\t// cache getKeyValue method if we can\n\t\t\tvar getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;\n\n\t\t\treturn shapeReflections.eachIndex(enumerableKeys, function(key){\n\t\t\t\tvar value = getKeyValue.call(obj, key);\n\t\t\t\treturn callback.call(context || obj, value, key, obj);\n\t\t\t});\n\t\t}\n\t\treturn obj;\n\t},\n\t/**\n\t * @function can-reflect.hasOwnKey hasOwnKey\n\t * @parent can-reflect/shape\n\t * @description  Determine whether an object contains a key on itself, not only on its prototype chain\n\t *\n\t * @signature `hasOwnKey(obj, key)`\n\t *\n\t * Return `true` if an object's own properties include the property key `key`, `false` otherwise.\n\t * An object may implement [can-symbol/symbols/hasOwnKey @@@@can.hasOwnKey] to override default behavior.\n\t * By default, `canReflect.hasOwnKey` will first look for\n\t * [can-symbol/symbols/getOwnKey @@@@can.getOwnKey] on `obj`. If present, it will call `@@@@can.getOwnKey` and\n\t * test `key` against the returned Array of keys.  If absent, `Object.prototype.hasOwnKey()` is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" });\n\t *\n\t * canReflect.hasOwnKey(foo, \"bar\"); // -> true\n\t * canReflect.hasOwnKey(foo, \"each\"); // -> false\n\t * foo.each // -> function each() {...}\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @param  {String} key The key to look up on `obj`\n\t * @return {Boolean} `true` if `obj`'s key set contains `key`, `false` otherwise\n\t */\n\t\"hasOwnKey\": function(obj, key){\n\t\t// if a key or index\n\t\t// like has own property\n\t\tvar hasOwnKey = obj[canSymbol.for(\"can.hasOwnKey\")];\n\t\tif(hasOwnKey) {\n\t\t\treturn hasOwnKey.call(obj, key);\n\t\t}\n\t\tvar getOwnKeys = obj[canSymbol.for(\"can.getOwnKeys\")];\n\t\tif( getOwnKeys ) {\n\t\t\tvar found = false;\n\t\t\tshapeReflections.eachIndex(getOwnKeys.call(obj), function(objKey){\n\t\t\t\tif(objKey === key) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn found;\n\t\t}\n\t\treturn hasOwnProperty.call(obj, key);\n\t},\n\t/**\n\t * @function can-reflect.getOwnEnumerableKeys getOwnEnumerableKeys\n\t * @parent can-reflect/shape\n\t * @description Return the list of keys which can be iterated over on an object\n\t *\n\t * @signature `getOwnEnumerableKeys(obj)`\n\t *\n\t * Return all keys on `obj` which have been defined as enumerable, either from explicitly setting\n\t * `enumerable` on the property descriptor, or by using `=` to set the value of the property without\n\t * a key descriptor, but excluding properties that only exist on `obj`'s prototype chain.  The\n\t * default behavior can be overridden by implementing\n\t * [can-symbol/symbols/getOwnEnumerableKeys @@@@can.getOwnEnumerableKeys] on `obj`.  By default,\n\t * `canReflect.getOwnEnumerableKeys` will use [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] to\n\t * retrieve the set of keys and [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]\n\t * to filter for those which are enumerable.  If either symbol is absent from `obj`, `Object.keys`\n\t * is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\", [canSymbol.for(\"quux\")]: \"thud\" });\n\t * Object.defineProperty(foo, \"jeek\", {\n\t *   enumerable: true,\n\t *   value: \"plonk\"\n\t * });\n\t *\n\t * canReflect.getOwnEnumerableKeys(foo); // -> [\"bar\", \"jeek\"]\n\t * ```\n\t *\n\t * @param  {Object} obj Any Map-like object\n\t * @return {Array} the Array of all enumerable keys from the object, either using\n\t * [can-symbol/symbols/getOwnEnumerableKeys `@@@@can.getOwnEnumerableKeys`] from `obj`, or filtering\n\t * `obj`'s own keys for those which are enumerable.\n\t */\n\tgetOwnEnumerableKeys: function(obj){\n\t\t// own enumerable keys (aliased as keys)\n\t\tvar getOwnEnumerableKeys = obj[canSymbol.for(\"can.getOwnEnumerableKeys\")];\n\t\tif(getOwnEnumerableKeys) {\n\t\t\treturn getOwnEnumerableKeys.call(obj);\n\t\t}\n\t\tif( obj[canSymbol.for(\"can.getOwnKeys\")] && obj[canSymbol.for(\"can.getOwnKeyDescriptor\")] ) {\n\t\t\tvar keys = [];\n\t\t\tshapeReflections.eachIndex(shapeReflections.getOwnKeys(obj), function(key){\n\t\t\t\tvar descriptor =  shapeReflections.getOwnKeyDescriptor(obj, key);\n\t\t\t\tif(descriptor.enumerable) {\n\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\treturn keys;\n\t\t} /*else if(obj[canSymbol.iterator]){\n\t\t\tvar iter = obj[canSymbol.iterator](obj);\n\t\t\tvar index = 0;\n\t\t\tvar keys;\n\t\t\treturn {\n\t\t\t\tnext: function(){\n\t\t\t\t\tvar res = iter.next();\n\t\t\t\t\tif(index++)\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!().done) {\n\n\t\t\t\tif( callback.call(context || list, res.value, index++, list) === false ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/ else {\n\t\t\treturn Object_Keys(obj);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.getOwnKeys getOwnKeys\n\t * @parent can-reflect/shape\n\t * @description Return the list of keys on an object, whether or not they can be iterated over\n\t *\n\t * @signature `getOwnKeys(obj)`\n\t *\n\t * Return the Array of all String (not Symbol) keys from `obj`, whether they are enumerable or not.  If\n\t * [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] exists on `obj`, it is called to return\n\t * the keys; otherwise, `Object.getOwnPropertyNames()` is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\", [canSymbol.for(\"quux\")]: \"thud\" });\n\t * Object.defineProperty(foo, \"jeek\", {\n\t *   enumerable: false,\n\t *   value: \"plonk\"\n\t * });\n\t *\n\t * canReflect.getOwnKeys(foo); // -> [\"bar\", \"jeek\"]\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @return {Array} the Array of all String keys from the object.\n\t */\n\tgetOwnKeys: function(obj){\n\t\t// own enumerable&non-enumerable keys (Object.getOwnPropertyNames)\n\t\tvar getOwnKeys = obj[canSymbol.for(\"can.getOwnKeys\")];\n\t\tif(getOwnKeys) {\n\t\t\treturn getOwnKeys.call(obj);\n\t\t} else {\n\t\t\treturn Object.getOwnPropertyNames(obj);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.getOwnKeyDescriptor getOwnKeyDescriptor\n\t * @parent can-reflect/shape\n\t * @description Return a property descriptor for a named property on an object.\n\t *\n\t * @signature `getOwnKeyDescriptor(obj, key)`\n\t *\n\t *\tReturn the key descriptor for the property key `key` on the Map-like object `obj`. A key descriptor\n\t *\tis specified in ECMAScript 5 and contains keys for the property's `configurable` and `enumerable` states,\n\t *\tas well as either `value` and `writable` for value properties, or `get` and `set` for getter/setter properties.\n\t *\n\t * The default behavior can be overridden by implementing [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]\n\t * on `obj`; otherwise the default is to call `Object.getOwnKeyDescriptor()`.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * getOwnKeyDescriptor(foo, \"bar\"); // -> {configurable: true, writable: true, enumerable: true, value: \"baz\"}\n\t * ```\n\t *\n\t * @param  {Object} obj Any object with named properties\n\t * @param  {String} key The property name to look up on `obj`\n\t * @return {Object}   A key descriptor object\n\t */\n\tgetOwnKeyDescriptor: function(obj, key){\n\t\tvar getOwnKeyDescriptor = obj[canSymbol.for(\"can.getOwnKeyDescriptor\")];\n\t\tif(getOwnKeyDescriptor) {\n\t\t\treturn getOwnKeyDescriptor.call(obj, key);\n\t\t} else {\n\t\t\treturn Object.getOwnPropertyDescriptor(obj, key);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.unwrap unwrap\n\t * @parent can-reflect/shape\n\t * @description Unwraps a map-like or array-like value into an object or array.\n\t *\n\t *\n\t * @signature `unwrap(obj)`\n\t *\n\t * Recursively unwraps a map-like or list-like object.\n\t *\n\t * ```js\n\t * import canReflect from \"can-reflect\";\n\t *\n\t * var map = new DefineMap({foo: \"bar\"});\n\t * canReflect.unwrap(map) //-> {foo: \"bar\"}\n\t * ```\n\t *\n\t * `unwrap` is similar to [can-reflect.serialize] except it does not try to provide `JSON.stringify()`-safe\n\t * objects.  For example, an object with a `Date` instance property value will not be expected to\n\t * serialize the date instance:\n\t *\n\t * ```js\n\t * var date = new Date();\n\t * var map = new DefineMap({date: date});\n\t * canReflect.unwrap(map) //-> {date: date}\n\t * ```\n\t *\n\t * @param {Object} obj A map-like or array-like object.\n\t * @return {Object} Returns objects and arrays.\n\t */\n\tunwrap: makeSerializer(\"unwrap\",[canSymbol.for(\"can.unwrap\")]),\n\t/**\n\t * @function can-reflect.serialize serialize\n\t * @parent can-reflect/shape\n\t * @description Serializes an object to a value that can be passed to JSON.stringify.\n\t *\n\t *\n\t * @signature `serialize(obj)`\n\t *\n\t * Recursively serializes a map-like or list-like object.\n\t *\n\t * ```js\n\t * import canReflect from \"can-reflect\";\n\t * canReflect.serialize({foo: \"bar\"}) //-> {foo: \"bar\"}\n\t * ```\n\t *\n\t * It does this by recursively:\n\t *\n\t *  - Checking if `obj` is a primitive, if it is, returns the value.\n\t *  - If `obj` is an object:\n\t *    - calling the `@can.serialize` property on the value if it exists.\n\t *    - If the `@can.serialize` value doesn't exist, walks through every key-value\n\t *      on `obj` and copy to a new object.\n\t *\n\t * @param {Object} obj A map-like or array-like object.\n\t * @return {Object} Returns a plain object or array.\n\t */\n\tserialize: makeSerializer(\"serialize\",[canSymbol.for(\"can.serialize\"), canSymbol.for(\"can.unwrap\")]),\n\n\tassignMap: function(target, source) {\n\t\t// read each key and set it on target\n\t\tvar hasOwnKey = fastHasOwnKey(target);\n\t\tvar getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\t\tshapeReflections.eachKey(source,function(value, key){\n\t\t\t// if the target doesn't have this key or the keys are not the same\n\t\t\tif(!hasOwnKey(key) || getKeyValue.call(target, key) !==  value) {\n\t\t\t\tsetKeyValue.call(target, key, value);\n\t\t\t}\n\t\t});\n\t\treturn target;\n\t},\n\tassignList: function(target, source) {\n\t\tvar inserting = shapeReflections.toArray(source);\n\t\tgetSetReflections.splice(target, 0, inserting, inserting );\n\t\treturn target;\n\t},\n\t/**\n\t * @function can-reflect.assign assign\n\t * @parent can-reflect/shape\n\t * @description Assign one objects values to another\n\t *\n\t * @signature `.assign(target, source)`\n\t *\n\t * Copies the values (and properties if map-like) from `source` onto `target`.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {};\n\t * var source = {key : \"value\"};\n\t * var restult = canReflect.assign(target, source);\n\t * result === target //-> true\n\t * target //-> {key : \"value\"}\n\t * ```\n\t *\n\t * For Arrays, enumerated values are copied over, but the length of the array will not be\n\t * trunkated.  Use [can-reflect.update] for trunkating.\n\t *\n\t * ```js\n\t * var target = [\"a\",\"b\",\"c\"];\n\t * var source = [\"A\",\"B\"];\n\t * canReflect.assign(target, source);\n\t * target //-> [\"A\",\"B\",\"c\"]\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassign: function(target, source) {\n\t\tif(typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// copy to array and add these keys in place\n\t\t\tshapeReflections.assignList(target, source);\n\t\t} else {\n\t\t\tshapeReflections.assignMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tassignDeepMap: function(target, source) {\n\n\t\tvar hasOwnKey = fastHasOwnKey(target);\n\t\tvar getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(source, function(newVal, key){\n\t\t\tif(!hasOwnKey(key)) {\n\t\t\t\t// set no matter what\n\t\t\t\tgetSetReflections.setKeyValue(target, key, newVal);\n\t\t\t} else {\n\t\t\t\tvar curVal = getKeyValue.call(target, key);\n\n\t\t\t\t// if either was primitive, no recursive update possible\n\t\t\t\tif(newVal === curVal) {\n\t\t\t\t\t// do nothing\n\t\t\t\t} else if(typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\t\t\tsetKeyValue.call(target, key, newVal);\n\t\t\t\t} else {\n\t\t\t\t\tshapeReflections.assignDeep(curVal, newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\t\treturn target;\n\t},\n\tassignDeepList: function(target, source) {\n\t\treturn updateDeepList.call(this, target, source, true);\n\t},\n\t/**\n\t * @function can-reflect.assignDeep assignDeep\n\t * @parent can-reflect/shape\n\t * @description Assign one objects values to another, and performs the same action for all child values.\n\t *\n\t * @signature `.assignDeep(target, source)`\n\t *\n\t * Copies the values (and properties if map-like) from `source` onto `target` and repeates for all child\n\t * values.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var restult = canReflect.assignDeep(target, source);\n\t * target //->  {name: {first: \"Justin\", last: \"Meyer\"}}\n\t * ```\n\t *\n\t * An object can control the behavior of `assignDeep` using the [can-symbol/symbols/assignDeep] symbol.\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassignDeep: function(target, source){\n\t\tvar assignDeep = target[canSymbol.for(\"can.assignDeep\")];\n\t\tif(assignDeep) {\n\t\t\tassignDeep.call(target, source);\n\t\t} else if( typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// list-like\n\t\t\tshapeReflections.assignDeepList(target, source);\n\t\t} else {\n\t\t\t// map-like\n\t\t\tshapeReflections.assignDeepMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tupdateMap: function(target, source) {\n\t\tvar sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );\n\n\t\tvar sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(target, function(curVal, key){\n\t\t\tif(!sourceKeyMap.get(key)) {\n\t\t\t\tgetSetReflections.deleteKeyValue(target, key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsourceKeyMap.set(key, false);\n\t\t\tvar newVal = sourceGetKeyValue.call(source, key);\n\n\t\t\t// if either was primitive, no recursive update possible\n\t\t\tif(newVal !== curVal) {\n\t\t\t\ttargetSetKeyValue.call(target, key, newVal);\n\t\t\t}\n\t\t}, this);\n\n\t\tshapeReflections.eachIndex(sourceKeyMap.keys(), function(key){\n\t\t\tif(sourceKeyMap.get(key)) {\n\t\t\t\ttargetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );\n\t\t\t}\n\t\t});\n\n\t\treturn target;\n\t},\n\tupdateList: function(target, source) {\n\t\tvar inserting = shapeReflections.toArray(source);\n\n\t\tgetSetReflections.splice(target, 0, target, inserting );\n\t\treturn target;\n\t},\n\t/**\n\t * @function can-reflect.update update\n\t * @parent can-reflect/shape\n\t * @description Updates the values of an object match the values of an other object.\n\t *\n\t * @signature `.update(target, source)`\n\t *\n\t * Updates the values (and properties if map-like) of `target` to match the values of `source`.\n\t * Properties of `target` that are not on `source` will be removed. This does\n\t * not recursively update.  For that, use [can-reflect.updateDeep].\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}, age: 34};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var result = canReflect.update(target, source);\n\t * target //->  {name: {last: \"Meyer\"}}\n\t * ```\n\t *\n\t * With Arrays all items of the source will be replaced with the new items.\n\t *\n\t * ```js\n\t * var target = [\"a\",\"b\",\"c\"];\n\t * var source = [\"A\",\"B\"];\n\t * canReflect.update(target, source);\n\t * target //-> [\"A\",\"B\"]\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tupdate: function(target, source) {\n\t\tif(typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// copy to array and add these keys in place\n\t\t\tshapeReflections.updateList(target, source);\n\t\t} else {\n\t\t\tshapeReflections.updateMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tupdateDeepMap: function(target, source) {\n\t\tvar sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );\n\n\t\tvar sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(target, function(curVal, key){\n\n\t\t\tif(!sourceKeyMap.get(key)) {\n\t\t\t\tgetSetReflections.deleteKeyValue(target, key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsourceKeyMap.set(key, false);\n\t\t\tvar newVal = sourceGetKeyValue.call(source, key);\n\n\t\t\t// if either was primitive, no recursive update possible\n\t\t\tif(typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\t\ttargetSetKeyValue.call(target, key, newVal);\n\t\t\t} else {\n\t\t\t\tshapeReflections.updateDeep(curVal, newVal);\n\t\t\t}\n\n\t\t}, this);\n\n\t\tshapeReflections.eachIndex(sourceKeyMap.keys(), function(key){\n\t\t\tif(sourceKeyMap.get(key)) {\n\t\t\t\ttargetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );\n\t\t\t}\n\t\t});\n\t\treturn target;\n\t},\n\tupdateDeepList: function(target, source) {\n\t\treturn updateDeepList.call(this,target, source);\n\t},\n\t/**\n\t * @function can-reflect.updateDeep updateDeep\n\t * @parent can-reflect/shape\n\t * @description Makes the values of an object match the values of an other object including all children values.\n\t *\n\t * @signature `.updateDeep(target, source)`\n\t *\n\t * Updates the values (and properties if map-like) of `target` to match the values of `source`.\n\t * Removes properties from `target` that are not on `source`.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}, age: 34};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var result = canReflect.updateDeep(target, source);\n\t * target //->  {name: {last: \"Meyer\"}}\n\t * ```\n\t *\n\t * An object can control the behavior of `updateDeep` using the [can-symbol/symbols/updateDeep] symbol.\n\t *\n\t * For list-like objects, a diff and patch strategy is used.  This attempts to limit the number of changes.\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tupdateDeep: function(target, source){\n\t\tvar updateDeep = target[canSymbol.for(\"can.updateDeep\")];\n\t\tif(updateDeep) {\n\t\t\tupdateDeep.call(target, source);\n\t\t} else if( typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// list-like\n\t\t\tshapeReflections.updateDeepList(target, source);\n\t\t} else {\n\t\t\t// map-like\n\t\t\tshapeReflections.updateDeepMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\t// walks up the whole prototype chain\n\t/**\n\t * @function can-reflect.hasKey hasKey\n\t * @parent can-reflect/shape\n\t * @description Determine whether an object contains a key on itself or its prototype chain\n\t *\n\t * @signature `hasKey(obj, key)`\n\t *\n\t * Return `true` if an object's properties include the property key `key` or an object on its prototype\n\t * chain's properties include the key `key`, `false` otherwise.\n\t * An object may implement [can-symbol/symbols/hasKey @@@@can.hasKey] to override default behavior.\n\t * By default, `canReflect.hasKey` will use [can-reflect.hasOwnKey] and return true if the key is present.\n\t * If `hasOwnKey` returns false, the [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in in Operator] will be used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" });\n\t *\n\t * canReflect.in(foo, \"bar\"); // -> true\n\t * canReflect.in(foo, \"each\"); // -> true\n\t * foo.each // -> function each() {...}\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @param  {String} key The key to look up on `obj`\n\t * @return {Boolean} `true` if `obj`'s key set contains `key` or an object on its prototype chain's key set contains `key`, `false` otherwise\n\t */\n\thasKey: function(obj, key) {\n\t\tif( obj == null ) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeReflections.isPrimitive(obj)) {\n\t\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tvar proto;\n\t\t\t\tif(getPrototypeOfWorksWithPrimitives) {\n\t\t\t\t\tproto = Object.getPrototypeOf(obj);\n\t\t\t\t} else {\n\t\t\t\t\t// IE-remove-start\n\t\t\t\t\tproto = obj.__proto__; // jshint ignore:line\n\t\t\t\t\t// IE-remove-end\n\t\t\t\t}\n\t\t\t\tif(proto !== undefined) {\n\t\t\t\t\treturn key in proto;\n\t\t\t\t} else {\n\t\t\t\t\t// IE-remove-start\n\t\t\t\t\treturn obj[key] !== undefined;\n\t\t\t\t\t// IE-remove-end\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar hasKey = obj[canSymbol.for(\"can.hasKey\")];\n\t\tif(hasKey) {\n\t\t\treturn hasKey.call(obj, key);\n\t\t}\n\n\t\tvar found = shapeReflections.hasOwnKey(obj, key);\n\n\t\treturn found || key in obj;\n\t},\n\tgetAllEnumerableKeys: function(){},\n\tgetAllKeys: function(){},\n\t/**\n\t * @function can-reflect.assignSymbols assignSymbols\n\t * @parent can-reflect/shape\n\t * @description Assign well known symbols and values to an object.\n\t *\n\t * @signature `.assignSymbols(target, source)`\n\t *\n\t * Converts each property name on the `source` object to a [can-symbol.for well known symbol]\n\t * and uses that symbol to set the corresponding value on target.\n\t *\n\t * This is used to easily set symbols correctly even when symbol isn't natively supported.\n\t *\n\t * ```js\n\t * canReflect.assignSymbols(Map.prototype, {\n\t *   \"can.getKeyValue\": Map.prototype.get\n\t * })\n\t * ```\n\t *\n\t * If a `source` property name matches a symbol on `Symbol` (like `iterator` on `Symbol.iterator`),\n\t * that symbol will be used:\n\t *\n\t * ```js\n\t * canReflect.assignSymbols(ArrayLike.prototype, {\n\t *   \"iterator\": function() { ... }\n\t * })\n\t * ArrayLike.prototype[Symbol.iterator] = function(){ ... }\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s symbols and values.\n\t * @param  {Object<name,value>} source A source of symbol names and values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassignSymbols: function(target, source){\n\t\tshapeReflections.eachKey(source, function(value, key){\n\t\t\tvar symbol = typeReflections.isSymbolLike(canSymbol[key]) ? canSymbol[key] : canSymbol.for(key);\n\t\t\tgetSetReflections.setKeyValue(target, symbol, value);\n\t\t});\n\t\treturn target;\n\t},\n\tisSerialized: isSerializedHelper,\n\t/**\n\t * @function can-reflect.size size\n\t * @parent can-reflect/shape\n\t * @description Return the number of items in the collection.\n\t *\n\t * @signature `.size(target)`\n\t *\n\t * Returns the number of items contained in `target`. Target can\n\t * provide the size using the [can-symbol/symbols/size] symbol.\n\t *\n\t * If the `target` has a numeric `length` property that is greater than or equal to 0, that\n\t * `length` will be returned.\n\t *\n\t * ```js\n\t * canReflect.size([1,2,3]) //-> 3\n\t * ```\n\t *\n\t * If the `target` is [can-reflect.isListLike], the values of the list will be counted.\n\t *\n\t * If the `target` is a plain JS object, the number of enumerable properties will be returned.\n\t *\n\t * ```js\n\t * canReflect.size({foo:\"bar\"}) //-> 1\n\t * ```\n\t *\n\t * If the `target` is anything else, `undefined` is returned.\n\t *\n\t * @param  {Object} target The container object.\n\t * @return {Number} The number of values in the target.\n\t */\n\tsize: function(obj){\n\t\tif(obj == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar size = obj[sizeSymbol];\n\t\tvar count = 0;\n\t\tif(size) {\n\t\t\treturn size.call(obj);\n\t\t}\n\t\telse if(helpers.hasLength(obj)){\n\t\t\treturn obj.length;\n\t\t}\n\t\telse if(typeReflections.isListLike(obj)){\n\n\t\t\tshapeReflections.eachIndex(obj, function(){\n\t\t\t\tcount++;\n\t\t\t});\n\t\t\treturn count;\n\t\t}\n\t\telse if( obj ) {\n\t\t\treturn shapeReflections.getOwnEnumerableKeys(obj).length;\n\t\t}\n\t\telse {\n\t\t\treturn undefined;\n\t\t}\n\t},\n\t/**\n\t * @function {Function, String|Symbol, Object} can-reflect.defineInstanceKey defineInstanceKey\n\t * @parent can-reflect/shape\n\t * @description Create a key for all instances of a constructor.\n\t *\n\t * @signature `defineInstanceKey(cls, key, properties)`\n\t *\n\t * Define the property `key` on the prototype of the constructor `cls` using the symbolic\n\t * property [can-symbol/symbols/defineInstanceKey @@can.defineInstanceKey] if it exists; otherwise\n\t * use `Object.defineProperty()` to define the property.  The property definition\n\t *\n\t * @param  {Function} cls  a Constructor function\n\t * @param  {String} key     the String or Symbol key to set.\n\t * @param  {Object} properties a JavaScript property descriptor\n\t */\n\tdefineInstanceKey: function(cls, key, properties) {\n\t\tvar defineInstanceKey = cls[canSymbol.for(\"can.defineInstanceKey\")];\n\t\tif(defineInstanceKey) {\n\t\t\treturn defineInstanceKey.call(cls, key, properties);\n\t\t}\n\t\tvar proto = cls.prototype;\n\t\tdefineInstanceKey = proto[canSymbol.for(\"can.defineInstanceKey\")];\n\t\tif(defineInstanceKey) {\n\t\t\tdefineInstanceKey.call(proto, key, properties);\n\t\t} else {\n\t\t\tObject.defineProperty(\n\t\t\t\tproto,\n\t\t\t\tkey,\n\t\t\t\tshapeReflections.assign({\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: !typeReflections.isSymbolLike(key),\n\t\t\t\t\twritable: true\n\t\t\t\t}, properties)\n\t\t\t);\n\t\t}\n\t}\n};\n\nshapeReflections.isSerializable = shapeReflections.isSerialized;\nshapeReflections.keys = shapeReflections.getOwnEnumerableKeys;\nmodule.exports = shapeReflections;\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect/reflections/shape/shape.js?");

/***/ }),

/***/ "./node_modules/can-reflect/reflections/type/type.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-reflect/reflections/type/type.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/can-reflect/reflections/helpers.js\");\n\nvar plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames((function(){}).prototype);\nvar plainFunctionPrototypeProto = Object.getPrototypeOf( (function(){}).prototype );\n/**\n * @function can-reflect.isConstructorLike isConstructorLike\n * @parent can-reflect/type\n *\n * @description Test if a value looks like a constructor function.\n *\n * @signature `isConstructorLike(func)`\n *\n * Return `true` if `func` is a function and has a non-empty prototype, or implements\n *  [can-symbol/symbols/new `@@@@can.new`]; `false` otherwise.\n *\n * ```js\n * canReflect.isConstructorLike(function() {}); // -> false\n *\n * function Construct() {}\n * Construct.prototype = { foo: \"bar\" };\n * canReflect.isConstructorLike(Construct); // -> true\n *\n * canReflect.isConstructorLike({}); // -> false\n * !!canReflect.isConstructorLike({ [canSymbol.for(\"can.new\")]: function() {} }); // -> true\n * ```\n *\n * @param  {*}  func maybe a function\n * @return {Boolean} `true` if a constructor; `false` if otherwise.\n */\nfunction isConstructorLike(func){\n\t/* jshint unused: false */\n\t// if you can new it ... it's a constructor\n\tvar value = func[canSymbol.for(\"can.new\")];\n\tif(value !== undefined) {\n\t\treturn value;\n\t}\n\n\tif(typeof func !== \"function\") {\n\t\treturn false;\n\t}\n\t// If there are any properties on the prototype that don't match\n\t// what is normally there, assume it's a constructor\n\tvar prototype = func.prototype;\n\tif(!prototype) {\n\t\treturn false;\n\t}\n\t// Check if the prototype's proto doesn't point to what it normally would.\n\t// If it does, it means someone is messing with proto chains\n\tif( plainFunctionPrototypeProto !== Object.getPrototypeOf( prototype ) ) {\n\t\treturn true;\n\t}\n\n\tvar propertyNames = Object.getOwnPropertyNames(prototype);\n\tif(propertyNames.length === plainFunctionPrototypePropertyNames.length) {\n\t\tfor(var i = 0, len = propertyNames.length; i < len; i++) {\n\t\t\tif(propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\n/**\n * @function can-reflect.isFunctionLike isFunctionLike\n * @parent can-reflect/type\n * @description Test if a value looks like a function.\n * @signature `isFunctionLike(obj)`\n *\n *  Return `true` if `func` is a function, or implements\n *  [can-symbol/symbols/new `@@@@can.new`] or [can-symbol/symbols/apply `@@@@can.apply`]; `false` otherwise.\n *\n * ```js\n * canReflect.isFunctionLike(function() {}); // -> true\n * canReflect.isFunctionLike({}); // -> false\n * canReflect.isFunctionLike({ [canSymbol.for(\"can.apply\")]: function() {} }); // -> true\n * ```\n *\n * @param  {*}  obj maybe a function\n * @return {Boolean}\n */\nvar getNewOrApply = helpers.makeGetFirstSymbolValue([\"can.new\",\"can.apply\"]);\nfunction isFunctionLike(obj){\n\tvar result,\n\t\tsymbolValue = !!obj && obj[canSymbol.for(\"can.isFunctionLike\")];\n\n\tif (symbolValue !== undefined) {\n\t\treturn symbolValue;\n\t}\n\n\tresult = getNewOrApply(obj);\n\tif(result !== undefined) {\n\t\treturn !!result;\n\t}\n\n\treturn typeof obj === \"function\";\n}\n\n/**\n * @function can-reflect.isPrimitive isPrimitive\n * @parent can-reflect/type\n * @description Test if a value is a JavaScript primitive.\n * @signature `isPrimitive(obj)`\n *\n * Return `true` if `obj` is not a function nor an object via `typeof`, or is null; `false` otherwise.\n *\n * ```js\n * canReflect.isPrimitive(null); // -> true\n * canReflect.isPrimitive({}); // -> false\n * canReflect.isPrimitive(undefined); // -> true\n * canReflect.isPrimitive(1); // -> true\n * canReflect.isPrimitive([]); // -> false\n * canReflect.isPrimitive(function() {}); // -> false\n * canReflect.isPrimitive(\"foo\"); // -> true\n *\n * ```\n *\n * @param  {*}  obj maybe a primitive value\n * @return {Boolean}\n */\nfunction isPrimitive(obj){\n\tvar type = typeof obj;\n\tif(obj == null || (type !== \"function\" && type !== \"object\") ) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvar coreHasOwn = Object.prototype.hasOwnProperty;\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(obj) {\n\t// Must be an Object.\n\t// Because of IE, we also have to check the presence of the constructor property.\n\t// Make sure that DOM nodes and window objects don't pass through, as well\n\tif (!obj || typeof obj !== 'object' ) {\n\t\treturn false;\n\t}\n\tvar proto = Object.getPrototypeOf(obj);\n\tif(proto === Object.prototype || proto === null) {\n\t\treturn true;\n\t}\n\t// partially inspired by lodash: https://github.com/lodash/lodash\n\tvar Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;\n\treturn typeof Constructor === 'function' && Constructor instanceof Constructor &&\n    \tfuncToString.call(Constructor) === objectCtorString;\n}\n\n/**\n * @function can-reflect.isBuiltIn isBuiltIn\n * @parent can-reflect/type\n * @description Test if a value is a JavaScript built-in type.\n * @signature `isBuiltIn(obj)`\n *\n * Return `true` if `obj` is some type of JavaScript native built-in; `false` otherwise.\n *\n * ```js\n * canReflect.isBuiltIn(null); // -> true\n * canReflect.isBuiltIn({}); // -> true\n * canReflect.isBuiltIn(1); // -> true\n * canReflect.isBuiltIn([]); // -> true\n * canReflect.isBuiltIn(function() {}); // -> true\n * canReflect.isBuiltIn(\"foo\"); // -> true\n * canReflect.isBuiltIn(new Date()); // -> true\n * canReflect.isBuiltIn(/[foo].[bar]/); // -> true\n * canReflect.isBuiltIn(new DefineMap); // -> false\n *\n * ```\n *\n * Not supported in browsers that have implementations of Map/Set where\n * `toString` is not properly implemented to return `[object Map]`/`[object Set]`.\n *\n * @param  {*}  obj maybe a built-in value\n * @return {Boolean}\n */\nfunction isBuiltIn(obj) {\n\n\t// If primitive, array, or POJO return true. Also check if\n\t// it is not a POJO but is some type like [object Date] or\n\t// [object Regex] and return true.\n\tif (isPrimitive(obj) ||\n\t\tArray.isArray(obj) ||\n\t\tisPlainObject(obj) ||\n\t\t(Object.prototype.toString.call(obj) !== '[object Object]' &&\n\t\t\tObject.prototype.toString.call(obj).indexOf('[object ') !== -1)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\n/**\n * @function can-reflect.isValueLike isValueLike\n * @parent can-reflect/type\n * @description Test if a value represents a single value (as opposed to several values).\n *\n * @signature `isValueLike(obj)`\n *\n * Return `true` if `obj` is a primitive or implements [can-symbol/symbols/getValue `@@can.getValue`],\n * `false` otherwise.\n *\n * ```js\n * canReflect.isValueLike(null); // -> true\n * canReflect.isValueLike({}); // -> false\n * canReflect.isValueLike(function() {}); // -> false\n * canReflect.isValueLike({ [canSymbol.for(\"can.isValueLike\")]: true}); // -> true\n * canReflect.isValueLike({ [canSymbol.for(\"can.getValue\")]: function() {} }); // -> true\n * canReflect.isValueLike(canCompute()); // -> true\n * canReflect.isValueLike(new DefineMap()); // -> false\n *\n * ```\n *\n * @param  {*}  obj maybe a primitive or an object that yields a value\n * @return {Boolean}\n */\nfunction isValueLike(obj) {\n\tvar symbolValue;\n\tif(isPrimitive(obj)) {\n\t\treturn true;\n\t}\n\tsymbolValue = obj[canSymbol.for(\"can.isValueLike\")];\n\tif( typeof symbolValue !== \"undefined\") {\n\t\treturn symbolValue;\n\t}\n\tvar value = obj[canSymbol.for(\"can.getValue\")];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n}\n\n/**\n * @function can-reflect.isMapLike isMapLike\n * @parent can-reflect/type\n *\n * @description Test if a value represents multiple values.\n *\n * @signature `isMapLike(obj)`\n *\n * Return `true` if `obj` is _not_ a primitive, does _not_ have a falsy value for\n * [can-symbol/symbols/isMapLike `@@@@can.isMapLike`], or alternately implements\n * [can-symbol/symbols/getKeyValue `@@@@can.getKeyValue`]; `false` otherwise.\n *\n * ```js\n * canReflect.isMapLike(null); // -> false\n * canReflect.isMapLike(1); // -> false\n * canReflect.isMapLike(\"foo\"); // -> false\n * canReflect.isMapLike({}); // -> true\n * canReflect.isMapLike(function() {}); // -> true\n * canReflect.isMapLike([]); // -> false\n * canReflect.isMapLike({ [canSymbol.for(\"can.isMapLike\")]: false }); // -> false\n * canReflect.isMapLike({ [canSymbol.for(\"can.getKeyValue\")]: null }); // -> false\n * canReflect.isMapLike(canCompute()); // -> false\n * canReflect.isMapLike(new DefineMap()); // -> true\n *\n * ```\n *\n * @param  {*}  obj maybe a Map-like\n * @return {Boolean}\n */\nfunction isMapLike(obj) {\n\tif(isPrimitive(obj)) {\n\t\treturn false;\n\t}\n\tvar isMapLike = obj[canSymbol.for(\"can.isMapLike\")];\n\tif(typeof isMapLike !== \"undefined\") {\n\t\treturn !!isMapLike;\n\t}\n\tvar value = obj[canSymbol.for(\"can.getKeyValue\")];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n\t// everything else in JS is MapLike\n\treturn true;\n}\n\n/**\n * @function can-reflect.isObservableLike isObservableLike\n * @parent can-reflect/type\n * @description Test if a value (or its keys) can be observed for changes.\n *\n * @signature `isObservableLike(obj)`\n *\n * Return  `true` if `obj` is _not_ a primitive and implements any of\n * [can-symbol/symbols/onValue `@@@@can.onValue`], [can-symbol/symbols/onKeyValue `@@@@can.onKeyValue`], or\n * [can-symbol/symbols/onPatches `@@@@can.onKeys`]; `false` otherwise.\n *\n * ```js\n * canReflect.isObservableLike(null); // -> false\n * canReflect.isObservableLike({}); // -> false\n * canReflect.isObservableLike([]); // -> false\n * canReflect.isObservableLike(function() {}); // -> false\n * canReflect.isObservableLike({ [canSymbol.for(\"can.onValue\")]: function() {} }); // -> true\n * canReflect.isObservableLike({ [canSymbol.for(\"can.onKeyValue\")]: function() {} }); // -> true\n * canReflect.isObservableLike(canCompute())); // -> true\n * canReflect.isObservableLike(new DefineMap())); // -> true\n * ```\n *\n * @param  {*}  obj maybe an observable\n * @return {Boolean}\n */\n\n// Specially optimized\nvar onValueSymbol = canSymbol.for(\"can.onValue\"),\n\tonKeyValueSymbol = canSymbol.for(\"can.onKeyValue\"),\n\tonPatchesSymbol = canSymbol.for(\"can.onPatches\");\nfunction isObservableLike( obj ) {\n\tif(isPrimitive(obj)) {\n\t\treturn false;\n\t}\n\treturn Boolean(obj[onValueSymbol] || obj[onKeyValueSymbol] || obj[onPatchesSymbol]);\n}\n\n/**\n * @function can-reflect.isListLike isListLike\n * @parent can-reflect/type\n *\n * @description Test if a value looks like a constructor function.\n *\n * @signature `isListLike(list)`\n *\n * Return `true` if `list` is a `String`, <br>OR `list` is _not_ a primitive and implements `@@@@iterator`,\n * <br>OR `list` is _not_ a primitive and returns `true` for `Array.isArray()`, <br>OR `list` is _not_ a primitive and has a\n * numerical length and is either empty (`length === 0`) or has a last element at index `length - 1`; <br>`false` otherwise\n *\n * ```js\n * canReflect.isListLike(null); // -> false\n * canReflect.isListLike({}); // -> false\n * canReflect.isListLike([]); // -> true\n * canReflect.isListLike(\"foo\"); // -> true\n * canReflect.isListLike(1); // -> false\n * canReflect.isListLike({ [canSymbol.for(\"can.isListLike\")]: true }); // -> true\n * canReflect.isListLike({ [canSymbol.iterator]: function() {} }); // -> true\n * canReflect.isListLike({ length: 0 }); // -> true\n * canReflect.isListLike({ length: 3 }); // -> false\n * canReflect.isListLike({ length: 3, \"2\": true }); // -> true\n * canReflect.isListLike(new DefineMap()); // -> false\n * canReflect.isListLike(new DefineList()); // -> true\n * ```\n *\n * @param  {*}  list maybe a List-like\n * @return {Boolean}\n */\nfunction isListLike( list ) {\n\tvar symbolValue,\n\t\ttype = typeof list;\n\tif(type === \"string\") {\n\t\treturn true;\n\t}\n\tif( isPrimitive(list) ) {\n\t\treturn false;\n\t}\n\tsymbolValue = list[canSymbol.for(\"can.isListLike\")];\n\tif( typeof symbolValue !== \"undefined\") {\n\t\treturn symbolValue;\n\t}\n\tvar value = list[canSymbol.iterator];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n\tif(Array.isArray(list)) {\n\t\treturn true;\n\t}\n\treturn helpers.hasLength(list);\n}\n\n/**\n * @function can-reflect.isSymbolLike isSymbolLike\n * @parent can-reflect/type\n *\n * @description Test if a value is a symbol or a [can-symbol].\n *\n * @signature `isSymbolLike(symbol)`\n *\n * Return `true` if `symbol` is a native Symbol, or evaluates to a String with a prefix\n * equal to that of CanJS's symbol polyfill; `false` otherwise.\n *\n * ```js\n * /* ES6 *\\/ canReflect.isSymbolLike(Symbol.iterator); // -> true\n * canReflect.isSymbolLike(canSymbol.for(\"foo\")); // -> true\n * canReflect.isSymbolLike(\"@@symbol.can.isSymbol\"); // -> true (due to polyfill for non-ES6)\n * canReflect.isSymbolLike(\"foo\"); // -> false\n * canReflect.isSymbolLike(null); // -> false\n * canReflect.isSymbolLike(1); // -> false\n * canReflect.isSymbolLike({}); // -> false\n * canReflect.isSymbolLike({ toString: function() { return \"@@symbol.can.isSymbol\"; } }); // -> true\n * ```\n *\n * @param  {*}  symbol maybe a symbol\n * @return {Boolean}\n */\n\nvar supportsNativeSymbols = (function() {\n\tvar symbolExists = typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\";\n\n\tif (!symbolExists) {\n\t\treturn false;\n\t}\n\n\tvar symbol = Symbol(\"a symbol for testing symbols\");\n\treturn typeof symbol === \"symbol\";\n}());\n\nvar isSymbolLike;\nif(supportsNativeSymbols) {\n\tisSymbolLike = function(symbol) {\n\t\treturn typeof symbol === \"symbol\";\n\t};\n} else {\n\tvar symbolStart = \"@@symbol\";\n\tisSymbolLike = function(symbol) {\n\t\tif(typeof symbol === \"object\" && !Array.isArray(symbol)){\n\t\t\treturn symbol.toString().substr(0, symbolStart.length) === symbolStart;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n}\n\nmodule.exports = {\n\tisConstructorLike: isConstructorLike,\n\tisFunctionLike: isFunctionLike,\n\tisListLike: isListLike,\n\tisMapLike: isMapLike,\n\tisObservableLike: isObservableLike,\n\tisPrimitive: isPrimitive,\n\tisBuiltIn: isBuiltIn,\n\tisValueLike: isValueLike,\n\tisSymbolLike: isSymbolLike,\n\t/**\n\t * @function can-reflect.isMoreListLikeThanMapLike isMoreListLikeThanMapLike\n\t * @parent can-reflect/type\n\t *\n\t * @description Test if a value should be treated as a list instead of a map.\n\t *\n\t * @signature `isMoreListLikeThanMapLike(obj)`\n\t *\n\t * Return  `true` if `obj` is an Array, declares itself to be more ListLike with\n\t * `@@@@can.isMoreListLikeThanMapLike`, or self-reports as ListLike but not as MapLike; `false` otherwise.\n\t *\n\t * ```js\n\t * canReflect.isMoreListLikeThanMapLike([]); // -> true\n\t * canReflect.isMoreListLikeThanMapLike(null); // -> false\n\t * canReflect.isMoreListLikeThanMapLike({}); // -> false\n\t * canReflect.isMoreListLikeThanMapLike(new DefineList()); // -> true\n\t * canReflect.isMoreListLikeThanMapLike(new DefineMap()); // -> false\n\t * canReflect.isMoreListLikeThanMapLike(function() {}); // -> false\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test for ListLike against MapLike traits.\n\t * @return {Boolean}\n\t */\n\tisMoreListLikeThanMapLike: function(obj){\n\t\tif(Array.isArray(obj)) {\n\t\t\treturn true;\n\t\t}\n\t\tif(obj instanceof Array) {\n\t\t\treturn true;\n\t\t}\n\t\tif( obj == null ) {\n\t\t\treturn false;\n\t\t}\n\t\tvar value = obj[canSymbol.for(\"can.isMoreListLikeThanMapLike\")];\n\t\tif(value !== undefined) {\n\t\t\treturn value;\n\t\t}\n\t\tvar isListLike = this.isListLike(obj),\n\t\t\tisMapLike = this.isMapLike(obj);\n\t\tif(isListLike && !isMapLike) {\n\t\t\treturn true;\n\t\t} else if(!isListLike && isMapLike) {\n\t\t\treturn false;\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.isIteratorLike isIteratorLike\n\t * @parent can-reflect/type\n\t * @description Test if a value looks like an iterator.\n\t * @signature `isIteratorLike(obj)`\n\t *\n\t * Return `true` if `obj` has a key `\"next\"` pointing to a zero-argument function; `false` otherwise\n\t *\n\t * ```js\n\t * canReflect.isIteratorLike([][Symbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(new DefineList()[canSymbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(new DefineMap()[canSymbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(null); // -> false\n\t * canReflect.isIteratorLike({ next: function() {} }); // -> true\n\t * canReflect.isIteratorLike({ next: function(foo) {} }); // -> false (iterator nexts do not take arguments)\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test for Iterator traits\n\t * @return {Boolean}\n\t */\n\tisIteratorLike: function(obj){\n\t\treturn obj &&\n\t\t\ttypeof obj === \"object\" &&\n\t\t\ttypeof obj.next === \"function\" &&\n\t\t\tobj.next.length === 0;\n\t},\n\t/**\n\t * @function can-reflect.isPromise isPromise\n\t * @parent can-reflect/type\n\t * @description Test if a value is a promise.\n\t *\n\t * @signature `isPromise(obj)`\n\t *\n\t * Return `true` if `obj` is an instance of promise or `.toString` returns `\"[object Promise]\"`.\n\t *\n\t * ```js\n\t * canReflect.isPromise(Promise.resolve()); // -> true\n\t * ```\n\t *\n\t * @param  {*}  obj the object to test for Promise traits.\n\t * @return {Boolean}\n\t */\n\tisPromise: function(obj){\n\t\treturn (obj instanceof Promise || (Object.prototype.toString.call(obj) === '[object Promise]'));\n\t},\n\t/**\n\t * @function can-reflect.isPlainObject isPlainObject\n\t * @parent can-reflect/type\n\t * @description Test if a value is an object created with `{}` or `new Object()`.\n\t *\n\t * @signature `isPlainObject(obj)`\n\t *\n\t * Attempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:\n\t *\n\t * 1. Objects with prototypes (created using the `new` keyword).\n\t * 2. Booleans.\n\t * 3. Numbers.\n\t * 4. NaN.\n\t *\n\t * ```js\n\t * var isPlainObject = require(\"can-reflect\").isPlainObject;\n\t *\n\t * // Created with {}\n\t * console.log(isPlainObject({})); // -> true\n\t *\n\t * // new Object\n\t * console.log(isPlainObject(new Object())); // -> true\n\t *\n\t * // Custom object\n\t * var Ctr = function(){};\n\t * var obj = new Ctr();\n\t *\n\t * console.log(isPlainObject(obj)); // -> false\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test.\n\t * @return {Boolean}\n\t */\n\tisPlainObject: isPlainObject\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect/reflections/type/type.js?");

/***/ }),

/***/ "./node_modules/can-reflect/types/map.js":
/*!***********************************************!*\
  !*** ./node_modules/can-reflect/types/map.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar shape = __webpack_require__(/*! ../reflections/shape/shape */ \"./node_modules/can-reflect/reflections/shape/shape.js\");\nvar CanSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nfunction keysPolyfill() {\n  var keys = [];\n  var currentIndex = 0;\n\n  this.forEach(function(val, key) { // jshint ignore:line\n    keys.push(key);\n  });\n\n  return {\n    next: function() {\n      return {\n        value: keys[currentIndex],\n        done: (currentIndex++ === keys.length)\n      };\n    }\n  };\n}\n\nif (typeof Map !== \"undefined\") {\n  shape.assignSymbols(Map.prototype, {\n    \"can.getOwnEnumerableKeys\": Map.prototype.keys,\n    \"can.setKeyValue\": Map.prototype.set,\n    \"can.getKeyValue\": Map.prototype.get,\n    \"can.deleteKeyValue\": Map.prototype[\"delete\"],\n    \"can.hasOwnKey\": Map.prototype.has\n  });\n\n  if (typeof Map.prototype.keys !== \"function\") {\n    Map.prototype.keys = Map.prototype[CanSymbol.for(\"can.getOwnEnumerableKeys\")] = keysPolyfill;\n  }\n}\n\nif (typeof WeakMap !== \"undefined\") {\n  shape.assignSymbols(WeakMap.prototype, {\n    \"can.getOwnEnumerableKeys\": function() {\n      throw new Error(\"can-reflect: WeakMaps do not have enumerable keys.\");\n    },\n    \"can.setKeyValue\": WeakMap.prototype.set,\n    \"can.getKeyValue\": WeakMap.prototype.get,\n    \"can.deleteKeyValue\": WeakMap.prototype[\"delete\"],\n    \"can.hasOwnKey\": WeakMap.prototype.has\n  });\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect/types/map.js?");

/***/ }),

/***/ "./node_modules/can-reflect/types/set.js":
/*!***********************************************!*\
  !*** ./node_modules/can-reflect/types/set.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar shape = __webpack_require__(/*! ../reflections/shape/shape */ \"./node_modules/can-reflect/reflections/shape/shape.js\");\nvar CanSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nif (typeof Set !== \"undefined\") {\n  shape.assignSymbols(Set.prototype, {\n    \"can.isMoreListLikeThanMapLike\": true,\n    \"can.updateValues\": function(index, removing, adding) {\n      if (removing !== adding) {\n        shape.each(\n          removing,\n          function(value) {\n            this.delete(value);\n          },\n          this\n        );\n      }\n      shape.each(\n        adding,\n        function(value) {\n          this.add(value);\n        },\n        this\n      );\n    },\n    \"can.size\": function() {\n      return this.size;\n    }\n  });\n\n  // IE11 doesn't support Set.prototype[@@iterator]\n  if (typeof Set.prototype[CanSymbol.iterator] !== \"function\") {\n\t  Set.prototype[CanSymbol.iterator] = function() {\n\t\t  var arr = [];\n\t\t  var currentIndex = 0;\n\n\t\t  this.forEach(function(val) {\n\t\t\t  arr.push(val);\n\t\t  });\n\n\t\t  return {\n\t\t\t  next: function() {\n\t\t\t\t  return {\n\t\t\t\t\t  value: arr[currentIndex],\n\t\t\t\t\t  done: (currentIndex++ === arr.length)\n\t\t\t\t  };\n\t\t\t  }\n\t\t  };\n\t  };\n  }\n}\nif (typeof WeakSet !== \"undefined\") {\n  shape.assignSymbols(WeakSet.prototype, {\n    \"can.isListLike\": true,\n    \"can.isMoreListLikeThanMapLike\": true,\n    \"can.updateValues\": function(index, removing, adding) {\n      if (removing !== adding) {\n        shape.each(\n          removing,\n          function(value) {\n            this.delete(value);\n          },\n          this\n        );\n      }\n      shape.each(\n        adding,\n        function(value) {\n          this.add(value);\n        },\n        this\n      );\n    },\n    \"can.size\": function() {\n      throw new Error(\"can-reflect: WeakSets do not have enumerable keys.\");\n    }\n  });\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-reflect/types/set.js?");

/***/ }),

/***/ "./node_modules/can-rest-model/can-rest-model.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-rest-model/can-rest-model.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var constructor = __webpack_require__(/*! can-connect/constructor/constructor */ \"./node_modules/can-connect/constructor/constructor.js\");\nvar canMap = __webpack_require__(/*! can-connect/can/map/map */ \"./node_modules/can-connect/can/map/map.js\");\nvar dataParse = __webpack_require__(/*! can-connect/data/parse/parse */ \"./node_modules/can-connect/data/parse/parse.js\");\nvar dataUrl = __webpack_require__(/*! can-connect/data/url/url */ \"./node_modules/can-connect/data/url/url.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar ObservableArray = __webpack_require__(/*! can-observable-array */ \"./node_modules/can-observable-array/dist/can-observable-array.js\");\nvar ObservableObject = __webpack_require__(/*! can-observable-object */ \"./node_modules/can-observable-object/dist/can-observable-object.js\");\nvar base = __webpack_require__(/*! can-connect/base/base */ \"./node_modules/can-connect/base/base.js\");\nvar type = __webpack_require__(/*! can-type */ \"./node_modules/can-type/can-type.js\");\n\nfunction restModel(optionsOrUrl) {\n\n\t// If optionsOrUrl is a string, make options = {url: optionsOrUrl}\n\tvar options = (typeof optionsOrUrl === \"string\") ? {url: optionsOrUrl} : optionsOrUrl;\n\n\t// If options.ObjectType or .ArrayType arenâ€™t provided, define them\n\tif (typeof options.ObjectType === \"undefined\") {\n\t\toptions.ObjectType = class DefaultObjectType extends ObservableObject {};\n\t}\n\tif (typeof options.ArrayType === \"undefined\") {\n\t\toptions.ArrayType = class DefaultArrayType extends ObservableArray {\n\t\t\tstatic get items() {\n\t\t\t\treturn type.convert(options.ObjectType);\n\t\t\t}\n\t\t};\n\t}\n\n\tvar connection = [base,dataUrl, dataParse, constructor, canMap].reduce(function(prev, behavior){\n\t\treturn behavior(prev);\n\t}, options);\n\tconnection.init();\n\treturn connection;\n}\n\nmodule.exports = namespace.restModel = restModel;\n\n\n//# sourceURL=webpack:///./node_modules/can-rest-model/can-rest-model.js?");

/***/ }),

/***/ "./node_modules/can-route-hash/can-route-hash.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-route-hash/can-route-hash.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Regular expression for identifying &amp;key=value lists.\nvar paramsMatcher = /^(?:&[^=]+=[^&]*)+/;\n\nvar LOCATION = __webpack_require__(/*! can-globals/location/location */ \"./node_modules/can-globals/location/location.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"./node_modules/can-key-tree/can-key-tree.js\");\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\n\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"./node_modules/can-dom-events/can-dom-events.js\");\n\nfunction getHash(){\n    var loc = LOCATION();\n    return loc.href.split(/#!?/)[1] || \"\";\n}\n\nfunction HashchangeObservable() {\n    var dispatchHandlers =  this.dispatchHandlers.bind(this);\n    var self = this;\n\t\tthis._value = \"\";\n    this.handlers = new KeyTree([Object,Array],{\n        onFirst: function(){\n            self._value = getHash();\n            domEvents.addEventListener(window, 'hashchange', dispatchHandlers);\n        },\n        onEmpty: function(){\n            domEvents.removeEventListener(window, 'hashchange', dispatchHandlers);\n        }\n    });\n}\nHashchangeObservable.prototype = Object.create(SimpleObservable.prototype);\nHashchangeObservable.constructor = HashchangeObservable;\ncanReflect.assign(HashchangeObservable.prototype,{\n    // STUFF NEEDED FOR can-route integration\n    paramsMatcher: paramsMatcher,\n    querySeparator: \"&\",\n    // don't greedily match slashes in routing rules\n    matchSlashes: false,\n    root: \"#!\",\n    dispatchHandlers: function() {\n        var old = this._value;\n        this._value = getHash();\n        if(old !== this._value) {\n            queues.enqueueByQueue(this.handlers.getNode([]), this, [this._value, old]\n                //!steal-remove-start\n                /* jshint laxcomma: true */\n                , null\n                , [ canReflect.getName(this), \"changed to\", this._value, \"from\", old ]\n                /* jshint laxcomma: false */\n                //!steal-remove-end\n            );\n        }\n    },\n    get: function(){\n        ObservationRecorder.add(this);\n        return getHash();\n    },\n    set: function(path){\n        var loc = LOCATION();\n        if(!path && !loc.hash) {\n\n        } else if(loc.hash !== \"#\" + path) {\n            loc.hash = \"!\" + path;\n        }\n        return path;\n    }\n});\n\nObject.defineProperty(HashchangeObservable.prototype, \"value\", {\n\tget: function(){\n\t\treturn canReflect.getValue(this);\n\t},\n\tset: function(value){\n\t\tcanReflect.setValue(this, value);\n\t}\n});\n\ncanReflect.assignSymbols(HashchangeObservable.prototype,{\n\t\"can.getValue\": HashchangeObservable.prototype.get,\n\t\"can.setValue\": HashchangeObservable.prototype.set,\n\t\"can.onValue\": HashchangeObservable.prototype.on,\n\t\"can.offValue\": HashchangeObservable.prototype.off,\n\t\"can.isMapLike\": false,\n\t\"can.valueHasDependencies\": function(){\n\t\treturn true;\n\t},\n\t//!steal-remove-start\n\t\"can.getName\": function() {\n\t\treturn \"HashchangeObservable<\" + this._value + \">\";\n\t},\n\t//!steal-remove-end\n});\n\nmodule.exports = HashchangeObservable;\n\n\n//# sourceURL=webpack:///./node_modules/can-route-hash/can-route-hash.js?");

/***/ }),

/***/ "./node_modules/can-route-mock/can-route-mock.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-route-mock/can-route-mock.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nfunction MockRoute(){\n    this.routeValue = new SimpleObservable(\"\");\n}\ncanReflect.assignMap(MockRoute.prototype,{\n    paramsMatcher: /^(?:&[^=]+=[^&]*)+/,\n    querySeparator: \"&\",\n    // don't greedily match slashes in routing rules\n    matchSlashes: false,\n    root: \"#!\",\n    get: function(){\n        return this.value;\n    },\n    set: function(newVal){\n        return this.value = newVal;\n    },\n    on: function(handler){\n        canReflect.onValue(this, handler);\n    },\n    off: function(handler){\n        canReflect.offValue(this, handler);\n    }\n});\n\nObject.defineProperty(MockRoute.prototype,\"value\",{\n    get: function(){\n        return this.routeValue.get().split(/#!?/)[1] || \"\";\n    },\n    set: function(path){\n        if(path[0] !== \"#\") {\n\t\t\tthis.routeValue.set(\"#\"+(path || \"\"));\n\t\t} else {\n\t\t\tthis.routeValue.set(path || \"\");\n\t\t}\n\t\treturn path;\n    }\n});\n\ncanReflect.assignSymbols(MockRoute.prototype,{\n    \"can.onValue\": function(handler){\n        this.routeValue.on(handler);\n    },\n    \"can.offValue\": function(handler) {\n        this.routeValue.off(handler);\n    },\n    // Gets the part of the url we are determinging the route from.\n    // For hashbased routing, it's everything after the #, for\n    // pushState it's configurable\n    \"can.getValue\": function() {\n        return this.value;\n    },\n    // gets called with the serializedcanRoute data after a route has changed\n    // returns what the url has been updated to (for matching purposes)\n    \"can.setValue\": function(path){\n\t\tthis.value = path;\n    }\n});\n\n\nmodule.exports = MockRoute;\n\n\n//# sourceURL=webpack:///./node_modules/can-route-mock/can-route-mock.js?");

/***/ }),

/***/ "./node_modules/can-route-pushstate/can-route-pushstate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-route-pushstate/can-route-pushstate.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// # can-route-pushstate.js\n\n// Plugin for `route` which uses browser `history.pushState` support\n// to update window's pathname in addition to `hash`.\n\n// On a high-level, `can-route-pushstate` creates an observable type, \n// `PushstateObservable`, that changes when `history.pushState` is called.\n// It does this by:\n//  - Intercepting `click` events on anchor elements ('<a>') when the\n//    `.href` matches a routing rule.\n//  - Decorating `replaceState` and `pushState` to dispatch observable\n//    event handlers when called.\n//  - Listen to `popstate` events and dispatch obserevable event handlers.\n\n// `PushstateObservable` inherits from `SimpleObservable`, most of\n// `PushstateObservable`'s \"observable\" logic comes from `SimpleObservable`.\n\n/*jshint maxdepth:6, scripturl:true*/\n\nvar route = __webpack_require__(/*! can-route */ \"./node_modules/can-route/can-route.js\");\nvar bindingProxy = __webpack_require__(/*! can-route/src/binding-proxy */ \"./node_modules/can-route/src/binding-proxy.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar isNode = __webpack_require__(/*! can-globals/is-node/is-node */ \"./node_modules/can-globals/is-node/is-node.js\");\nvar LOCATION = __webpack_require__(/*! can-globals/location/location */ \"./node_modules/can-globals/location/location.js\");\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\nvar getGlobal = __webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\n\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"./node_modules/can-dom-events/can-dom-events.js\");\n\nvar diffObject = __webpack_require__(/*! can-diff/map/map */ \"./node_modules/can-diff/map/map.js\");\n\n// ## methodsToOverwrite\n// Method names on `history` that will be overwritten\n// during teardown these are reset to their original functions.\nvar methodsToOverwrite = [\"pushState\", \"replaceState\"],\n\t// This symbol is used in dispatchHandlers.\n\tdispatchSymbol = canSymbol.for(\"can.dispatch\");\n\n// ## Helpers\n// The following are helper functions useful to `can-route-pushstate`'s main methods.\n\n// ### cleanRoot\n// Start of `location.pathname` is the root. \n// Returns the root minus the domain.\nfunction cleanRoot() {\n\tvar location = LOCATION(),\n\t\tdomain = location.protocol + \"//\" + location.host,\n\t\t// pulls root from route.urlData\n\t\troot = bindingProxy.call(\"root\"),\n\t\tindex = root.indexOf(domain);\n\n\tif (index === 0) {\n\t\treturn root.substr(domain.length);\n\t}\n\treturn root;\n}\n\n// ### getCurrentUrl\n// Gets the current url after the root.\n// `root` is defined in the PushstateObservable constructor.\nfunction getCurrentUrl() {\n\tvar root = cleanRoot(),\n\t\tlocation = LOCATION(),\n\t\tloc = (location.pathname + location.search),\n\t\tindex = loc.indexOf(root);\n\n\treturn loc.substr(index + root.length);\n}\n\n// ## PushstateObservable\nfunction PushstateObservable() {\n\t// Keys passed into `replaceStateOnce` will be stored in `replaceStateOnceKeys`.\n\tthis.replaceStateOnceKeys = [];\n\t// Keys passed into `replaceStateOn` will be stored in `replaceStateKeys`.\n\tthis.replaceStateKeys = [];\n\tthis.dispatchHandlers = this.dispatchHandlers.bind(this);\n\tthis.anchorClickHandler = function(event) {\n\t\tvar shouldCallPushState = PushstateObservable.prototype.shouldCallPushState.call(this, this, event);\n\t\tif (shouldCallPushState) {\n\t\t\tPushstateObservable.prototype.anchorClickHandler.call(this, this, event);\n\t\t}\n\t};\n\n\t// ### `keepHash`\n\t// Currently is neither a feature that's documented,\n\t// nor is it toggled. [Issue #133](https://github.com/canjs/can-route-pushstate/issues/133)\n\t// is the discourse on it's removal.\n\tthis.keepHash = true;\n}\n\nPushstateObservable.prototype = Object.create(SimpleObservable.prototype);\nPushstateObservable.constructor = PushstateObservable;\ncanReflect.assign(PushstateObservable.prototype, {\n\n\t// ### root\n\t// Start of `location.pathname` is the root.\n\t// (Can be configured via `route.urlData.root`)\n\t// The default is `\"#!\"` set in can-route-hash.\n\troot: \"/\",\n\n\t// ### matchSlashes\n\t// The default is `false` set in can-route-hash.\n\t// Don't greedily match slashes in routing rules.\n\tmatchSlashes: false,\n\n\t// ### paramsMatcher\n\t// Matches things like:\n\t//  - ?foo=bar\n\t//  - ?foo=bar&framework=canjs\n\t//  - ?foo=&bar=\n\tparamsMatcher: /^\\?(?:[^=]+=[^&]*&)*[^=]+=[^&]*/,\n\n\t// ### querySeparator\n\t// Used in `can-route` for building regular expressions to match routes, or\n\t// return url substrings of routes.\n\tquerySeparator: \"?\",\n\n\t// ### dispatchHandlers\n\t// Updates `this._value` to the current url and \n\t// dispatches event handlers that are on the object.\n\t// `dispatchHandlers` is called if `pushState` or `replaceState`\n\t// are called, it is also an event handler on `'popstate'`.\n\tdispatchHandlers: function() {\n\t\tvar old = this._value;\n\t\tthis._value = getCurrentUrl();\n\n\t\tif (old !== this._value) {\n\t\t\t// PushstateObservable inherits from `SimpleObservable` which\n\t\t\t// is using the `can-event-queue/value/value` mixin, and is called\n\t\t\t// using the `can.dispatch` symbol.\n\t\t\tthis[dispatchSymbol](this._value, old);\n\t\t}\n\t},\n\n\t// ### shouldCallPushState\n\t// Checks if a route is matched, if one is, returns true\n\tshouldCallPushState: function(node, event) {\n\t\tif (!(event.isDefaultPrevented ? event.isDefaultPrevented() : event.defaultPrevented === true)) {\n\t\t\t// If href has some JavaScript in it, let it run.\n\t\t\tif (node.href === \"javascript://\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Do not pushstate if target is for blank window.\n\t\t\tif (node.target === \"_blank\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Do not pushstate if meta key was pressed, mimicking standard browser behavior.\n\t\t\tif (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// linksHost is a Fix for IE showing blank host, but blank host means current host.\n\t\t\tvar linksHost = node.host || window.location.host;\n\n\t\t\t// If link is within the same domain and descendant of `root`.\n\t\t\tif (window.location.host === linksHost) {\n\t\t\t\tvar root = cleanRoot(),\n\t\t\t\t\tpathname,\n\t\t\t\t\thref,\n\t\t\t\t\tnodePathWithSearch;\n\n\t\t\t\tif (node instanceof HTMLAnchorElement) {\n\t\t\t\t\tpathname = node.pathname;\n\t\t\t\t\thref = node.href;\n\t\t\t\t\tnodePathWithSearch = pathname + node.search;\n\t\t\t\t} else if (node.namespaceURI === \"http://www.w3.org/1999/xlink\") {\n\t\t\t\t\tpathname = href = node.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\");\n\t\t\t\t\tnodePathWithSearch = href;\n\t\t\t\t}\n\n\t\t\t\t// If the link is within the `root`.\n\t\t\t\tif (pathname !== undefined && pathname.indexOf(root) === 0) {\n\t\t\t\t\tvar url = nodePathWithSearch.substr(root.length);\n\n\t\t\t\t\t// If a matching route exists.\n\t\t\t\t\tif (route.rule(url) !== undefined) {\n\t\t\t\t\t\t// Makes it possible to have a link with a hash.\n\t\t\t\t\t\t// Calling .pushState will dispatch events, causing\n\t\t\t\t\t\t// `can-route` to update its data, and then try to set back\n\t\t\t\t\t\t// the url without the hash.  We need to retain that.\n\t\t\t\t\t\tif (href.indexOf(\"#\") >= 0) {\n\t\t\t\t\t\t\tthis.keepHash = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We do not want to call preventDefault() if the link is to the\n\t\t\t\t\t\t// same page and just a different hash; see can-route-pushstate#75.\n\t\t\t\t\t\tvar windowPathWithSearch = window.location.pathname + window.location.search;\n\t\t\t\t\t\tvar shouldCallPreventDefault = nodePathWithSearch !== windowPathWithSearch || node.hash === window.location.hash;\n\n\t\t\t\t\t\t// Test if you can preventDefault.\n\t\t\t\t\t\tif (shouldCallPreventDefault && event.preventDefault) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// ### anchorClickHandler\n\t// Handler function for `click` events.\n\tanchorClickHandler: function(node, event) {\n\t\tvar href = node.href ? node.href : node.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\");\n\t\t// Update `window.location`.\n\t\twindow.history.pushState(null, null, href);\n\t},\n\n\t// ### onBound\n\t// Initalizes this._value.\n\t// Sets up event listeners to capture `click` events on `<a>` elements.\n\t// Overwrites the history api methods `.pushState` and `.replaceState`.\n\tonBound: function() {\n\t\t// if running in Node.js, don't setup.\n\t\tif (isNode()) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar document = getDocument(),\n\t\t\twindow = getGlobal();\n\n\t\tthis._value = getCurrentUrl();\n\n\t\t// Intercept routable links.\n\t\tdomEvents.addDelegateListener(document.documentElement, \"click\", \"a\", this.anchorClickHandler);\n\t\tvar originalMethods = this.originalMethods = {};\n\t\tvar dispatchHandlers = this.dispatchHandlers;\n\n\t\t// Rewrites original `pushState`/`replaceState` methods on `history`\n\t\t// and keeps pointer to original methods.\n\t\tcanReflect.eachKey(methodsToOverwrite, function(method) {\n\t\t\tthis.originalMethods[method] = window.history[method];\n\t\t\twindow.history[method] = function(state, title, url) {\n\n\t\t\t\t// Avoid doubled history states (with pushState).\n\t\t\t\tvar absolute = url.indexOf(\"http\") === 0;\n\t\t\t\tvar location = LOCATION();\n\t\t\t\tvar searchHash = location.search + location.hash;\n\n\t\t\t\t// If url differs from current call original history method and update `route` state.\n\t\t\t\tif ((!absolute && url !== location.pathname + searchHash) ||\n\t\t\t\t\t(absolute && url !== location.href + searchHash)) {\n\t\t\t\t\toriginalMethods[method].apply(window.history, arguments);\n\t\t\t\t\tdispatchHandlers();\n\t\t\t\t}\n\t\t\t};\n\t\t}, this);\n\n\t\t// Bind dispatchHandlers to the `popstate` event, so they will fire\n\t\t// when `history.back()` or `history.forward()` methods are called.\n\t\tdomEvents.addEventListener(window, \"popstate\", this.dispatchHandlers);\n\t},\n\n\t// ### onUnbound\n\t// removes the event listerns for capturing routable links.\n\t// Sets `.pushState` and `.replacState` to their original methods.\n\tonUnbound: function() {\n\t\t// If running in Node.js, don't teardown.\n\t\tif(isNode()) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar document = getDocument(),\n\t\t\twindow = getGlobal();\n\n\t\tdomEvents.removeDelegateListener(document.documentElement, \"click\", \"a\", this.anchorClickHandler);\n\n\t\t// Reset the changed `window.history` methods to their original values.\n\t\tcanReflect.eachKey(methodsToOverwrite, function(method) {\n\t\t\twindow.history[method] = this.originalMethods[method];\n\t\t}, this);\n\n\t\tdomEvents.removeEventListener(window, \"popstate\", this.dispatchHandlers);\n\t},\n\n\t// ### get\n\t// Allows `PushstateObservable` to be observable by can-observations,\n\t// and returns the current url.\n\tget: function get() {\n\t\tObservationRecorder.add(this);\n\t\treturn getCurrentUrl();\n\t},\n\n\t// ### set\n\t// Calls either pushState or replaceState on the difference\n\t// in properties between `oldProps` and `newProps`.\n\tset: function(path) {\n\t\tvar newProps = route.deparam(path),\n\t\t\toldProps = route.deparam(getCurrentUrl()),\n\t\t\tmethod = \"pushState\",\n\t\t\tchanged = {};\n\n\t\t// Adds window.location.hash to path if it's not already in path.\n\t\tif (this.keepHash && path.indexOf(\"#\") === -1 && window.location.hash) {\n\t\t\tpath += window.location.hash;\n\t\t}\n\n\t\t// The old state and new state are diffed \n\t\t// to figure out which keys are changing.\n\t\tdiffObject(oldProps, newProps)\n\t\t\t.forEach(function(patch) {\n\t\t\t\t// `patch.key` refers to the mutated property name on `newProps`.\n\t\t\t\treturn changed[patch.key] = true;\n\t\t\t});\n\n\t\t// If any of the changed properties are in `replaceStateKeys` or \n\t\t// `replaceStateOnceKeys` change the method to `'replaceState'`.\n\t\tif (this.replaceStateKeys.length) {\n\t\t\tthis.replaceStateKeys.forEach(function(replaceKey) {\n\t\t\t\tif (changed[replaceKey]) {\n\t\t\t\t\tmethod = \"replaceState\";\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (this.replaceStateOnceKeys.length) {\n\t\t\tthis.replaceStateOnceKeys\n\t\t\t\t.forEach(function(replaceOnceKey, index, thisArray) {\n\t\t\t\t\tif (changed[replaceOnceKey]) {\n\t\t\t\t\t\tmethod = \"replaceState\";\n\t\t\t\t\t\t// Remove so we don't attempt to replace \n\t\t\t\t\t\t// the state on this key again.\n\t\t\t\t\t\tthisArray.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t\twindow.history[method](null, null, bindingProxy.call(\"root\") + path);\n\t},\n\n\t// ### replaceStateOn\n\t// Adds given arguments to `this.replaceStateKeys`.\n\treplaceStateOn: function() {\n\t\tcanReflect.addValues(this.replaceStateKeys, canReflect.toArray(arguments));\n\t},\n\n\t// ### replaceStateOnce\n\t// Adds given arguments to `this.replaceStateOnceKeys`.\n\t// Keys in `this.replaceStateOnceKeys` will be removed\n\t// from the array the first time a changed route contains that key.\n\treplaceStateOnce: function() {\n\t\tcanReflect.addValues(this.replaceStateOnceKeys, canReflect.toArray(arguments));\n\t},\n\n\t// ### replaceStateOff\n\t// Removes given arguments from both `this.replaceStateKeys` and\n\t// `this.replaceOnceKeys`.\n\treplaceStateOff: function() {\n\t\tcanReflect.removeValues(this.replaceStateKeys, canReflect.toArray(arguments));\n\t\tcanReflect.removeValues(this.replaceStateOnceKeys, canReflect.toArray(arguments));\n\t}\n});\n\ncanReflect.assignSymbols(PushstateObservable.prototype, {\n\t\"can.getValue\": PushstateObservable.prototype.get,\n\t\"can.setValue\": PushstateObservable.prototype.set,\n});\n\nmodule.exports = PushstateObservable;\n\n\n//# sourceURL=webpack:///./node_modules/can-route-pushstate/can-route-pushstate.js?");

/***/ }),

/***/ "./node_modules/can-route/can-route.js":
/*!*********************************************!*\
  !*** ./node_modules/can-route/can-route.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {// # can-route.js\n// Manage browser history and client state by synchronizing\n// the window.location.hash with an observable.\n\n\nvar Bind = __webpack_require__(/*! can-bind */ \"./node_modules/can-bind/can-bind.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar type = __webpack_require__(/*! can-type */ \"./node_modules/can-type/can-type.js\");\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar devLog = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar makeCompute = __webpack_require__(/*! can-simple-observable/make-compute/make-compute */ \"./node_modules/can-simple-observable/make-compute/make-compute.js\");\nvar RouteData = __webpack_require__(/*! ./src/routedata */ \"./node_modules/can-route/src/routedata.js\");\nvar stringCoercingMapDecorator = __webpack_require__(/*! ./src/string-coercion */ \"./node_modules/can-route/src/string-coercion.js\").stringCoercingMapDecorator;\n\nvar registerRoute = __webpack_require__(/*! ./src/register */ \"./node_modules/can-route/src/register.js\");\nvar urlHelpers = __webpack_require__(/*! ./src/url-helpers */ \"./node_modules/can-route/src/url-helpers.js\");\nvar routeParam = __webpack_require__(/*! ./src/param */ \"./node_modules/can-route/src/param.js\");\nvar routeDeparam = __webpack_require__(/*! ./src/deparam */ \"./node_modules/can-route/src/deparam.js\");\nvar bindingProxy = __webpack_require__(/*! ./src/binding-proxy */ \"./node_modules/can-route/src/binding-proxy.js\");\nvar Hashchange = __webpack_require__(/*! can-route-hash */ \"./node_modules/can-route-hash/can-route-hash.js\");\n\nvar isWebWorker =  __webpack_require__(/*! can-globals/is-web-worker/is-web-worker */ \"./node_modules/can-globals/is-web-worker/is-web-worker.js\");\nvar isBrowserWindow =  __webpack_require__(/*! can-globals/is-browser-window/is-browser-window */ \"./node_modules/can-globals/is-browser-window/is-browser-window.js\");\n\n// ## hashchangeObservable\n// `hashchangeObservable` is an instance of `Hashchange`, instances of\n// `Hashchange` are two-way bound to `window.location.hash` once the\n// instances have a listener.\nvar hashchangeObservable = new Hashchange();\nbindingProxy.bindings.hashchange = hashchangeObservable;\nbindingProxy.defaultBinding = \"hashchange\";\nbindingProxy.urlDataObservable.value = hashchangeObservable;\n\n\n// ## canRoute\nfunction canRoute(url, defaults) {\n\t//!steal-remove-start\n\tif (typeof process !== \"undefined\" && \"development\" !== \"production\") {\n\t\tdevLog.warn(\"Call route.register(url,defaults) instead of calling route(url, defaults)\");\n\t}\n\t//!steal-remove-end\n\tregisterRoute.register(url, defaults);\n\treturn canRoute;\n}\n\n\n// ## Helper Functions\n// A ~~throttled~~ debounced function called multiple times will only fire once the\n// timer runs down. Each call resets the timer.\nvar timer;\n// A dummy events object used to dispatch url change events on.\nvar currentRuleObservable = new Observation(function canRoute_matchedRoute() {\n\tvar url = bindingProxy.call(\"can.getValue\");\n\treturn canRoute.rule(url);\n});\n\n// ### updateUrl\n// If the `route.data` changes, update the hash.\n// Using `.serialize()` retrieves the raw data contained in the `observable`.\n// This function is ~~throttled~~ debounced so it only updates once even if multiple values changed.\n// This might be able to use batchNum and avoid this.\nfunction updateUrl(serializedData) {\n\t// collect attributes that are changing\n\tclearTimeout(timer);\n\ttimer = setTimeout(function () {\n\t\t// indicate that the hash is set to look like the data\n\t\tvar serialized = canReflect.serialize( canRoute.data ),\n\t\t\tcurrentRouteName = currentRuleObservable.get(),\n\t\t\troute = routeParam.getMatchedRoute(serialized, currentRouteName),\n\t\t\tpath = routeParam.paramFromRoute(route, serialized);\n\n\t\tbindingProxy.call(\"can.setValue\", path);\n\t\tvar onStartComplete = canRoute._onStartComplete;\n\t\tif (onStartComplete) {\n\t\t\tcanRoute._onStartComplete = undefined;\n\t\t\tonStartComplete();\n\t\t}\n\t}, 10);\n}\n\n// ### updateRouteData\n// Deparameterizes the portion of the hash of interest and assign the\n// values to the `route.data` removing existing values no longer in the hash.\n// updateRouteData is called typically by hashchange which fires asynchronously\n// So itâ€™s possible that someone started changing the data before the\n// hashchange event fired.  For this reason, it will not set the route data\n// if the data is changing or the hash already matches the hash that was set.\nfunction updateRouteData() {\n\tvar hash = bindingProxy.call(\"can.getValue\");\n\t// if the hash data is currently changing, or\n\t// the hash is what we set it to anyway, do NOT change the hash\n\n\tqueues.batch.start();\n\n\tvar state = canRoute.deparam(hash);\n\tdelete state.route;\n\tcanReflect.update(canRoute.data,state);\n\tqueues.batch.stop();\n\n}\n\n\n/**\n * @static\n */\nObject.defineProperty(canRoute, \"routes\", {\n\t/**\n\t * @property {Object} routes\n\t * @hide\n\t *\n\t * A list of routes recognized by the router indixed by the url used to add it.\n\t * Each route is an object with these members:\n\t *\n\t *  - test - A regular expression that will match the route when variable values\n\t *    are present; i.e. for {page}/{type} the `RegExp` is /([\\w\\.]*)/([\\w\\.]*)/ which\n\t *    will match for any value of {page} and {type} (word chars or period).\n\t *\n\t *  - route - The original URL, same as the index for this entry in routes.\n\t *\n\t *  - names - An array of all the variable names in this route\n\t *\n\t *  - defaults - Default values provided for the variables or an empty object.\n\t *\n\t *  - length - The number of parts in the URL separated by '/'.\n\t */\n \tget: function() {\n \t\treturn registerRoute.routes;\n \t},\n\tset: function(newVal) {\n\t\treturn registerRoute.routes = newVal;\n\t}\n});\n\n// ## canRoute.defaultBinding\nObject.defineProperty(canRoute, \"defaultBinding\", {\n \tget: function() {\n\t\treturn bindingProxy.defaultBinding;\n\t},\n\tset: function(newVal) {\n\t\tbindingProxy.defaultBinding = newVal;\n\t\tvar observable = bindingProxy.bindings[bindingProxy.defaultBinding];\n\t\tif (observable) {\n\t\t\tbindingProxy.urlDataObservable.value = observable;\n\t\t}\n\t}\n});\n\n// ## canRoute.urlData\nObject.defineProperty(canRoute, \"urlData\", {\n \tget: function() {\n\t\treturn bindingProxy.urlDataObservable.value;\n\t},\n\tset: function(newVal) {\n\t\tcanRoute._teardown();\n\t\tbindingProxy.urlDataObservable.value = newVal;\n\t}\n});\n\ncanReflect.assignMap(canRoute, {\n\t// ## canRoute.param\n\tparam: routeParam,\n\t// ## canRoute.deparam\n\tdeparam: routeDeparam,\n\t// ## canRoute.map\n\tmap: function(data) {\n\t\t//!steal-remove-start\n\t\tif (typeof process !== \"undefined\" && \"development\" !== \"production\") {\n\t\t\tdevLog.warn(\"Set route.data directly instead of calling route.map\");\n\t\t}\n\t\t//!steal-remove-end\n\t\tcanRoute.data = data;\n\t},\n\n\t// ## canRoute.start\n\tstart: function (val) {\n\t\tif (canRoute.data instanceof RouteData) {\n\t\t\tvar routeData = canRoute.data;\n\t\t\tvar definePropertyWithDefault = function(defaults, name) {\n\t\t\t\tvar defaultValue = defaults[name];\n\t\t\t\tvar propertyType = defaultValue != null ? type.maybeConvert(defaultValue.constructor) : type.maybeConvert(String);\n\t\t\t\tcanReflect.defineInstanceKey(routeData.constructor, name, {\n\t\t\t\t\ttype: propertyType\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tcanReflect.eachKey(canRoute.routes, function(route) {\n\t\t\t\tcanReflect.eachIndex(route.names, function (name) {\n\t\t\t\t\tdefinePropertyWithDefault(route.defaults, name);\n\t\t\t\t});\n\n\t\t\t\tcanReflect.eachKey(route.defaults, function(value, key) {\n\t\t\t\t\tdefinePropertyWithDefault(route.defaults, key);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tif (val !== true) {\n\t\t\tcanRoute._setup();\n\t\t\tif (isBrowserWindow() || isWebWorker()) {\n\t\t\t\t// We can't use updateRouteData because we want to merge the route data\n\t\t\t\t// into .data\n\t\t\t\tvar hash = bindingProxy.call(\"can.getValue\");\n\t\t\t\tqueues.batch.start();\n\t\t\t\t// get teh data\n\t\t\t\tvar state = canRoute.deparam(hash);\n\t\t\t\tdelete state.route;\n\n\t\t\t\tcanReflect.assign(canRoute.data,state);\n\t\t\t\tqueues.batch.stop();\n\t\t\t\tupdateUrl();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn canRoute;\n\t},\n\t// ## canRoute.url\n\turl: urlHelpers.url,\n\tlink: urlHelpers.link,\n\tisCurrent: urlHelpers.isCurrent,\n\tbindings: bindingProxy.bindings,\n\n\t// ready calls setup\n\t// setup binds and listens to data changes\n\t// bind listens to whatever you should be listening to\n\t// data changes tries to set the path\n\n\t// we need to be able to\n\t// easily kick off calling updateRouteData\n\t// \tteardown whatever is there\n\t//  turn on a particular binding\n\n\t// called when the route is ready\n\t_setup: function () {\n\t\tif (!canRoute._canBinding) {\n\n\t\t\tvar bindingOptions = {\n\n\t\t\t\t// The parent is the hashchange observable\n\t\t\t\tparent: bindingProxy.urlDataObservable.value,\n\t\t\t\tsetParent: updateUrl,\n\n\t\t\t\t// The child is route.data\n\t\t\t\tchild: canRoute.serializedObservation,\n\t\t\t\tsetChild: updateRouteData,\n\n\t\t\t\t// On init, we do not want the child set to the parentâ€™s value; this is\n\t\t\t\t// handled by start() for reasons mentioned there.\n\t\t\t\tonInitDoNotUpdateChild: true,\n\n\t\t\t\t// Cycles are allowed because updateUrl is async; if another change\n\t\t\t\t// happens during its setTimeout, then without cycles the change would\n\t\t\t\t// be ignored :( TODO: Can this be removed if updateUrl stops using\n\t\t\t\t// setTimeout in a major version?\n\t\t\t\tcycles: 1,\n\n\t\t\t\t// Listen for changes in the notify queue\n\t\t\t\tqueue: \"notify\"\n\n\t\t\t};\n\n\t\t\t// For debugging: the names that will be assigned to the updateChild and\n\t\t\t// updateParent functions within can-bind\n\t\t\t//!steal-remove-start\n\t\t\tif (typeof process !== \"undefined\" && \"development\" !== \"production\") {\n\t\t\t\tbindingOptions.updateChildName = \"can-route.updateRouteData\";\n\t\t\t\tbindingOptions.updateParentName = \"can-route.updateUrl\";\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\t// Create a new binding with can-bind\n\t\t\tcanRoute._canBinding = new Bind(bindingOptions);\n\n\t\t\t// â€¦and turn it on!\n\t\t\tcanRoute._canBinding.start();\n\n\t\t}\n\t},\n\t_teardown: function () {\n\t\tif (canRoute._canBinding) {\n\t\t\tcanRoute._canBinding.stop();\n\t\t\tcanRoute._canBinding = null;\n\t\t}\n\t\tclearTimeout(timer);\n\t},\n\n\tstop: function() {\n\t\tthis._teardown();\n\t\treturn canRoute;\n\t},\n\n\tcurrentRule: makeCompute( currentRuleObservable ),\n\tregister: registerRoute.register,\n\trule: function(url) {\n\t\tvar rule = routeDeparam.getRule(url);\n\t\tif (rule) {\n\t\t\treturn rule.route;\n\t\t}\n\t}\n});\n\n// The functions in the following list applied to `canRoute` (e.g. `canRoute.attr('...')`) will\n// instead act on the `canRoute.data` observe.\n\nvar bindToCanRouteData = function (name, args) {\n\tif (!canRoute.data[name]) {\n\t\treturn canRoute.data.addEventListener.apply(canRoute.data, args);\n\t}\n\treturn canRoute.data[name].apply(canRoute.data, args);\n};\n\n[\"addEventListener\",\"removeEventListener\",\"bind\", \"unbind\", \"on\", \"off\"].forEach(function(name) {\n\t// exposing all internal eventQueue evtâ€™s to canRoute\n\tcanRoute[name] = function(eventName, handler) {\n\t\tif (eventName === \"__url\") {\n\t\t\treturn bindingProxy.call(\"can.onValue\", handler );\n\t\t}\n\t\treturn bindToCanRouteData(name, arguments);\n\t};\n});\n\n[\"delegate\", \"undelegate\", \"removeAttr\", \"compute\", \"_get\", \"___get\", \"each\"].forEach(function (name) {\n\tcanRoute[name] = function () {\n\t\t// `delegate` and `undelegate` require\n\t\t// the `can/map/delegate` plugin\n\t\treturn bindToCanRouteData(name, arguments);\n\t};\n});\n\n\nvar routeData,\n\tserializedObservation,\n\tserializedCompute;\n\nfunction setRouteData(data) {\n\trouteData = data;\n\treturn routeData;\n}\n\nObject.defineProperty(canRoute, \"serializedObservation\", {\n\tget: function() {\n\t\tif (!serializedObservation) {\n\t\t\tserializedObservation = new Observation(function canRoute_data_serialized() {\n\t\t\t\treturn canReflect.serialize( canRoute.data );\n\t\t\t});\n\t\t}\n\t\treturn serializedObservation;\n\t}\n});\nObject.defineProperty(canRoute, \"serializedCompute\", {\n\tget: function() {\n\t\tif (!serializedCompute) {\n\t\t\tserializedCompute = makeCompute(canRoute.serializedObservation);\n\t\t}\n\t\treturn serializedCompute;\n\t}\n});\n\nvar viewModelSymbol = canSymbol.for(\"can.viewModel\");\nObject.defineProperty(canRoute, \"data\", {\n\tget: function() {\n\t\tif (routeData) {\n\t\t\treturn routeData;\n\t\t} else {\n\t\t\treturn setRouteData(new RouteData());\n\t\t}\n\t},\n\tset: function(data) {\n\t\tif ( canReflect.isConstructorLike(data) ) {\n\t\t\tdata = new data();\n\t\t}\n\t\tif (data && data[viewModelSymbol] !== undefined) {\n\t\t\tdata = data[viewModelSymbol];\n\t\t}\n\t\t// if itâ€™s a map, we make it always set strings for backwards compat\n\t\tif ( \"attr\" in data ) {\n\t\t\tsetRouteData( stringCoercingMapDecorator(data) );\n\t\t} else {\n\t\t\tsetRouteData(data);\n\t\t}\n\t}\n});\n\ncanRoute.attr = function(prop, value) {\n\tconsole.warn(\"can-route: can-route.attr is deprecated. Use methods on can-route.data instead.\");\n\tif (\"attr\" in canRoute.data) {\n\t\treturn canRoute.data.attr.apply(canRoute.data, arguments);\n\t} else {\n\t\tif (arguments.length > 1) {\n\t\t\tcanReflect.setKeyValue(canRoute.data, prop, value);\n\t\t\treturn canRoute.data;\n\t\t} else if (typeof prop === \"object\") {\n\t\t\tcanReflect.assignDeep(canRoute.data,prop);\n\t\t\treturn canRoute.data;\n\t\t} else if (arguments.length === 1) {\n\t\t\treturn canReflect.getKeyValue(canRoute.data, prop);\n\t\t} else {\n\t\t\treturn canReflect.unwrap(canRoute.data);\n\t\t}\n\t}\n};\n\n\ncanReflect.setKeyValue(canRoute, canSymbol.for(\"can.isFunctionLike\"), false);\n\n// LEGACY\ncanRoute.matched = canRoute.currentRule;\ncanRoute.current = canRoute.isCurrent;\n\nmodule.exports = namespace.route = canRoute;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/can-route/can-route.js?");

/***/ }),

/***/ "./node_modules/can-route/src/binding-proxy.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-route/src/binding-proxy.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\n\nvar urlDataObservable = new SimpleObservable(null);\n\ncanReflect.setName(urlDataObservable, \"route.urlData\");\n\nvar bindingProxy = {\n\tdefaultBinding: null,\n\turlDataObservable: urlDataObservable,\n\tbindings: {},\n\tcall: function() {\n\t\tvar args = canReflect.toArray(arguments),\n\t\t\tprop = args.shift(),\n\t\t\tbinding = urlDataObservable.value;\n\t\tif (binding === null) {\n\t\t\tthrow new Error(\"there is no current binding!!!\");\n\t\t}\n\t\tvar method = binding[prop.indexOf(\"can.\") === 0 ? canSymbol.for(prop) : prop];\n\t\tif (method.apply) {\n\t\t\treturn method.apply(binding, args);\n\t\t} else {\n\t\t\treturn method;\n\t\t}\n\t}\n};\nmodule.exports = bindingProxy;\n\n\n//# sourceURL=webpack:///./node_modules/can-route/src/binding-proxy.js?");

/***/ }),

/***/ "./node_modules/can-route/src/deparam.js":
/*!***********************************************!*\
  !*** ./node_modules/can-route/src/deparam.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar deparam = __webpack_require__(/*! can-deparam */ \"./node_modules/can-deparam/can-deparam.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar bindingProxy = __webpack_require__(/*! ./binding-proxy */ \"./node_modules/can-route/src/binding-proxy.js\");\nvar register = __webpack_require__(/*! ./register */ \"./node_modules/can-route/src/register.js\");\n\n// ## Helper Functions\n\n// ### decode\n// Restore escaped HTML from its URI value.\n// It isn't compatable with named character references (`&copy;`, etc).\nfunction decode(str) {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch(ex) {\n\t\treturn unescape(str);\n\t}\n}\n\n// ### toURLFragment\n// If the `root` ends with `/` and the url starts with it, remove `/`.\n// TODO: I'm not totally sure this belongs here. This might be shifted to can-route-pushstate.\nfunction toURLFragment(url) {\n\tvar root = bindingProxy.call(\"root\");\n\tif (root.lastIndexOf(\"/\") === root.length - 1 && url.indexOf(\"/\") === 0) {\n\t\turl = url.substr(1);\n\t}\n\treturn url;\n}\n\n// ### canRoute_getRule\nfunction canRoute_getRule(url) {\n\turl = toURLFragment(url);\n\t// See if the url matches any routes by testing it against the `route.test` `RegExp`.\n\t// By comparing the URL length the most specialized route that matches is used.\n\tvar route = {\n\t\tlength: -1\n\t};\n\tcanReflect.eachKey(register.routes, function(temp, name) {\n\t\tif (temp.test.test(url) && temp.length > route.length) {\n\t\t\troute = temp;\n\t\t}\n\t});\n\t// If a route was matched.\n\tif (route.length > -1) {\n\t\treturn route;\n\t}\n}\n\nfunction canRoute_deparam(url) {\n\n\tvar route = canRoute_getRule(url),\n\t\tquerySeparator = bindingProxy.call(\"querySeparator\"),\n\t\tparamsMatcher = bindingProxy.call(\"paramsMatcher\");\n\n\turl = toURLFragment(url);\n\n\t// If a route was matched.\n\tif (route) {\n\t\t// Since `RegExp` backreferences are used in `route.test` (parens)\n\t\t// the parts will contain the full matched string and each variable (back-referenced) value.\n\t\tvar parts = url.match(route.test),\n\t\t\t// Start will contain the full matched string; parts contain the variable values.\n\t\t\tstart = parts.shift(),\n\t\t\t// The remainder will be the `&amp;key=value` list at the end of the URL.\n\t\t\tremainder = url.substr(start.length - (parts[parts.length - 1] === querySeparator ? 1 : 0)),\n\t\t\t// If there is a remainder and it contains a `&amp;key=value` list deparam it.\n\t\t\tobj = (remainder && paramsMatcher.test(remainder)) ? deparam(remainder.slice(1)) : {};\n\n\t\t// Add the default values for this route.\n\t\tobj = canReflect.assignDeep(canReflect.assignDeep({}, route.defaults), obj);\n\t\t// Overwrite each of the default values in `obj` with those in\n\t\t// parts if that part is not empty.\n\t\tparts.forEach(function (part, i) {\n\t\t\tif (part && part !== querySeparator) {\n\t\t\t\tobj[route.names[i]] = decode(part);\n\t\t\t}\n\t\t});\n\t\treturn obj;\n\t}\n\t// If no route was matched, it is parsed as a `&amp;key=value` list.\n\tif (url.charAt(0) !== querySeparator) {\n\t\turl = querySeparator + url;\n\t}\n\treturn paramsMatcher.test(url) ? deparam(url.slice(1)) : {};\n}\n\ncanRoute_deparam.getRule = canRoute_getRule;\n\nmodule.exports = canRoute_deparam;\n\n\n//# sourceURL=webpack:///./node_modules/can-route/src/deparam.js?");

/***/ }),

/***/ "./node_modules/can-route/src/param.js":
/*!*********************************************!*\
  !*** ./node_modules/can-route/src/param.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar param = __webpack_require__(/*! can-param */ \"./node_modules/can-param/can-param.js\");\n\nvar register = __webpack_require__(/*! ./register */ \"./node_modules/can-route/src/register.js\");\nvar regexps = __webpack_require__(/*! ./regexps */ \"./node_modules/can-route/src/regexps.js\");\nvar bindingProxy = __webpack_require__(/*! ./binding-proxy */ \"./node_modules/can-route/src/binding-proxy.js\");\n\n// ## matchesData\n// Checks if a route matches the data provided. If any route variable\n// is not present in the data, the route does not match. If all route\n// variables are present in the data, the number of matches is returned\n// to allow discerning between general and more specific routes.\nfunction matchesData(route, data) {\n\tvar count = 0,\n\t\tdefaults = {};\n\n\t// Look at default route values, if they match increment count\n\tfor (var name in route.defaults) {\n\t\tif (route.defaults[name] === data[name]) {\n\t\t\tdefaults[name] = 1;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tfor (var i = 0; i < route.names.length; i++) {\n\t\t// If a route name isn't present in data, the route doesn't match.\n\t\tif (!data.hasOwnProperty(route.names[i])) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!defaults[route.names[i]]) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n// ## getMatchedRoute\n\nfunction getMatchedRoute(data, routeName) {\n\t// Check if the provided data keys match the names in any routes;\n\t// Get the one with the most matches.\n\tvar route,\n\t\t// Need to have at least 1 match.\n\t\tmatches = 0,\n\t\tmatchCount,\n\t\tpropCount = 0;\n\n\tdelete data.route;\n\n\tcanReflect.eachKey(data, function () {\n\t\tpropCount++;\n\t});\n\t// Otherwise find route.\n\tcanReflect.eachKey(register.routes, function (temp, name) {\n\t\t// best route is the first with all defaults matching\n\n\t\tmatchCount = matchesData(temp, data);\n\t\tif (matchCount > matches) {\n\t\t\troute = temp;\n\t\t\tmatches = matchCount;\n\t\t}\n\t\tif (matchCount >= propCount) {\n\t\t\treturn false;\n\t\t}\n\t});\n\t// If we have a route name in our `register` data, and it's\n\t// just as good as what currently matches, use that\n\tif (register.routes[routeName] && matchesData(register.routes[routeName], data) === matches) {\n\t\troute = register.routes[routeName];\n\t}\n\t// If this is match...\n\treturn route;\n}\nfunction paramFromRoute(route, data) {\n\tvar cpy,\n\t\tres,\n\t\tafter,\n\t\tmatcher;\n\tif (route) {\n\n\t\tcpy = canReflect.assignMap({}, data);\n\t\t// fall back to legacy :foo RegExp if necessary\n\t\tmatcher = regexps.colon.test(route.route) ? regexps.colon : regexps.curlies;\n\t\t// Create the url by replacing the var names with the provided data.\n\t\t// If the default value is found an empty string is inserted.\n\t\tres = route.route.replace(matcher, function (whole, name) {\n\t\t\tdelete cpy[name];\n\t\t\treturn data[name] === route.defaults[name] ? \"\" : encodeURIComponent(data[name]);\n\t\t})\n\t\t.replace(\"\\\\\", \"\");\n\t\t// Remove matching default values\n\t\tcanReflect.eachKey(route.defaults, function (val, name) {\n\t\t\tif (cpy[name] === val) {\n\t\t\t\tdelete cpy[name];\n\t\t\t}\n\t\t});\n\t\t// The remaining elements of data are added as\n\t\t// `&amp;` separated parameters to the url.\n\t\tafter = param(cpy);\n\t\t// if we are paraming for setting the hash\n\t\t// we also want to make sure the route value is updated\n\t\t//if (_setRoute) {\n\t\t//    register.matched(route.route);\n\t\t//}\n\t\treturn res + (after ? bindingProxy.call(\"querySeparator\") + after : \"\");\n\t}\n\t// If no route was found, there is no hash URL, only paramters.\n\treturn canReflect.size(data) === 0 ? \"\" :bindingProxy.call(\"querySeparator\") + param(data);\n}\n\nfunction canRoute_param(data, currentRouteName) {\n \treturn paramFromRoute(getMatchedRoute(data, currentRouteName), data);\n}\nmodule.exports = canRoute_param;\ncanRoute_param.paramFromRoute = paramFromRoute;\ncanRoute_param.getMatchedRoute = getMatchedRoute;\n\n\n//# sourceURL=webpack:///./node_modules/can-route/src/param.js?");

/***/ }),

/***/ "./node_modules/can-route/src/regexps.js":
/*!***********************************************!*\
  !*** ./node_modules/can-route/src/regexps.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = {\n\tcurlies: /\\{\\s*([\\w.]+)\\s*\\}/g,\n\tcolon: /\\:([\\w.]+)/g\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-route/src/regexps.js?");

/***/ }),

/***/ "./node_modules/can-route/src/register.js":
/*!************************************************!*\
  !*** ./node_modules/can-route/src/register.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// This file contains the function that allows the registration of routes\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\nvar bindingProxy = __webpack_require__(/*! ./binding-proxy */ \"./node_modules/can-route/src/binding-proxy.js\");\nvar regexps = __webpack_require__(/*! ./regexps */ \"./node_modules/can-route/src/regexps.js\");\n\nvar diff = __webpack_require__(/*! can-diff/list/list */ \"./node_modules/can-diff/list/list.js\");\nvar diffObject = __webpack_require__(/*! can-diff/map/map */ \"./node_modules/can-diff/map/map.js\");\n\n// `RegExp` used to match route variables of the type '{name}'.\n// Any word character or a period is matched.\n\n// ### removeBackslash\n// Removes all backslashes (`\\`) from a string.\nfunction removeBackslash(string) {\n\treturn string.replace(/\\\\/g, \"\");\n}\n\n// ### wrapQuote\n// Converts input to a string and readies string for regex\n// input by escaping the following special characters: `[ ] ( ) { } \\ ^ $ . | ? * +`.\nfunction wrapQuote(string) {\n\treturn (string + \"\")\n\t\t.replace(/([.?*+\\^$\\[\\]\\\\(){}|\\-])/g, \"\\\\$1\");\n}\n\nvar RouteRegistry = {\n\troutes:  {},\n\tregister: function(url, defaults) {\n\t\t// If the root ends with a forward slash (`/`)\n\t\t// and url starts with a forward slash (`/`), remove the leading\n\t\t// forward slash (`/`) of the url.\n\t\tvar root = bindingProxy.call(\"root\");\n\n\t\tif ( root.lastIndexOf(\"/\") === root.length - 1 && url.indexOf(\"/\") === 0 ) {\n\t\t\turl = url.substr(1);\n\t\t}\n\n\t\t// `matcher` will be a regex\n\t\t// fall back to legacy `:foo` RegExp if necessary\n\t\tvar matcher;\n\t\tif (regexps.colon.test(url)) {\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tdev.warn(\"update route \\\"\" + url + \"\\\" to \\\"\" + url.replace(regexps.colon, function(name, key) {\n\t\t\t\t\treturn \"{\" + key + \"}\";\n\t\t\t\t}) + \"\\\"\");\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tmatcher = regexps.colon;\n\t\t} else {\n\t\t\tmatcher = regexps.curlies;\n\t\t}\n\n\t\tdefaults = defaults || {};\n\n\t\t// Extract the variable names and replace with `RegExp` that will match\n\t\t// an actual URL with values.\n\t\tvar lastIndex = matcher.lastIndex = 0,\n\t\t\tnames = [],\n\t\t\tres,\n\t\t\ttest = \"\",\n\t\t\tnext,\n\t\t\tquerySeparator = bindingProxy.call(\"querySeparator\"),\n\t\t\tmatchSlashes = bindingProxy.call(\"matchSlashes\");\n\n\t\t// res will be something like [\"{foo}\",\"foo\"]\n\t\twhile (res = matcher.exec(url)) {\n\t\t\tnames.push(res[1]);\n\t\t\ttest += removeBackslash(url.substring(lastIndex, matcher.lastIndex - res[0].length));\n\t\t\t// If matchSlashes is false (the default) don't greedily match any slash in the string, assume its part of the URL\n\t\t\tnext = \"\\\\\" + (removeBackslash(url.substr(matcher.lastIndex, 1)) || querySeparator+(matchSlashes? \"\": \"|/\"));\n\t\t\t// A name without a default value HAS to have a value.\n\t\t\t// A name that has a default value can be empty.\n\t\t\t// The `\\\\` is for string-escaping giving single `\\` for `RegExp` escaping.\n\t\t\ttest += \"([^\" + next + \"]\" + (defaults[res[1]] ? \"*\" : \"+\") + \")\";\n\t\t\tlastIndex = matcher.lastIndex;\n\t\t}\n\t\ttest += removeBackslash(url.substr(lastIndex));\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\t// warn if new route uses same map properties as an existing route\n\t\t\tcanReflect.eachKey(RouteRegistry.routes, function(r) {\n\t\t\t\tvar existingKeys = r.names.concat(Object.keys(r.defaults)).sort(),\n\t\t\t\t\tkeys = names.concat(Object.keys(defaults)).sort(),\n\t\t\t\t\tsameMapKeys = !diff(existingKeys, keys).length,\n\t\t\t\t\tsameDefaultValues = !diffObject(r.defaults, defaults).length,\n\t\t\t\t\t//the regex removes the trailing slash\n\t\t\t\t\tmatchingRoutesWithoutTrailingSlash = r.route.replace(/\\/$/, \"\") === url.replace(/\\/$/, \"\");\n\n\t\t\t\tif (sameMapKeys && sameDefaultValues && !matchingRoutesWithoutTrailingSlash) {\n\t\t\t\t\tdev.warn(\"two routes were registered with matching keys:\\n\" +\n\t\t\t\t\t\t\"\\t(1) route.register(\\\"\" + r.route + \"\\\", \" + JSON.stringify(r.defaults) + \")\\n\" +\n\t\t\t\t\t\t\"\\t(2) route.register(\\\"\" + url + \"\\\", \" + JSON.stringify(defaults) + \")\\n\" +\n\t\t\t\t\t\t\"(1) will always be chosen since it was registered first\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// Add route in a form that can be easily figured out.\n\t\treturn RouteRegistry.routes[url] = {\n\t\t\t// A regular expression that will match the route when variable values\n\t\t\t// are present; i.e. for (`{page}/{type}`) the `RegExp` is `/([\\w\\.]*)/([\\w\\.]*)/` which\n\t\t\t// will match for any value of `{page}` and `{type}` (word chars or period).\n\t\t\ttest: new RegExp(\"^\" + test + \"($|\" + wrapQuote(querySeparator) + \")\"),\n\t\t\t// The original URL, same as the index for this entry in routes.\n\t\t\troute: url,\n\t\t\t// An `array` of all the variable names in this route.\n\t\t\tnames: names,\n\t\t\t// Default values provided for the variables.\n\t\t\tdefaults: defaults,\n\t\t\t// The number of parts in the URL separated by `/`.\n\t\t\tlength: url.split(\"/\").length\n\t\t};\n\t}\n};\n\nmodule.exports = RouteRegistry;\n\n\n//# sourceURL=webpack:///./node_modules/can-route/src/register.js?");

/***/ }),

/***/ "./node_modules/can-route/src/routedata.js":
/*!*************************************************!*\
  !*** ./node_modules/can-route/src/routedata.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar ObservableObject = __webpack_require__(/*! can-observable-object */ \"./node_modules/can-observable-object/dist/can-observable-object.js\");\nvar stringify = __webpack_require__(/*! ./string-coercion */ \"./node_modules/can-route/src/string-coercion.js\").stringify;\n\nvar Stringify = {};\nStringify[canSymbol.for(\"can.new\")] = function(value) {\n\treturn stringify(value);\n};\nStringify[canSymbol.for(\"can.isMember\")] = function(value) {\n\treturn typeof value === \"string\";\n};\n\nclass RouteData extends ObservableObject {\n\tstatic get propertyDefaults() {\n\t\treturn {\n\t\t\ttype: Stringify\n\t\t};\n\t}\n}\n\nmodule.exports = RouteData;\n\n\n//# sourceURL=webpack:///./node_modules/can-route/src/routedata.js?");

/***/ }),

/***/ "./node_modules/can-route/src/string-coercion.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-route/src/string-coercion.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\n// # String Coercion Helper Functions\n\n// ## stringify\n// Converts an object, array, Map or List to a string.\n// It attempts the following flow to convert to a string:\n// if `obj` is an object:\n//   - call `.serialize` on `obj`, if available\n//   - shallow copy `obj` using `.slice` or `can-reflect.assign`\n//   - convert each proprety to a string recursively\n// else\n//   - call `.toString` on `obj`, if available.\nfunction stringify(obj) {\n\tif (obj && typeof obj === \"object\") {\n\t\tif (\"serialize\" in obj) {\n\t\t\tobj = obj.serialize();\n\n\t\t// Get array from array-like or shallow-copy object.\n\t\t} else if (typeof obj.slice === \"function\") {\n\t\t\tobj = obj.slice();\n\t\t} else {\n\t\t\tcanReflect.assign({}, obj);\n\t\t}\n\n\t\t// Convert each object property or array item into a string.\n\t\tcanReflect.eachKey(obj, function(val, prop) {\n\t\t\tobj[prop] = stringify(val);\n\t\t});\n\n\t// If `obj` supports `.toString` call it.\n\t} else if (obj !== undefined && obj !== null && (typeof obj.toString === \"function\" )) {\n\t\tobj = obj.toString();\n\t}\n\n\treturn obj;\n}\n\n// ## stringCoercingMapDecorator\n// Coercies the arguments of `can-map.attr` to strings.\n// everything in the backing Map is a string\n// add type coercion during Map setter to coerce all values to strings so unexpected conflicts don't happen.\n// https://github.com/canjs/canjs/issues/2206\n// A proposal to change this behavior is currently open:\n// https://github.com/canjs/can-route/issues/125\nfunction stringCoercingMapDecorator(map) {\n\tvar decoratorSymbol = canSymbol.for(\"can.route.stringCoercingMapDecorator\");\n\n\tif (!map.attr[decoratorSymbol]) {\n\t\tvar attrUndecoratedFunction = map.attr;\n\n\t\tmap.attr = function(key) {\n\n\t\t\tvar serializable = typeof key === \"string\" &&\n\t\t\t\t(this.define === undefined || this.define[key] === undefined || !!this.define[key].serialize),\n\t\t\t\targs;\n\n\t\t\tif (serializable) { // if setting non-str non-num attr\n\t\t\t\targs = stringify(Array.apply(null, arguments));\n\t\t\t} else {\n\t\t\t\targs = arguments;\n\t\t\t}\n\n\t\t\treturn attrUndecoratedFunction.apply(this, args);\n\t\t};\n\n\t\tcanReflect.setKeyValue(map.attr, decoratorSymbol, true);\n\t}\n\n\treturn map;\n}\n\nexports.stringCoercingMapDecorator = stringCoercingMapDecorator;\nexports.stringify = stringify;\n\n\n//# sourceURL=webpack:///./node_modules/can-route/src/string-coercion.js?");

/***/ }),

/***/ "./node_modules/can-route/src/url-helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/can-route/src/url-helpers.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar bindingProxy = __webpack_require__(/*! ./binding-proxy */ \"./node_modules/can-route/src/binding-proxy.js\");\nvar routeDeparam = __webpack_require__(/*! ./deparam */ \"./node_modules/can-route/src/deparam.js\");\nvar routeParam = __webpack_require__(/*! ./param */ \"./node_modules/can-route/src/param.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar string = __webpack_require__(/*! can-string */ \"./node_modules/can-string/can-string.js\");\n\n// ### formatAttributes\n// Creates HTML-like attributes from an object.\n// It escapes hyperlink references.\nfunction formatAttributes(props) {\n\tvar tags = [];\n\tcanReflect.eachKey(props, function(value, name) {\n\t\t// Converts `\"className\"` to `\"class\"`.\n\t\tvar attributeName = name === \"className\" ? \"class\" : name,\n\n\t\t\t// Escapes `value` if `name` is `\"href\"`.\n\t\t\tattributeValue = name === \"href\" ? value : string.esc(value);\n\n\t\ttags.push(attributeName + \"=\\\"\" + attributeValue + \"\\\"\");\n\t});\n\treturn tags.join(\" \");\n}\n\n// ### matchCheck\n// It recursively compares property values in `matcher` to those in `source`.\n// It returns `false` if there's a property in `source` that's not in `matcher`,\n// or if the two values aren't loosely equal.\nfunction matchCheck(source, matcher) {\n\t/*jshint eqeqeq:false*/\n\tfor(var property in source) {\n\t\tvar sourceProperty = source[property],\n\t\t\tmatcherProperty = matcher[property];\n\n\t\tif (sourceProperty && matcherProperty &&\n\t\t\ttypeof sourceProperty === \"object\" && typeof matcher === \"object\"\n\t\t) {\n\t\t\treturn matchCheck(sourceProperty, matcherProperty);\n\t\t}\n\n\t\tif (sourceProperty != matcherProperty) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// ### canRoute_url\nfunction canRoute_url(options, merge) {\n\tif (merge) {\n\t\tvar baseOptions = routeDeparam( bindingProxy.call(\"can.getValue\") );\n\t\toptions = canReflect.assignMap(canReflect.assignMap({}, baseOptions), options);\n\t}\n\treturn bindingProxy.call(\"root\") + routeParam(options);\n}\n\nmodule.exports = {\n\turl: canRoute_url,\n\n\tlink: function canRoute_link(name, options, props, merge) {\n\t\treturn \"<a \" + formatAttributes(\n\t\t\tcanReflect.assignMap({\n\t\t\t\thref: canRoute_url(options, merge)\n\t\t\t}, props)) + \">\" + name + \"</a>\";\n\t},\n\n\tisCurrent: function canRoute_isCurrent(options, subsetMatch) {\n\t\tvar getValueSymbol = bindingProxy.call(\"can.getValue\");\n\n\t\tif (subsetMatch) {\n\t\t\t// Everything in `options` shouhld be in `baseOptions`.\n\t\t\tvar baseOptions = routeDeparam( getValueSymbol );\n\t\t\treturn matchCheck(options, baseOptions);\n\t\t} else {\n\t\t\treturn getValueSymbol === routeParam(options);\n\t\t}\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-route/src/url-helpers.js?");

/***/ }),

/***/ "./node_modules/can-set-legacy/can-set-legacy.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-set-legacy/can-set-legacy.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// for can-set compat\nvar Query = __webpack_require__(/*! can-query-logic */ \"./node_modules/can-query-logic/can-query-logic.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar transform = __webpack_require__(/*! can-key/transform/transform */ \"./node_modules/can-key/transform/transform.js\");\nvar deleteKey = __webpack_require__(/*! can-key/delete/delete */ \"./node_modules/can-key/delete/delete.js\");\nvar getKey = __webpack_require__(/*! can-key/get/get */ \"./node_modules/can-key/get/get.js\");\nvar helpers = __webpack_require__(/*! can-query-logic/src/helpers */ \"./node_modules/can-query-logic/src/helpers.js\");\nvar makeEnum = __webpack_require__(/*! can-query-logic/src/types/make-enum */ \"./node_modules/can-query-logic/src/types/make-enum.js\");\nvar SET = __webpack_require__(/*! can-query-logic/src/set */ \"./node_modules/can-query-logic/src/set.js\");\n\nvar IsBoolean = function(){\n\n};\nmakeEnum(IsBoolean,[true, false], function(value) {\n\n    if(value === \"true\") {\n        return true;\n    } else if(value === \"false\") {\n        return false;\n    } else {\n        return value;\n    }\n\n});\n\nfunction hasKey(obj, keys, parent, parentKey) {\n    if(obj && typeof obj === \"object\") {\n        for(var key in obj) {\n            if(keys[key]) {\n                if(typeof keys[key] === \"function\") {\n                    parent[parentKey] = keys[key](obj);\n                } else {\n                    return true;\n                }\n\n            } else {\n                if( hasKey(obj[key], keys, obj, key) ) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nfunction convertToJSONAPISort(sortPropValue){\n    var parts = sortPropValue.split(' ');\n    var isDesc = (parts[1] || '').toLowerCase()\t=== 'desc';\n\n    return isDesc ? \"-\"+parts[0] : parts[0];\n}\nfunction convertToLegacySort(value) {\n    var result = helpers.sortData(value);\n    return result.desc ? \"-\"+result.prop : result.prop;\n}\n\nvar defaultAlgebra;\n\nvar set = {\n    UNIVERSAL: SET.UNIVERSAL,\n    // Nothing\n    EMPTY: SET.EMPTY,\n    // The set exists, but we lack the language to represent it.\n    UNDEFINABLE: SET.UNDEFINABLE,\n\n    // We don't know if this exists. Intersection between two paginated sets.\n    UNKNOWABLE: SET.UNKNOWABLE,\n    Algebra: function(){\n        var mutators = {\n            schema: [],\n            hydrate: [],\n            serialize: []\n        };\n        canReflect.eachIndex(arguments, function(value){\n            for(var prop in value) {\n                if(mutators[prop]) {\n                    mutators[prop].push(value[prop]);\n                } else {\n                    throw new Error(\"can-query-logic: This type of configuration is not supported. Please use can-query-logic directly.\");\n                }\n\n            }\n        });\n\n        var obj = canReflect.assignSymbols({},{\n            \"can.getSchema\": function(){\n                var schema = {\n                    kind: \"record\",\n                    identity: [],\n                    keys: {}\n                };\n                mutators.schema.forEach(function(updateSchema){\n                    updateSchema(schema);\n                });\n                if(!schema.identity.length) {\n                    schema.identity.push(\"id\");\n                }\n\n                return schema;\n            }\n        });\n        return new Query(obj, {\n            toQuery: function(data){\n                return mutators.hydrate.reduce(function(last, hydrator){\n                    return hydrator(last);\n                }, {filter: data});\n            },\n            toParams: function(data){\n                if(SET.isSpecial(data)) {\n                    return data;\n                }\n                /*if(data === SET.EMPTY) {\n                    return false;\n                }\n                if(data === SET.UNDEFINABLE) {\n                    return true;\n                }*/\n                if(Array.isArray(data.filter)){\n                    // OR is not supported ...\n                    return SET.UNDEFINABLE;\n                }\n\n                var filter = data.filter || {};\n                if(hasKey(filter, {\n                    \"$ne\": true,\n                    \"$in\": function(val){ return val.$in; }\n                })) {\n                    return SET.UNDEFINABLE;\n                }\n\n                var out = mutators.serialize.reduce(function(last, serializer){\n                    return serializer(last);\n                }, data);\n\n                filter = out.filter || {};\n                delete out.filter;\n                return canReflect.assign(out, filter);\n            }\n        });\n    },\n    Translate: function(clause, prop){\n        if(clause !== \"where\") {\n            throw new Error(\"can-query-logic/compat.Translate is only able to translate the where clause\");\n        }\n        return {\n            // {filter: {$where: {a:b}}} -> {filter: {a:b}}\n            hydrate: function(raw){\n                var clone = canReflect.serialize(raw);\n                var value = clone.filter[prop];\n                delete clone.filter[prop];\n                if(value) {\n                    canReflect.assign(clone.filter, value);\n                }\n\n                return clone;\n            },\n            // {filter: {foo:bar}} -> {filter: {where: {foo: bar}}}\n            serialize: function(query){\n\n                if(query.filter) {\n                    var clone = canReflect.serialize(query);\n                    var filter = query.filter;\n                    clone.filter = {};\n                    clone.filter[prop] = filter;\n                    return clone;\n                } else {\n                    return query;\n                }\n            }\n        };\n    },\n    props: {\n\n        boolean: function(prop){\n            // create boolean or enum\n            return {\n                schema: function(schema) {\n                    schema.keys[prop] = IsBoolean;\n                }\n            };\n        },\n        dotNotation: function(){\n            // This will be supported by default\n            return {};\n        },\n        enum: function(property, propertyValues) {\n            function Enum(){}\n            makeEnum(Enum, propertyValues);\n            return {\n                schema: function(schema) {\n                    schema.keys[property] = Enum;\n                }\n            };\n        },\n        id: function(id){\n            return {\n                \"schema\": function(schema){\n                    schema.identity.push(id);\n                }\n            };\n        },\n        offsetLimit: function(offset, limit){\n            offset = offset || \"offset\";\n            limit = limit || \"limit\";\n\n            return {\n                // taking what was given and making it a raw query look\n                // start -> page.start\n                // end -> page.end\n                hydrate: function(raw){\n                    var clone = canReflect.serialize(raw);\n                    if((offset in clone.filter) || (limit in clone.filter)) {\n                        clone.page = {};\n                    }\n                    if(offset in clone.filter) {\n                        clone.page.start = parseInt(clone.filter[offset], 10);\n                        delete clone.filter[offset];\n                    }\n                    if(limit in clone.filter) {\n                        clone.page.end = (clone.page.start || 0 ) + parseInt(clone.filter[limit], 10) - 1;\n                        delete clone.filter[limit];\n                    }\n                    return clone;\n                },\n                // taking the normal format and putting it back\n                // page.start -> start\n                // page.end -> end\n                serialize: function(raw){\n                    var clone = canReflect.serialize(raw);\n                    if(clone.page) {\n                        clone[offset] = clone.page.start;\n                        clone[limit] = (clone.page.end - clone.page.start) + 1;\n                        delete clone.page;\n                    }\n                    return clone;\n                }\n            };\n        },\n        rangeInclusive: function(start, end){\n            var hydrateTransfomer = {};\n            hydrateTransfomer[\"filter.\"+start] = \"page.start\";\n            hydrateTransfomer[\"filter.\"+end] = \"page.end\";\n\n            var serializeTransformer = {\n                \"page.start\": start,\n                \"page.end\": end\n            };\n            return {\n                // taking what was given and making it a raw query look\n                // start -> page.start\n                // end -> page.end\n                hydrate: function(raw){\n                    var res = transform(raw, hydrateTransfomer);\n                    if(res.page) {\n                        if(res.page.start) {\n                            res.page.start = parseInt(res.page.start, 10);\n                        }\n                        if(res.page.end) {\n                            res.page.end = parseInt(res.page.end, 10);\n                        }\n                    }\n                    return res;\n                },\n                // taking the normal format and putting it back\n                // page.start -> start\n                // page.end -> end\n                serialize: function(raw){\n                    return transform(raw, serializeTransformer);\n                }\n            };\n        },\n        ignore: function(prop){\n            return {\n                hydrate: function(raw){\n                    var clone = canReflect.serialize(raw);\n                    delete clone.filter[prop];\n                    return clone;\n                }\n            };\n        },\n        sort: function(prop, sortFunc){\n            /**\n             * var parts = sortPropValue.split(' ');\n                 return {\n                     prop: parts[0],\n                     desc: (parts[1] || '').toLowerCase()\t=== 'desc'\n                 };\n             */\n            if(!prop) {\n                prop = \"sort\";\n            }\n            if(sortFunc) {\n                throw new Error(\"can-query-logic/compat.sort - sortFunc is not supported\");\n            }\n\n            return {\n                hydrate: function(raw){\n                    var clone = canReflect.serialize(raw);\n                    var sort = getKey(clone,\"filter.\"+prop);\n                    if(sort !== undefined) {\n                        deleteKey(clone,\"filter.\"+prop);\n                        clone.sort = convertToJSONAPISort(sort);\n                    }\n\n                    return clone;\n                },\n                serialize: function(raw){\n                    var clone = canReflect.serialize(raw);\n                    var sort = clone.sort;\n                    if(sort !== undefined) {\n                        delete clone.sort;\n                        clone[prop] = convertToLegacySort(sort);\n                    }\n                    return clone;\n                }\n            };\n        }\n    }\n};\n\nfunction makeAlgebra(algebra) {\n    if(!algebra) {\n        return defaultAlgebra;\n    }\n    else if(!(algebra instanceof Query) ) {\n        return new set.Algebra(algebra);\n    }\n    return algebra;\n}\n\nfunction makeFromTwoQueries(prop) {\n    set[prop] = function( a, b, algebra ){\n        return makeAlgebra(algebra)[prop](a, b);\n    };\n}\nmakeFromTwoQueries(\"difference\");\nmakeFromTwoQueries(\"union\");\nmakeFromTwoQueries(\"intersection\");\nmakeFromTwoQueries(\"isSubset\");\nmakeFromTwoQueries(\"isEqual\");\nmakeFromTwoQueries(\"isProperSubset\");\n\nset.count = function(query, algebra) {\n    return makeAlgebra(algebra).count(query);\n};\n\nset.comparators = set.props;\n\ndefaultAlgebra = new set.Algebra();\n\nmodule.exports = set;\n\n\n//# sourceURL=webpack:///./node_modules/can-set-legacy/can-set-legacy.js?");

/***/ }),

/***/ "./node_modules/can-simple-map/can-simple-map.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-simple-map/can-simple-map.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Construct = __webpack_require__(/*! can-construct */ \"./node_modules/can-construct/can-construct.js\");\nvar eventQueue = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\n// Ensure the \"obj\" passed as an argument has an object on @@can.meta\nvar ensureMeta = function ensureMeta(obj) {\n\tvar metaSymbol = canSymbol.for(\"can.meta\");\n\tvar meta = obj[metaSymbol];\n\n\tif (!meta) {\n\t\tmeta = {};\n\t\tcanReflect.setKeyValue(obj, metaSymbol, meta);\n\t}\n\n\treturn meta;\n};\n\n// this is a very simple can-map like object\nvar SimpleMap = Construct.extend(\"SimpleMap\",\n\t{\n\t\t// ### setup\n\t\t// A setup function for the instantiation of a simple-map.\n\t\tsetup: function(initialData){\n\t\t\tthis._data = {};\n\t\t\tif(initialData && typeof initialData === \"object\") {\n\t\t\t\tthis.attr(initialData);\n\t\t\t}\n\t\t},\n\t\t// ### attr\n\t\t// The main get/set interface simple-map.\n\t\t// Either sets or gets one or more properties depending on how it is called.\n\t\tattr: function(prop, value) {\n\t\t\tvar self = this;\n\n\t\t\tif(arguments.length === 0 ) {\n\t\t\t\tObservationRecorder.add(this,\"can.keys\");\n\t\t\t\tvar data = {};\n\t\t\t\tcanReflect.eachKey(this._data, function(value, prop){\n\t\t\t\t\tObservationRecorder.add(this, prop);\n\t\t\t\t\tdata[prop] = value;\n\t\t\t\t}, this);\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\telse if(arguments.length > 1) {\n\t\t\t\tvar had = this._data.hasOwnProperty(prop);\n\t\t\t\tvar old = this._data[prop];\n\t\t\t\tthis._data[prop] = value;\n\t\t\t\tif(old !== value) {\n\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\t\t\t\tthis._log(prop, value, old);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tvar dispatched = {\n\t\t\t\t\t\tkeyChanged: !had ? prop : undefined,\n\t\t\t\t\t\ttype: prop\n\t\t\t\t\t};\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tdispatched = {\n\t\t\t\t\t\t\tkeyChanged: !had ? prop : undefined,\n\t\t\t\t\t\t\ttype: prop,\n\t\t\t\t\t\t\treasonLog: [ canReflect.getName(this) + \"'s\", prop, \"changed to\", value, \"from\", old ],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tthis.dispatch(dispatched, [value, old]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// 1 argument\n\t\t\telse if(typeof prop === 'object') {\n\t\t\t\tqueues.batch.start();\n\t\t\t\tcanReflect.eachKey(prop, function(value, key) {\n\t\t\t\t\tself.attr(key, value);\n\t\t\t\t});\n\t\t\t\tqueues.batch.stop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(prop !== \"constructor\") {\n\t\t\t\t\tObservationRecorder.add(this, prop);\n\t\t\t\t\treturn this._data[prop];\n\t\t\t\t}\n\n\t\t\t\treturn this.constructor;\n\t\t\t}\n\t\t},\n\t\tserialize: function(){\n\t\t\treturn canReflect.serialize(this, Map);\n\t\t},\n\t\tget: function(){\n\t\t\treturn this.attr.apply(this, arguments);\n\t\t},\n\t\tset: function(){\n\t\t\treturn this.attr.apply(this, arguments);\n\t\t},\n\t\t// call `.log()` to log all property changes\n\t\t// pass a single property to only get logs for said property, e.g: `.log(\"foo\")`\n\t\tlog: function(key) {\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tvar quoteString = function quoteString(x) {\n\t\t\t\t\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n\t\t\t\t};\n\t\t\t\tvar meta = ensureMeta(this);\n\t\t\t\tmeta.allowedLogKeysSet = meta.allowedLogKeysSet || new Set();\n\n\t\t\t\tif (key) {\n\t\t\t\t\tmeta.allowedLogKeysSet.add(key);\n\t\t\t\t}\n\n\t\t\t\tthis._log = function(prop, current, previous, log) {\n\t\t\t\t\tif (key && !meta.allowedLogKeysSet.has(prop)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdev.log(\n\t\t\t\t\t\tcanReflect.getName(this),\n\t\t\t\t\t\t\"\\n key \", quoteString(prop),\n\t\t\t\t\t\t\"\\n is  \", quoteString(current),\n\t\t\t\t\t\t\"\\n was \", quoteString(previous)\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\t}\n);\n\neventQueue(SimpleMap.prototype);\n\nvar simpleMapProto = {\n\t// -type-\n\t\"can.isMapLike\": true,\n\t\"can.isListLike\": false,\n\t\"can.isValueLike\": false,\n\n\t// -get/set-\n\t\"can.getKeyValue\": SimpleMap.prototype.get,\n\t\"can.setKeyValue\": SimpleMap.prototype.set,\n\t\"can.deleteKeyValue\": function(prop) {\n\t\tvar dispatched;\n\t\tif( this._data.hasOwnProperty(prop) ) {\n\t\t\tvar old = this._data[prop];\n\t\t\tdelete this._data[prop];\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\t\tthis._log(prop, undefined, old);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tdispatched = {\n\t\t\t\tkeyChanged: prop,\n\t\t\t\ttype: prop\n\t\t\t};\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tdispatched = {\n\t\t\t\t\tkeyChanged: prop,\n\t\t\t\t\ttype: prop,\n\t\t\t\t\treasonLog: [ canReflect.getName(this) + \"'s\", prop, \"deleted\", old ]\n\t\t\t\t};\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tthis.dispatch(dispatched, [undefined, old]);\n\t\t}\n\t},\n\n\n\t// -shape\n\t\"can.getOwnEnumerableKeys\": function(){\n\t\tObservationRecorder.add(this, 'can.keys');\n\t\treturn Object.keys(this._data);\n\t},\n\n\t// -shape get/set-\n\t\"can.assignDeep\": function(source){\n\t\tqueues.batch.start();\n\t\t// TODO: we should probably just throw an error instead of cleaning\n\t\tcanReflect.assignMap(this, source);\n\t\tqueues.batch.stop();\n\t},\n\t\"can.updateDeep\": function(source){\n\t\tqueues.batch.start();\n\t\t// TODO: we should probably just throw an error instead of cleaning\n\t\tcanReflect.updateMap(this, source);\n\t\tqueues.batch.stop();\n\t},\n\t\"can.keyHasDependencies\": function(key) {\n\t\treturn false;\n\t},\n\t\"can.getKeyDependencies\": function(key) {\n\t\treturn undefined;\n\t},\n\t\"can.hasOwnKey\": function(key){\n\t\treturn this._data.hasOwnProperty(key);\n\t}\n};\n\n//!steal-remove-start\nif (true) {\n\tsimpleMapProto[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"{}\";\n\t};\n}\n//!steal-remove-end\ncanReflect.assignSymbols(SimpleMap.prototype,simpleMapProto);\n\n// Setup other symbols\n\n\nmodule.exports = SimpleMap;\n\n\n//# sourceURL=webpack:///./node_modules/can-simple-map/can-simple-map.js?");

/***/ }),

/***/ "./node_modules/can-simple-observable/async/async.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-simple-observable/async/async.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar SimpleObservable = __webpack_require__(/*! ../can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar SettableObservable = __webpack_require__(/*! ../settable/settable */ \"./node_modules/can-simple-observable/settable/settable.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"./node_modules/can-event-queue/value/value.js\");\n\n// This is an observable that is like `settable`, but passed a `resolve`\n// function that can resolve the value of this observable late.\nfunction AsyncObservable(fn, context, initialValue) {\n\tthis.resolve = this.resolve.bind(this);\n\tthis.lastSetValue = new SimpleObservable(initialValue);\n\tthis.handler = this.handler.bind(this);\n\n\tfunction observe() {\n\t\tthis.resolveCalled = false;\n\n\t\t// set inGetter flag to avoid calling `resolve` redundantly if it is called\n\t\t// synchronously in the getter\n\t\tthis.inGetter = true;\n\t\tvar newVal = fn.call(\n\t\t\tcontext,\n\t\t\tthis.lastSetValue.get(),\n\t\t\tthis.bound === true ? this.resolve : undefined\n\t\t);\n\t\tthis.inGetter = false;\n\n\t\t// if the getter returned a value, resolve with the value\n\t\tif (newVal !== undefined) {\n\t\t\tthis.resolve(newVal);\n\t\t}\n\t\t// otherwise, if `resolve` was called synchronously in the getter,\n\t\t// resolve with the value passed to `resolve`\n\t\telse if (this.resolveCalled) {\n\t\t\tthis.resolve(this._value);\n\t\t}\n\n\t\t// if bound, the handlers will be called by `resolve`\n\t\t// returning here would cause a duplicate event\n\t\tif (this.bound !== true) {\n\t\t\treturn newVal;\n\t\t}\n\t}\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor) +\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(fn) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.handler, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".handler\"\n\t\t});\n\t\tObject.defineProperty(observe, \"name\", {\n\t\t\tvalue: canReflect.getName(fn) + \"::\" + canReflect.getName(this.constructor)\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tthis.observation = new Observation(observe, this);\n}\nAsyncObservable.prototype = Object.create(SettableObservable.prototype);\nAsyncObservable.prototype.constructor = AsyncObservable;\n\nAsyncObservable.prototype.handler = function(newVal) {\n\tif (newVal !== undefined) {\n\t\tSettableObservable.prototype.handler.apply(this, arguments);\n\t}\n};\n\nvar peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));\nAsyncObservable.prototype.activate = function() {\n\tcanReflect.onValue(this.observation, this.handler, \"notify\");\n\tif (!this.resolveCalled) {\n\t\tthis._value = peek(this.observation);\n\t}\n};\n\nAsyncObservable.prototype.resolve = function resolve(newVal) {\n\tthis.resolveCalled = true;\n\tvar old = this._value;\n\tthis._value = newVal;\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tif (typeof this._log === \"function\") {\n\t\t\tthis._log(old, newVal);\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// if resolve was called synchronously from the getter, do not enqueue changes\n\t// the observation will handle calling resolve again if required\n\tif (!this.inGetter) {\n\t\tvar queuesArgs = [\n\t\tthis.handlers.getNode([]),\n\t\t\tthis,\n\t\t\t[newVal, old],\n\t\t\tnull\n\t\t];\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\tthis,\n\t\t\t\t[newVal, old],\n\t\t\t\tnull\n\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t, [canReflect.getName(this), \"resolved with\", newVal]\n\t\t\t\t/* jshint laxcomma: false */\n\t\t\t];\n\t\t}\n\t\t//!steal-remove-end\n\t\t// adds callback handlers to be called w/i their respective queue.\n\t\tqueues.enqueueByQueue.apply(queues, queuesArgs);\n\t}\n};\n\nmodule.exports = AsyncObservable;\n\n\n//# sourceURL=webpack:///./node_modules/can-simple-observable/async/async.js?");

/***/ }),

/***/ "./node_modules/can-simple-observable/can-simple-observable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-simple-observable/can-simple-observable.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar log = __webpack_require__(/*! ./log */ \"./node_modules/can-simple-observable/log.js\");\nvar ns = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"./node_modules/can-event-queue/value/value.js\");\n\nvar dispatchSymbol = canSymbol.for(\"can.dispatch\");\n\n/**\n * @module {function} can-simple-observable\n * @parent can-observables\n * @collection can-infrastructure\n * @package ./package.json\n * @description Create an observable value.\n *\n * @signature `new SimpleObservable(initialValue)`\n *\n * Creates an observable value that can be read, written, and observed using [can-reflect].\n *\n * @param {*} initialValue The initial value of the observable.\n *\n * @return {can-simple-observable} An observable instance\n *\n * @body\n *\n * ## Use\n *\n * ```js\n *  var obs = new SimpleObservable('one');\n *\n *  canReflect.getValue(obs); // -> \"one\"\n *\n *  canReflect.setValue(obs, 'two');\n *  canReflect.getValue(obs); // -> \"two\"\n *\n *  function handler(newValue) {\n *    // -> \"three\"\n *  };\n *  canReflect.onValue(obs, handler);\n *  canReflect.setValue(obs, 'three');\n *\n *  canReflect.offValue(obs, handler);\n * ```\n */\nfunction SimpleObservable(initialValue) {\n\tthis._value = initialValue;\n}\n\n// mix in the value-like object event bindings\nvalueEventBindings(SimpleObservable.prototype);\n\ncanReflect.assignMap(SimpleObservable.prototype, {\n\tlog: log,\n\tget: function(){\n\t\tObservationRecorder.add(this);\n\t\treturn this._value;\n\t},\n\tset: function(value){\n\t\tvar old = this._value;\n\t\tthis._value = value;\n\n\t\tthis[dispatchSymbol](value, old);\n\t}\n});\nObject.defineProperty(SimpleObservable.prototype,\"value\",{\n\tset: function(value){\n\t\treturn this.set(value);\n\t},\n\tget: function(){\n\t\treturn this.get();\n\t}\n});\n\nvar simpleObservableProto = {\n\t\"can.getValue\": SimpleObservable.prototype.get,\n\t\"can.setValue\": SimpleObservable.prototype.set,\n\t\"can.isMapLike\": false,\n\t\"can.valueHasDependencies\": function(){\n\t\treturn true;\n\t}\n};\n\n//!steal-remove-start\nif (true) {\n\tsimpleObservableProto[\"can.getName\"] = function() {\n\t\tvar value = this._value;\n\t\tif (typeof value !== 'object' || value === null) {\n\t\t\tvalue = JSON.stringify(value);\n\t\t}\n\t\telse {\n\t\t\tvalue = '';\n\t\t}\n\n\t\treturn canReflect.getName(this.constructor) + \"<\" + value + \">\";\n\t};\n}\n//!steal-remove-end\n\ncanReflect.assignSymbols(SimpleObservable.prototype, simpleObservableProto);\n\nmodule.exports = ns.SimpleObservable = SimpleObservable;\n\n\n//# sourceURL=webpack:///./node_modules/can-simple-observable/can-simple-observable.js?");

/***/ }),

/***/ "./node_modules/can-simple-observable/key/key.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-simple-observable/key/key.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canKey = __webpack_require__(/*! can-key */ \"./node_modules/can-key/can-key.js\");\nvar canKeyUtils = __webpack_require__(/*! can-key/utils */ \"./node_modules/can-key/utils.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\n\n//!steal-remove-start\nif (true) {\n\tvar canReflectDependencies = __webpack_require__(/*! can-reflect-dependencies */ \"./node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\n}\n//!steal-remove-end\n\nmodule.exports = function keyObservable(root, keyPath) {\n\tvar keyPathParts = canKeyUtils.parts(keyPath);\n\tvar lastIndex = keyPathParts.length - 1;\n\n\t// Some variables used to build the dependency/mutation graph\n\t//!steal-remove-start\n\tif (true) {\n\t\tvar lastKey;// This stores the last part of the keyPath, e.g. â€œkeyâ€ in â€œouter.inner.keyâ€\n\t\tvar lastParent;// This stores the object that the last key is on, e.g. â€œouter.innerâ€ in outer: {inner: {\"key\": \"value\"}}\n\t}\n\t//!steal-remove-end\n\n\tvar observation = new Observation(function() {\n\t\tvar value;\n\n\t\t// This needs to be walked every time because the objects along the key path might change\n\t\tcanKey.walk(root, keyPathParts, function(keyData, i) {\n\t\t\tif (i === lastIndex) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\t// observation is mutating keyData.parent\n\t\t\t\t\tif (lastParent && (keyData.key !== lastKey || keyData.parent !== lastParent)) {\n\t\t\t\t\t\tcanReflectDependencies.deleteMutatedBy(lastParent, lastKey, observation);\n\t\t\t\t\t}\n\t\t\t\t\tlastKey = keyData.key;\n\t\t\t\t\tlastParent = keyData.parent;\n\t\t\t\t\tcanReflectDependencies.addMutatedBy(lastParent, lastKey, observation);\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\tvalue = keyData.value;\n\t\t\t}\n\t\t});\n\n\t\treturn value;\n\t});\n\n\t// Function for setting the value\n\tvar valueSetter = function(newVal) {\n\t\tcanKey.set(root, keyPathParts, newVal);\n\t};\n\n\t// The `value` property getter & setter\n\tObject.defineProperty(observation, \"value\", {\n\t\tget: observation.get,\n\t\tset: valueSetter\n\t});\n\n\tvar symbolsToAssign = {\n\t\t\"can.setValue\": valueSetter\n\t};\n\n\t//!steal-remove-start\n\tif (true) {\n\n\t\t// Debug name\n\t\tsymbolsToAssign[\"can.getName\"] = function getName() {\n\t\t\tvar objectName = canReflect.getName(root);\n\t\t\treturn \"keyObservable<\" + objectName + \".\" + keyPath + \">\";\n\t\t};\n\n\t\t// Register what this observable changes\n\t\tsymbolsToAssign[\"can.getWhatIChange\"] = function getWhatIChange() {\n\t\t\tvar m = new Map();\n\t\t\tvar s = new Set();\n\t\t\ts.add(lastKey);\n\t\t\tm.set(lastParent, s);\n\t\t\treturn {\n\t\t\t\tmutate: {\n\t\t\t\t\tkeyDependencies: m\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\t//!steal-remove-end\n\n\treturn canReflect.assignSymbols(observation, symbolsToAssign);\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-simple-observable/key/key.js?");

/***/ }),

/***/ "./node_modules/can-simple-observable/log.js":
/*!***************************************************!*\
  !*** ./node_modules/can-simple-observable/log.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\n// when printing out strings to the console, quotes are not included which\n// makes it confusing to tell the actual output from static string messages\nfunction quoteString(x) {\n\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n}\n\n// To add the `.log` function to a observable\n// a.- Add the log function to the propotype:\n//\t   `Observable.propotype.log = log`\n// b.- Make sure `._log` is called by the observable when mutation happens\n//     `_.log` should be passed the current value and the value before the mutation\nmodule.exports = function log() {\n\t//!steal-remove-start\n\tif (true) {\n\t\tthis._log = function(previous, current) {\n\t\t\tdev.log(\n\t\t\t\tcanReflect.getName(this),\n\t\t\t\t\"\\n is  \", quoteString(current),\n\t\t\t\t\"\\n was \", quoteString(previous)\n\t\t\t);\n\t\t};\n\t}\n\t//!steal-remove-end\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-simple-observable/log.js?");

/***/ }),

/***/ "./node_modules/can-simple-observable/make-compute/make-compute.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-simple-observable/make-compute/make-compute.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar Compute = function(newVal) {\n\tif (arguments.length) {\n\t\treturn canReflect.setValue(this, newVal);\n\t} else {\n\t\treturn canReflect.getValue(this);\n\t}\n};\n\nvar translationHelpers = new WeakMap();\n\nmodule.exports = function(observable) {\n\tvar compute = Compute.bind(observable);\n\tcompute.on = compute.bind = compute.addEventListener = function(\n\t\tevent,\n\t\thandler\n\t) {\n\t\tvar translationHandler = translationHelpers.get(handler);\n\t\tif (!translationHandler) {\n\t\t\ttranslationHandler = function(newVal, oldVal) {\n\t\t\t\thandler.call(compute, { type: \"change\" }, newVal, oldVal);\n\t\t\t};\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tObject.defineProperty(translationHandler, \"name\", {\n\t\t\t\t\tvalue:\n\t\t\t\t\t\t\"translationHandler(\" +\n\t\t\t\t\t\tevent +\n\t\t\t\t\t\t\")::\" +\n\t\t\t\t\t\tcanReflect.getName(observable) +\n\t\t\t\t\t\t\".onValue(\" +\n\t\t\t\t\t\tcanReflect.getName(handler) +\n\t\t\t\t\t\t\")\"\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\ttranslationHelpers.set(handler, translationHandler);\n\t\t}\n\t\tcanReflect.onValue(observable, translationHandler);\n\t};\n\tcompute.off = compute.unbind = compute.removeEventListener = function(\n\t\tevent,\n\t\thandler\n\t) {\n\t\tcanReflect.offValue(observable, translationHelpers.get(handler));\n\t};\n\n\tcanReflect.assignSymbols(compute, {\n\t\t\"can.getValue\": function() {\n\t\t\treturn canReflect.getValue(observable);\n\t\t},\n\t\t\"can.setValue\": function(newVal) {\n\t\t\treturn canReflect.setValue(observable, newVal);\n\t\t},\n\t\t\"can.onValue\": function(handler, queue) {\n\t\t\treturn canReflect.onValue(observable, handler, queue);\n\t\t},\n\t\t\"can.offValue\": function(handler, queue) {\n\t\t\treturn canReflect.offValue(observable, handler, queue);\n\t\t},\n\t\t\"can.valueHasDependencies\": function() {\n\t\t\treturn canReflect.valueHasDependencies(observable);\n\t\t},\n\t\t\"can.getPriority\": function() {\n\t\t\treturn canReflect.getPriority(observable);\n\t\t},\n\t\t\"can.setPriority\": function(newPriority) {\n\t\t\tcanReflect.setPriority(observable, newPriority);\n\t\t},\n\t\t\"can.isValueLike\": true,\n\t\t\"can.isFunctionLike\": false\n\t});\n\tcompute.isComputed = true;\n\treturn compute;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-simple-observable/make-compute/make-compute.js?");

/***/ }),

/***/ "./node_modules/can-simple-observable/resolver/resolver.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-simple-observable/resolver/resolver.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar mapEventBindings = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\nvar SettableObservable = __webpack_require__(/*! ../settable/settable */ \"./node_modules/can-simple-observable/settable/settable.js\");\nvar SimpleObservable = __webpack_require__(/*! ../can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\n\nvar getChangesSymbol = canSymbol.for(\"can.getChangesDependencyRecord\");\nvar metaSymbol = canSymbol.for(\"can.meta\");\n\nfunction ResolverObservable(resolver, context, initialValue, options) {\n\t// we don't want reads leaking out.  We should be binding to all of this ourselves.\n\tthis.resolver = ObservationRecorder.ignore(resolver);\n\tthis.context = context;\n\tthis._valueOptions = {\n\t\tresolve: this.resolve.bind(this),\n\t\tlistenTo: this.listenTo.bind(this),\n\t\tstopListening: this.stopListening.bind(this),\n\t\tlastSet: new SimpleObservable(initialValue)\n\t};\n\n\tthis.update = this.update.bind(this);\n\n\tthis.contextHandlers = new WeakMap();\n\tthis.teardown = null;\n\t// a place holder for remembering where we bind\n\tthis.binder = {};\n\t//!steal-remove-start\n\tif (true) {\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor) +\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(resolver) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.update, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".update\"\n\t\t});\n\n\t\tcanReflect.assignSymbols(this._valueOptions.lastSet, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor)  +\"::lastSet\"+\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(resolver) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tthis[metaSymbol] = canReflect.assignMap({}, options);\n}\nResolverObservable.prototype = Object.create(SettableObservable.prototype);\n\nfunction deleteHandler(bindTarget, event, queue, handler){\n\tmapEventBindings.off.call(bindTarget, event, handler, queue);\n}\n\ncanReflect.assignMap(ResolverObservable.prototype, {\n\tconstructor: ResolverObservable,\n\tlistenTo: function(bindTarget, event, handler, queueName) {\n\t\t//Object.defineProperty(this.handler, \"name\", {\n\t\t//\tvalue: canReflect.getName(this) + \".handler\"\n\t\t//});\n\t\tif(canReflect.isPrimitive(bindTarget)) {\n\t\t\thandler = event;\n\t\t\tevent = bindTarget;\n\t\t\tbindTarget = this.context;\n\t\t}\n\t\tif(typeof event === \"function\") {\n\t\t\thandler = event;\n\t\t\tevent = undefined;\n\t\t}\n\n\t\tvar resolverInstance = this;\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif(!handler.name) {\n\t\t\t\tObject.defineProperty(handler, \"name\", {\n\t\t\t\t\tvalue:\n\t\t\t\t\t\t(bindTarget ?\n\t\t\t\t\t\t\t canReflect.getName(bindTarget) : \"\")+\n\t\t\t\t\t\t (event ? \".on('\"+event+\"',handler)\" : \".on(handler)\")+\n\t\t\t\t\t\t \"::\"+canReflect.getName(this)\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tvar contextHandler = handler.bind(this.context);\n\t\tcontextHandler[getChangesSymbol] = function getChangesDependencyRecord() {\n\t\t\tvar s = new Set();\n\t\t\ts.add(resolverInstance);\n\t\t\treturn {\n\t\t\t\tvalueDependencies: s\n\t\t\t};\n\t\t};\n\n\t\tthis.contextHandlers.set(handler, contextHandler);\n\t\tmapEventBindings.listenTo.call(this.binder, bindTarget, event, contextHandler, queueName || \"notify\");\n\t},\n\tstopListening: function(){\n\n\t\tvar meta = this.binder[canSymbol.for(\"can.meta\")];\n\t\tvar listenHandlers = meta && meta.listenHandlers;\n\t\tif(listenHandlers) {\n\t\t\tvar keys = mapEventBindings.stopListeningArgumentsToKeys.call({context: this.context, defaultQueue: \"notify\"});\n\n\t\t\tlistenHandlers.delete(keys, deleteHandler);\n\t\t}\n\t\treturn this;\n\t},\n\tresolve: function(newVal) {\n\t\tthis._value = newVal;\n\t\t// if we are setting up the initial binding and we get a resolved value\n\t\t// do not emit events for it.\n\n\t\tif(this.isBinding) {\n\t\t\tthis.lastValue = this._value;\n\t\t\treturn newVal;\n\t\t}\n\n\t\tif(this._value !== this.lastValue) {\n\t\t\tvar enqueueMeta  = {};\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\tenqueueMeta = {\n\t\t\t\t\tlog: [canReflect.getName(this.update)],\n\t\t\t\t\treasonLog: [canReflect.getName(this), \"resolved with\", newVal]\n\t\t\t\t};\n\t\t\t\t/* jshint laxcomma: false */\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tqueues.batch.start();\n\t\t\tqueues.deriveQueue.enqueue(\n\t\t\t\tthis.update,\n\t\t\t\tthis,\n\t\t\t\t[],\n\t\t\t\tenqueueMeta\n\t\t\t);\n\t\t\tqueues.batch.stop();\n\t\t}\n\t\treturn newVal;\n\t},\n\tupdate: function(){\n\n\t\tif(this.lastValue !== this._value) {\n\n\t\t\tvar old = this.lastValue;\n\t\t\tthis.lastValue = this._value;\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\t\tthis._log(old, this._value);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\t// adds callback handlers to be called w/i their respective queue.\n\t\t\tqueues.enqueueByQueue(\n\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\tthis,\n\t\t\t\t[this._value, old]\n\t\t\t);\n\t\t}\n\t},\n\tactivate: function() {\n\t\tthis.isBinding = true;\n\t\tthis.teardown = this.resolver.call(this.context, this._valueOptions);\n\t\tthis.isBinding = false;\n\t},\n\tonUnbound: function() {\n\t\tthis.bound = false;\n\t\tmapEventBindings.stopListening.call(this.binder);\n\t\tif(this.teardown != null) {\n\t\t\tthis.teardown();\n\t\t\tthis.teardown = null;\n\t\t}\n\t},\n\tset: function(value) {\n\t\tthis._valueOptions.lastSet.set(value);\n\n\t\t/*if (newVal !== this.lastSetValue.get()) {\n\t\t\tthis.lastSetValue.set(newVal);\n\t\t}*/\n\t},\n\tget: function() {\n\t\tif (ObservationRecorder.isRecording()) {\n\t\t\tObservationRecorder.add(this);\n\t\t\tif (!this.bound) {\n\t\t\t\tthis.onBound();\n\t\t\t}\n\t\t}\n\n\t\tif (this.bound === true) {\n\t\t\treturn this._value;\n\t\t} else {\n\t\t\tif (this[metaSymbol].resetUnboundValueInGet) {\n\t\t\t\tthis._value = undefined;\n\t\t\t}\n\n\t\t\tvar handler = function(){};\n\t\t\tthis.on(handler);\n\t\t\tvar val = this._value;\n\t\t\tthis.off(handler);\n\t\t\treturn val;\n\t\t}\n\t},\n\thasDependencies: function hasDependencies() {\n\t\tvar hasDependencies = false;\n\n\t\tif (this.bound) {\n\t\t\tvar meta = this.binder[metaSymbol];\n\t\t\tvar listenHandlers = meta && meta.listenHandlers;\n\t\t\thasDependencies = !!listenHandlers.size();\n\t\t}\n\n\t\treturn hasDependencies;\n\t},\n\tgetValueDependencies: function getValueDependencies() {\n\t\tif (this.bound) {\n\t\t\tvar meta = this.binder[canSymbol.for(\"can.meta\")];\n\t\t\tvar listenHandlers = meta && meta.listenHandlers;\n\n\t\t\tvar keyDeps = new Map();\n\t\t\tvar valueDeps = new Set();\n\n\t\t\tif (listenHandlers) {\n\t\t\t\tcanReflect.each(listenHandlers.root, function(events, obj) {\n\t\t\t\t\tcanReflect.each(events, function(queues, eventName) {\n\t\t\t\t\t\tif (eventName === undefined) {\n\t\t\t\t\t\t\tvalueDeps.add(obj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar entry = keyDeps.get(obj);\n\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\tentry = new Set();\n\t\t\t\t\t\t\t\tkeyDeps.set(obj, entry);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry.add(eventName);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tif (valueDeps.size || keyDeps.size) {\n\t\t\t\t\tvar result = {};\n\n\t\t\t\t\tif (keyDeps.size) {\n\t\t\t\t\t\tresult.keyDependencies = keyDeps;\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDeps.size) {\n\t\t\t\t\t\tresult.valueDependencies = valueDeps;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\ncanReflect.assignSymbols(ResolverObservable.prototype, {\n\t\"can.getValue\": ResolverObservable.prototype.get,\n\t\"can.setValue\": ResolverObservable.prototype.set,\n\t\"can.isMapLike\": false,\n\t\"can.getPriority\": function() {\n\t\t// TODO: the priority should come from any underlying values\n\t\treturn this.priority || 0;\n\t},\n\t\"can.setPriority\": function(newPriority) {\n\t\tthis.priority = newPriority;\n\t},\n\t\"can.valueHasDependencies\": ResolverObservable.prototype.hasDependencies,\n\t\"can.getValueDependencies\": ResolverObservable.prototype.getValueDependencies\n});\n\n\nmodule.exports = ResolverObservable;\n\n\n//# sourceURL=webpack:///./node_modules/can-simple-observable/resolver/resolver.js?");

/***/ }),

/***/ "./node_modules/can-simple-observable/settable/settable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-simple-observable/settable/settable.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar SimpleObservable = __webpack_require__(/*! ../can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar log = __webpack_require__(/*! ../log */ \"./node_modules/can-simple-observable/log.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"./node_modules/can-event-queue/value/value.js\");\n\nvar peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));\n\n// This supports an \"internal\" settable value that the `fn` can derive its value from.\n// It's useful to `can-define`.\n// ```\n// new SettableObservable(function(lastSet){\n//   return lastSet * 5;\n// }, null, 5)\n// ```\nfunction SettableObservable(fn, context, initialValue) {\n\n\tthis.lastSetValue = new SimpleObservable(initialValue);\n\tfunction observe() {\n\t\treturn fn.call(context, this.lastSetValue.get());\n\t}\n\tthis.handler = this.handler.bind(this);\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor) +\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(fn) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.handler, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".handler\"\n\t\t});\n\t\tObject.defineProperty(observe, \"name\", {\n\t\t\tvalue: canReflect.getName(fn) + \"::\" + canReflect.getName(this.constructor)\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tthis.observation = new Observation(observe, this);\n}\n\nvalueEventBindings(SettableObservable.prototype);\n\ncanReflect.assignMap(SettableObservable.prototype, {\n\t// call `obs.log()` to log observable changes to the browser console\n\t// The observable has to be bound for `.log` to be called\n\tlog: log,\n\tconstructor: SettableObservable,\n\thandler: function(newVal) {\n\t\tvar old = this._value, reasonLog;\n\t\tthis._value = newVal;\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\tthis._log(old, newVal);\n\t\t\t}\n\t\t\treasonLog = [canReflect.getName(this),\"set to\", newVal, \"from\", old];\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// adds callback handlers to be called w/i their respective queue.\n\t\tqueues.enqueueByQueue(\n\t\t\tthis.handlers.getNode([]),\n\t\t\tthis,\n\t\t\t[newVal, old],\n\t\t\tnull,\n\t\t\treasonLog\n\t\t);\n\t},\n\tonBound: function() {\n\t\t// onBound can be called by `.get` and then later called through\n\t\t// a keyTree binding.\n\t\tif(!this.bound) {\n\t\t\tthis.bound = true;\n\t\t\tthis.activate();\n\t\t}\n\t},\n\tactivate: function(){\n\t\tcanReflect.onValue(this.observation, this.handler, \"notify\");\n\t\tthis._value = peek(this.observation);\n\t},\n\tonUnbound: function() {\n\t\tthis.bound = false;\n\t\tcanReflect.offValue(this.observation, this.handler, \"notify\");\n\t},\n\tset: function(newVal) {\n\t\tvar oldVal =  this.lastSetValue.get();\n\n\t\tif (\n\t\t\tcanReflect.isObservableLike(oldVal) &&\n\t\t\tcanReflect.isValueLike(oldVal) &&\n\t\t\t!canReflect.isObservableLike(newVal)\n\t\t) {\n\t\t\tcanReflect.setValue(oldVal, newVal);\n\t\t} else {\n\t\t\tif (newVal !== oldVal) {\n\t\t\t\tthis.lastSetValue.set(newVal);\n\t\t\t}\n\t\t}\n\t},\n\tget: function() {\n\t\tif (ObservationRecorder.isRecording()) {\n\t\t\tObservationRecorder.add(this);\n\t\t\tif (!this.bound) {\n\t\t\t\t// proactively setup bindings\n\t\t\t\tthis.onBound();\n\t\t\t}\n\t\t}\n\n\t\tif (this.bound === true) {\n\t\t\treturn this._value;\n\t\t} else {\n\t\t\treturn this.observation.get();\n\t\t}\n\t},\n\thasDependencies: function() {\n\t\treturn canReflect.valueHasDependencies(this.observation);\n\t},\n\tgetValueDependencies: function() {\n\t\treturn canReflect.getValueDependencies(this.observation);\n\t}\n});\n\nObject.defineProperty(SettableObservable.prototype,\"value\",{\n\tset: function(value){\n\t\treturn this.set(value);\n\t},\n\tget: function(){\n\t\treturn this.get();\n\t}\n});\n\ncanReflect.assignSymbols(SettableObservable.prototype, {\n\t\"can.getValue\": SettableObservable.prototype.get,\n\t\"can.setValue\": SettableObservable.prototype.set,\n\t\"can.isMapLike\": false,\n\t\"can.getPriority\": function() {\n\t\treturn canReflect.getPriority(this.observation);\n\t},\n\t\"can.setPriority\": function(newPriority) {\n\t\tcanReflect.setPriority(this.observation, newPriority);\n\t},\n\t\"can.valueHasDependencies\": SettableObservable.prototype.hasDependencies,\n\t\"can.getValueDependencies\": SettableObservable.prototype.getValueDependencies\n});\n\nmodule.exports = SettableObservable;\n\n\n//# sourceURL=webpack:///./node_modules/can-simple-observable/settable/settable.js?");

/***/ }),

/***/ "./node_modules/can-simple-observable/setter/setter.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-simple-observable/setter/setter.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar SettableObservable = __webpack_require__(/*! ../settable/settable */ \"./node_modules/can-simple-observable/settable/settable.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"./node_modules/can-event-queue/value/value.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar setElementSymbol = canSymbol.for(\"can.setElement\");\n\n// SetterObservable's call a function when set. Their getter is backed up by an\n// observation.\nfunction SetterObservable(getter, setter) {\n\tthis.setter = setter;\n\tthis.observation = new Observation(getter);\n\tthis.handler = this.handler.bind(this);\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor) +\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(getter) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.handler, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".handler\"\n\t\t});\n\t}\n\t//!steal-remove-end\n}\n\nSetterObservable.prototype = Object.create(SettableObservable.prototype);\nSetterObservable.prototype.constructor = SetterObservable;\nSetterObservable.prototype.set = function(newVal) {\n\tthis.setter(newVal);\n};\nSetterObservable.prototype.hasDependencies = function() {\n\treturn canReflect.valueHasDependencies(this.observation);\n};\ncanReflect.assignSymbols(SetterObservable.prototype, {\n\t\"can.setValue\": SetterObservable.prototype.set,\n\t\"can.valueHasDependencies\": SetterObservable.prototype.hasDependencies,\n\t\"can.setElement\": function(el) {\n\t\tthis.observation[setElementSymbol](el);\n\t}\n});\n\nmodule.exports = SetterObservable;\n\n\n//# sourceURL=webpack:///./node_modules/can-simple-observable/setter/setter.js?");

/***/ }),

/***/ "./node_modules/can-single-reference/can-single-reference.js":
/*!*******************************************************************!*\
  !*** ./node_modules/can-single-reference/can-single-reference.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar CID = __webpack_require__(/*! can-cid */ \"./node_modules/can-cid/can-cid.js\");\n\nvar singleReference;\n\nfunction getKeyName(key, extraKey) {\n\tvar keyName = extraKey ? CID(key) + \":\" + extraKey : CID(key);\n\treturn keyName || key;\n}\n\n// weak maps are slow\n/* if(typeof WeakMap !== \"undefined\") {\n\tvar globalMap = new WeakMap();\n\tsingleReference = {\n\t\tset: function(obj, key, value){\n\t\t\tvar localMap = globalMap.get(obj);\n\t\t\tif( !localMap ) {\n\t\t\t\tglobalMap.set(obj, localMap = new WeakMap());\n\t\t\t}\n\t\t\tlocalMap.set(key, value);\n\t\t},\n\t\tgetAndDelete: function(obj, key){\n\t\t\treturn globalMap.get(obj).get(key);\n\t\t},\n\t\treferences: globalMap\n\t};\n} else {*/\nsingleReference = {\n\t// obj is a function ... we need to place `value` on it so we can retreive it\n\t// we can't use a global map\n\tset: function(obj, key, value, extraKey){\n\t\t// check if it has a single reference map\n\t\tobj[getKeyName(key, extraKey)] = value;\n\t},\n\n\tgetAndDelete: function(obj, key, extraKey){\n\t\tvar keyName = getKeyName(key, extraKey);\n\t\tvar value = obj[keyName];\n\t\tdelete obj[keyName];\n\t\treturn value;\n\t}\n};\n/*}*/\n\nmodule.exports = singleReference;\n\n\n//# sourceURL=webpack:///./node_modules/can-single-reference/can-single-reference.js?");

/***/ }),

/***/ "./node_modules/can-stache-ast/can-stache-ast.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache-ast/can-stache-ast.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar controls = __webpack_require__(/*! ./controls */ \"./node_modules/can-stache-ast/controls.js\");\nvar parser = __webpack_require__(/*! can-view-parser */ \"./node_modules/can-view-parser/can-view-parser.js\");\n\nexports.parse = function(filename, source){\n\tif (arguments.length === 1) {\n\t\tsource = arguments[0];\n\t\tfilename = undefined;\n\t}\n\n\tvar template = source;\n\ttemplate = controls.cleanWhitespaceControl(template);\n\ttemplate = controls.cleanLineEndings(template);\n\n\tvar imports = [],\n\t\tdynamicImports = [],\n\t\timportDeclarations = [],\n\t\tases = {},\n\t\tattributes = new Map(),\n\t\tinImport = false,\n\t\tinFrom = false,\n\t\tinAs = false,\n\t\tisUnary = false,\n\t\timportIsDynamic = false,\n\t\tcurrentAs = \"\",\n\t\tcurrentFrom = \"\",\n\t\tcurrentAttrName = null;\n\n\tfunction processImport(line) {\n\t\tif(currentAs) {\n\t\t\tases[currentAs] = currentFrom;\n\t\t\tcurrentAs = \"\";\n\t\t}\n\t\tif(importIsDynamic) {\n\t\t\tdynamicImports.push(currentFrom);\n\t\t} else {\n\t\t\timports.push(currentFrom);\n\t\t}\n\t\timportDeclarations.push({\n\t\t\tspecifier: currentFrom,\n\t\t\tloc: {\n\t\t\t\tline: line\n\t\t\t},\n\t\t\tattributes: attributes\n\t\t});\n\n\t\t// Reset this scope value so that the next import gets new attributes.\n\t\tattributes = new Map();\n\t}\n\n\tvar program = parser(template, {\n\t\tfilename: filename,\n\t\tstart: function( tagName, unary ){\n\t\t\tif(tagName === \"can-import\") {\n\t\t\t\tisUnary = unary;\n\t\t\t\timportIsDynamic = false; // assume static import unless there is content (chars/tags/special).\n\t\t\t\tinImport = true;\n\t\t\t} else if(tagName === \"can-dynamic-import\") {\n\t\t\t\tisUnary = unary;\n\t\t\t\timportIsDynamic = true;\n\t\t\t\tinImport = true;\n\t\t\t} else if(inImport) {\n\t\t\t\timportIsDynamic = true;  // found content inside can-import tag.\n\t\t\t\tinImport = false;\n\t\t\t}\n\t\t},\n\t\tattrStart: function( attrName ){\n\t\t\tcurrentAttrName = attrName;\n\t\t\t// Default to a boolean attribute, the attrValue hook will replace that.\n\t\t\tattributes.set(currentAttrName, true);\n\n\t\t\tif(attrName === \"from\") {\n\t\t\t\tinFrom = true;\n\t\t\t} else if(attrName === \"as\" || attrName === \"export-as\") {\n\t\t\t\tinAs = true;\n\t\t\t}\n\t\t},\n\t\tattrEnd: function( attrName ){\n\t\t\tif(attrName === \"from\") {\n\t\t\t\tinFrom = false;\n\t\t\t} else if(attrName === \"as\" || attrName === \"export-as\") {\n\t\t\t\tinAs = false;\n\t\t\t}\n\t\t},\n\t\tattrValue: function( value ){\n\t\t\tif(inImport) {\n\t\t\t\tattributes.set(currentAttrName, value);\n\t\t\t}\n\t\t\tif(inFrom && inImport) {\n\t\t\t\tcurrentFrom = value;\n\t\t\t} else if(inAs && inImport) {\n\t\t\t\tcurrentAs = value;\n\t\t\t}\n\t\t},\n\t\tend: function(tagName, unary, line){\n\t\t\tif((tagName === \"can-import\" || tagName === \"can-dynamic-import\") && isUnary) {\n\t\t\t\tprocessImport(line);\n\t\t\t}\n\t\t},\n\t\tclose: function(tagName, unary, line){\n\t\t\tif((tagName === \"can-import\" || tagName === \"can-dynamic-import\")) {\n\t\t\t\tprocessImport(line);\n\t\t\t}\n\t\t},\n\t\tchars: function(text) {\n\t\t\tif(text.trim().length > 0) {\n\t\t\t\timportIsDynamic = true;\n\t\t\t}\n\t\t},\n\t\tspecial: function() {\n\t\t\timportIsDynamic = true;\n\t\t}\n\t}, true);\n\n\treturn {\n\t\tintermediate: program,\n\t\tprogram: program,\n\t\timports: imports,\n\t\tdynamicImports: dynamicImports,\n\t\timportDeclarations: importDeclarations,\n\t\tases: ases,\n\t\texports: ases\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-stache-ast/can-stache-ast.js?");

/***/ }),

/***/ "./node_modules/can-stache-ast/controls.js":
/*!*************************************************!*\
  !*** ./node_modules/can-stache-ast/controls.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar mustacheLineBreakRegExp = /(?:(^|\\r?\\n)(\\s*)(\\{\\{([\\s\\S]*)\\}\\}\\}?)([^\\S\\n\\r]*)($|\\r?\\n))|(\\{\\{([\\s\\S]*)\\}\\}\\}?)/g,\n\tmustacheWhitespaceRegExp = /(\\s*)(\\{\\{\\{?)(-?)([\\s\\S]*?)(-?)(\\}\\}\\}?)(\\s*)/g;\n\nfunction splitModeFromExpression(expression, state){\n\texpression = expression.trim();\n\tvar mode = expression.charAt(0);\n\n\tif( \"#/{&^>!<\".indexOf(mode) >= 0 ) {\n\t\texpression =  expression.substr(1).trim();\n\t} else {\n\t\tmode = null;\n\t}\n\t// Triple braces do nothing within a tag.\n\tif(mode === \"{\" && state.node) {\n\t\tmode = null;\n\t}\n\treturn {\n\t\tmode: mode,\n\t\texpression: expression\n\t};\n}\n\nfunction cleanLineEndings(template) {\n\t\t// Finds mustache tags with space around them or no space around them.\n\t\treturn template.replace( mustacheLineBreakRegExp,\n\t\t\tfunction(whole,\n\t\t\t\treturnBefore,\n\t\t\t\tspaceBefore,\n\t\t\t\tspecial,\n\t\t\t\texpression,\n\t\t\t\tspaceAfter,\n\t\t\t\treturnAfter,\n\t\t\t\t// A mustache magic tag that has no space around it.\n\t\t\t\tspaceLessSpecial,\n\t\t\t\tspaceLessExpression,\n\t\t\t\tmatchIndex){\n\n\t\t\t// IE 8 will provide undefined\n\t\t\tspaceAfter = (spaceAfter || \"\");\n\t\t\treturnBefore = (returnBefore || \"\");\n\t\t\tspaceBefore = (spaceBefore || \"\");\n\n\t\t\tvar modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});\n\n\t\t\t// If it's a partial or tripple stache, leave in place.\n\t\t\tif(spaceLessSpecial || \">{\".indexOf( modeAndExpression.mode) >= 0) {\n\t\t\t\treturn whole;\n\t\t\t}  else if( \"^#!/\".indexOf(  modeAndExpression.mode ) >= 0 ) {\n\t\t\t\t// Return the magic tag and a trailing linebreak if this did not\n\t\t\t\t// start a new line and there was an end line.\n\t\t\t\t// Add a normalized leading space, if there was any leading space, in case this abuts a tag name\n\t\t\t\tspaceBefore = (returnBefore + spaceBefore) && \" \";\n\t\t\t\treturn spaceBefore+special+( matchIndex !== 0 && returnAfter.length ? returnBefore+\"\\n\" :\"\");\n\n\n\t\t\t} else {\n\t\t\t\t// There is no mode, return special with spaces around it.\n\t\t\t\treturn spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+\"\\n\" : \"\");\n\t\t\t}\n\t\t});\n}\n\nfunction whiteSpaceReplacement(\n\twhole,\n\tspaceBefore,\n\tbracketBefore,\n\tcontrolBefore,\n\texpression,\n\tcontrolAfter,\n\tbracketAfter,\n\tspaceAfter\n) {\n\n\tif (controlBefore === '-') {\n\t\tspaceBefore = '';\n\t}\n\n\tif (controlAfter === '-') {\n\t\tspaceAfter = '';\n\t}\n\n\treturn spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;\n}\n\nfunction cleanWhitespaceControl(template) {\n\treturn template.replace(mustacheWhitespaceRegExp, whiteSpaceReplacement);\n}\n\nexports.cleanLineEndings = cleanLineEndings;\nexports.cleanWhitespaceControl = cleanWhitespaceControl;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache-ast/controls.js?");

/***/ }),

/***/ "./node_modules/can-stache-bindings/can-stache-bindings.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-stache-bindings/can-stache-bindings.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # can-stache-bindings.js\n//\n// This module provides CanJS's default data and event bindings.\n// It's broken up into several parts:\n//\n// - Behaviors - Binding behaviors that run given an attribute or element.\n// - Attribute Syntaxes - Hooks up custom attributes to their behaviors.\n// - getObservableFrom - Methods that return a observable cross bound to the scope, viewModel, or element.\n// - bind - Methods for setting up cross binding\n// - getBindingInfo - A helper that returns the details of a data binding given an attribute.\n// - makeDataBinding - A helper method for setting up a data binding.\n// - initializeValues - A helper that initializes a data binding.\nvar Bind = __webpack_require__(/*! can-bind */ \"./node_modules/can-bind/can-bind.js\");\nvar expression = __webpack_require__(/*! can-stache/src/expression */ \"./node_modules/can-stache/src/expression.js\");\nvar canViewModel = __webpack_require__(/*! can-view-model */ \"./node_modules/can-view-model/can-view-model.js\");\nvar stacheKey = __webpack_require__(/*! can-stache-key */ \"./node_modules/can-stache-key/can-stache-key.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\nvar Scope = __webpack_require__(/*! can-view-scope */ \"./node_modules/can-view-scope/can-view-scope.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar domData = __webpack_require__(/*! can-dom-data */ \"./node_modules/can-dom-data/can-dom-data.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"./node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\nvar encoder = __webpack_require__(/*! can-attribute-encoder */ \"./node_modules/can-attribute-encoder/can-attribute-encoder.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\nvar SettableObservable = __webpack_require__(/*! can-simple-observable/setter/setter */ \"./node_modules/can-simple-observable/setter/setter.js\");\nvar AttributeObservable = __webpack_require__(/*! can-attribute-observable */ \"./node_modules/can-attribute-observable/can-attribute-observable.js\");\nvar makeCompute = __webpack_require__(/*! can-view-scope/make-compute-like */ \"./node_modules/can-view-scope/make-compute-like.js\");\n\nvar canEventQueue = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\n\n// Contains all of the stache bindings that will be exported.\nvar bindings = new Map();\n\nvar onMatchStr = \"on:\",\n\tvmMatchStr = \"vm:\",\n\telMatchStr = \"el:\",\n\tbyMatchStr = \":by:\",\n\ttoMatchStr = \":to\",\n\tfromMatchStr = \":from\",\n\tbindMatchStr = \":bind\",\n\tviewModelBindingStr = \"viewModel\",\n\tattributeBindingStr = \"attribute\",\n\tscopeBindingStr = \"scope\",\n\tviewModelOrAttributeBindingStr = \"viewModelOrAttribute\",\n\tviewModelSymbol = canSymbol.for(\"can.viewModel\"),\n\tpreventDataBindingsSymbol = canSymbol.for(\"can.preventDataBindings\");\n\nvar throwOnlyOneTypeOfBindingError = function() {\n\tthrow new Error(\"can-stache-bindings - you can not have contextual bindings ( this:from='value' ) and key bindings ( prop:from='value' ) on one element.\");\n};\n\n// This function checks if there bindings that are trying\n// to set a property ON the viewModel _conflicting_ with bindings trying to\n// set THE viewModel ITSELF.\n// If there is a conflict, an error is thrown.\nvar checkBindingState = function(bindingState, siblingBindingData) {\n\tvar isSettingOnViewModel = siblingBindingData.parent.exports && siblingBindingData.child.source === viewModelBindingStr;\n\tif (isSettingOnViewModel) {\n\t\tvar bindingName = siblingBindingData.child.name;\n\t\tvar isSettingViewModel = isSettingOnViewModel && ( bindingName === 'this' || bindingName === '.' );\n\n\t\tif (isSettingViewModel) {\n\t\t\tif (bindingState.isSettingViewModel || bindingState.isSettingOnViewModel) {\n\t\t\t\tthrowOnlyOneTypeOfBindingError();\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tisSettingViewModel: true,\n\t\t\t\t\tinitialViewModelData: undefined\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\t// just setting on viewModel\n\t\t\tif (bindingState.isSettingViewModel) {\n\t\t\t\tthrowOnlyOneTypeOfBindingError();\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tisSettingOnViewModel: true,\n\t\t\t\t\tinitialViewModelData: bindingState.initialViewModelData\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn bindingState;\n\t}\n};\n\nvar getEventBindingData = function (attributeName, el, scope) {\n\tvar bindingCode = attributeName.substr(onMatchStr.length);\n\tvar viewModel = el && el[viewModelSymbol];\n\tvar elUsed = startsWith.call(bindingCode, elMatchStr);\n\tvar vmUsed = startsWith.call(bindingCode, vmMatchStr);\n\tvar byUsed = bindingCode.indexOf(byMatchStr) > -1;\n\tvar scopeUsed;\n\n\t// The values being returned\n\tvar bindingContext;\n\tvar eventName;\n\tvar bindingContextObservable;\n\tvar shortBindingCode = \"\";\n\n\t// if explicit context is specified, trim the string down\n\t// else, determine value of which scope being used elUsed, vmUsed, scopeUsed\n\tif (vmUsed) {\n\t\tshortBindingCode = \"vm\";\n\t\tbindingCode = bindingCode.substr(vmMatchStr.length);\n\t} else if (elUsed) {\n\t\tshortBindingCode = \"el\";\n\t\tbindingCode = bindingCode.substr(elMatchStr.length);\n\t} else if (!vmUsed && !elUsed) {\n\t\tif (byUsed) {\n\t\t\tscopeUsed = true;\n\t\t} else if (viewModel)  {\n\t\t\tvmUsed = true;\n\t\t} else {\n\t\t\telUsed = true;\n\t\t}\n\t}\n\n\t// if by is used, take the appropriate path to determine the bindingContext\n\t// and create the bindingKeyValue\n\tvar bindingContextKey;\n\tif (byUsed) {\n\t\tvar byIndex = bindingCode.indexOf(byMatchStr);\n\t\tbindingContextKey = bindingCode.substr(byIndex + byMatchStr.length);\n\t\tbindingCode = bindingCode.substr(0, byIndex);\n\t}\n\teventName = bindingCode;\n\tif (elUsed) {\n\t\tif (byUsed) {\n\t\t\tthrow new Error('binding with :by in element scope is not currently supported');\n\t\t} else {\n\t\t\tbindingContext = el;\n\t\t}\n\t} else if (vmUsed) {\n\t\tbindingContext = viewModel;\n\t\tif (byUsed) {\n\t\t\tbindingContext = viewModel.get(bindingContextKey);\n\t\t\tbindingContextObservable = new Scope(viewModel).computeData(bindingContextKey);\n\t\t}\n\t} else if (scopeUsed) {\n\t\tbindingContext = scope;\n\t\tif (byUsed) {\n\t\t\tbindingContext = bindingContext.get(bindingContextKey);\n\t\t\tbindingContextObservable = scope.computeData(bindingContextKey);\n\t\t}\n\t}\n\n\treturn {\n\t\t// single observable object to listen to eventName directly on one observable object\n\t\tbindingContext: bindingContext,\n\t\t// this observable emits the bindingContext\n\t\tbindingContextObservable: bindingContextObservable,\n\t\t// the eventName string\n\t\teventName: eventName,\n\t\t// which binding code was explicitly set by the user\n\t\tbindingCode: shortBindingCode,\n\t};\n};\n\nvar onKeyValueSymbol = canSymbol.for(\"can.onKeyValue\");\nvar makeScopeFromEvent = function(element, event, viewModel, args, data, bindingContext){\n\t// TODO: Remove in 6.0.  In 4 and 5 arguments were wrong.\n\tvar shiftArgumentsForLegacyArguments = bindingContext && bindingContext[onKeyValueSymbol] !== undefined;\n\n\tvar specialValues = {\n\t\telement: element,\n\t\tevent: event,\n\t\tviewModel: viewModel,\n\t\targuments: shiftArgumentsForLegacyArguments ? Array.prototype.slice.call(args, 1) : args,\n\t\targs: args\n\t};\n\n\t// make a scope with these things just under\n\treturn data.scope.add(specialValues, { special: true });\n};\n\nvar runEventCallback = function (el, ev, data, scope, expr, attributeName, attrVal) {\n\t// create \"special\" values that can be looked up using\n\t// {{scope.element}}, etc\n\n\tvar updateFn = function() {\n\t\tvar value = expr.value(scope, {\n\t\t\tdoNotWrapInObservation: true\n\t\t});\n\n\t\tvalue = canReflect.isValueLike(value) ?\n\t\t\tcanReflect.getValue(value) :\n\t\t\tvalue;\n\n\t\treturn typeof value === 'function' ?\n\t\t\tvalue(el) :\n\t\t\tvalue;\n\t};\n\t//!steal-remove-start\n\tif (true) {\n\t\tObject.defineProperty(updateFn, \"name\", {\n\t\t\tvalue: attributeName + '=\"' + attrVal + '\"'\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tqueues.batch.start();\n\tvar mutateQueueArgs = [];\n\tmutateQueueArgs = [\n\t\tupdateFn,\n\t\tnull,\n\t\tnull,\n\t\t{}\n\t];\n\t//!steal-remove-start\n\tif (true) {\n\t\tmutateQueueArgs = [\n\t\t\tupdateFn,\n\t\t\tnull,\n\t\t\tnull, {\n\t\t\t\treasonLog: [el, ev, attributeName+\"=\"+attrVal]\n\t\t\t}\n\t\t];\n\t}\n\t//!steal-remove-end\n\tqueues.mutateQueue.enqueue.apply(queues.mutateQueue, mutateQueueArgs);\n\tqueues.batch.stop();\n};\n\n// ## Behaviors\nvar behaviors = {\n\t// ## completeBindings\n\t// Given a list of bindings, initializes the bindings, then the viewModel then completes the bindings.\n\t// Arguments:\n\t// - bindings  - An array of `{binding, siblingBindingData}`\n\t// - initialViewModelData - Extra initial viewModel values\n\t// - makeViewModel - `makeViewModel(props, hasBindings, bindingsState)`\n\t// - bindingContext - optional, `{scope}`\n\t// Returns:\n\t// `{viewModel, onTeardowns, bindingsState}`\n\tinitializeViewModel: function(bindings, initialViewModelData, makeViewModel, bindingContext) {\n\n\t\tvar onCompleteBindings = [],\n\t\t\tonTeardowns = {};\n\n\t\tvar bindingsState = {\n\t\t\t// if we have a binding like {something}=\"foo\"\n\t\t\tisSettingOnViewModel: false,\n\t\t\t// if we have binding like {this}=\"bar\"\n\t\t\tisSettingViewModel: false,\n\t\t\tinitialViewModelData: initialViewModelData || {}\n\t\t};\n\n\t\tbindings.forEach(function(dataBinding){\n\t\t\t// Immediately bind to the parent so we can read its value\n\t\t\tdataBinding.binding.startParent();\n\n\t\t\tvar siblingBindingData = dataBinding.siblingBindingData;\n\t\t\tbindingsState = checkBindingState(bindingsState, siblingBindingData);\n\n\t\t\t// For bindings that change the viewModel,\n\t\t\t// save the initial value on the viewModel.\n\t\t\tif (siblingBindingData.parent.exports) {\n\n\t\t\t\tvar parentValue = siblingBindingData.child.setCompute ? makeCompute(dataBinding.binding.parent) : dataBinding.binding.parentValue;\n\n\t\t\t\tif (parentValue !== undefined) {\n\n\t\t\t\t\tif (bindingsState.isSettingViewModel) {\n\t\t\t\t\t\t// the initial data is the context\n\t\t\t\t\t\t// TODO: this is covered by can-componentâ€™s tests but not can-stache-bindingsâ€™ tests\n\t\t\t\t\t\tbindingsState.initialViewModelData = parentValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbindingsState.initialViewModelData[cleanVMName(siblingBindingData.child.name, bindingContext.scope)] = parentValue;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Save what needs to happen after the `viewModel` is created.\n\t\t\tonCompleteBindings.push(dataBinding.binding.start.bind(dataBinding.binding));\n\n\t\t\tonTeardowns[siblingBindingData.bindingAttributeName] = dataBinding.binding.stop.bind(dataBinding.binding);\n\t\t});\n\n\t\tvar viewModel = makeViewModel(bindingsState.initialViewModelData, bindings.length > 0, bindingsState);\n\n\t\t// bind on the viewModel so we can updat ethe parent\n\t\tfor (var i = 0, len = onCompleteBindings.length; i < len; i++) {\n\t\t\tonCompleteBindings[i]();\n\t\t}\n\t\treturn {viewModel: viewModel, onTeardowns: onTeardowns, bindingsState: bindingsState};\n\t},\n\t// ### bindings.behaviors.viewModel\n\t// Sets up all of an element's data binding attributes to a \"soon-to-be-created\"\n\t// `viewModel`.\n\t// This is primarily used by `Component` to ensure that its\n\t// `viewModel` is initialized with values from the data bindings as quickly as possible.\n\t// Component could look up the data binding values itself.  However, that lookup\n\t// would have to be duplicated when the bindings are established.\n\t// Instead, this uses the `makeDataBinding` helper, which allows creation of the `viewModel`\n\t// after scope values have been looked up.\n\t//\n\t// Arguments:\n\t// - `makeViewModel(initialViewModelData)` - a function that returns the `viewModel`.\n\t// - `initialViewModelData` any initial data that should already be added to the `viewModel`.\n\t//\n\t// Returns:\n\t// - `function` - a function that tears all the bindings down. Component\n\t// wants all the bindings active so cleanup can be done during a component being removed.\n\tviewModel: function(el, tagData, makeViewModel, initialViewModelData, staticDataBindingsOnly) {\n\n\t\tvar attributeViewModelBindings = assign({}, initialViewModelData),\n\n\t\t\t// The data around the binding.\n\t\t\tbindingContext = assign({\n\t\t\t\telement: el,\n\t\t\t\t// this gets defined later\n\t\t\t\tviewModel: undefined\n\t\t\t}, tagData),\n\n\t\t\t// global settings for the bindings\n\t\t\tbindingSettings = {\n\t\t\t\tattributeViewModelBindings: attributeViewModelBindings,\n\t\t\t\talreadyUpdatedChild: true,\n\t\t\t\t// force viewModel bindings in cases when it is ambiguous whether you are binding\n\t\t\t\t// on viewModel or an attribute (:to, :from, :bind)\n\t\t\t\tfavorViewModel: true\n\t\t\t},\n\t\t\tdataBindings = [];\n\n\t\t// For each attribute, we create a dataBinding object.\n\t\t// These look like: `{binding, siblingBindingData}`\n\t\tcanReflect.eachListLike(el.attributes || [], function(node) {\n\t\t\tvar dataBinding = makeDataBinding(node, bindingContext, bindingSettings);\n\n\t\t\tif (dataBinding) {\n\t\t\t\tdataBindings.push(dataBinding);\n\t\t\t}\n\t\t});\n\n\t\t// If there are no binding, exit.\n\t\tif (staticDataBindingsOnly && dataBindings.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Initialize the viewModel\n\t\tvar completedData = behaviors.initializeViewModel(dataBindings, initialViewModelData, function(){\n\t\t\t// we need to make sure we have the viewModel available\n\t\t\tbindingContext.viewModel = makeViewModel.apply(this, arguments);\n\t\t}, bindingContext),\n\t\t\tonTeardowns = completedData.onTeardowns,\n\t\t\tbindingsState = completedData.bindingsState,\n\t\t\tsiblingBindingDatas = {};\n\n\n\t\t// Listen to attribute changes and re-initialize\n\t\t// the bindings.\n\t\tvar attributeDisposal;\n\t\tif (!bindingsState.isSettingViewModel) {\n\t\t\t// We need to update the child on any new bindings.\n\t\t\tbindingSettings.alreadyUpdatedChild = false;\n\t\t\tattributeDisposal = domMutate.onNodeAttributeChange(el, function(ev) {\n\t\t\t\tvar attrName = ev.attributeName,\n\t\t\t\t\tvalue = el.getAttribute(attrName);\n\n\t\t\t\tif (onTeardowns[attrName]) {\n\t\t\t\t\tonTeardowns[attrName]();\n\t\t\t\t}\n\t\t\t\t// Parent attribute bindings we always re-setup.\n\t\t\t\tvar parentBindingWasAttribute = siblingBindingDatas[attrName] && siblingBindingDatas[attrName].parent.source === attributeBindingStr;\n\n\t\t\t\tif (value !== null || parentBindingWasAttribute) {\n\t\t\t\t\tvar dataBinding = makeDataBinding({\n\t\t\t\t\t\tname: attrName,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t}, bindingContext, bindingSettings);\n\t\t\t\t\tif (dataBinding) {\n\t\t\t\t\t\t// The viewModel is created, so call callback immediately.\n\t\t\t\t\t\tdataBinding.binding.start();\n\t\t\t\t\t\tsiblingBindingDatas[attrName] = dataBinding.siblingBindingData;\n\t\t\t\t\t\tonTeardowns[attrName] = dataBinding.binding.stop.bind(dataBinding.binding);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn function() {\n\t\t\tif (attributeDisposal) {\n\t\t\t\tattributeDisposal();\n\t\t\t\tattributeDisposal = undefined;\n\t\t\t}\n\t\t\tfor (var attrName in onTeardowns) {\n\t\t\t\tonTeardowns[attrName]();\n\t\t\t}\n\t\t};\n\t},\n\t// ### bindings.behaviors.data\n\t// This is called when an individual data binding attribute is placed on an element.\n\t// For example `{^value}=\"name\"`.\n\tdata: function(el, attrData) {\n\t\tif (el[preventDataBindingsSymbol] === true || domData.get(el, \"preventDataBindings\")) {\n\t\t\treturn;\n\t\t}\n\t\tvar viewModel,\n\t\t\tgetViewModel = ObservationRecorder.ignore(function() {\n\t\t\t\treturn viewModel || (viewModel = canViewModel(el));\n\t\t\t}),\n\t\t\tteardown,\n\t\t\tattributeDisposal,\n\t\t\tremovedDisposal,\n\t\t\tbindingContext = {\n\t\t\t\telement: el,\n\t\t\t\ttemplateType: attrData.templateType,\n\t\t\t\tscope: attrData.scope,\n\t\t\t\tparentNodeList: attrData.nodeList,\n\t\t\t\tget viewModel(){\n\t\t\t\t\treturn getViewModel();\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Setup binding\n\t\tvar dataBinding = makeDataBinding({\n\t\t\tname: attrData.attributeName,\n\t\t\tvalue: el.getAttribute(attrData.attributeName),\n\t\t}, bindingContext, {\n\t\t\tsyncChildWithParent: false\n\t\t});\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (dataBinding.siblingBindingData.child.source === \"viewModel\" && !domData.get(el, \"viewModel\")) {\n\t\t\t\tdev.warn('This element does not have a viewModel. (Attempting to bind `' + dataBinding.siblingBindingData.bindingAttributeName + '=\"' + dataBinding.siblingBindingData.parent.name + '\"`)');\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// Flag to prevent start binding twice in dev mode\n\t\tvar started = false;\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (el.nodeName === 'INPUT') {\n\t\t\t\ttry {\n\t\t\t\t\tdataBinding.binding.start();\n\t\t\t\t\tstarted = true;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new Error(error.message + ' <input> elements always set properties to Strings.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif (!started) {\n\t\t\tdataBinding.binding.start();\n\t\t\tstarted = true;\n\t\t}\n\n\t\tvar attributeListener = function(ev) {\n\t\t\tvar attrName = ev.attributeName,\n\t\t\t\tvalue = el.getAttribute(attrName);\n\n\t\t\tif (attrName === attrData.attributeName) {\n\t\t\t\tif (teardown) {\n\t\t\t\t\tteardown();\n\t\t\t\t}\n\n\t\t\t\tif(value !== null  ) {\n\t\t\t\t\tvar dataBinding = makeDataBinding({name: attrName, value: value}, bindingContext, {\n\t\t\t\t\t\tsyncChildWithParent: false\n\t\t\t\t\t});\n\t\t\t\t\tif(dataBinding) {\n\t\t\t\t\t\t// The viewModel is created, so call callback immediately.\n\t\t\t\t\t\tdataBinding.binding.start();\n\t\t\t\t\t\tteardown = dataBinding.binding.stop.bind(dataBinding.binding);\n\t\t\t\t\t}\n\t\t\t\t\tteardown = dataBinding.onTeardown;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\tvar tearItAllDown = function() {\n\t\t\tif (teardown) {\n\t\t\t\tteardown();\n\t\t\t\tteardown = undefined;\n\t\t\t}\n\n\t\t\tif (removedDisposal) {\n\t\t\t\tremovedDisposal();\n\t\t\t\tremovedDisposal = undefined;\n\t\t\t}\n\t\t\tif (attributeDisposal) {\n\t\t\t\tattributeDisposal();\n\t\t\t\tattributeDisposal = undefined;\n\t\t\t}\n\t\t};\n\n\n\n\t\t// Listen for changes\n\t\tteardown = dataBinding.binding.stop.bind(dataBinding.binding);\n\n\t\tattributeDisposal = domMutate.onNodeAttributeChange(el, attributeListener);\n\t\tremovedDisposal = domMutate.onNodeDisconnected(el, function() {\n\t\t\tvar doc = el.ownerDocument;\n\t\t\tvar ownerNode = doc.contains ? doc : doc.documentElement;\n\t\t\tif (!ownerNode || ownerNode.contains(el) === false) {\n\t\t\t\ttearItAllDown();\n\t\t\t}\n\t\t});\n\t},\n\t// ### bindings.behaviors.event\n\t// The following section contains code for implementing the can-EVENT attribute.\n\t// This binds on a wildcard attribute name. Whenever a view is being processed\n\t// and can-xxx (anything starting with can-), this callback will be run.  Inside, its setting up an event handler\n\t// that calls a method identified by the value of this attribute.\n\tevent: function(el, data) {\n\t\tvar eventBindingData;\n\t\t// Get the `event` name and if we are listening to the element or viewModel.\n\t\t// The attribute name is the name of the event.\n\t\tvar attributeName = encoder.decode(data.attributeName),\n\t\t\t// the name of the event we are binding\n\t\t\tevent,\n\t\t\t// the context to which we bind the event listener\n\t\t\tbindingContext,\n\t\t\t// if the bindingContext is null, then use this observable to watch for changes\n\t\t\tbindingContextObservable;\n\n\t\t// check for `on:event:value:to` type things and call data bindings\n\t\tif (attributeName.indexOf(toMatchStr + \":\") !== -1 ||\n\t\t\tattributeName.indexOf(fromMatchStr + \":\") !== -1 ||\n\t\t\tattributeName.indexOf(bindMatchStr + \":\") !== -1\n\t\t) {\n\t\t\treturn this.data(el, data);\n\t\t}\n\n\t\tif (startsWith.call(attributeName, onMatchStr)) {\n\t\t\teventBindingData = getEventBindingData(attributeName, el, data.scope);\n\t\t\tevent = eventBindingData.eventName;\n\t\t\tbindingContext = eventBindingData.bindingContext;\n\t\t\tbindingContextObservable = eventBindingData.bindingContextObservable;\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tif(\n\t\t\t\t\t!eventBindingData.bindingCode &&\n\t\t\t\t\tel[viewModelSymbol] &&\n\t\t\t\t\t(\"on\" + event) in el\n\t\t\t\t) {\n\t\t\t\t\tdev.warn(\n\t\t\t\t\t\t\"The \" + event + \" event is bound the view model for <\" + el.tagName.toLowerCase() +\n\t\t\t\t\t\t\t\">. Use \" + attributeName.replace(onMatchStr, \"on:el:\") +  \" to bind to the element instead.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t} else {\n\t\t\tthrow new Error(\"can-stache-bindings - unsupported event bindings \" + attributeName);\n\t\t}\n\n\t\t// This is the method that the event will initially trigger. It will look up the method by the string name\n\t\t// passed in the attribute and call it.\n\t\tvar handler = function(ev) {\n\t\t\tvar attrVal = el.getAttribute(encoder.encode(attributeName));\n\t\t\tif (!attrVal) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar viewModel = el[viewModelSymbol];\n\n\t\t\t// expression.parse will read the attribute\n\t\t\t// value and parse it identically to how mustache helpers\n\t\t\t// get parsed.\n\t\t\tvar expr = expression.parse(attrVal, {\n\t\t\t\tlookupRule: function() {\n\t\t\t\t\treturn expression.Lookup;\n\t\t\t\t},\n\t\t\t\tmethodRule: \"call\"\n\t\t\t});\n\n\t\t\tvar runScope = makeScopeFromEvent(el, ev, viewModel, arguments, data, bindingContext);\n\n\t\t\tif (expr instanceof expression.Hashes) {\n\t\t\t\tvar hashExprs = expr.hashExprs;\n\t\t\t\tvar key = Object.keys(hashExprs)[0];\n\t\t\t\tvar value = expr.hashExprs[key].value(runScope);\n\t\t\t\tvar isObservableValue = canReflect.isObservableLike(value) && canReflect.isValueLike(value);\n\t\t\t\trunScope.set(key, isObservableValue ? canReflect.getValue(value) : value);\n\t\t\t} else if (expr instanceof expression.Call) {\n\t\t\t\trunEventCallback(el, ev, data, runScope, expr, attributeName, attrVal);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"can-stache-bindings: Event bindings must be a call expression. Make sure you have a () in \" + data.attributeName + \"=\" + JSON.stringify(attrVal));\n\t\t\t}\n\t\t};\n\n\t\tvar attributesDisposal,\n\t\t\tremovalDisposal,\n\t\t\tremoveObservation,\n\t\t\tcurrentContext;\n\n\t\t// Unbind the event when the attribute is removed from the DOM\n\t\tvar attributesHandler = function(ev) {\n\t\t\tvar isEventAttribute = ev.attributeName === attributeName;\n\t\t\tvar isRemoved = !el.getAttribute(attributeName);\n\t\t\tvar isEventAttributeRemoved = isEventAttribute && isRemoved;\n\t\t\tif (isEventAttributeRemoved) {\n\t\t\t\tunbindEvent();\n\t\t\t}\n\t\t};\n\t\tvar removalHandler = function() {\n\t\t\tvar doc = el.ownerDocument;\n\t\t\tvar ownerNode = doc.contains ? doc : doc.documentElement;\n\t\t\tif (!ownerNode || !ownerNode.contains(el)) {\n\t\t\t\tunbindEvent();\n\t\t\t}\n\t\t};\n\t\tvar unbindEvent = function() {\n\t\t\tif (bindingContext) {\n\t\t\t\tcanEventQueue.off.call(bindingContext, event, handler);\n\t\t\t}\n\t\t\tif (attributesDisposal) {\n\t\t\t\tattributesDisposal();\n\t\t\t\tattributesDisposal = undefined;\n\t\t\t}\n\t\t\tif (removalDisposal) {\n\t\t\t\tremovalDisposal();\n\t\t\t\tremovalDisposal = undefined;\n\t\t\t}\n\t\t\tif (removeObservation) {\n\t\t\t\tremoveObservation();\n\t\t\t\tremoveObservation = undefined;\n\t\t\t}\n\t\t};\n\n\t\tfunction updateListener(newVal, oldVal) {\n\t\t\tif (oldVal) {\n\t\t\t\tcanEventQueue.off.call(oldVal, event, handler);\n\t\t\t}\n\t\t\tif (newVal) {\n\t\t\t\tcanEventQueue.on.call(newVal, event, handler);\n\t\t\t\tcurrentContext = newVal;\n\t\t\t}\n\t\t}\n\n\t\t// Bind the handler defined above to the element we're currently processing and the event name provided in this\n\t\t// attribute name (can-click=\"foo\")\n\t\tattributesDisposal = domMutate.onNodeAttributeChange(el, attributesHandler);\n\t\tremovalDisposal = domMutate.onNodeDisconnected(el, removalHandler);\n\t\tif (!bindingContext && bindingContextObservable) {\n\t\t\t// on value changes of the observation, rebind the listener to the new context\n\t\t\tremoveObservation = function () {\n\t\t\t\tif (currentContext) {\n\t\t\t\t\tcanEventQueue.off.call(currentContext, event, handler);\n\t\t\t\t}\n\t\t\t\tcanReflect.offValue(bindingContextObservable, updateListener);\n\t\t\t};\n\t\t\tcanReflect.onValue(bindingContextObservable, updateListener);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcanEventQueue.on.call(bindingContext, event, handler);\n\t\t\t} catch (error) {\n\t\t\t\tif (/Unable to bind/.test(error.message)) {\n\t\t\t\t\tvar msg = 'can-stache-bindings - Unable to bind \"' + event + '\"';\n\t\t\t\t\tmsg += ': \"' + event  + '\" is a property on a plain object \"';\n\t\t\t\t\tmsg += JSON.stringify(bindingContext);\n\t\t\t\t\tmsg += '\". Binding is available with observable objects only.';\n\t\t\t\t\tmsg += ' For more details check https://canjs.com/doc/can-stache-bindings.html#Callafunctionwhenaneventhappensonavalueinthescope_animation_';\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t} else {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n// ## Attribute Syntaxes\n// The following sets up the bindings functions to be called\n// when called in a template.\n\n\n// value:to=\"bar\" data bindings\n// these are separate so that they only capture at the end\n// to avoid (toggle)=\"bar\" which is encoded as :lp:toggle:rp:=\"bar\"\nbindings.set(/[\\w\\.:]+:to$/, behaviors.data);\nbindings.set(/[\\w\\.:]+:from$/, behaviors.data);\nbindings.set(/[\\w\\.:]+:bind$/, behaviors.data);\nbindings.set(/[\\w\\.:]+:raw$/, behaviors.data);\n// value:to:on:input=\"bar\" data bindings\nbindings.set(/[\\w\\.:]+:to:on:[\\w\\.:]+/, behaviors.data);\nbindings.set(/[\\w\\.:]+:from:on:[\\w\\.:]+/, behaviors.data);\nbindings.set(/[\\w\\.:]+:bind:on:[\\w\\.:]+/, behaviors.data);\n\n\n// `(EVENT)` event bindings.\nbindings.set(/on:[\\w\\.:]+/, behaviors.event);\n\n// ## getObservableFrom\n// An object of helper functions that make a getter/setter observable\n// on different types of objects.\nvar getObservableFrom = {\n\t// ### getObservableFrom.viewModelOrAttribute\n\tviewModelOrAttribute: function(bindingData, bindingContext) {\n\t\tvar viewModel = bindingContext.element[viewModelSymbol];\n\n\t\t// if we have a viewModel, use it; otherwise, setup attribute binding\n\t\tif (viewModel) {\n\t\t\treturn this.viewModel.apply(this, arguments);\n\t\t} else {\n\t\t\treturn this.attribute.apply(this, arguments);\n\t\t}\n\t},\n\t// ### getObservableFrom.scope\n\t// Returns a compute from the scope.  This handles expressions like `someMethod(.,1)`.\n\tscope: function(bindingData, bindingContext) {\n\t\tvar scope = bindingContext.scope,\n\t\t\tscopeProp = bindingData.name,\n\t\t\tmustBeGettable = bindingData.exports;\n\n\t\tif (!scopeProp) {\n\t\t\treturn new SimpleObservable();\n\t\t} else {\n\t\t\t// Check if we need to spend time building a scope-key-data\n\t\t\t// If we have a '(', it likely means a call expression.\n\t\t\tif (mustBeGettable || scopeProp.indexOf(\"(\") >= 0 || scopeProp.indexOf(\"=\") >= 0) {\n\t\t\t\tvar parentExpression = expression.parse(scopeProp,{baseMethodType: \"Call\"});\n\n\t\t\t\tif (parentExpression instanceof expression.Hashes) {\n\t\t\t\t\treturn new SimpleObservable(function () {\n\t\t\t\t\t\tvar hashExprs = parentExpression.hashExprs;\n\t\t\t\t\t\tvar key = Object.keys(hashExprs)[0];\n\t\t\t\t\t\tvar value = parentExpression.hashExprs[key].value(scope);\n\t\t\t\t\t\tvar isObservableValue = canReflect.isObservableLike(value) && canReflect.isValueLike(value);\n\t\t\t\t\t\tscope.set(key, isObservableValue ? canReflect.getValue(value) : value);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn parentExpression.value(scope);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar observation = {};\n\t\t\t\tcanReflect.assignSymbols(observation, {\n\t\t\t\t\t\"can.getValue\": function getValue() {},\n\n\t\t\t\t\t\"can.valueHasDependencies\": function hasValueDependencies() {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\n\t\t\t\t\t\"can.setValue\": function setValue(newVal) {\n\t\t\t\t\t\tvar expr = expression.parse(cleanVMName(scopeProp, scope),{baseMethodType: \"Call\"});\n\t\t\t\t\t\tvar value = expr.value(scope);\n\t\t\t\t\t\tcanReflect.setValue(value, newVal);\n\t\t\t\t\t},\n\n\t\t\t\t\t// Register what the custom observation changes\n\t\t\t\t\t\"can.getWhatIChange\": function getWhatIChange() {\n\t\t\t\t\t\tvar data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));\n\t\t\t\t\t\tvar m = new Map();\n\t\t\t\t\t\tvar s = new Set();\n\t\t\t\t\t\ts.add(data.key);\n\t\t\t\t\t\tm.set(data.parent, s);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tmutate: {\n\t\t\t\t\t\t\t\tkeyDependencies: m\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\n\t\t\t\t\t\"can.getName\": function getName() {\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tvar result = \"ObservableFromScope<>\";\n\t\t\t\t\t\t\tvar data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));\n\n\t\t\t\t\t\t\tif (data.parent && data.key) {\n\t\t\t\t\t\t\t\tresult = \"ObservableFromScope<\" +\n\t\t\t\t\t\t\t\t\tcanReflect.getName(data.parent) +\n\t\t\t\t\t\t\t\t\t\".\" +\n\t\t\t\t\t\t\t\t\tdata.key +\n\t\t\t\t\t\t\t\t\t\">\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tvar data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));\n\t\t\t\tif (data.parent && data.key) {\n\t\t\t\t\t// Register what changes the Scope's parent key\n\t\t\t\t\tcanReflectDeps.addMutatedBy(data.parent, data.key, observation);\n\t\t\t\t}\n\n\t\t\t\treturn observation;\n\t\t\t}\n\t\t}\n\t},\n\t// ### getObservableFrom.viewModel\n\t// Returns a compute that's two-way bound to the `viewModel` returned by\n\t// `options.bindingSettings()`.\n\t// Arguments:\n\t// - bindingData - {source, name, setCompute}\n\t// - bindingContext - {scope, element}\n\t// - bindingSettings - {getViewModel}\n\tviewModel: function(bindingData, bindingContext) {\n\t\tvar scope = bindingContext.scope,\n\t\t\tvmName = bindingData.name,\n\t\t\tsetCompute = bindingData.setCompute;\n\n\t\tvar setName = cleanVMName(vmName, scope);\n\t\tvar isBoundToContext = vmName === \".\" || vmName === \"this\";\n\t\tvar keysToRead = isBoundToContext ? [] : stacheKey.reads(vmName);\n\n\t\tfunction getViewModelProperty() {\n\t\t\tvar viewModel = bindingContext.viewModel;\n\t\t\treturn stacheKey.read(viewModel, keysToRead, {}).value;\n\t\t}\n\t\t//!steal-remove-start\n\t\tif (true) {\n\n\t\t\tObject.defineProperty(getViewModelProperty, \"name\", {\n\t\t\t\tvalue: \"<\"+bindingContext.element.tagName.toLowerCase()+\">.\" + vmName\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tvar observation = new SettableObservable(\n\t\t\tgetViewModelProperty,\n\n\t\t\tfunction setViewModelProperty(newVal) {\n\t\t\t\tvar viewModel = bindingContext.viewModel;\n\n\t\t\t\tif (setCompute) {\n\t\t\t\t\t// If there is a binding like `foo:from=\"~bar\"`, we need\n\t\t\t\t\t// to set the observable itself.\n\t\t\t\t\tvar oldValue = canReflect.getKeyValue(viewModel, setName);\n\t\t\t\t\tif (canReflect.isObservableLike(oldValue)) {\n\t\t\t\t\t\tcanReflect.setValue(oldValue, newVal);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanReflect.setKeyValue(\n\t\t\t\t\t\t\tviewModel,\n\t\t\t\t\t\t\tsetName,\n\t\t\t\t\t\t\tnew SimpleObservable(canReflect.getValue(newVal))\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isBoundToContext) {\n\t\t\t\t\t\tcanReflect.setValue(viewModel, newVal);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstacheKey.write(viewModel, keysToRead, newVal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tvar viewModel = bindingContext.viewModel;\n\t\t\tif (viewModel && setName) {\n\t\t\t\tcanReflectDeps.addMutatedBy(viewModel, setName, observation);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn observation;\n\t},\n\t// ### getObservableFrom.attribute\n\t// Returns a compute that is two-way bound to an attribute or property on the element.\n\tattribute: function(bindingData, bindingContext ) {\n\n\t\tif(bindingData.name === \"this\") {\n\t\t\treturn canReflect.assignSymbols({}, {\n\t\t\t\t\"can.getValue\": function() {\n\t\t\t\t\treturn bindingContext.element;\n\t\t\t\t},\n\n\t\t\t\t\"can.valueHasDependencies\": function() {\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\t\"can.getName\": function getName() {\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\treturn \"<\"+bindingContext.element.nodeName+\">\";\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn new AttributeObservable(bindingContext.element, bindingData.name, {}, bindingData.event);\n\t\t}\n\n\t}\n};\n\nvar startsWith = String.prototype.startsWith || function(text){\n\treturn this.indexOf(text) === 0;\n};\n\n// Gets an event name in the after part.\nfunction getEventName(result) {\n\tif (result.special.on !== undefined) {\n\t\treturn result.tokens[result.special.on + 1];\n\t}\n}\n\nvar siblingBindingRules = {\n\tto: {\n\t\tchild: {\n\t\t\texports: true,\n\t\t\tsyncSibling: false\n\t\t},\n\t\tparent: {\n\t\t\texports: false,\n\t\t\tsyncSibling: false\n\t\t}\n\t},\n\tfrom: {\n\t\tchild: {\n\t\t\texports: false,\n\t\t\tsyncSibling: false\n\t\t},\n\t\tparent: {\n\t\t\texports: true,\n\t\t\tsyncSibling: false\n\t\t}\n\t},\n\tbind: {\n\t\tchild: {\n\t\t\texports: true,\n\t\t\tsyncSibling: false\n\t\t},\n\t\tparent: {\n\t\t\texports: true,\n\t\t\tsyncSibling: true\n\t\t}\n\t},\n\traw: {\n\t\tchild: {\n\t\t\texports: false,\n\t\t\tsyncSibling: false\n\t\t},\n\t\tparent: {\n\t\t\texports: true,\n\t\t\tsyncSibling: false\n\t\t}\n\t}\n};\nvar bindingNames = [];\nvar special = {\n\tvm: true,\n\ton: true\n};\ncanReflect.eachKey(siblingBindingRules, function(value, key) {\n\tbindingNames.push(key);\n\tspecial[key] = true;\n});\n\n// \"on:click:value:to\" //-> {tokens: [...], special: {on: 0, to: 3}}\nfunction tokenize(source) {\n\tvar splitByColon = source.split(\":\");\n\t// combine tokens that are not to, from, vm,\n\tvar result = {\n\t\ttokens: [],\n\t\tspecial: {}\n\t};\n\tsplitByColon.forEach(function(token) {\n\t\tif (special[token]) {\n\t\t\tresult.special[token] = result.tokens.push(token) - 1;\n\t\t} else {\n\t\t\tresult.tokens.push(token);\n\t\t}\n\t});\n\n\treturn result;\n}\n\n// ## getChildBindingStr\nvar getChildBindingStr = function(tokens, favorViewModel) {\n\tif (tokens.indexOf('vm') >= 0) {\n\t\treturn viewModelBindingStr;\n\t} else if (tokens.indexOf('el') >= 0) {\n\t\treturn attributeBindingStr;\n\t} else {\n\t\treturn favorViewModel ? viewModelBindingStr : viewModelOrAttributeBindingStr;\n\t}\n};\n\n// ## getSiblingBindingData\n// Returns information about the binding read from an attribute node.\n// Arguments:\n// - node - An attribute node like: `{name, value}`\n// - bindingSettings - Optional.  Has {favorViewModel: Boolean}\n// Returns an object with:\n// - `parent` - {source, name, event, exports, syncSibling}\n// - `child` - {source, name, event, exports, syncSibling, setCompute}\n// - `bindingAttributeName` - debugging name.\n// - `initializeValues` - should parent and child be initialized to their counterpart.\n//\n// `parent` and `child` properties:\n//\n// - `source` - where is the value read from: \"scope\", \"attribute\", \"viewModel\".\n// - `name` - the name of the property that should be read\n// - `event` - an optional event name to listen to\n// - `exports` - if the value is exported to its sibling\n// - `syncSibling` - if the value is sticky. When this value is updated, should the value be checked after\n//   and its sibling be updated immediately.\n// - `setCompute` - set the value to a compute.\nfunction getSiblingBindingData(node, bindingSettings) {\n\n\tvar siblingBindingData,\n\t\tattributeName = encoder.decode(node.name),\n\t\tattributeValue = node.value || \"\";\n\n\tvar result = tokenize(attributeName),\n\t\tdataBindingName,\n\t\tspecialIndex;\n\n\t// check if there's a match of a binding name with at least a value before it\n\tbindingNames.forEach(function(name) {\n\t\tif (result.special[name] !== undefined && result.special[name] > 0) {\n\t\t\tdataBindingName = name;\n\t\t\tspecialIndex = result.special[name];\n\t\t\treturn false;\n\t\t}\n\t});\n\n\tif (dataBindingName) {\n\t\tvar childEventName = getEventName(result);\n\n\t\tvar initializeValues = childEventName && dataBindingName !== \"bind\" ? false : true;\n\t\tsiblingBindingData = {\n\t\t\tparent: assign({\n\t\t\t\tsource: scopeBindingStr,\n\t\t\t\tname: result.special.raw ? ('\"' + attributeValue + '\"') : attributeValue\n\t\t\t}, siblingBindingRules[dataBindingName].parent),\n\t\t\tchild: assign({\n\t\t\t\tsource: getChildBindingStr(result.tokens, bindingSettings && bindingSettings.favorViewModel),\n\t\t\t\tname: result.tokens[specialIndex - 1],\n\t\t\t\tevent: childEventName\n\t\t\t}, siblingBindingRules[dataBindingName].child),\n\t\t\tbindingAttributeName: attributeName,\n\t\t\tinitializeValues: initializeValues\n\t\t};\n\t\tif (attributeValue.trim().charAt(0) === \"~\") {\n\t\t\tsiblingBindingData.child.setCompute = true;\n\t\t}\n\t\treturn siblingBindingData;\n\t}\n}\n\n\n\n// ## makeDataBinding\n// Makes a data binding for an attribute `node`.  Returns an object with information\n// about the binding, including an `onTeardown` method that undoes the binding.\n// If the data binding involves a `viewModel`, an `onCompleteBinding` method is returned on\n// the object.  This method must be called after the element has a `viewModel` with the\n// `viewModel` to complete the binding.\n//\n// Arguments:\n// - `node` - an attribute node or an object with a `name` and `value` property.\n// - `bindingContext` - The stache context  `{scope, element, parentNodeList}`\n// - `bindingSettings` - Settings to control the behavior.\n//   - `getViewModel`  - a function that returns the `viewModel` when called.  This function can be passed around (not called) even if the\n//      `viewModel` doesn't exist yet.\n//   - `attributeViewModelBindings` - properties already specified as being a viewModel<->attribute (as opposed to viewModel<->scope) binding.\n//   - `favorViewModel`\n//   - `alreadyUpdatedChild`\n// Returns:\n// - `undefined` - If this isn't a data binding.\n// - `object` - An object with information about the binding:\n//   - siblingBindingData: the binding behavior\n//   - binding: canBinding\nvar makeDataBinding = function(node, bindingContext, bindingSettings) {\n\t// Get information about the binding.\n\tvar siblingBindingData = getSiblingBindingData( node, bindingSettings );\n\tif (!siblingBindingData) {\n\t\treturn;\n\t}\n\n\t// Get computes for the parent and child binding\n\tvar parentObservable = getObservableFrom[siblingBindingData.parent.source](\n\t\tsiblingBindingData.parent,\n\t\tbindingContext, bindingSettings\n\t),\n\tchildObservable = getObservableFrom[siblingBindingData.child.source](\n\t\tsiblingBindingData.child,\n\t\tbindingContext, bindingSettings,\n\t\tparentObservable\n\t);\n\n\tvar childToParent = !!siblingBindingData.child.exports;\n\tvar parentToChild = !!siblingBindingData.parent.exports;\n\n\t// Check for child:bind=\"~parent\" (itâ€™s not supported because itâ€™s unclear\n\t// what the â€œrightâ€Â behavior should be)\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tif (siblingBindingData.child.setCompute && childToParent && parentToChild) {\n\t\t\tdev.warn(\"Two-way binding computes is not supported.\");\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\tvar bindingOptions = {\n\t\tchild: childObservable,\n\t\tchildToParent: childToParent,\n\t\t// allow cycles if one directional\n\t\tcycles: childToParent === true && parentToChild === true ? 0 : 100,\n\t\tonInitDoNotUpdateChild: bindingSettings.alreadyUpdatedChild || siblingBindingData.initializeValues === false,\n\t\tonInitDoNotUpdateParent: siblingBindingData.initializeValues === false,\n\t\tonInitSetUndefinedParentIfChildIsDefined: true,\n\t\tparent: parentObservable,\n\t\tparentToChild: parentToChild,\n\t\tpriority: bindingContext.parentNodeList ? bindingContext.parentNodeList.nesting + 1 : undefined,\n\t\tqueue: \"dom\",\n\t\tsticky: siblingBindingData.parent.syncSibling ? \"childSticksToParent\" : undefined,\n\t\telement: bindingContext.element\n\t};\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tvar nodeHTML = encoder.decode(node.name)+\"=\"+JSON.stringify(node.value);\n\t\tvar tagStart = \"<\"+bindingContext.element.nodeName.toLowerCase(),\n\t\t\ttag = tagStart+\">\";\n\n\t\tvar makeUpdateName = function(child, childName) {\n\n\t\t\tif(child === \"viewModel\") {\n\t\t\t\treturn tag+\".\"+childName;\n\t\t\t}\n\t\t\telse if(child === \"scope\") {\n\t\t\t\treturn \"{{\"+childName+\"}}\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"\"+child+\".\"+childName;\n\t\t\t}\n\t\t};\n\t\tbindingOptions.debugName = tagStart+\" \"+nodeHTML+\">\";\n\t\tbindingOptions.updateChildName = bindingOptions.debugName+\" updates \"+\n\t\t\tmakeUpdateName(siblingBindingData.child.source, siblingBindingData.child.name)+\n\t\t\t\" from \"+makeUpdateName(siblingBindingData.parent.source, siblingBindingData.parent.name);\n\n\t\tbindingOptions.updateParentName = bindingOptions.debugName+\" updates \"+\n\t\t\tmakeUpdateName(siblingBindingData.parent.source, siblingBindingData.parent.name)+\n\t\t\t\" from \"+makeUpdateName(siblingBindingData.child.source, siblingBindingData.child.name);\n\t}\n\t//!steal-remove-end\n\n\t// Create the binding\n\tvar canBinding = new Bind(bindingOptions);\n\n\treturn {\n\t\tsiblingBindingData: siblingBindingData,\n\t\tbinding: canBinding\n\t};\n};\n\nvar cleanVMName = function(name, scope) {\n\t//!steal-remove-start\n\tif (true) {\n\t\tif (name.indexOf(\"@\") >= 0 && scope) {\n\t\t\tvar filename = scope.peek('scope.filename');\n\t\t\tvar lineNumber = scope.peek('scope.lineNumber');\n\n\t\t\tdev.warn(\n\t\t\t\t(filename ? filename + ':' : '') +\n\t\t\t\t(lineNumber ? lineNumber + ': ' : '') +\n\t\t\t\t'functions are no longer called by default so @ is unnecessary in \\'' + name + '\\'.');\n\t\t}\n\t}\n\t//!steal-remove-end\n\treturn name.replace(/@/g, \"\");\n};\n\nvar canStacheBindings = {\n\tbehaviors: behaviors,\n\tgetSiblingBindingData: getSiblingBindingData,\n\tbindings: bindings,\n\tgetObservableFrom: getObservableFrom,\n\tmakeDataBinding: makeDataBinding\n};\n\ncanStacheBindings[canSymbol.for(\"can.callbackMap\")] = bindings;\n\nmodule.exports = canStacheBindings;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache-bindings/can-stache-bindings.js?");

/***/ }),

/***/ "./node_modules/can-stache-converters/can-stache-converters.js":
/*!*********************************************************************!*\
  !*** ./node_modules/can-stache-converters/can-stache-converters.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar stache = __webpack_require__(/*! can-stache */ \"./node_modules/can-stache/can-stache.js\");\nvar stringToAny = __webpack_require__(/*! can-string-to-any */ \"./node_modules/can-string-to-any/can-string-to-any.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar stacheBindings = __webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\nvar stacheHelpers = __webpack_require__(/*! can-stache-helpers */ \"./node_modules/can-stache-helpers/can-stache-helpers.js\");\n\n\nstache.addBindings(stacheBindings);\n\n// feature detect if multiple arguments are going to be passed\n// to an nested function call\nvar shouldPop = false;\nstache(\"{{echo(args(1))}}\")({\n\techo: function(){},\n\targs: function(){\n\t\tshouldPop = ( arguments.length > 1 );\n\t}\n});\n\nstache.registerConverter(\"boolean-to-inList\", {\n\tget: function(item, list){\n\t\tif(!list) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn list.indexOf(item) !== -1;\n\t\t}\n\t},\n\tset: function(newVal, item, list){\n\t\tif(!list) {\n\t\t\treturn;\n\t\t}\n\t\tif(!newVal) {\n\t\t\tvar idx = list.indexOf(item);\n\t\t\tif(idx !== -1) {\n\t\t\t\tlist.splice(idx, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tlist.push(item);\n\t\t}\n\t}\n});\n\nvar converters = {\n\t\"string-to-any\": {\n\t\tget: function(obs){\n\t\t\treturn \"\" + canReflect.getValue(obs);\n\t\t},\n\t\tset: function(newVal, obs){\n\t\t\tvar converted = stringToAny(newVal);\n\t\t\tcanReflect.setValue(obs, converted);\n\t\t}\n\t},\n\t\"index-to-selected\": {\n\t\tget: function(item, list){\n\t\t\tvar val = canReflect.getValue(item);\n\t\t\tvar idx = canReflect.getValue(list).indexOf(val);\n\t\t\treturn idx;\n\t\t},\n\t\tset: function(idx, item, list){\n\t\t\tvar newVal = canReflect.getValue(list)[idx];\n\t\t\tcanReflect.setValue(item, newVal);\n\t\t}\n\t},\n\t\"selected-to-index\": {\n\t\tget: function(idx, list){\n\t\t\tvar val = canReflect.getValue(idx),\n\t\t\t\tlistValue = canReflect.getValue(list);\n\t\t\tvar item = listValue[val];\n\t\t\treturn item;\n\t\t},\n\t\tset: function(item, idx, list){\n\t\t\tvar newVal = canReflect.getValue(list).indexOf(item);\n\t\t\tcanReflect.setValue(idx, newVal);\n\t\t}\n\t},\n\t\"either-or\": {\n\t\tget: function(chosen, a, b){\n\t\t\tvar chosenVal = canReflect.getValue(chosen),\n\t\t\t\taValue = canReflect.getValue(a),\n\t\t\t\tbValue = canReflect.getValue(b);\n\t\t\tvar matchA = (aValue === chosenVal);\n\t\t\tvar matchB = (bValue === chosenVal);\n\n\t\t\tif (!matchA && !matchB) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tdev.warn(\n\t\t\t\t\t\t\"can-stache-converter.either-or:\",\n\t\t\t\t\t\t\"`\" + chosenVal + \"`\",\n\t\t\t\t\t\t\"does not match `\" + aValue + \"`\",\n\t\t\t\t\t\t\"or `\" + bValue + \"`\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn matchA;\n\t\t\t}\n\t\t},\n\t\tset: function(newVal, chosen, a, b){\n\t\t\tvar setVal = newVal ? canReflect.getValue(a) : canReflect.getValue(b);\n\t\t\tcanReflect.setValue(chosen, setVal);\n\t\t}\n\t},\n\t\"equal\": {\n\t\tget: function(){\n\t\t\tvar args = canReflect.toArray(arguments);\n\t\t\t// We don't need the helperOptions\n\t\t\tif(shouldPop) {\n\t\t\t\targs.pop();\n\t\t\t}\n\t\t\tif (args.length > 1) {\n\t\t\t\tvar comparer = canReflect.getValue( args.pop() );\n\n\t\t\t\treturn args.every(function(obs) {\n\t\t\t\t\tvar value = canReflect.getValue(obs);\n\t\t\t\t\treturn value === comparer;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tset: function(){\n\t\t\tvar args = canReflect.toArray(arguments);\n\t\t\t// Ignore the helperOptions\n\t\t\tif(shouldPop) {\n\t\t\t\targs.pop();\n\t\t\t}\n\t\t\tif (args.length > 2) {\n\t\t\t\tvar b = args.shift();\n\t\t\t\tvar comparer = canReflect.getValue( args.pop() );\n\t\t\t\tif(b) {\n\t\t\t\t\tfor(var i = 0; i < args.length; i++) {\n\t\t\t\t\t\tcanReflect.setValue(args[i], comparer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Register itself right away\nstache.addConverter(converters);\n\nif(!stacheHelpers.not) {\n\tstache.addConverter(\"not\",{\n\t\tget: function(obs){\n\t\t\treturn !canReflect.getValue(obs);\n\t\t},\n\t\tset: function(newVal, obs){\n\t\t\tcanReflect.setValue(obs, !newVal);\n\t\t}\n\t});\n}\n\nmodule.exports = converters;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache-converters/can-stache-converters.js?");

/***/ }),

/***/ "./node_modules/can-stache-element/dist/can-stache-element.js":
/*!********************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/can-stache-element.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar mixinLifecycleMethods = __webpack_require__(/*! ./mixin-lifecycle-methods */ \"./node_modules/can-stache-element/dist/mixin-lifecycle-methods.js\");\n\nvar mixinProps = __webpack_require__(/*! ./mixin-props */ \"./node_modules/can-stache-element/dist/mixin-props.js\");\n\nvar mixinStacheView = __webpack_require__(/*! ./mixin-stache-view */ \"./node_modules/can-stache-element/dist/mixin-stache-view.js\");\n\nvar mixinViewModelSymbol = __webpack_require__(/*! ./mixin-viewmodel-symbol */ \"./node_modules/can-stache-element/dist/mixin-viewmodel-symbol.js\");\n\nvar mixinBindings = __webpack_require__(/*! ./mixin-bindings */ \"./node_modules/can-stache-element/dist/mixin-bindings.js\");\n\nvar mixinInitializeBindings = __webpack_require__(/*! ./mixin-initialize-bindings */ \"./node_modules/can-stache-element/dist/mixin-initialize-bindings.js\");\n\nvar mixinBindBehaviour = __webpack_require__(/*! ./mixin-bind-behaviour */ \"./node_modules/can-stache-element/dist/mixin-bind-behaviour.js\");\n\nvar _require = __webpack_require__(/*! ./mixin-bind-behaviour */ \"./node_modules/can-stache-element/dist/mixin-bind-behaviour.js\"),\n    initializeObservedAttributes = _require.initializeObservedAttributes;\n\nvar canStacheBindings = __webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\n\nvar _require2 = __webpack_require__(/*! can-observable-mixin */ \"./node_modules/can-observable-mixin/dist/mixins.js\"),\n    createConstructorFunction = _require2.createConstructorFunction;\n\nvar initializeSymbol = Symbol.for(\"can.initialize\");\nvar teardownHandlersSymbol = Symbol.for(\"can.teardownHandlers\");\nvar isViewSymbol = Symbol.for(\"can.isView\");\n\nvar Scope = __webpack_require__(/*! can-view-scope */ \"./node_modules/can-view-scope/can-view-scope.js\"); // Calling a renderer like {{foo()}} gets the template scope\n// added no matter what. This checks for that condition.\n// https://github.com/canjs/can-stache/issues/719\n\n\nfunction rendererWasCalledWithData(scope) {\n  return scope instanceof Scope && scope._parent && scope._parent._context instanceof Scope.TemplateContext;\n}\n\nfunction addContext(rawRenderer, tagData) {\n  function renderer(data) {\n    if (rendererWasCalledWithData(data)) {\n      return rawRenderer(tagData.scope.addLetContext(data._context));\n    } else {\n      // if it was called programmatically (not in stache), just add the data\n      return rawRenderer(tagData.scope.addLetContext(data));\n    }\n  } // Marking as a view will add the template scope ... but it should\n  // already be present in `tagData.scope`.\n  // However, I mark this as a renderer because that is what it is.\n\n\n  renderer[isViewSymbol] = true;\n  return renderer;\n}\n\nfunction DeriveElement() {\n  var BaseElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n\n  var StacheElement =\n  /*#__PURE__*/\n  function (_mixinLifecycleMethod) {\n    _inherits(StacheElement, _mixinLifecycleMethod);\n\n    function StacheElement() {\n      _classCallCheck(this, StacheElement);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(StacheElement).apply(this, arguments));\n    }\n\n    _createClass(StacheElement, [{\n      key: initializeSymbol,\n      value: function value(el, tagData) {\n        var teardownBindings = canStacheBindings.behaviors.viewModel(el, tagData, function makeViewModel(initialViewmodelData) {\n          for (var prop in tagData.templates) {\n            // It's ok to modify the argument. The argument is created\n            // just for what gets passed into creating the VM.\n            initialViewmodelData[prop] = addContext(tagData.templates[prop], tagData);\n          }\n\n          el.render(initialViewmodelData);\n          return el;\n        });\n\n        if (el[teardownHandlersSymbol]) {\n          el[teardownHandlersSymbol].push(teardownBindings);\n        }\n      }\n    }]);\n\n    return StacheElement;\n  }( // add lifecycle methods\n  // this needs to happen after other mixins that implement these methods\n  // so that this.<lifecycleMethod> is the actual lifecycle method which\n  // controls whether the methods farther \"down\" the chain are called\n  mixinLifecycleMethods( // mixin .bindings() method and behavior\n  mixinBindings( // Find all prop definitions and extract `{ bind: () => {} }` for binding initialization\n  mixinBindBehaviour( // Initialize the bindings\n  mixinInitializeBindings( // mix in viewModel symbol used by can-stache-bindings\n  mixinViewModelSymbol( // mix in stache renderer from `static view` property\n  mixinStacheView( // add getters/setters from `static props` property\n  mixinProps(BaseElement))))))));\n\n  var StacheElementConstructorFunction = createConstructorFunction(StacheElement); // Initialize the `observedAttributes`\n\n  initializeObservedAttributes(StacheElementConstructorFunction);\n  return StacheElementConstructorFunction;\n}\n\nmodule.exports = namespace.StacheElement = DeriveElement();\n\n//# sourceURL=webpack:///./node_modules/can-stache-element/dist/can-stache-element.js?");

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-bind-behaviour.js":
/*!**********************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-bind-behaviour.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar _require = __webpack_require__(/*! can-observable-mixin */ \"./node_modules/can-observable-mixin/dist/mixins.js\"),\n    mixins = _require.mixins;\n\nvar metaSymbol = Symbol.for(\"can.meta\"); // `attributeChangedCallback` cannot be overwritten so we need to create a named\n// function to check if we have had a `attributeChangedCallback` set.\n\nfunction baseAttributeChangedCallback() {\n  /* jshint validthis: true */\n  if (this.attributeChangedCallback !== baseAttributeChangedCallback) {\n    // `this.attributeChangedCallback` is being set up within `can-observable-bindings`\n    this.attributeChangedCallback.apply(this, arguments);\n  }\n}\n\nmodule.exports = function mixinBindBehaviour() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n\n  var BindingPropsClass =\n  /*#__PURE__*/\n  function (_Base) {\n    _inherits(BindingPropsClass, _Base);\n\n    function BindingPropsClass() {\n      _classCallCheck(this, BindingPropsClass);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(BindingPropsClass).apply(this, arguments));\n    }\n\n    _createClass(BindingPropsClass, [{\n      key: \"initialize\",\n      value: function initialize(props) {\n        var _this = this;\n\n        if (this[metaSymbol] === undefined) {\n          this[metaSymbol] = {};\n        }\n\n        if (this[metaSymbol]._bindings === undefined) {\n          this[metaSymbol]._bindings = [];\n        } // `_uninitializedBindings` are being set within `observedAttributes` which creates the bindings\n\n\n        Object.keys(this.constructor[metaSymbol]._uninitializedBindings).forEach(function (propName) {\n          var binding = _this.constructor[metaSymbol]._uninitializedBindings[propName](_this); // Add bindings to the instance `metaSymbol` to be set up during `mixin-initialize-bindings`\n\n\n          _this[metaSymbol]._bindings.push({\n            binding: binding,\n            siblingBindingData: {\n              parent: {\n                source: \"scope\",\n                exports: true\n              },\n              child: {\n                source: \"viewModel\",\n                exports: true,\n                name: propName\n              },\n              bindingAttributeName: propName\n            }\n          });\n        });\n\n        if (_get(_getPrototypeOf(BindingPropsClass.prototype), \"initialize\", this)) {\n          _get(_getPrototypeOf(BindingPropsClass.prototype), \"initialize\", this).call(this, props);\n        }\n      }\n    }]);\n\n    return BindingPropsClass;\n  }(Base); // To prevent inifinite loop, use a named function so we can differentiate\n  // make it writable so it can be set elsewhere  \n\n\n  Object.defineProperty(BindingPropsClass.prototype, 'attributeChangedCallback', {\n    value: baseAttributeChangedCallback,\n    writable: true\n  });\n  return BindingPropsClass;\n}; // We can't set `observedAttributes` on the `StacheElement.prototype` as static properties are\n// not copied over with `Object.create`\n\n\nmodule.exports.initializeObservedAttributes = function initializeObservedAttributes(ctr) {\n  Object.defineProperty(ctr, 'observedAttributes', {\n    get: function get() {\n      var _this2 = this;\n\n      // We only want to return `observedAttributes` if we have a `bind` on the\n      // property definition\n      var hasBindDefinition = false; // Run finalizeClass to set up the property definitions\n\n      mixins.finalizeClass(this);\n\n      if (this[metaSymbol] === undefined) {\n        this[metaSymbol] = {};\n      }\n\n      if (this[metaSymbol]._uninitializedBindings === undefined) {\n        this[metaSymbol]._uninitializedBindings = {};\n      } // Check that we have property definitions\n\n\n      var definitions = this.prototype._define && this.prototype._define.definitions;\n\n      if (definitions) {\n        // Run through all defitions so we can check if they have a `bind` function\n        Object.keys(definitions).forEach(function (propName) {\n          var definition = definitions[propName];\n\n          if (typeof definition.bind === 'function') {\n            var bindFn = definition.bind(propName, _this2); // Set up the bindings so that they can be called during initialize\n            // to setup binding starts\n\n            _this2[metaSymbol]._uninitializedBindings[propName] = bindFn;\n            hasBindDefinition = true;\n          }\n        });\n      } // Only return `this.observedAttributes` if we have binds otherwise\n      // we create an inifinite loop\n\n\n      return hasBindDefinition ? this.observedAttributes : [];\n    }\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/can-stache-element/dist/mixin-bind-behaviour.js?");

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-bindings.js":
/*!****************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-bindings.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar keyObservable = __webpack_require__(/*! can-simple-observable/key/key */ \"./node_modules/can-simple-observable/key/key.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar Bind = __webpack_require__(/*! can-bind */ \"./node_modules/can-bind/can-bind.js\");\n\nvar getValueSymbol = Symbol.for(\"can.getValue\");\nvar setValueSymbol = Symbol.for(\"can.setValue\");\nvar metaSymbol = Symbol.for(\"can.meta\");\n\nmodule.exports = function mixinBindings() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return (\n    /*#__PURE__*/\n    function (_Base) {\n      _inherits(BindingsClass, _Base);\n\n      function BindingsClass() {\n        _classCallCheck(this, BindingsClass);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(BindingsClass).apply(this, arguments));\n      }\n\n      _createClass(BindingsClass, [{\n        key: \"bindings\",\n        value: function bindings(_bindings) {\n          var _this = this;\n\n          if (this[metaSymbol] === undefined) {\n            this[metaSymbol] = {};\n          }\n\n          var bindingsObservables = {};\n          canReflect.eachKey(_bindings, function (parent, propName) {\n            // Create an observable for reading/writing the viewModel\n            // even though it doesn't exist yet.\n            var child = keyObservable(_this, propName);\n            bindingsObservables[propName] = {\n              parent: parent,\n              child: child\n            };\n          });\n          this[metaSymbol]._connectedBindings = bindingsObservables;\n          return this;\n        }\n      }, {\n        key: \"initialize\",\n        value: function initialize(props) {\n          var _this2 = this;\n\n          var savedBindings = this[metaSymbol] && this[metaSymbol]._connectedBindings;\n\n          if (savedBindings) {\n            props = props || {};\n\n            if (this[metaSymbol]._bindings === undefined) {\n              this[metaSymbol]._bindings = [];\n            }\n\n            canReflect.eachKey(savedBindings, function (binding, propName) {\n              var child = binding.child,\n                  parent = binding.parent;\n              var canGetParentValue = parent != null && !!parent[getValueSymbol];\n              var canSetParentValue = parent != null && !!parent[setValueSymbol]; // If we can get or set the value, then weâ€™ll create a binding\n\n              if (canGetParentValue || canSetParentValue) {\n                // Create the binding similar to whatâ€™s in can-stache-bindings\n                var canBinding = new Bind({\n                  child: child,\n                  parent: parent,\n                  queue: \"dom\",\n                  element: _this2,\n                  //!steal-remove-start\n                  // For debugging: the names that will be assigned to the updateChild\n                  // and updateParent functions within can-bind\n                  updateChildName: \"update <\" + _this2.nodeName.toLowerCase() + \">.\" + propName,\n                  updateParentName: \"update \" + canReflect.getName(parent) + \" from <\" + _this2.nodeName.toLowerCase() + \">.\" + propName //!steal-remove-end\n\n                });\n\n                _this2[metaSymbol]._bindings.push({\n                  binding: canBinding,\n                  siblingBindingData: {\n                    parent: {\n                      source: \"scope\",\n                      exports: canGetParentValue\n                    },\n                    child: {\n                      source: \"viewModel\",\n                      exports: canSetParentValue,\n                      name: propName\n                    },\n                    bindingAttributeName: propName\n                  }\n                });\n              } else {\n                // Canâ€™t get or set the value, so assume itâ€™s not an observable\n                props[propName] = parent;\n              }\n            });\n            this[metaSymbol].other = true;\n          }\n\n          if (_get(_getPrototypeOf(BindingsClass.prototype), \"initialize\", this)) {\n            _get(_getPrototypeOf(BindingsClass.prototype), \"initialize\", this).call(this, props);\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render(props, renderOptions) {\n          var viewRoot = this.viewRoot || this;\n          viewRoot.innerHTML = \"\";\n\n          if (_get(_getPrototypeOf(BindingsClass.prototype), \"render\", this)) {\n            _get(_getPrototypeOf(BindingsClass.prototype), \"render\", this).call(this, props, renderOptions);\n          }\n        }\n      }, {\n        key: \"disconnect\",\n        value: function disconnect() {\n          delete this[metaSymbol]._bindings;\n\n          if (_get(_getPrototypeOf(BindingsClass.prototype), \"disconnect\", this)) {\n            _get(_getPrototypeOf(BindingsClass.prototype), \"disconnect\", this).call(this);\n          }\n        }\n      }]);\n\n      return BindingsClass;\n    }(Base)\n  );\n};\n\n//# sourceURL=webpack:///./node_modules/can-stache-element/dist/mixin-bindings.js?");

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-initialize-bindings.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-initialize-bindings.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar stacheBindings = __webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\n\nvar metaSymbol = Symbol.for(\"can.meta\");\nvar inSetupSymbol = Symbol.for(\"can.initializing\");\n\nmodule.exports = function mixinBindings() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return (\n    /*#__PURE__*/\n    function (_Base) {\n      _inherits(InitializeBindingsClass, _Base);\n\n      function InitializeBindingsClass() {\n        _classCallCheck(this, InitializeBindingsClass);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(InitializeBindingsClass).apply(this, arguments));\n      }\n\n      _createClass(InitializeBindingsClass, [{\n        key: \"initialize\",\n        value: function initialize(props) {\n          var _this = this;\n\n          var bindings = this[metaSymbol] && this[metaSymbol]._bindings;\n\n          if (bindings && bindings.length) {\n            // set inSetup to false so that observations read in `initializeViewModel`\n            // correctly set up bindings\n            var origInSetup = this[inSetupSymbol];\n            this[inSetupSymbol] = false;\n            var bindingContext = {\n              element: this\n            }; // Initialize the viewModel.  Make sure you\n            // save it so the observables can access it.\n\n            var initializeData = stacheBindings.behaviors.initializeViewModel(bindings, props, function (properties) {\n              _get(_getPrototypeOf(InitializeBindingsClass.prototype), \"initialize\", _this).call(_this, properties);\n\n              return _this;\n            }, bindingContext);\n\n            this[metaSymbol]._connectedBindingsTeardown = function () {\n              for (var attrName in initializeData.onTeardowns) {\n                initializeData.onTeardowns[attrName]();\n              }\n            }; // restore inSetup to the original value\n\n\n            this[inSetupSymbol] = origInSetup;\n          } else {\n            if (_get(_getPrototypeOf(InitializeBindingsClass.prototype), \"initialize\", this)) {\n              _get(_getPrototypeOf(InitializeBindingsClass.prototype), \"initialize\", this).call(this, props);\n            }\n          }\n        }\n      }, {\n        key: \"disconnect\",\n        value: function disconnect() {\n          if (this[metaSymbol] && this[metaSymbol]._connectedBindingsTeardown) {\n            this[metaSymbol]._connectedBindingsTeardown();\n\n            this[metaSymbol]._connectedBindingsTeardown = null;\n          }\n\n          if (_get(_getPrototypeOf(InitializeBindingsClass.prototype), \"disconnect\", this)) {\n            _get(_getPrototypeOf(InitializeBindingsClass.prototype), \"disconnect\", this).call(this);\n          }\n        }\n      }]);\n\n      return InitializeBindingsClass;\n    }(Base)\n  );\n};\n\n//# sourceURL=webpack:///./node_modules/can-stache-element/dist/mixin-initialize-bindings.js?");

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-lifecycle-methods.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-lifecycle-methods.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar lifecycleStatusSymbol = Symbol.for(\"can.lifecycleStatus\");\nvar inSetupSymbol = Symbol.for(\"can.initializing\");\nvar teardownHandlersSymbol = Symbol.for(\"can.teardownHandlers\");\n\nfunction defineConfigurableNonEnumerable(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: value\n  });\n}\n\nmodule.exports = function mixinLifecycleMethods() {\n  var BaseElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return (\n    /*#__PURE__*/\n    function (_BaseElement) {\n      _inherits(LifecycleElement, _BaseElement);\n\n      function LifecycleElement() {\n        var _this;\n\n        _classCallCheck(this, LifecycleElement);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(LifecycleElement).call(this));\n\n        if (arguments.length) {\n          throw new Error(\"can-stache-element: Do not pass arguments to the constructor. Initial property values should be passed to the `initialize` hook.\");\n        } // add inSetup symbol to prevent events being dispatched\n\n\n        defineConfigurableNonEnumerable(_assertThisInitialized(_this), inSetupSymbol, true); // add lifecycle status symbol\n\n        defineConfigurableNonEnumerable(_assertThisInitialized(_this), lifecycleStatusSymbol, {\n          initialized: false,\n          rendered: false,\n          connected: false,\n          disconnected: false\n        }); // add a place to store additional teardownHandlers\n\n        defineConfigurableNonEnumerable(_assertThisInitialized(_this), teardownHandlersSymbol, []);\n        return _this;\n      } // custom element lifecycle methods\n\n\n      _createClass(LifecycleElement, [{\n        key: \"connectedCallback\",\n        value: function connectedCallback(props) {\n          this.initialize(props);\n          this.render();\n          this.connect();\n          return this;\n        }\n      }, {\n        key: \"disconnectedCallback\",\n        value: function disconnectedCallback() {\n          this.disconnect();\n          return this;\n        } // custom lifecycle methods\n\n      }, {\n        key: \"initialize\",\n        value: function initialize(props) {\n          var lifecycleStatus = this[lifecycleStatusSymbol];\n\n          if (lifecycleStatus.initialized) {\n            return this;\n          } // Overwrite ... this means that this initialize\n          // can't be inherited (super.initialize).\n\n\n          this[inSetupSymbol] = true;\n\n          if (_get(_getPrototypeOf(LifecycleElement.prototype), \"initialize\", this)) {\n            _get(_getPrototypeOf(LifecycleElement.prototype), \"initialize\", this).call(this, props);\n          }\n\n          this[inSetupSymbol] = false;\n          lifecycleStatus.initialized = true;\n          return this;\n        }\n      }, {\n        key: \"render\",\n        value: function render(props) {\n          var lifecycleStatus = this[lifecycleStatusSymbol];\n\n          if (lifecycleStatus.rendered) {\n            return this;\n          }\n\n          if (!lifecycleStatus.initialized) {\n            this.initialize(props);\n          }\n\n          if (_get(_getPrototypeOf(LifecycleElement.prototype), \"render\", this)) {\n            _get(_getPrototypeOf(LifecycleElement.prototype), \"render\", this).call(this, props);\n          }\n\n          lifecycleStatus.rendered = true;\n          return this;\n        }\n      }, {\n        key: \"connect\",\n        value: function connect(props) {\n          var lifecycleStatus = this[lifecycleStatusSymbol];\n\n          if (lifecycleStatus.connected) {\n            return this;\n          }\n\n          if (!lifecycleStatus.initialized) {\n            this.initialize(props);\n          }\n\n          if (!lifecycleStatus.rendered) {\n            this.render(props);\n          }\n\n          if (_get(_getPrototypeOf(LifecycleElement.prototype), \"connect\", this)) {\n            _get(_getPrototypeOf(LifecycleElement.prototype), \"connect\", this).call(this, props);\n          }\n\n          if (this.connected) {\n            var connectedTeardown = this.connected();\n\n            if (typeof connectedTeardown === \"function\") {\n              this[teardownHandlersSymbol].push(connectedTeardown);\n            }\n          }\n\n          lifecycleStatus.connected = true;\n          lifecycleStatus.disconnected = false;\n          return this;\n        }\n      }, {\n        key: \"disconnect\",\n        value: function disconnect() {\n          var lifecycleStatus = this[lifecycleStatusSymbol];\n\n          if (lifecycleStatus.disconnected) {\n            return this;\n          }\n\n          if (_get(_getPrototypeOf(LifecycleElement.prototype), \"disconnect\", this)) {\n            _get(_getPrototypeOf(LifecycleElement.prototype), \"disconnect\", this).call(this);\n          }\n\n          if (this.stopListening) {\n            this.stopListening();\n          }\n\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = this[teardownHandlersSymbol][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var handler = _step.value;\n              handler.call(this);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          if (this.disconnected) {\n            this.disconnected();\n          }\n\n          this[lifecycleStatusSymbol] = {\n            initialized: false,\n            rendered: false,\n            connected: false,\n            disconnected: true\n          };\n          return this;\n        }\n      }]);\n\n      return LifecycleElement;\n    }(BaseElement)\n  );\n};\n\n//# sourceURL=webpack:///./node_modules/can-stache-element/dist/mixin-lifecycle-methods.js?");

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-props.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-props.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _require = __webpack_require__(/*! can-observable-mixin */ \"./node_modules/can-observable-mixin/dist/mixins.js\"),\n    mixinElement = _require.mixinElement;\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar canLogDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\nvar eventTargetInstalledSymbol = Symbol.for(\"can.eventTargetInstalled\");\n\nmodule.exports = function mixinDefine() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  var realAddEventListener = Base.prototype.addEventListener;\n  var realRemoveEventListener = Base.prototype.removeEventListener;\n\n  function installEventTarget(Type) {\n    if (Type[eventTargetInstalledSymbol]) {\n      return;\n    }\n\n    var eventQueueAddEventListener = Type.prototype.addEventListener;\n    var eventQueueRemoveEventListener = Type.prototype.removeEventListener;\n\n    Type.prototype.addEventListener = function () {\n      eventQueueAddEventListener.apply(this, arguments);\n      return realAddEventListener.apply(this, arguments);\n    };\n\n    Type.prototype.removeEventListener = function () {\n      eventQueueRemoveEventListener.apply(this, arguments);\n      return realRemoveEventListener.apply(this, arguments);\n    };\n\n    Type[eventTargetInstalledSymbol] = true;\n  } // Warn on special properties\n  //!steal-remove-start\n\n\n  function raisePropWarnings(Type, Base) {\n    if (true) {\n      // look for `static props`and fall back to `static define` if `props` doesn't exist\n      var props = _typeof(Type.props) === \"object\" ? Type.props : _typeof(Type.define) === \"object\" ? Type.define : {};\n      Object.keys(props).forEach(function (key) {\n        if (\"on\" + key in Type.prototype) {\n          canLogDev.warn(\"\".concat(canReflect.getName(Type), \": The defined property [\").concat(key, \"] matches the name of a DOM event. This property could update unexpectedly. Consider renaming.\"));\n        } else if (key in Base.prototype) {\n          canLogDev.warn(\"\".concat(canReflect.getName(Type), \": The defined property [\").concat(key, \"] matches the name of a property on the type being extended, \").concat(canReflect.getName(Base), \". This could lead to errors by changing the expected behaviour of that property. Consider renaming.\"));\n        }\n      });\n    }\n  } //!steal-remove-end\n\n\n  var DefinedClass =\n  /*#__PURE__*/\n  function (_mixinElement) {\n    _inherits(DefinedClass, _mixinElement);\n\n    function DefinedClass() {\n      var _this;\n\n      _classCallCheck(this, DefinedClass);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(DefinedClass).call(this)); //!steal-remove-start\n\n      raisePropWarnings(_this.constructor, Base); //!steal-remove-end\n\n      installEventTarget(_this.constructor);\n      return _this;\n    }\n\n    _createClass(DefinedClass, [{\n      key: \"intialize\",\n      value: function intialize(props) {\n        _get(_getPrototypeOf(DefinedClass.prototype), \"intialize\", this).call(this, props);\n      }\n    }]);\n\n    return DefinedClass;\n  }(mixinElement(Base));\n\n  return DefinedClass;\n};\n\n//# sourceURL=webpack:///./node_modules/can-stache-element/dist/mixin-props.js?");

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-stache-view.js":
/*!*******************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-stache-view.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar stache = __webpack_require__(/*! can-stache */ \"./node_modules/can-stache/can-stache.js\");\n\nvar stacheBindings = __webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\n\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\n\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar Scope = __webpack_require__(/*! can-view-scope */ \"./node_modules/can-view-scope/can-view-scope.js\");\n\nvar rendererSymbol = Symbol.for(\"can.stacheRenderer\");\nvar viewInsertSymbol = Symbol.for(\"can.viewInsert\"); // make bindings work\n\nstache.addBindings(stacheBindings);\n\nmodule.exports = function mixinStacheView() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n\n  var StacheClass =\n  /*#__PURE__*/\n  function (_Base) {\n    _inherits(StacheClass, _Base);\n\n    function StacheClass() {\n      _classCallCheck(this, StacheClass);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(StacheClass).apply(this, arguments));\n    }\n\n    _createClass(StacheClass, [{\n      key: \"render\",\n      value: function render(props, renderOptions) {\n        if (_get(_getPrototypeOf(StacheClass.prototype), \"render\", this)) {\n          _get(_getPrototypeOf(StacheClass.prototype), \"render\", this).call(this, props);\n        } // cache renderer function so `stache(...)` is only called\n        // for the first instance of each StacheElement constructor\n\n\n        var renderer = this.constructor[rendererSymbol];\n\n        if (!renderer) {\n          var view = this.constructor.view;\n          var viewName = canReflect.getName(this.constructor) + \"View\";\n          renderer = typeof view === \"function\" ? view : stache(viewName, view || \"\");\n          this.constructor[rendererSymbol] = renderer;\n        }\n\n        var frag = renderer(new Scope(this, null, {\n          viewModel: true\n        }), renderOptions);\n        var viewRoot = this.viewRoot || this;\n        domMutateNode.appendChild.call(viewRoot, frag);\n      }\n    }, {\n      key: \"connect\",\n      value: function connect() {\n        var _this = this;\n\n        if (_get(_getPrototypeOf(StacheClass.prototype), \"connect\", this)) {\n          _get(_getPrototypeOf(StacheClass.prototype), \"connect\", this).call(this);\n        }\n\n        var removedDisposal = domMutate.onNodeRemoved(this, function () {\n          var doc = _this.ownerDocument;\n          var rootNode = doc.contains ? doc : doc.documentElement;\n\n          if (!rootNode || !rootNode.contains(_this)) {\n            removedDisposal();\n\n            _this.disconnect();\n          }\n        });\n      }\n    }, {\n      key: viewInsertSymbol,\n      value: function value() {\n        return this;\n      }\n    }]);\n\n    return StacheClass;\n  }(Base);\n\n  StacheClass.prototype[Symbol.for(\"can.preventDataBindings\")] = true;\n  return StacheClass;\n};\n\n//# sourceURL=webpack:///./node_modules/can-stache-element/dist/mixin-stache-view.js?");

/***/ }),

/***/ "./node_modules/can-stache-element/dist/mixin-viewmodel-symbol.js":
/*!************************************************************************!*\
  !*** ./node_modules/can-stache-element/dist/mixin-viewmodel-symbol.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"./node_modules/can-define-lazy-value/define-lazy-value.js\");\n\nvar viewModelSymbol = Symbol.for(\"can.viewModel\");\n\nmodule.exports = function mixinViewModelSymbol() {\n  var BaseClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n\n  var ViewModelClass =\n  /*#__PURE__*/\n  function (_BaseClass) {\n    _inherits(ViewModelClass, _BaseClass);\n\n    function ViewModelClass() {\n      _classCallCheck(this, ViewModelClass);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ViewModelClass).apply(this, arguments));\n    }\n\n    return ViewModelClass;\n  }(BaseClass); // can-stache-bindings uses viewModel symbol\n\n\n  defineLazyValue(ViewModelClass.prototype, viewModelSymbol, function () {\n    return this;\n  });\n  return ViewModelClass;\n};\n\n//# sourceURL=webpack:///./node_modules/can-stache-element/dist/mixin-viewmodel-symbol.js?");

/***/ }),

/***/ "./node_modules/can-stache-helpers/can-stache-helpers.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-stache-helpers/can-stache-helpers.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nif (namespace.stacheHelpers) {\n\tthrow new Error(\"You can't have two versions of can-stache-helpers, check your dependencies\");\n} else {\n\tmodule.exports = namespace.stacheHelpers = {};\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-stache-helpers/can-stache-helpers.js?");

/***/ }),

/***/ "./node_modules/can-stache-key/can-stache-key.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache-key/can-stache-key.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canReflectPromise = __webpack_require__(/*! can-reflect-promise */ \"./node_modules/can-reflect-promise/can-reflect-promise.js\");\n\nvar getValueSymbol = canSymbol.for(\"can.getValue\");\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\n\nvar isValueLikeSymbol = canSymbol.for(\"can.isValueLike\");\nvar peek = ObservationRecorder.ignore(canReflect.getKeyValue.bind(canReflect));\nvar observeReader;\nvar isPromiseLike = ObservationRecorder.ignore(function isPromiseLike(value){\n\treturn typeof value === \"object\" && value && typeof value.then === \"function\";\n});\n\nvar bindName = Function.prototype.bind;\n//!steal-remove-start\nif (true) {\n\tbindName = function(source){\n\t\tvar fn = Function.prototype.bind.call(this, source);\n\t\tObject.defineProperty(fn, \"name\", {\n\t\t\tvalue: canReflect.getName(source) + \".\"+canReflect.getName(this)\n\t\t});\n\t\treturn fn;\n\t};\n}\n//!steal-remove-end\n\nvar isAt = function(index, reads) {\n\tvar prevRead = reads[index-1];\n\treturn prevRead && prevRead.at;\n};\n\nvar readValue = function(value, index, reads, options, state, prev){\n\t// if the previous read is AT false ... we shouldn't be doing this;\n\tvar usedValueReader;\n\tdo {\n\n\t\tusedValueReader = false;\n\t\tfor(var i =0, len = observeReader.valueReaders.length; i < len; i++){\n\t\t\tif( observeReader.valueReaders[i].test(value, index, reads, options) ) {\n\t\t\t\tvalue = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);\n\t\t\t\t//usedValueReader = true;\n\t\t\t}\n\t\t}\n\t} while(usedValueReader);\n\n\treturn value;\n};\n\nvar specialRead = {index: true, key: true, event: true, element: true, viewModel: true};\n\nvar checkForObservableAndNotify = function(options, state, getObserves, value, index){\n\tif(options.foundObservable && !state.foundObservable) {\n\t\tif(ObservationRecorder.trapsCount()) {\n\t\t\tObservationRecorder.addMany( getObserves() );\n\t\t\toptions.foundObservable(value, index);\n\t\t\tstate.foundObservable = true;\n\t\t}\n\t}\n};\n\nvar objHasKeyAtIndex = function(obj, reads, index) {\n\treturn !!(\n\t\treads && reads.length &&\n\t\tcanReflect.hasKey(obj, reads[index].key)\n\t);\n};\n\nobserveReader = {\n\t// there are things that you need to evaluate when you get them back as a property read\n\t// for example a compute or a function you might need to call to get the next value to\n\t// actually check\n\t// - readCompute - can be set to `false` to prevent reading an ending compute.  This is used by component to get a\n\t//   compute as a delegate.  In 3.0, this should be removed and force people to write \"{@prop} change\"\n\t// - callMethodsOnObservables - this is an overwrite ... so normal methods won't be called, but observable ones will.\n\t// - executeAnonymousFunctions - call a function if it's found, defaults to true\n\t// - proxyMethods - if the last read is a method, return a function so `this` will be correct.\n\t// - args - arguments to call functions with.\n\t//\n\t// Callbacks\n\t// - earlyExit - called if a value could not be found\n\t// - foundObservable - called when an observable value is found\n\tread: function (parent, reads, options) {\n\t\toptions = options || {};\n\t\tvar state = {\n\t\t\tfoundObservable: false\n\t\t};\n\t\tvar getObserves;\n\t\tif(options.foundObservable) {\n\t\t\tgetObserves = ObservationRecorder.trap();\n\t\t}\n\n\t\t// `cur` is the current value.\n\t\tvar cur = readValue(parent, 0, reads, options, state),\n\t\t\ttype,\n\t\t\t// `prev` is the object we are reading from.\n\t\t\tprev,\n\t\t\t// `foundObs` did we find an observable.\n\t\t\treadLength = reads.length,\n\t\t\ti = 0,\n\t\t\tlast,\n\t\t\tparentHasKey;\n\n\t\tcheckForObservableAndNotify(options, state, getObserves, parent, 0);\n\n\t\twhile( i < readLength ) {\n\t\t\tprev = cur;\n\t\t\t// try to read the property\n\t\t\tfor(var r=0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {\n\t\t\t\tvar reader = observeReader.propertyReaders[r];\n\t\t\t\tif(reader.test(cur)) {\n\t\t\t\t\tcur = reader.read(cur, reads[i], i, options, state);\n\t\t\t\t\tbreak; // there can be only one reading of a property\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckForObservableAndNotify(options, state, getObserves, prev, i);\n\t\t\tlast = cur;\n\t\t\ti = i+1;\n\t\t\t// read the value if it is a compute or function\n\t\t\tcur = readValue(cur, i, reads, options, state, prev);\n\n\t\t\tcheckForObservableAndNotify(options, state, getObserves, prev, i-1);\n\n\t\t\ttype = typeof cur;\n\t\t\t// early exit if need be\n\t\t\tif (i < reads.length && (cur === null || cur === undefined )) {\n\t\t\t\tparentHasKey = objHasKeyAtIndex(prev, reads, i - 1);\n\t\t\t\tif (options.earlyExit && !parentHasKey) {\n\t\t\t\t\toptions.earlyExit(prev, i - 1, cur);\n\t\t\t\t}\n\t\t\t\t// return undefined so we know this isn't the right value\n\t\t\t\treturn {\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t\tparent: prev,\n\t\t\t\t\tparentHasKey: parentHasKey,\n\t\t\t\t\tfoundLastParent: false\n\t\t\t\t};\n\t\t\t}\n\n\t\t}\n\n\t\tparentHasKey = objHasKeyAtIndex(prev, reads, reads.length - 1);\n\t\t// if we don't have a value, exit early.\n\t\tif (cur === undefined && !parentHasKey) {\n\t\t\tif (options.earlyExit) {\n\t\t\t\toptions.earlyExit(prev, i - 1);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tvalue: cur,\n\t\t\tparent: prev,\n\t\t\tparentHasKey: parentHasKey,\n\t\t\tfoundLastParent: true\n\t\t};\n\t},\n\tget: function(parent, reads, options){\n\t\treturn observeReader.read(parent, observeReader.reads(reads), options || {}).value;\n\t},\n\tvalueReadersMap: {},\n\t// an array of types that might have a value inside them like functions\n\t// value readers check the current value\n\t// and get a new value from it\n\t// ideally they would keep calling until\n\t// none of these passed\n\tvalueReaders: [\n\t\t{\n\t\t\tname: \"function\",\n\t\t\t// if this is a function before the last read and its not a constructor function\n\t\t\ttest: function(value){\n\t\t\t\treturn value && canReflect.isFunctionLike(value) && !canReflect.isConstructorLike(value);\n\t\t\t},\n\t\t\tread: function(value, i, reads, options, state, prev){\n\t\t\t\tif(options.callMethodsOnObservables && canReflect.isObservableLike(prev) && canReflect.isMapLike(prev)) {\n\t\t\t\t\tdev.warn(\"can-stache-key: read() called with `callMethodsOnObservables: true`.\");\n\n\t\t\t\t\treturn value.apply(prev, options.args || []);\n\t\t\t\t}\n\n\t\t\t\treturn options.proxyMethods !== false ? bindName.call(value, prev) : value;\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tname: \"isValueLike\",\n\t\t\t// compute value reader\n\t\t\ttest: function(value, i, reads, options) {\n\t\t\t\treturn value && value[getValueSymbol] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads) );\n\t\t\t},\n\t\t\tread: function(value, i, reads, options){\n\t\t\t\tif(options.readCompute === false && i === reads.length ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\treturn canReflect.getValue(value);\n\t\t\t},\n\t\t\twrite: function(base, newVal){\n\t\t\t\tif(base[setValueSymbol]) {\n\t\t\t\t\tbase[setValueSymbol](newVal);\n\t\t\t\t} else if(base.set) {\n\t\t\t\t\tbase.set(newVal);\n\t\t\t\t} else {\n\t\t\t\t\tbase(newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t}],\n\tpropertyReadersMap: {},\n\t// an array of things that might have a property\n\tpropertyReaders: [\n\t\t{\n\t\t\tname: \"map\",\n\t\t\ttest: function(value){\n\t\t\t\t// the first time we try reading from a promise, set it up for\n\t\t\t\t//  special reflections.\n\t\t\t\tif(canReflect.isPromise(value) ||\n\t\t\t\t\tisPromiseLike(value)) {\n\t\t\t\t\tcanReflectPromise(value);\n\t\t\t\t}\n\n\t\t\t\treturn canReflect.isObservableLike(value) && canReflect.isMapLike(value);\n\t\t\t},\n\t\t\tread: function(value, prop){\n\t\t\t\tvar res = canReflect.getKeyValue(value, prop.key);\n\t\t\t\tif(res !== undefined) {\n\t\t\t\t\treturn res;\n\t\t\t\t} else {\n\t\t\t\t\treturn value[prop.key];\n\t\t\t\t}\n\t\t\t},\n\t\t\twrite: canReflect.setKeyValue\n\t\t},\n\n\t\t// read a normal object\n\t\t{\n\t\t\tname: \"object\",\n\t\t\t// this is the default\n\t\t\ttest: function(){return true;},\n\t\t\tread: function(value, prop, i, options){\n\t\t\t\tif(value == null) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\tif(typeof value === \"object\") {\n\t\t\t\t\t\tif(prop.key in value) {\n\t\t\t\t\t\t\treturn value[prop.key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: remove in 5.0.\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tif( prop.at && specialRead[prop.key] && ( (\"@\"+prop.key) in value)) {\n\t\t\t\t\t\t\t\toptions.foundAt = true;\n\t\t\t\t\t\t\t\tdev.warn(\"Use %\"+prop.key+\" in place of @\"+prop.key+\".\");\n\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn value[prop.key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\twrite: function(base, prop, newVal){\n\t\t\t\tvar propValue = base[prop];\n\t\t\t\t// if newVal is observable object, lets try to update\n\t\t\t\tif(newVal != null && typeof newVal === \"object\" && canReflect.isMapLike(propValue) ) {\n\t\t\t\t\tdev.warn(\"can-stache-key: Merging data into \\\"\" + prop + \"\\\" because its parent is non-observable\");\n\t\t\t\t\tcanReflect.update(propValue, newVal);\n\t\t\t\t} else if(propValue != null && propValue[setValueSymbol] !== undefined){\n\t\t\t\t\tcanReflect.setValue(propValue, newVal);\n\t\t\t\t} else {\n\t\t\t\t\tbase[prop] = newVal;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t],\n\treads: function(keyArg) {\n\t\tvar key = \"\"+keyArg;\n\t\tvar keys = [];\n\t\tvar last = 0;\n\t\tvar at = false;\n\t\tif( key.charAt(0) === \"@\" ) {\n\t\t\tlast = 1;\n\t\t\tat = true;\n\t\t}\n\t\tvar keyToAdd = \"\";\n\t\tfor(var i = last; i < key.length; i++) {\n\t\t\tvar character = key.charAt(i);\n\t\t\tif(character === \".\" || character === \"@\") {\n\t\t\t\tif( key.charAt(i -1) !== \"\\\\\" ) {\n\t\t\t\t\tkeys.push({\n\t\t\t\t\t\tkey: keyToAdd,\n\t\t\t\t\t\tat: at\n\t\t\t\t\t});\n\t\t\t\t\tat = character === \"@\";\n\t\t\t\t\tkeyToAdd = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tkeyToAdd = keyToAdd.substr(0,keyToAdd.length - 1) + \".\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeyToAdd += character;\n\t\t\t}\n\t\t}\n\t\tkeys.push({\n\t\t\tkey: keyToAdd,\n\t\t\tat: at\n\t\t});\n\n\t\treturn keys;\n\t},\n\t// This should be able to set a property similar to how read works.\n\twrite: function(parent, key, value, options) {\n\t\tvar keys = typeof key === \"string\" ? observeReader.reads(key) : key;\n\t\tvar last;\n\n\t\toptions = options || {};\n\t\tif(keys.length > 1) {\n\t\t\tlast = keys.pop();\n\t\t\tparent = observeReader.read(parent, keys, options).value;\n\t\t\tkeys.push(last);\n\t\t} else {\n\t\t\tlast = keys[0];\n\t\t}\n\t\tif(!parent) {\n\t\t\treturn;\n\t\t}\n\t\tvar keyValue = peek(parent, last.key);\n\t\t// here's where we need to figure out the best way to write\n\n\t\t// if property being set points at a compute, set the compute\n\t\tif( observeReader.valueReadersMap.isValueLike.test(keyValue, keys.length - 1, keys, options) ) {\n\t\t\tobserveReader.valueReadersMap.isValueLike.write(keyValue, value, options);\n\t\t} else {\n\t\t\tif(observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options) ) {\n\t\t\t\tparent = parent[getValueSymbol]();\n\t\t\t}\n\t\t\tif(observeReader.propertyReadersMap.map.test(parent)) {\n\t\t\t\tobserveReader.propertyReadersMap.map.write(parent, last.key, value, options);\n\t\t\t}\n\t\t\telse if(observeReader.propertyReadersMap.object.test(parent)) {\n\t\t\t\tobserveReader.propertyReadersMap.object.write(parent, last.key, value, options);\n\t\t\t\tif(options.observation) {\n\t\t\t\t\toptions.observation.update();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nobserveReader.propertyReaders.forEach(function(reader){\n\tobserveReader.propertyReadersMap[reader.name] = reader;\n});\nobserveReader.valueReaders.forEach(function(reader){\n\tobserveReader.valueReadersMap[reader.name] = reader;\n});\nobserveReader.set = observeReader.write;\n\nmodule.exports = observeReader;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache-key/can-stache-key.js?");

/***/ }),

/***/ "./node_modules/can-stache-route-helpers/can-stache-route-helpers.js":
/*!***************************************************************************!*\
  !*** ./node_modules/can-stache-route-helpers/can-stache-route-helpers.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar helpers = __webpack_require__(/*! can-stache/helpers/core */ \"./node_modules/can-stache/helpers/core.js\");\nvar route = __webpack_require__(/*! can-route */ \"./node_modules/can-route/can-route.js\");\n\nvar stacheExpression = __webpack_require__(/*! can-stache/src/expression */ \"./node_modules/can-stache/src/expression.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar looksLikeOptions = helpers.looksLikeOptions;\n\nvar calculateArgs = function(){\n\tvar finalParams,\n\t\tfinalMerge,\n\t\toptionsArg;\n\n\tcanReflect.eachIndex(arguments, function(arg){\n\t\tif(typeof arg === \"boolean\") {\n\t\t\tfinalMerge = arg;\n\t\t} else if( arg && typeof arg === \"object\"  ) {\n\t\t\tif(!looksLikeOptions(arg) ) {\n\t\t\t\tfinalParams = helpers.resolveHash(arg);\n\t\t\t} else {\n\t\t\t\toptionsArg = arg;\n\t\t\t}\n\t\t}\n\t});\n\n\tif(!finalParams && optionsArg) {\n\t\tfinalParams = helpers.resolveHash(optionsArg.hash);\n\t}\n\treturn {\n\t\tfinalParams: finalParams || {},\n\t\tfinalMerge: finalMerge,\n\t\toptionsArg: optionsArg\n\t};\n};\n\n\n// go through arguments ... if there's a boolean ... if there's a plain object\nvar routeUrl = function(){\n\tvar args = calculateArgs.apply(this, arguments);\n\n\treturn route.url(args.finalParams, typeof args.finalMerge === \"boolean\" ? args.finalMerge : undefined);\n};\nhelpers.registerHelper('routeUrl', routeUrl);\n\nvar routeCurrent = function(){\n\n\tvar args = calculateArgs.apply(this, arguments);\n\tvar result = route.isCurrent( args.finalParams, typeof args.finalMerge === \"boolean\" ? args.finalMerge : undefined );\n\n\tif( args.optionsArg && !(args.optionsArg instanceof stacheExpression.Call) ) {\n\t\tif( result ) {\n\t\t\treturn args.optionsArg.fn();\n\t\t} else {\n\t\t\treturn args.optionsArg.inverse();\n\t\t}\n\t} else {\n\t\treturn result;\n\t}\n};\nrouteCurrent.callAsMethod = true;\n\nhelpers.registerHelper('routeCurrent', routeCurrent);\n\nmodule.exports = {\n\trouteUrl: routeUrl,\n\trouteCurrent: routeCurrent\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-stache-route-helpers/can-stache-route-helpers.js?");

/***/ }),

/***/ "./node_modules/can-stache/can-stache.js":
/*!***********************************************!*\
  !*** ./node_modules/can-stache/can-stache.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint undef: false */\n\nvar parser = __webpack_require__(/*! can-view-parser */ \"./node_modules/can-view-parser/can-view-parser.js\");\nvar viewCallbacks = __webpack_require__(/*! can-view-callbacks */ \"./node_modules/can-view-callbacks/can-view-callbacks.js\");\n\nvar HTMLSectionBuilder = __webpack_require__(/*! ./src/html_section */ \"./node_modules/can-stache/src/html_section.js\");\nvar TextSectionBuilder = __webpack_require__(/*! ./src/text_section */ \"./node_modules/can-stache/src/text_section.js\");\nvar mustacheCore = __webpack_require__(/*! ./src/mustache_core */ \"./node_modules/can-stache/src/mustache_core.js\");\nvar mustacheHelpers = __webpack_require__(/*! ./helpers/core */ \"./node_modules/can-stache/helpers/core.js\");\nvar getIntermediateAndImports = __webpack_require__(/*! can-stache-ast */ \"./node_modules/can-stache-ast/can-stache-ast.js\").parse;\nvar utils = __webpack_require__(/*! ./src/utils */ \"./node_modules/can-stache/src/utils.js\");\nvar makeRendererConvertScopes = utils.makeRendererConvertScopes;\nvar last = utils.last;\n\nvar attributeEncoder = __webpack_require__(/*! can-attribute-encoder */ \"./node_modules/can-attribute-encoder/can-attribute-encoder.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar DOCUMENT = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar importer = __webpack_require__(/*! can-import-module */ \"./node_modules/can-import-module/can-import-module.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar Scope = __webpack_require__(/*! can-view-scope */ \"./node_modules/can-view-scope/can-view-scope.js\");\nvar TemplateContext = __webpack_require__(/*! can-view-scope/template-context */ \"./node_modules/can-view-scope/template-context.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n// Make sure that we can also use our modules with Stache as a plugin\n\n__webpack_require__(/*! can-view-target */ \"./node_modules/can-view-target/can-view-target.js\");\n\n\nif(!viewCallbacks.tag(\"content\")) {\n\t// This was moved from the legacy view/scanner.js to here.\n\t// This makes sure content elements will be able to have a callback.\n\tviewCallbacks.tag(\"content\", function(el, tagData) {\n\t\treturn tagData.scope;\n\t});\n}\n\nvar isViewSymbol = canSymbol.for(\"can.isView\");\n\nvar wrappedAttrPattern = /[{(].*[)}]/;\nvar colonWrappedAttrPattern = /^on:|(:to|:from|:bind)$|.*:to:on:.*/;\nvar svgNamespace = \"http://www.w3.org/2000/svg\",\nxmlnsAttrNamespaceURI = \"http://www.w3.org/2000/xmlns/\",\nxlinkHrefAttrNamespaceURI =  \"http://www.w3.org/1999/xlink\";\nvar namespaces = {\n\t\"svg\": svgNamespace,\n\t// this allows a partial to start with g.\n\t\"g\": svgNamespace,\n\t\"defs\": svgNamespace,\n\t\"path\": svgNamespace,\n\t\"filter\": svgNamespace,\n\t\"feMorphology\": svgNamespace,\n\t\"feGaussianBlur\": svgNamespace,\n\t\"feOffset\": svgNamespace,\n\t\"feComposite\": svgNamespace,\n\t\"feColorMatrix\": svgNamespace,\n\t\"use\": svgNamespace\n},\n\tattrsNamespacesURI = {\n\t\t'xmlns': xmlnsAttrNamespaceURI,\n\t\t'xlink:href': xlinkHrefAttrNamespaceURI\n\t},\n\ttextContentOnlyTag = {style: true, script: true};\n\nfunction stache (filename, template) {\n\tif (arguments.length === 1) {\n\t\ttemplate = arguments[0];\n\t\tfilename = undefined;\n\t}\n\n\tvar inlinePartials = {};\n\n\t// Remove line breaks according to mustache's specs.\n\tif(typeof template === \"string\") {\n\t\ttemplate = mustacheCore.cleanWhitespaceControl(template);\n\t\ttemplate = mustacheCore.cleanLineEndings(template);\n\t}\n\n\t// The HTML section that is the root section for the entire template.\n\tvar section = new HTMLSectionBuilder(filename),\n\t\t// Tracks the state of the parser.\n\t\tstate = {\n\t\t\tnode: null,\n\t\t\tattr: null,\n\t\t\t// A stack of which node / section we are in.\n\t\t\t// There is probably a better way of doing this.\n\t\t\tsectionElementStack: [],\n\t\t\t// If text should be inserted and HTML escaped\n\t\t\ttext: false,\n\t\t\t// which namespace we are in\n\t\t\tnamespaceStack: [],\n\t\t\t// for style and script tags\n\t\t\t// we create a special TextSectionBuilder and add things to that\n\t\t\t// when the element is done, we compile the text section and\n\t\t\t// add it as a callback to `section`.\n\t\t\ttextContentOnly: null\n\n\t\t},\n\n\t\t// This function is a catch all for taking a section and figuring out\n\t\t// how to create a \"renderer\" that handles the functionality for a\n\t\t// given section and modify the section to use that renderer.\n\t\t// For example, if an HTMLSection is passed with mode `#` it knows to\n\t\t// create a liveBindingBranchRenderer and pass that to section.add.\n\t\t// jshint maxdepth:5\n\t\tmakeRendererAndUpdateSection = function(section, mode, stache, lineNo){\n\n\t\t\tif(mode === \">\") {\n\t\t\t\t// Partials use liveBindingPartialRenderers\n\t\t\t\tsection.add(mustacheCore.makeLiveBindingPartialRenderer(stache, copyState({ filename: section.filename, lineNo: lineNo })));\n\n\t\t\t} else if(mode === \"/\") {\n\n\t\t\t\tvar createdSection = section.last();\n\t\t\t\tif ( createdSection.startedWith === \"<\" ) {\n\t\t\t\t\tinlinePartials[ stache ] = section.endSubSectionAndReturnRenderer();\n\t\t\t\t\t// Remove *TWO* nodes because we now have a start and an end comment for the section....\n\t\t\t\t\tsection.removeCurrentNode();\n\t\t\t\t\tsection.removeCurrentNode();\n\t\t\t\t} else {\n\t\t\t\t\tsection.endSection();\n\t\t\t\t}\n\n\t\t\t\t// to avoid \"Blocks are nested too deeply\" when linting\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tif(section instanceof HTMLSectionBuilder) {\n\t\t\t\t\t\tvar last = state.sectionElementStack[state.sectionElementStack.length - 1];\n\t\t\t\t\t\tif (last.tag && last.type === \"section\" && stache !== \"\" && stache !== last.tag) {\n\t\t\t\t\t\t\tif (filename) {\n\t\t\t\t\t\t\t\tdev.warn(filename + \":\" + lineNo + \": unexpected closing tag {{/\" + stache + \"}} expected {{/\" + last.tag + \"}}\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdev.warn(lineNo + \": unexpected closing tag {{/\" + stache + \"}} expected {{/\" + last.tag + \"}}\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\tif(section instanceof HTMLSectionBuilder) {\n\t\t\t\t\tstate.sectionElementStack.pop();\n\t\t\t\t}\n\t\t\t} else if(mode === \"else\") {\n\n\t\t\t\tsection.inverse();\n\n\t\t\t} else {\n\n\t\t\t\t// If we are an HTMLSection, we will generate a\n\t\t\t\t// a LiveBindingBranchRenderer; otherwise, a StringBranchRenderer.\n\t\t\t\t// A LiveBindingBranchRenderer function processes\n\t\t\t\t// the mustache text, and sets up live binding if an observable is read.\n\t\t\t\t// A StringBranchRenderer function processes the mustache text and returns a\n\t\t\t\t// text value.\n\t\t\t\tvar makeRenderer = section instanceof HTMLSectionBuilder ?\n\t\t\t\t\tmustacheCore.makeLiveBindingBranchRenderer:\n\t\t\t\t\tmustacheCore.makeStringBranchRenderer;\n\n\t\t\t\tif(mode === \"{\" || mode === \"&\") {\n\n\t\t\t\t\t// Adds a renderer function that just reads a value or calls a helper.\n\t\t\t\t\tsection.add(makeRenderer(null,stache, copyState({ filename: section.filename, lineNo: lineNo })));\n\n\t\t\t\t} else if(mode === \"#\" || mode === \"^\" || mode === \"<\") {\n\t\t\t\t\t// Adds a renderer function and starts a section.\n\t\t\t\t\tvar renderer = makeRenderer(mode, stache, copyState({ filename: section.filename, lineNo: lineNo }));\n\t\t\t\t\tvar sectionItem = {\n\t\t\t\t\t\ttype: \"section\"\n\t\t\t\t\t};\n\t\t\t\t\tsection.startSection(renderer, stache);\n\t\t\t\t\tsection.last().startedWith = mode;\n\n\t\t\t\t\t// If we are a directly nested section, count how many we are within\n\t\t\t\t\tif(section instanceof HTMLSectionBuilder) {\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tvar tag = typeof renderer.exprData.closingTag === 'function' ?\n\t\t\t\t\t\t\t\trenderer.exprData.closingTag() : stache;\n\t\t\t\t\t\t\tsectionItem.tag = tag;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\t\tstate.sectionElementStack.push(sectionItem);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Adds a renderer function that only updates text.\n\t\t\t\t\tsection.add(makeRenderer(null, stache, copyState({text: true, filename: section.filename, lineNo: lineNo })));\n\t\t\t\t}\n\n\t\t\t}\n\t\t},\n\t\tisDirectlyNested = function() {\n\t\t\tvar lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];\n\t\t\treturn state.sectionElementStack.length ?\n\t\t\t\tlastElement.type === \"section\" || lastElement.type === \"custom\": true;\n\t\t},\n\t\t// Copys the state object for use in renderers.\n\t\tcopyState = function(overwrites){\n\n\t\t\tvar cur = {\n\t\t\t\ttag: state.node && state.node.tag,\n\t\t\t\tattr: state.attr && state.attr.name,\n\t\t\t\t// <content> elements should be considered direclty nested\n\t\t\t\tdirectlyNested: isDirectlyNested(),\n\t\t\t\ttextContentOnly: !!state.textContentOnly\n\t\t\t};\n\t\t\treturn overwrites ? assign(cur, overwrites) : cur;\n\t\t},\n\t\taddAttributesCallback = function(node, callback){\n\t\t\tif( !node.attributes ) {\n\t\t\t\tnode.attributes = [];\n\t\t\t}\n\t\t\tnode.attributes.unshift(callback);\n\t\t};\n\n\tparser(template, {\n\t\tfilename: filename,\n\t\tstart: function(tagName, unary, lineNo){\n\t\t\tvar matchedNamespace = namespaces[tagName];\n\n\t\t\tif (matchedNamespace && !unary ) {\n\t\t\t\tstate.namespaceStack.push(matchedNamespace);\n\t\t\t}\n\n\t\t\t// either add templates: {} here or check below and decorate\n\t\t\t// walk up the stack/targetStack until you find the first node\n\t\t\t// with a templates property, and add the popped renderer\n\t\t\tstate.node = {\n\t\t\t\ttag: tagName,\n\t\t\t\tchildren: [],\n\t\t\t\tnamespace: matchedNamespace || last(state.namespaceStack)\n\t\t\t};\n\t\t},\n\t\tend: function(tagName, unary, lineNo){\n\t\t\tvar isCustomTag =  viewCallbacks.tag(tagName);\n\t\t\tvar directlyNested = isDirectlyNested();\n\t\t\tif(unary){\n\t\t\t\t// If it's a custom tag with content, we need a section renderer.\n\t\t\t\tsection.add(state.node);\n\t\t\t\tif(isCustomTag) {\n\t\t\t\t\t// Call directlyNested now as it's stateful.\n\t\t\t\t\taddAttributesCallback(state.node, function(scope){\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tscope.set('scope.lineNumber', lineNo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\tviewCallbacks.tagHandler(this,tagName, {\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\tsubtemplate: null,\n\t\t\t\t\t\t\ttemplateType: \"stache\",\n\t\t\t\t\t\t\tdirectlyNested: directlyNested\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsection.push(state.node);\n\n\t\t\t\tstate.sectionElementStack.push({\n\t\t\t\t\ttype: isCustomTag ? \"custom\" : null,\n\t\t\t\t\ttag: isCustomTag ? null : tagName,\n\t\t\t\t\ttemplates: {},\n\t\t\t\t\tdirectlyNested: directlyNested\n\t\t\t\t});\n\n\t\t\t\t// If it's a custom tag with content, we need a section renderer.\n\t\t\t\tif( isCustomTag ) {\n\t\t\t\t\tsection.startSubSection();\n\t\t\t\t} else if(textContentOnlyTag[tagName]) {\n\t\t\t\t\tstate.textContentOnly = new TextSectionBuilder(filename);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tstate.node =null;\n\n\t\t},\n\t\tclose: function(tagName, lineNo) {\n\t\t\tvar matchedNamespace = namespaces[tagName];\n\n\t\t\tif (matchedNamespace  ) {\n\t\t\t\tstate.namespaceStack.pop();\n\t\t\t}\n\n\t\t\tvar isCustomTag = viewCallbacks.tag(tagName),\n\t\t\t\trenderer;\n\n\t\t\tif( isCustomTag ) {\n\t\t\t\trenderer = section.endSubSectionAndReturnRenderer();\n\t\t\t}\n\n\t\t\tif(textContentOnlyTag[tagName]) {\n\t\t\t\tsection.last().add(state.textContentOnly.compile(copyState()));\n\t\t\t\tstate.textContentOnly = null;\n\t\t\t}\n\n\t\t\tvar oldNode = section.pop();\n\t\t\tif( isCustomTag ) {\n\t\t\t\tif (tagName === \"can-template\") {\n\t\t\t\t\t// If we find a can-template we want to go back 2 in the stack to get it's inner content\n\t\t\t\t\t// rather than the <can-template> element itself\n\t\t\t\t\tvar parent = state.sectionElementStack[state.sectionElementStack.length - 2];\n\t\t\t\t\tif (renderer) {// Only add the renderer if the template has content\n\t\t\t\t\t\tparent.templates[oldNode.attrs.name] = makeRendererConvertScopes(renderer);\n\t\t\t\t\t}\n\t\t\t\t\tsection.removeCurrentNode();\n\t\t\t\t} else {\n\t\t\t\t\t// Get the last element in the stack\n\t\t\t\t\tvar current = state.sectionElementStack[state.sectionElementStack.length - 1];\n\t\t\t\t\taddAttributesCallback(oldNode, function(scope){\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tscope.set('scope.lineNumber', lineNo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\tviewCallbacks.tagHandler(this,tagName, {\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\tsubtemplate: renderer  ? makeRendererConvertScopes(renderer) : renderer,\n\t\t\t\t\t\t\ttemplateType: \"stache\",\n\t\t\t\t\t\t\ttemplates: current.templates,\n\t\t\t\t\t\t\tdirectlyNested: current.directlyNested\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate.sectionElementStack.pop();\n\t\t},\n\t\tattrStart: function(attrName, lineNo){\n\t\t\tif(state.node.section) {\n\t\t\t\tstate.node.section.add(attrName+\"=\\\"\");\n\t\t\t} else {\n\t\t\t\tstate.attr = {\n\t\t\t\t\tname: attrName,\n\t\t\t\t\tvalue: \"\"\n\t\t\t\t};\n\t\t\t}\n\n\t\t},\n\t\tattrEnd: function(attrName, lineNo){\n\t\t\tvar matchedAttrNamespacesURI = attrsNamespacesURI[attrName];\n\t\t\tif(state.node.section) {\n\t\t\t\tstate.node.section.add(\"\\\" \");\n\t\t\t} else {\n\t\t\t\tif(!state.node.attrs) {\n\t\t\t\t\tstate.node.attrs = {};\n\t\t\t\t}\n\n\t\t\t\tif (state.attr.section) {\n\t\t\t\t\tstate.node.attrs[state.attr.name] = state.attr.section.compile(copyState());\n\t\t\t\t} else if (matchedAttrNamespacesURI) {\n\t\t\t\t\tstate.node.attrs[state.attr.name] = {\n\t\t\t\t\t\tvalue: state.attr.value,\n\t\t\t\t\t\tnamespaceURI: attrsNamespacesURI[attrName]\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tstate.node.attrs[state.attr.name] = state.attr.value;\n\t\t\t\t}\n\n\t\t\t\tvar attrCallback = viewCallbacks.attr(attrName);\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tvar decodedAttrName = attributeEncoder.decode(attrName);\n\t\t\t\t\tvar weirdAttribute = !!wrappedAttrPattern.test(decodedAttrName) || !!colonWrappedAttrPattern.test(decodedAttrName);\n\t\t\t\t\tif (weirdAttribute && !attrCallback) {\n\t\t\t\t\t\tdev.warn(\"unknown attribute binding \" + decodedAttrName + \". Is can-stache-bindings imported?\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\tif(attrCallback) {\n\t\t\t\t\tif( !state.node.attributes ) {\n\t\t\t\t\t\tstate.node.attributes = [];\n\t\t\t\t\t}\n\t\t\t\t\tstate.node.attributes.push(function(scope){\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tscope.set('scope.lineNumber', lineNo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\tattrCallback(this,{\n\t\t\t\t\t\t\tattributeName: attrName,\n\t\t\t\t\t\t\tscope: scope\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tstate.attr = null;\n\t\t\t}\n\t\t},\n\t\tattrValue: function(value, lineNo){\n\t\t\tvar section = state.node.section || state.attr.section;\n\t\t\tif(section){\n\t\t\t\tsection.add(value);\n\t\t\t} else {\n\t\t\t\tstate.attr.value += value;\n\t\t\t}\n\t\t},\n\t\tchars: function(text, lineNo) {\n\t\t\t(state.textContentOnly || section).add(text);\n\t\t},\n\t\tspecial: function(text, lineNo){\n\t\t\tvar firstAndText = mustacheCore.splitModeFromExpression(text, state),\n\t\t\t\tmode = firstAndText.mode,\n\t\t\t\texpression = firstAndText.expression;\n\n\n\t\t\tif(expression === \"else\") {\n\t\t\t\tvar inverseSection;\n\t\t\t\tif(state.attr && state.attr.section) {\n\t\t\t\t\tinverseSection = state.attr.section;\n\t\t\t\t} else if(state.node && state.node.section ) {\n\t\t\t\t\tinverseSection = state.node.section;\n\t\t\t\t} else {\n\t\t\t\t\tinverseSection = state.textContentOnly || section;\n\t\t\t\t}\n\t\t\t\tinverseSection.inverse();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(mode === \"!\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(state.node && state.node.section) {\n\n\t\t\t\tmakeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);\n\n\t\t\t\tif(state.node.section.subSectionDepth() === 0){\n\t\t\t\t\tstate.node.attributes.push( state.node.section.compile(copyState()) );\n\t\t\t\t\tdelete state.node.section;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// `{{}}` in an attribute like `class=\"{{}}\"`\n\t\t\telse if(state.attr) {\n\n\t\t\t\tif(!state.attr.section) {\n\t\t\t\t\tstate.attr.section = new TextSectionBuilder(filename);\n\t\t\t\t\tif(state.attr.value) {\n\t\t\t\t\t\tstate.attr.section.add(state.attr.value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmakeRendererAndUpdateSection(state.attr.section, mode, expression, lineNo);\n\n\t\t\t}\n\t\t\t// `{{}}` in a tag like `<div {{}}>`\n\t\t\telse if(state.node) {\n\n\t\t\t\tif(!state.node.attributes) {\n\t\t\t\t\tstate.node.attributes = [];\n\t\t\t\t}\n\t\t\t\tif(!mode) {\n\t\t\t\t\tstate.node.attributes.push(mustacheCore.makeLiveBindingBranchRenderer(null, expression, copyState({ filename: section.filename, lineNo: lineNo })));\n\t\t\t\t} else if( mode === \"#\" || mode === \"^\" ) {\n\t\t\t\t\tif(!state.node.section) {\n\t\t\t\t\t\tstate.node.section = new TextSectionBuilder(filename);\n\t\t\t\t\t}\n\t\t\t\t\tmakeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(mode+\" is currently not supported within a tag.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmakeRendererAndUpdateSection(state.textContentOnly || section, mode, expression, lineNo);\n\t\t\t}\n\t\t},\n\t\tcomment: function(text) {\n\t\t\t// create comment node\n\t\t\tsection.add({\n\t\t\t\tcomment: text\n\t\t\t});\n\t\t},\n\t\tdone: function(lineNo){\n\t\t\t//!steal-remove-start\n\t\t\t// warn if closing magic tag is missed #675\n\t\t\tif (true) {\n\t\t\t\tvar last = state.sectionElementStack[state.sectionElementStack.length - 1];\n\t\t\t\tif (last && last.tag && last.type === \"section\") {\n\t\t\t\t\tif (filename) {\n\t\t\t\t\t\tdev.warn(filename + \":\" + lineNo + \": closing tag {{/\" + last.tag + \"}} was expected\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdev.warn(lineNo + \": closing tag {{/\" + last.tag + \"}} was expected\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\t});\n\n\tvar renderer = section.compile();\n\n\tvar scopifiedRenderer = ObservationRecorder.ignore(function(scope, options){\n\t\t// if an object is passed to options, assume it is the helpers object\n\t\tif (options && !options.helpers && !options.partials && !options.tags) {\n\t\t\toptions = {\n\t\t\t\thelpers: options\n\t\t\t};\n\t\t}\n\t\t// mark passed in helper so they will be automatically passed\n\t\t// helperOptions (.fn, .inverse, etc) when called as Call Expressions\n\t\tcanReflect.eachKey(options && options.helpers, function(helperValue) {\n\t\t\thelperValue.requiresOptionsArgument = true;\n\t\t});\n\n\t\t// helpers, partials, tags, vars\n\t\tvar templateContext = new TemplateContext(options);\n\n\t\t// copy inline partials over\n\t\tcanReflect.eachKey(inlinePartials, function(partial, partialName) {\n\t\t\tcanReflect.setKeyValue(templateContext.partials, partialName, partial);\n\t\t});\n\n\t\t// allow the current renderer to be called with {{>scope.view}}\n\t\tcanReflect.setKeyValue(templateContext, 'view', scopifiedRenderer);\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tcanReflect.setKeyValue(templateContext, 'filename', section.filename);\n\t\t}\n\t\t//!steal-remove-end\n\n\n\t\t// now figure out the final structure ...\n\t\tif ( !(scope instanceof Scope) ) {\n\t\t\tscope = new Scope(templateContext).add(scope);\n\t\t} else {\n\t\t\t// we are going to split ...\n\t\t\tvar templateContextScope = new Scope(templateContext);\n\t\t\ttemplateContextScope._parent = scope._parent;\n\t\t\tscope._parent = templateContextScope;\n\t\t}\n\n\t\treturn renderer(scope.addLetContext());\n\t});\n\n\t// Identify is a view type\n\tscopifiedRenderer[isViewSymbol] = true;\n\n\treturn scopifiedRenderer;\n}\n\n// At this point, can.stache has been created\nassign(stache, mustacheHelpers);\n\nstache.safeString = function(text){\n\n\treturn canReflect.assignSymbols({},{\n\t\t\"can.toDOM\": function(){\n\t\t\treturn text;\n\t\t}\n\t});\n};\nstache.async = function(source){\n\tvar iAi = getIntermediateAndImports(source);\n\tvar importPromises = iAi.imports.map(function(moduleName){\n\t\treturn importer(moduleName);\n\t});\n\treturn Promise.all(importPromises).then(function(){\n\t\treturn stache(iAi.intermediate);\n\t});\n};\nvar templates = {};\nstache.from = mustacheCore.getTemplateById = function(id){\n\tif(!templates[id]) {\n\t\tvar el = DOCUMENT().getElementById(id);\n\t\tif(el) {\n\t\t\ttemplates[id] = stache(\"#\" + id, el.innerHTML);\n\t\t}\n\t}\n\treturn templates[id];\n};\n\nstache.registerPartial = function(id, partial) {\n\ttemplates[id] = (typeof partial === \"string\" ? stache(partial) : partial);\n};\n\nstache.addBindings = viewCallbacks.attrs;\n\nmodule.exports = namespace.stache = stache;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/can-stache.js?");

/***/ }),

/***/ "./node_modules/can-stache/expressions/arg.js":
/*!****************************************************!*\
  !*** ./node_modules/can-stache/expressions/arg.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ### Arg\n// `new Arg(Expression [,modifierOptions] )`\n// Used to identify an expression that should return a value.\nvar Arg = function(expression, modifiers){\n\tthis.expr = expression;\n\tthis.modifiers = modifiers || {};\n\tthis.isCompute = false;\n};\nArg.prototype.value = function(){\n\treturn this.expr.value.apply(this.expr, arguments);\n};\n//!steal-remove-start\nif (true) {\n\tArg.prototype.sourceText = function(){\n\t\treturn (this.modifiers.compute ? \"~\" : \"\")+ this.expr.sourceText();\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Arg;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/expressions/arg.js?");

/***/ }),

/***/ "./node_modules/can-stache/expressions/bracket.js":
/*!********************************************************!*\
  !*** ./node_modules/can-stache/expressions/bracket.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n//!steal-remove-start\nif (true) {\n\tvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n}\n//!steal-remove-end\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"./node_modules/can-stache/src/expression-helpers.js\");\n\n// ### Bracket\n// For accessing properties using bracket notation like `foo[bar]`\nvar Bracket = function (key, root, originalKey) {\n\tthis.root = root;\n\tthis.key = key;\n\t//!steal-remove-start\n\tif (true) {\n\t\tthis[canSymbol.for(\"can-stache.originalKey\")] = originalKey;\n\t}\n\t//!steal-remove-end\n};\nBracket.prototype.value = function (scope, helpers) {\n\tvar root = this.root ? this.root.value(scope, helpers) : scope.peek(\"this\");\n\treturn expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key.value(scope, helpers), root, scope, helpers, {});\n};\n//!steal-remove-start\nif (true) {\n\tBracket.prototype.sourceText = function(){\n\t\tif(this.rootExpr) {\n\t\t\treturn this.rootExpr.sourceText()+\"[\"+this.key+\"]\";\n\t\t} else {\n\t\t\treturn \"[\"+this.key+\"]\";\n\t\t}\n\t};\n}\n//!steal-remove-end\n\nBracket.prototype.closingTag = function() {\n\t//!steal-remove-start\n\tif (true) {\n\t\treturn this[canSymbol.for('can-stache.originalKey')] || '';\n\t}\n\t//!steal-remove-end\n};\n\nmodule.exports = Bracket;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/expressions/bracket.js?");

/***/ }),

/***/ "./node_modules/can-stache/expressions/call.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-stache/expressions/call.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Hashes = __webpack_require__(/*! ./hashes */ \"./node_modules/can-stache/expressions/hashes.js\");\nvar SetIdentifier = __webpack_require__(/*! ../src/set-identifier */ \"./node_modules/can-stache/src/set-identifier.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar SetterObservable = __webpack_require__(/*! can-simple-observable/setter/setter */ \"./node_modules/can-simple-observable/setter/setter.js\");\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"./node_modules/can-stache/src/expression-helpers.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\nvar sourceTextSymbol = canSymbol.for(\"can-stache.sourceText\");\nvar isViewSymbol = canSymbol.for(\"can.isView\");\nvar Scope = __webpack_require__(/*! can-view-scope */ \"./node_modules/can-view-scope/can-view-scope.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\n\n// ### Call\n// `new Call( new Lookup(\"method\"), [new ScopeExpr(\"name\")], {})`\n// A call expression like `method(arg1, arg2)` that, by default,\n// calls `method` with non compute values.\nvar Call = function(methodExpression, argExpressions){\n\tthis.methodExpr = methodExpression;\n\tthis.argExprs = argExpressions.map(expressionHelpers.convertToArgExpression);\n};\nCall.prototype.args = function(scope, ignoreArgLookup) {\n\tvar hashExprs = {};\n\tvar args = [];\n\tvar gotIgnoreFunction = typeof ignoreArgLookup === \"function\";\n\n\tfor (var i = 0, len = this.argExprs.length; i < len; i++) {\n\t\tvar arg = this.argExprs[i];\n\t\tif(arg.expr instanceof Hashes){\n\t\t\tassign(hashExprs, arg.expr.hashExprs);\n\t\t}\n\t\tif (!gotIgnoreFunction || !ignoreArgLookup(i)) {\n\t\t\tvar value = arg.value.apply(arg, arguments);\n\t\t\targs.push({\n\t\t\t\t// always do getValue unless compute is false\n\t\t\t\tcall: !arg.modifiers || !arg.modifiers.compute,\n\t\t\t\tvalue: value\n\t\t\t});\n\t\t}\n\t}\n\treturn function(doNotWrapArguments){\n\t\tvar finalArgs = [];\n\t\tif(canReflect.size(hashExprs) > 0){\n\t\t\tfinalArgs.hashExprs = hashExprs;\n\t\t}\n\t\tfor(var i = 0, len = args.length; i < len; i++) {\n\t\t\tif (doNotWrapArguments) {\n\t\t\t\tfinalArgs[i] = args[i].value;\n\t\t\t} else {\n\t\t\t\tfinalArgs[i] = args[i].call ?\n\t\t\t\t\tcanReflect.getValue( args[i].value ) :\n\t\t\t\t\texpressionHelpers.toCompute( args[i].value );\n\t\t\t}\n\t\t}\n\t\treturn finalArgs;\n\t};\n};\n\nCall.prototype.value = function(scope, helperOptions){\n\tvar callExpression = this;\n\n\t// proxyMethods must be false so that the `requiresOptionsArgument` and any\n\t// other flags stored on the function are preserved\n\tvar method = this.methodExpr.value(scope, { proxyMethods: false });\n\tObservation.temporarilyBind(method);\n\tvar func = canReflect.getValue( method );\n\n\tvar getArgs = callExpression.args(scope , func && func.ignoreArgLookup);\n\n\tvar computeFn = function(newVal){\n\t\tvar func = canReflect.getValue( method );\n\t\tif(typeof func === \"function\") {\n\t\t\tif (canReflect.isObservableLike(func)) {\n\t\t\t\tfunc = canReflect.getValue(func);\n\t\t\t}\n\t\t\tvar args = getArgs(\n\t\t\t\tfunc.isLiveBound\n\t\t\t);\n\n\t\t\tif (func.requiresOptionsArgument) {\n\t\t\t\tif(args.hashExprs && helperOptions && helperOptions.exprData){\n\t\t\t\t\thelperOptions.exprData.hashExprs = args.hashExprs;\n\t\t\t\t}\n\t\t\t\t// For #581\n\t\t\t\tif(helperOptions !== undefined) {\n\t\t\t\t\targs.push(helperOptions);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// we are calling a view!\n\t\t\tif(func[isViewSymbol] === true) {\n\t\t\t\t// if not a scope, we should create a scope that\n\t\t\t\t// includes the template scope\n\t\t\t\tif(!(args[0] instanceof Scope)){\n\t\t\t\t\targs[0] = scope.getTemplateContext().add(args[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(arguments.length) {\n\t\t\t\targs.unshift(new SetIdentifier(newVal));\n\t\t\t}\n\n\t\t\t// if this is a call like `foo.bar()` the method.thisArg will be set to `foo`\n\t\t\t// for a call like `foo()`, method.thisArg will not be set and we will default\n\t\t\t// to setting the scope as the context of the function\n\t\t\treturn func.apply(method.thisArg || scope.peek(\"this\"), args);\n\t\t}\n\t};\n\t//!steal-remove-start\n\tif (true) {\n\t\tObject.defineProperty(computeFn, \"name\", {\n\t\t\tvalue: \"{{\" + this.sourceText() + \"}}\"\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tif (helperOptions && helperOptions.doNotWrapInObservation) {\n\t\treturn computeFn();\n\t} else {\n\t\tvar computeValue = new SetterObservable(computeFn, computeFn);\n\n\t\treturn computeValue;\n\t}\n};\n//!steal-remove-start\nif (true) {\n\tCall.prototype.sourceText = function(){\n\t\tvar args = this.argExprs.map(function(arg){\n\t\t\treturn arg.sourceText();\n\t\t});\n\t\treturn this.methodExpr.sourceText()+\"(\"+args.join(\",\")+\")\";\n\t};\n}\n//!steal-remove-end\nCall.prototype.closingTag = function() {\n\t//!steal-remove-start\n\tif (true) {\n\t\tif(this.methodExpr[sourceTextSymbol]) {\n\t\t\treturn this.methodExpr[sourceTextSymbol];\n\t\t}\n\t}\n\t//!steal-remove-end\n\treturn this.methodExpr.key;\n};\n\nmodule.exports = Call;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/expressions/call.js?");

/***/ }),

/***/ "./node_modules/can-stache/expressions/hashes.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache/expressions/hashes.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"./node_modules/can-stache/src/expression-helpers.js\");\n\nvar Hashes = function(hashes){\n\tthis.hashExprs = hashes;\n};\nHashes.prototype.value = function(scope, helperOptions){\n\tvar hash = {};\n\tfor(var prop in this.hashExprs) {\n\t\tvar val = expressionHelpers.convertToArgExpression(this.hashExprs[prop]),\n\t\t\tvalue = val.value.apply(val, arguments);\n\n\t\thash[prop] = {\n\t\t\tcall: !val.modifiers || !val.modifiers.compute,\n\t\t\tvalue: value\n\t\t};\n\t}\n\treturn new Observation(function(){\n\t\tvar finalHash = {};\n\t\tfor(var prop in hash) {\n\t\t\tfinalHash[prop] = hash[prop].call ? canReflect.getValue( hash[prop].value ) : expressionHelpers.toComputeOrValue( hash[prop].value );\n\t\t}\n\t\treturn finalHash;\n\t});\n};\n//!steal-remove-start\nif (true) {\n\tHashes.prototype.sourceText = function(){\n\t\tvar hashes = [];\n\t\tcanReflect.eachKey(this.hashExprs, function(expr, prop){\n\t\t\thashes.push( prop+\"=\"+expr.sourceText() );\n\t\t});\n\t\treturn hashes.join(\" \");\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Hashes;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/expressions/hashes.js?");

/***/ }),

/***/ "./node_modules/can-stache/expressions/helper.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache/expressions/helper.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Literal = __webpack_require__(/*! ./literal */ \"./node_modules/can-stache/expressions/literal.js\");\nvar Hashes = __webpack_require__(/*! ./hashes */ \"./node_modules/can-stache/expressions/hashes.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"./node_modules/can-stache/src/expression-helpers.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar Helper = function(methodExpression, argExpressions, hashExpressions){\n\tthis.methodExpr = methodExpression;\n\tthis.argExprs = argExpressions;\n\tthis.hashExprs = hashExpressions;\n\tthis.mode = null;\n};\nHelper.prototype.args = function(scope){\n\tvar args = [];\n\tfor(var i = 0, len = this.argExprs.length; i < len; i++) {\n\t\tvar arg = this.argExprs[i];\n\t\t// TODO: once we know the helper, we should be able to avoid compute conversion\n\t\targs.push( expressionHelpers.toComputeOrValue( arg.value.apply(arg, arguments) ) );\n\t}\n\treturn args;\n};\nHelper.prototype.hash = function(scope){\n\tvar hash = {};\n\tfor(var prop in this.hashExprs) {\n\t\tvar val = this.hashExprs[prop];\n\t\t// TODO: once we know the helper, we should be able to avoid compute conversion\n\t\thash[prop] = expressionHelpers.toComputeOrValue( val.value.apply(val, arguments) );\n\t}\n\treturn hash;\n};\n\nHelper.prototype.value = function(scope, helperOptions){\n\t// If a literal, this means it should be treated as a key. But helpers work this way for some reason.\n\t// TODO: fix parsing so numbers will also be assumed to be keys.\n\tvar methodKey = this.methodExpr instanceof Literal ?\n\t\t\"\" + this.methodExpr._value :\n\t\tthis.methodExpr.key,\n\t\thelperInstance = this,\n\t\t// proxyMethods must be false so that the `requiresOptionsArgument` and any\n\t\t// other flags stored on the function are preserved\n\t\thelperFn = scope.computeData(methodKey,  { proxyMethods: false }),\n\t\tinitialValue = helperFn && helperFn.initialValue,\n\t\tthisArg = helperFn && helperFn.thisArg;\n\n\tif (typeof initialValue === \"function\") {\n\t\thelperFn = function helperFn() {\n\t\t\tvar args = helperInstance.args(scope),\n\t\t\t\thelperOptionArg = assign(assign({}, helperOptions), {\n\t\t\t\t\thash: helperInstance.hash(scope),\n\t\t\t\t\texprData: helperInstance\n\t\t\t\t});\n\n\t\t\targs.push(helperOptionArg);\n\n\t\t\treturn initialValue.apply(thisArg || scope.peek(\"this\"), args);\n\t\t};\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tObject.defineProperty(helperFn, \"name\", {\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: canReflect.getName(this)\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\t}\n\t//!steal-remove-start\n\telse if (true) {\n\t\tvar filename = scope.peek('scope.filename');\n\t\t\tvar lineNumber = scope.peek('scope.lineNumber');\n\t\t\tdev.warn(\n\t\t\t\t(filename ? filename + ':' : '') +\n\t\t\t\t(lineNumber ? lineNumber + ': ' : '') +\n\t\t\t\t'Unable to find helper \"' + methodKey + '\".');\n\t}\n\t//!steal-remove-end\n\n\treturn  helperFn;\n};\n\nHelper.prototype.closingTag = function() {\n\treturn this.methodExpr.key;\n};\n\n//!steal-remove-start\nif (true) {\n\tHelper.prototype.sourceText = function(){\n\t\tvar text = [this.methodExpr.sourceText()];\n\t\tif(this.argExprs.length) {\n\t\t\ttext.push( this.argExprs.map(function(arg){\n\t\t\t\treturn arg.sourceText();\n\t\t\t}).join(\" \") );\n\t\t}\n\t\tif(canReflect.size(this.hashExprs) > 0){\n\t\t\ttext.push( Hashes.prototype.sourceText.call(this) );\n\t\t}\n\t\treturn text.join(\" \");\n\t};\n\n\tcanReflect.assignSymbols(Helper.prototype,{\n\t\t\"can.getName\": function() {\n\t\t\treturn canReflect.getName(this.constructor) + \"{{\" + (this.sourceText()) + \"}}\";\n\t\t}\n\t});\n}\n//!steal-remove-end\n\nmodule.exports = Helper;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/expressions/helper.js?");

/***/ }),

/***/ "./node_modules/can-stache/expressions/literal.js":
/*!********************************************************!*\
  !*** ./node_modules/can-stache/expressions/literal.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ### Literal\n// For inline static values like `{{\"Hello World\"}}`\nvar Literal = function(value){\n\tthis._value = value;\n};\nLiteral.prototype.value = function(){\n\treturn this._value;\n};\n//!steal-remove-start\nif (true) {\n\tLiteral.prototype.sourceText = function(){\n\t\treturn JSON.stringify(this._value);\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Literal;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/expressions/literal.js?");

/***/ }),

/***/ "./node_modules/can-stache/expressions/lookup.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache/expressions/lookup.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"./node_modules/can-stache/src/expression-helpers.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar sourceTextSymbol = canSymbol.for(\"can-stache.sourceText\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\n// ### Lookup\n// `new Lookup(String, [Expression])`\n// Finds a value in the scope or a helper.\nvar Lookup = function(key, root, sourceText) {\n\tthis.key = key;\n\tthis.rootExpr = root;\n\tcanReflect.setKeyValue(this, sourceTextSymbol, sourceText);\n};\nLookup.prototype.value = function(scope, readOptions){\n\tif (this.rootExpr) {\n\t\treturn expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope), scope, {}, {});\n\t} else {\n\t\treturn scope.computeData(this.key, assign({\n\t\t\twarnOnMissingKey: true\n\t\t},readOptions));\n\t}\n};\n//!steal-remove-start\nif (true) {\n\tLookup.prototype.sourceText = function(){\n\t\tif(this[sourceTextSymbol]) {\n\t\t\treturn this[sourceTextSymbol];\n\t\t} else if(this.rootExpr) {\n\t\t\treturn this.rootExpr.sourceText()+\".\"+this.key;\n\t\t} else {\n\t\t\treturn this.key;\n\t\t}\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Lookup;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/expressions/lookup.js?");

/***/ }),

/***/ "./node_modules/can-stache/helpers/-debugger.js":
/*!******************************************************!*\
  !*** ./node_modules/can-stache/helpers/-debugger.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canLog = __webpack_require__(/*! can-log */ \"./node_modules/can-log/can-log.js\");\nfunction noop () {}\nvar resolveValue = noop;\nvar evaluateArgs = noop;\nvar __testing = {};\n\n//!steal-remove-start\nif (true) {\n\tvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\n\tvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\n\t__testing = {\n\t\tallowDebugger: true\n\t};\n\n\tresolveValue = function (value) {\n\t\tif (value && value[canSymbol.for(\"can.getValue\")]) {\n\t\t\treturn canReflect.getValue(value);\n\t\t}\n\t\treturn value;\n\t};\n\n\tevaluateArgs = function (left, right) {\n\t\tswitch (arguments.length) {\n\t\t\tcase 0: return true;\n\t\t\tcase 1: return !!resolveValue(left);\n\t\t\tcase 2: return resolveValue(left) === resolveValue(right);\n\t\t\tdefault:\n\t\t\t\tcanLog.log([\n\t\t\t\t\t'Usage:',\n\t\t\t\t\t'  {{debugger}}: break any time this helper is evaluated',\n\t\t\t\t\t'  {{debugger condition}}: break when `condition` is truthy',\n\t\t\t\t\t'  {{debugger left right}}: break when `left` === `right`'\n\t\t\t\t].join('\\n'));\n\t\t\t\tthrow new Error('{{debugger}} must have less than three arguments');\n\t\t}\n\t};\n}\n//!steal-remove-end\n\nfunction debuggerHelper (left, right) {\n\t//!steal-remove-start\n\tif (true) {\n\t\tvar shouldBreak = evaluateArgs.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n\t\tif (!shouldBreak) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar options = arguments[arguments.length - 1],\n\t\t\tscope = options && options.scope;\n\t\tvar get = function (path) {\n\t\t\treturn scope.get(path);\n\t\t};\n\t\t// This makes sure `get`, `options` and `scope` are available\n\t\tdebuggerHelper._lastGet = get;\n\n\t\tcanLog.log('Use `get(<path>)` to debug this template');\n\n\t\tvar allowDebugger = __testing.allowDebugger;\n\t\t// forgotten debugger\n\t\t// jshint -W087\n\t\tif (allowDebugger) {\n\t\t\tdebugger;\n\t\t\treturn;\n\t\t}\n\t\t// jshint +W087\n\t}\n\t//!steal-remove-end\n\n\tcanLog.warn('Forgotten {{debugger}} helper');\n}\ndebuggerHelper.requiresOptionsArgument = true;\n\nmodule.exports = {\n\thelper: debuggerHelper,\n\tevaluateArgs: evaluateArgs,\n\tresolveValue: resolveValue,\n\n\t// used only for testing purposes\n\t__testing: __testing\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/helpers/-debugger.js?");

/***/ }),

/***/ "./node_modules/can-stache/helpers/-for-of.js":
/*!****************************************************!*\
  !*** ./node_modules/can-stache/helpers/-for-of.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar live = __webpack_require__(/*! can-view-live */ \"./node_modules/can-view-live/can-view-live.js\");\nvar expression = __webpack_require__(/*! ../src/expression */ \"./node_modules/can-stache/src/expression.js\");\nvar KeyObservable = __webpack_require__(/*! ../src/key-observable */ \"./node_modules/can-stache/src/key-observable.js\");\n\nvar bindAndRead = function (value) {\n\tif ( value && canReflect.isValueLike(value) ) {\n\t\tObservation.temporarilyBind(value);\n\t\treturn canReflect.getValue(value);\n\t} else {\n\t\treturn value;\n\t}\n};\n\nfunction forOfInteger(integer, variableName, options) {\n\tvar result = [];\n\tfor (var i = 0; i < integer; i++) {\n\t\tvar variableScope = {};\n\t\tif(variableName !== undefined){\n\t\t\tvariableScope[variableName] = i;\n\t\t}\n\t\tresult.push(\n\t\t\toptions.fn( options.scope\n\t\t\t\t.add({ index: i }, { special: true })\n\t\t\t\t.addLetContext(variableScope) )\n\t\t);\n\t}\n\n\treturn options.stringOnly ? result.join('') : result;\n}\n\nfunction forOfObject(object, variableName, options){\n\tvar result = [];\n\tcanReflect.each(object, function(val, key){\n\t\t// Allow key to contain a dot, for example: \"My.key.has.dot\"\n\t\tvar value = new KeyObservable(object, key.replace(/\\./g, \"\\\\.\"));\n\t\tvar variableScope = {};\n\t\tif(variableName !== undefined){\n\t\t\tvariableScope[variableName] = value;\n\t\t}\n\t\tresult.push(\n\t\t\toptions.fn( options.scope\n\t\t\t\t.add({ key: key }, { special: true })\n\t\t\t\t.addLetContext(variableScope) )\n\t\t);\n\t});\n\n\treturn options.stringOnly ? result.join('') : result;\n}\n\n// this is called with the ast ... we are going to use that to our advantage.\nvar forHelper = function(helperOptions) {\n\t// lookup\n\n\t// TODO: remove in prod\n\t// make sure we got called with the right stuff\n\tif(helperOptions.exprData.argExprs.length !== 1) {\n\t\tthrow new Error(\"for(of) broken syntax\");\n\t}\n\n\t// TODO: check if an instance of helper;\n\n\tvar helperExpr = helperOptions.exprData.argExprs[0].expr;\n\tvar variableName, valueLookup, valueObservable;\n\tif(helperExpr instanceof expression.Lookup) {\n\n\t\tvalueObservable = helperExpr.value(helperOptions.scope);\n\n\t} else if(helperExpr instanceof expression.Helper) {\n\t\t// TODO: remove in prod\n\t\tvar inLookup = helperExpr.argExprs[0];\n\t\tif(inLookup.key !== \"of\") {\n\t\t\tthrow new Error(\"for(of) broken syntax\");\n\t\t}\n\t\tvariableName = helperExpr.methodExpr.key;\n\t\tvalueLookup = helperExpr.argExprs[1];\n\t\tvalueObservable = valueLookup.value(helperOptions.scope);\n\t}\n\n\tvar items =  valueObservable;\n\n\tvar args = [].slice.call(arguments),\n\t\toptions = args.pop(),\n\t\tresolved = bindAndRead(items);\n\n\tif(resolved && resolved === Math.floor(resolved)) {\n\t\treturn forOfInteger(resolved, variableName, helperOptions);\n\t}\n\tif(resolved && !canReflect.isListLike(resolved)) {\n\t\treturn forOfObject(resolved,variableName, helperOptions);\n\t}\n\tif(options.stringOnly) {\n\t\tvar parts = [];\n\t\tcanReflect.eachIndex(resolved, function(value, index){\n\t\t\tvar variableScope = {};\n\t\t\tif(variableName !== undefined){\n\t\t\t\tvariableScope[variableName] = value;\n\t\t\t}\n\t\t\tparts.push(\n\t\t\t\thelperOptions.fn( options.scope\n\t\t\t\t\t.add({ index: index }, { special: true })\n\t\t\t\t\t.addLetContext(variableScope) )\n\t\t\t);\n\t\t});\n\t\treturn parts.join(\"\");\n\t} else {\n\t\t// Tells that a helper has been called, this function should be returned through\n\t\t// checking its value.\n\t\toptions.metadata.rendered = true;\n\t\treturn function(el){\n\n\t\t\tvar cb = function (item, index) {\n\t\t\t\tvar variableScope = {};\n\t\t\t\tif(variableName !== undefined){\n\t\t\t\t\tvariableScope[variableName] = item;\n\t\t\t\t}\n\t\t\t\treturn options.fn(\n\t\t\t\t\toptions.scope\n\t\t\t\t\t.add({ index: index }, { special: true })\n\t\t\t\t\t.addLetContext(variableScope),\n\t\t\t\t\toptions.options\n\t\t\t\t);\n\t\t\t};\n\n\t\t\tlive.list(el, items, cb, options.context, function(list){\n\t\t\t\treturn options.inverse(options.scope, options.options);\n\t\t\t});\n\t\t};\n\t}\n};\nforHelper.isLiveBound = true;\nforHelper.requiresOptionsArgument = true;\nforHelper.ignoreArgLookup = function ignoreArgLookup(index) {\n\treturn index === 0;\n};\n\nmodule.exports = forHelper;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/helpers/-for-of.js?");

/***/ }),

/***/ "./node_modules/can-stache/helpers/-let.js":
/*!*************************************************!*\
  !*** ./node_modules/can-stache/helpers/-let.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nfunction isVariable(scope) {\n\treturn scope._meta.variable === true;\n}\n\n// This sets variables so it needs to not causes changes.\nvar letHelper = ObservationRecorder.ignore(function(options){\n\tif(options.isSection){\n\t\treturn options.fn( options.scope.addLetContext( options.hash ) );\n\t}\n\tvar variableScope = options.scope.getScope(isVariable);\n\tif(!variableScope) {\n\t\tthrow new Error(\"There is no variable scope!\");\n\t}\n\n\tcanReflect.assignMap(variableScope._context, options.hash);\n\treturn document.createTextNode(\"\");\n});\n\nmodule.exports = letHelper;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/helpers/-let.js?");

/***/ }),

/***/ "./node_modules/can-stache/helpers/-portal.js":
/*!****************************************************!*\
  !*** ./node_modules/can-stache/helpers/-portal.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar live = __webpack_require__(/*! can-view-live */ \"./node_modules/can-view-live/can-view-live.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar liveHelpers = __webpack_require__(/*! can-view-live/lib/helpers */ \"./node_modules/can-view-live/lib/helpers.js\");\n\nvar keepNodeSymbol = canSymbol.for(\"done.keepNode\");\n\nfunction portalHelper(elementObservable, options){\n\tvar debugName = \"portal(\" + canReflect.getName(elementObservable) + \")\";\n\n\tfunction portalContents() {\n\t\tvar frag = options.fn(\n\t\t\toptions.scope\n\t\t\t.addLetContext({}),\n\t\t\toptions.options\n\t\t);\n\n\t\tvar child = frag.firstChild;\n\t\twhile(child) {\n\t\t\t// makes sure DoneJS does not remove these nodes\n\t\t\tchild[keepNodeSymbol] = true;\n\t\t\tchild = child.nextSibling;\n\t\t}\n\n\n\t\treturn frag;\n\t}\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tObject.defineProperty(portalContents,\"name\",{\n\t\t\tvalue: debugName+\" contents\"\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\n\t// Where we are portalling\n\tvar portalElement,\n\t\tstartPortalledPlaceholder,\n\t\tendPortalledPlaceholder,\n\t\tcommentPlaceholderDispose;\n\tfunction teardownPortalledContent() {\n\n\t\tif(portalElement) {\n\t\t\tcanReflect.offValue(elementObservable, getElementAndRender);\n\t\t\tportalElement = null;\n\t\t}\n\n\t\tif(startPortalledPlaceholder && endPortalledPlaceholder) {\n\t\t\tvar parentNode = startPortalledPlaceholder.parentNode;\n\t\t\tif(parentNode) {\n\t\t\t\tliveHelpers.range.remove({start: startPortalledPlaceholder, end: endPortalledPlaceholder});\n\t\t\t\tdomMutateNode.removeChild.call(parentNode, startPortalledPlaceholder );\n\t\t\t\tdomMutateNode.removeChild.call(parentNode, endPortalledPlaceholder );\n\t\t\t\tstartPortalledPlaceholder = endPortalledPlaceholder = null;\n\t\t\t}\n\t\t}\n\t}\n\tfunction teardownEverything(){\n\t\tif(commentPlaceholderDispose) {\n\t\t\tcommentPlaceholderDispose();\n\t\t}\n\t\tteardownPortalledContent();\n\t}\n\t// The element has changed\n\tfunction getElementAndRender() {\n\t\t// remove the old rendered content and unbind if we've bound before\n\t\tteardownPortalledContent();\n\n\t\tcanReflect.onValue(elementObservable, getElementAndRender);\n\n\t\tportalElement = canReflect.getValue(elementObservable);\n\n\t\tif(portalElement) {\n\t\t\tstartPortalledPlaceholder = portalElement.ownerDocument.createComment(debugName+\" contents\");\n\t\t\tendPortalledPlaceholder = portalElement.ownerDocument.createComment(\"can-end-placeholder\");\n\t\t\tstartPortalledPlaceholder[keepNodeSymbol] = true;\n\t\t\tendPortalledPlaceholder[keepNodeSymbol] = true;\n\t\t\tportalElement.appendChild(startPortalledPlaceholder);\n\t\t\tportalElement.appendChild(endPortalledPlaceholder);\n\n\t\t\tvar observable = new Observation(portalContents, null, {isObservable: false});\n\n\t\t\tlive.html(startPortalledPlaceholder, observable);\n\t\t} else {\n\t\t\toptions.metadata.rendered = true;\n\t\t}\n\n\t}\n\n\tgetElementAndRender();\n\n\treturn function(placeholderElement) {\n\t\tvar commentPlaceholder = placeholderElement.ownerDocument.createComment(debugName);\n\n\t\tplaceholderElement.parentNode.replaceChild(commentPlaceholder, placeholderElement);\n\t\tcommentPlaceholderDispose = domMutate.onNodeRemoved(commentPlaceholder, teardownEverything);\n\t\treturn commentPlaceholder;\n\t};\n}\n\nportalHelper.isLiveBound = true;\nportalHelper.requiresOptionsArgument = true;\n\nmodule.exports = portalHelper;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/helpers/-portal.js?");

/***/ }),

/***/ "./node_modules/can-stache/helpers/converter.js":
/*!******************************************************!*\
  !*** ./node_modules/can-stache/helpers/converter.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar SetIdentifier = __webpack_require__(/*! ../src/set-identifier */ \"./node_modules/can-stache/src/set-identifier.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nfunction makeConverter(getterSetter){\n\tgetterSetter = getterSetter || {};\n\treturn function(newVal, source) {\n\t\tvar args = canReflect.toArray(arguments);\n\t\tif(newVal instanceof SetIdentifier) {\n\t\t\treturn typeof getterSetter.set === \"function\" ?\n\t\t\t\tgetterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) :\n\t\t\t\tsource(newVal.value);\n\t\t} else {\n\t\t\treturn typeof getterSetter.get === \"function\" ?\n\t\t\t\tgetterSetter.get.apply(this, args) :\n\t\t\t\targs[0];\n\t\t}\n\t};\n}\n\nmodule.exports = makeConverter;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/helpers/converter.js?");

/***/ }),

/***/ "./node_modules/can-stache/helpers/core.js":
/*!*************************************************!*\
  !*** ./node_modules/can-stache/helpers/core.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(System) {\nvar live = __webpack_require__(/*! can-view-live */ \"./node_modules/can-view-live/can-view-live.js\");\nvar utils = __webpack_require__(/*! ../src/utils */ \"./node_modules/can-stache/src/utils.js\");\nvar getBaseURL = __webpack_require__(/*! can-globals/base-url/base-url */ \"./node_modules/can-globals/base-url/base-url.js\");\nvar joinURIs = __webpack_require__(/*! can-join-uris */ \"./node_modules/can-join-uris/can-join-uris.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar debuggerHelper = __webpack_require__(/*! ./-debugger */ \"./node_modules/can-stache/helpers/-debugger.js\").helper;\nvar KeyObservable = __webpack_require__(/*! ../src/key-observable */ \"./node_modules/can-stache/src/key-observable.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar TruthyObservable = __webpack_require__(/*! ../src/truthy-observable */ \"./node_modules/can-stache/src/truthy-observable.js\");\nvar helpers = __webpack_require__(/*! can-stache-helpers */ \"./node_modules/can-stache-helpers/can-stache-helpers.js\");\nvar makeConverter = __webpack_require__(/*! ./converter */ \"./node_modules/can-stache/helpers/converter.js\");\n\nvar domData = __webpack_require__(/*! can-dom-data */ \"./node_modules/can-dom-data/can-dom-data.js\");\n\nvar forHelper = __webpack_require__(/*! ./-for-of */ \"./node_modules/can-stache/helpers/-for-of.js\");\nvar letHelper = __webpack_require__(/*! ./-let */ \"./node_modules/can-stache/helpers/-let.js\");\nvar portalHelper = __webpack_require__(/*! ./-portal */ \"./node_modules/can-stache/helpers/-portal.js\");\n\nvar builtInHelpers = {};\nvar builtInConverters = {};\nvar converterPackages = new WeakMap();\n\n// ## Helpers\nvar helpersCore = {\n\tlooksLikeOptions: function(options){\n\t\treturn options && typeof options.fn === \"function\" && typeof options.inverse === \"function\";\n\t},\n\tresolve: function(value) {\n\t\tif (value && canReflect.isValueLike(value)) {\n\t\t\treturn canReflect.getValue(value);\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t},\n\tresolveHash: function(hash){\n\t\tvar params = {};\n\t\tfor(var prop in hash) {\n\t\t\tparams[prop] = helpersCore.resolve(hash[prop]);\n\t\t}\n\t\treturn params;\n\t},\n\tbindAndRead: function (value) {\n\t\tif ( value && canReflect.isValueLike(value) ) {\n\t\t\tObservation.temporarilyBind(value);\n\t\t\treturn canReflect.getValue(value);\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t},\n\tregisterHelper: function(name, callback){\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (helpers[name]) {\n\t\t\t\tdev.warn('The helper ' + name + ' has already been registered.');\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// mark passed in helper so it will be automatically passed\n\t\t// helperOptions (.fn, .inverse, etc) when called as Call Expressions\n\t\tcallback.requiresOptionsArgument = true;\n\n\t\t// store on global helpers list\n\t\thelpers[name] = callback;\n\t},\n\tregisterHelpers: function(helpers) {\n\t\tvar name, callback;\n\t\tfor(name in helpers) {\n\t\t\tcallback = helpers[name];\n\t\t\thelpersCore.registerHelper(name, helpersCore.makeSimpleHelper(callback));\n\t\t}\n\t},\n\tregisterConverter: function(name, getterSetter) {\n\t\thelpersCore.registerHelper(name, makeConverter(getterSetter));\n\t},\n\tmakeSimpleHelper: function(fn) {\n\t\treturn function() {\n\t\t\tvar realArgs = [];\n\t\t\tcanReflect.eachIndex(arguments, function(val) {\n\t\t\t\trealArgs.push(helpersCore.resolve(val));\n\t\t\t});\n\t\t\treturn fn.apply(this, realArgs);\n\t\t};\n\t},\n\taddHelper: function(name, callback) {\n\t\tif(typeof name === \"object\") {\n\t\t\treturn helpersCore.registerHelpers(name);\n\t\t}\n\t\treturn helpersCore.registerHelper(name, helpersCore.makeSimpleHelper(callback));\n\t},\n\taddConverter: function(name, getterSetter) {\n\t\tif(typeof name === \"object\") {\n\t\t\tif(!converterPackages.has(name)) {\n\t\t\t\tconverterPackages.set(name, true);\n\t\t\t\tcanReflect.eachKey(name, function(getterSetter, name) {\n\t\t\t\t\thelpersCore.addConverter(name, getterSetter);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar helper = makeConverter(getterSetter);\n\t\thelper.isLiveBound = true;\n\t\thelpersCore.registerHelper(name, helper);\n\t},\n\n\t// add helpers that set up their own internal live-binding\n\t// these helpers will not be wrapped in computes and will\n\t// receive observable arguments when called with Call Expressions\n\taddLiveHelper: function(name, callback) {\n\t\tcallback.isLiveBound = true;\n\t\treturn helpersCore.registerHelper(name, callback);\n\t},\n\n\tgetHelper: function(name, scope) {\n\t\tvar helper = scope && scope.getHelper(name);\n\n\t\tif (!helper) {\n\t\t\thelper = helpers[name];\n\t\t}\n\n\t\treturn helper;\n\t},\n\t__resetHelpers: function() {\n\t\t// remove all helpers from can-stache-helpers object\n\t\tfor (var helper in helpers) {\n\t\t\tdelete helpers[helper];\n\t\t}\n\t\t// Clear converterPackages map before re-adding converters\n\t\tconverterPackages.delete(builtInConverters);\n\n\t\thelpersCore.addBuiltInHelpers();\n\t\thelpersCore.addBuiltInConverters();\n\t},\n\taddBuiltInHelpers: function() {\n\t\tcanReflect.each(builtInHelpers, function(helper, helperName) {\n\t\t\thelpers[helperName] = helper;\n\t\t});\n\t},\n\taddBuiltInConverters: function () {\n\t\thelpersCore.addConverter(builtInConverters);\n\t},\n\t_makeLogicHelper: function(name, logic){\n\t\tvar logicHelper =  assign(function() {\n\t\t\tvar args = Array.prototype.slice.call(arguments, 0),\n\t\t\t\toptions;\n\n\t\t\tif( helpersCore.looksLikeOptions(args[args.length - 1]) ){\n\t\t\t\toptions = args.pop();\n\t\t\t}\n\n\t\t\tfunction callLogic(){\n\t\t\t\t// if there are options, we want to prevent re-rendering if values are still truthy\n\t\t\t\tif(options) {\n\t\t\t\t\treturn logic(args) ? true: false;\n\t\t\t\t} else {\n\t\t\t\t\treturn logic(args);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tObject.defineProperty(callLogic, \"name\", {\n\t\t\t\t\tvalue: name+\"(\"+args.map(function(arg){\n\t\t\t\t\t\treturn canReflect.getName(arg);\n\t\t\t\t\t}).join(\",\")+\")\",\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar callFn = new Observation(callLogic);\n\n\t\t\tif(options) {\n\t\t\t\treturn callFn.get() ? options.fn() : options.inverse();\n\t\t\t} else {\n\t\t\t\treturn callFn.get();\n\t\t\t}\n\n\t\t},{requiresOptionsArgument: true, isLiveBound: true});\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tObject.defineProperty(logicHelper, \"name\", {\n\t\t\t\tvalue: name,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn logicHelper;\n\t}\n};\n\n\n\n// ## IF HELPER\nvar ifHelper = assign(function ifHelper(expr, options) {\n\tvar value;\n\t// if it's a function, wrap its value in a compute\n\t// that will only change values from true to false\n\tif (expr && canReflect.isValueLike(expr)) {\n\t\tvalue = canReflect.getValue(new TruthyObservable(expr));\n\t} else {\n\t\tvalue = !! helpersCore.resolve(expr);\n\t}\n\n\tif (options) {\n\t\treturn value ? options.fn(options.scope || this) : options.inverse(options.scope || this);\n\t}\n\n\treturn !!value;\n}, {requiresOptionsArgument: true, isLiveBound: true});\n\n\n\n\n//## EQ/IS HELPER\nvar isHelper = helpersCore._makeLogicHelper(\"eq\", function eqHelper(args){\n\tvar curValue, lastValue;\n\tfor (var i = 0; i < args.length; i++) {\n\t\tcurValue = helpersCore.resolve(args[i]);\n\t\tcurValue = typeof curValue === \"function\" ? curValue() : curValue;\n\n\t\tif (i > 0) {\n\t\t\tif (curValue !== lastValue) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tlastValue = curValue;\n\t}\n\treturn true;\n});\n\nvar andHelper = helpersCore._makeLogicHelper(\"and\", function andHelper(args){\n\tif(args.length === 0 ) {\n\t\treturn false;\n\t}\n\tvar last;\n\tfor (var i = 0, len = args.length; i < len; i++) {\n\t\tlast = helpersCore.resolve(args[i]);\n\t\tif( !last  ) {\n\t\t\treturn last;\n\t\t}\n\t}\n\treturn last;\n});\n\nvar orHelper = helpersCore._makeLogicHelper(\"or\", function orHelper(args){\n\tif(args.length === 0 ) {\n\t\treturn false;\n\t}\n\tvar last;\n\tfor (var i = 0, len = args.length; i < len; i++) {\n\t\tlast = helpersCore.resolve(args[i]);\n\t\tif( last  ) {\n\t\t\treturn last;\n\t\t}\n\t}\n\treturn last;\n});\n\n\nvar switchHelper = function(expression, options){\n\thelpersCore.resolve(expression);\n\tvar found = false;\n\n\tvar caseHelper = function(value, options) {\n\t\tif(!found && helpersCore.resolve(expression) === helpersCore.resolve(value)) {\n\t\t\tfound = true;\n\t\t\treturn options.fn(options.scope);\n\t\t}\n\t};\n\tcaseHelper.requiresOptionsArgument = true;\n\n\t// create default helper as a value-like function\n\t// so that either {{#default}} or {{#default()}} will work\n\tvar defaultHelper = function(options) {\n\t\tif (!found) {\n\t\t\treturn options ? options.scope.peek('this') : true;\n\t\t}\n\t};\n\tdefaultHelper.requiresOptionsArgument = true;\n\tcanReflect.assignSymbols(defaultHelper, {\n\t\t\"can.isValueLike\": true,\n\t\t\"can.isFunctionLike\": false,\n\t\t\"can.getValue\": function() {\n\t\t\t// pass the helperOptions passed to {{#switch}}\n\t\t\treturn this(options);\n\t\t}\n\t});\n\n\tvar newScope = options.scope.add({\n\t\tcase: caseHelper,\n\t\tdefault: defaultHelper\n\t}, { notContext: true });\n\n\treturn options.fn(newScope, options);\n};\nswitchHelper.requiresOptionsArgument = true;\n\n\n// ## ODD HELPERS\n\nvar domDataHelper = function(attr, value) {\n\tvar data = (helpersCore.looksLikeOptions(value) ? value.context : value) || this;\n\treturn function setDomData(el) {\n\t\tdomData.set( el, attr, data );\n\t};\n};\n\nvar joinBaseHelper = function(firstExpr/* , expr... */){\n\tvar args = [].slice.call(arguments);\n\tvar options = args.pop();\n\n\tvar moduleReference = args.map( function(expr){\n\t\tvar value = helpersCore.resolve(expr);\n\t\treturn typeof value === \"function\" ? value() : value;\n\t}).join(\"\");\n\n\tvar templateModule = canReflect.getKeyValue(options.scope.templateContext.helpers, 'module');\n\tvar parentAddress = templateModule ? templateModule.uri: undefined;\n\n\tvar isRelative = moduleReference[0] === \".\";\n\n\tif(isRelative && parentAddress) {\n\t\treturn joinURIs(parentAddress, moduleReference);\n\t} else {\n\t\tvar baseURL = ( true &&\n\t\t\t(System.renderingBaseURL || System.baseURL)) ||\tgetBaseURL();\n\n\t\t// Make sure one of them has a needed /\n\t\tif(moduleReference[0] !== \"/\" && baseURL[baseURL.length - 1] !== \"/\") {\n\t\t\tbaseURL += \"/\";\n\t\t}\n\n\t\treturn joinURIs(baseURL, moduleReference);\n\t}\n};\njoinBaseHelper.requiresOptionsArgument = true;\n\n// ## LEGACY HELPERS\n\n// ### each\nvar eachHelper = function(items) {\n\tvar args = [].slice.call(arguments),\n\t\toptions = args.pop(),\n\t\thashExprs = options.exprData.hashExprs,\n\t\tresolved = helpersCore.bindAndRead(items),\n\t\thashOptions,\n\t\taliases;\n\n\t// Check if using hash\n\tif (canReflect.size(hashExprs) > 0) {\n\t\thashOptions = {};\n\t\tcanReflect.eachKey(hashExprs, function (exprs, key) {\n\t\t\thashOptions[exprs.key] = key;\n\t\t});\n\t}\n\n\tif ((\n\t\tcanReflect.isObservableLike(resolved) && canReflect.isListLike(resolved) ||\n\t\t\t( canReflect.isListLike(resolved) && canReflect.isValueLike(items) )\n\t) && !options.stringOnly) {\n\t\t// Tells that a helper has been called, this function should be returned through\n\t\t// checking its value.\n\t\toptions.metadata.rendered = true;\n\t\treturn function(el){\n\t\t\tvar cb = function (item, index) {\n\t\t\t\tvar aliases = {};\n\n\t\t\t\tif (canReflect.size(hashOptions) > 0) {\n\t\t\t\t\tif (hashOptions.value) {\n\t\t\t\t\t\taliases[hashOptions.value] = item;\n\t\t\t\t\t}\n\t\t\t\t\tif (hashOptions.index) {\n\t\t\t\t\t\taliases[hashOptions.index] = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn options.fn(\n\t\t\t\t\toptions.scope\n\t\t\t\t\t.add(aliases, { notContext: true })\n\t\t\t\t\t.add({ index: index }, { special: true })\n\t\t\t\t\t.add(item),\n\t\t\t\toptions.options\n\t\t\t\t);\n\t\t\t};\n\n\t\t\tlive.list(el, items, cb, options.context , function(list){\n\t\t\t\treturn options.inverse(options.scope.add(list), options.options);\n\t\t\t});\n\t\t};\n\t}\n\n\tvar expr = helpersCore.resolve(items),\n\t\tresult;\n\n\tif (!!expr && canReflect.isListLike(expr)) {\n\t\tresult = utils.getItemsFragContent(expr, options, options.scope);\n\t\treturn options.stringOnly ? result.join('') : result;\n\t} else if (canReflect.isObservableLike(expr) && canReflect.isMapLike(expr) || expr instanceof Object) {\n\t\tresult = [];\n\t\tcanReflect.each(expr, function(val, key){\n\t\t\tvar value = new KeyObservable(expr, key);\n\t\t\taliases = {};\n\n\t\t\tif (canReflect.size(hashOptions) > 0) {\n\t\t\t\tif (hashOptions.value) {\n\t\t\t\t\taliases[hashOptions.value] = value;\n\t\t\t\t}\n\t\t\t\tif (hashOptions.key) {\n\t\t\t\t\taliases[hashOptions.key] = key;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.push(options.fn(\n\t\t\t\toptions.scope\n\t\t\t\t.add(aliases, { notContext: true })\n\t\t\t\t.add({ key: key }, { special: true })\n\t\t\t\t.add(value)\n\t\t\t));\n\t\t});\n\n\t\treturn options.stringOnly ? result.join('') : result;\n\t}\n};\neachHelper.isLiveBound = true;\neachHelper.requiresOptionsArgument = true;\neachHelper.ignoreArgLookup = function ignoreArgLookup(index) {\n\treturn index === 1;\n};\n\n// ### index\n// This is legacy for `{{index(5)}}`\nvar indexHelper = assign(function indexHelper(offset, options) {\n\tif (!options) {\n\t\toptions = offset;\n\t\toffset = 0;\n\t}\n\tvar index = options.scope.peek(\"scope.index\");\n\treturn \"\"+((typeof(index) === \"function\" ? index() : index) + offset);\n}, {requiresOptionsArgument: true});\n\n// ### WITH HELPER\nvar withHelper = function (expr, options) {\n\tvar ctx = expr;\n\tif(!options) {\n\t\t// hash-only case if no current context expression\n\t\toptions = expr;\n\t\texpr = true;\n\t\tctx = options.hash;\n\t} else {\n\t\texpr = helpersCore.resolve(expr);\n\t\tif(options.hash && canReflect.size(options.hash) > 0) {\n\t\t\t// presumably rare case of both a context object AND hash keys\n\t\t\t// Leaving it undocumented for now, but no reason not to support it.\n\t\t\tctx = options.scope.add(options.hash, { notContext: true }).add(ctx);\n\t\t}\n\t}\n\treturn options.fn(ctx || {});\n};\nwithHelper.requiresOptionsArgument = true;\n\n// ### data helper\nvar dataHelper = function(attr, value) {\n\tvar data = (helpersCore.looksLikeOptions(value) ? value.context : value) || this;\n\treturn function setData(el) {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.warn('The {{data}} helper has been deprecated; use {{domData}} instead: https://canjs.com/doc/can-stache.helpers.domData.html');\n\t\t}\n\t\t//!steal-remove-end\n\t\tdomData.set( el, attr, data );\n\t};\n};\n\n// ## UNLESS HELPER\nvar unlessHelper = function (expr, options) {\n\tif(!options) {\n\t\treturn !ifHelper.apply(this, [expr]);\n\t}\n\treturn ifHelper.apply(this, [expr, assign(assign({}, options), {\n\t\tfn: options.inverse,\n\t\tinverse: options.fn\n\t})]);\n};\nunlessHelper.requiresOptionsArgument = true;\nunlessHelper.isLiveBound = true;\n\n\n// ## Converters\n// ## NOT converter\nvar notConverter = {\n\tget: function(obs, options){\n\t\tif(helpersCore.looksLikeOptions(options)) {\n\t\t\treturn canReflect.getValue(obs) ? options.inverse() : options.fn();\n\t\t} else {\n\t\t\treturn !canReflect.getValue(obs);\n\t\t}\n\t},\n\tset: function(newVal, obs){\n\t\tcanReflect.setValue(obs, !newVal);\n\t}\n};\n\n// ## Register as defaults\n\nassign(builtInHelpers, {\n\t'debugger': debuggerHelper,\n\teach: eachHelper,\n\teachOf: eachHelper,\n\tindex: indexHelper,\n\t'if': ifHelper,\n\tis: isHelper,\n\teq: isHelper,\n\tunless: unlessHelper,\n\t'with': withHelper,\n\tconsole: console,\n\tdata: dataHelper,\n\tdomData: domDataHelper,\n\t'switch': switchHelper,\n\tjoinBase: joinBaseHelper,\n\tand: andHelper,\n\tor: orHelper,\n\t'let': letHelper,\n\t'for': forHelper,\n\tportal: portalHelper\n});\n\nassign(builtInConverters, {\n\t'not': notConverter\n});\n\n// add all the built-in helpers when stache is loaded\nhelpersCore.addBuiltInHelpers();\nhelpersCore.addBuiltInConverters();\n\nmodule.exports = helpersCore;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/system.js */ \"./node_modules/webpack/buildin/system.js\")))\n\n//# sourceURL=webpack:///./node_modules/can-stache/helpers/core.js?");

/***/ }),

/***/ "./node_modules/can-stache/src/expression-helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-stache/src/expression-helpers.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Arg = __webpack_require__(/*! ../expressions/arg */ \"./node_modules/can-stache/expressions/arg.js\");\nvar Literal = __webpack_require__(/*! ../expressions/literal */ \"./node_modules/can-stache/expressions/literal.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar stacheKey = __webpack_require__(/*! can-stache-key */ \"./node_modules/can-stache-key/can-stache-key.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar makeComputeLike = __webpack_require__(/*! can-view-scope/make-compute-like */ \"./node_modules/can-view-scope/make-compute-like.js\");\nvar SetterObservable = __webpack_require__(/*! can-simple-observable/setter/setter */ \"./node_modules/can-simple-observable/setter/setter.js\");\n\n// ## Helpers\n\nfunction getObservableValue_fromDynamicKey_fromObservable(key, root, helperOptions, readOptions) {\n\t// This needs to return something similar to a ScopeKeyData with intialValue and parentHasKey\n\tvar getKeys = function(){\n\t\treturn stacheKey.reads((\"\" + canReflect.getValue(key)).replace(/\\./g, \"\\\\.\"));\n\t};\n\tvar parentHasKey;\n\tvar computeValue = new SetterObservable(function getDynamicKey() {\n\t\tvar readData = stacheKey.read( canReflect.getValue(root) , getKeys());\n\t\tparentHasKey = readData.parentHasKey;\n\t\treturn readData.value;\n\t}, function setDynamicKey(newVal){\n\t\tstacheKey.write(canReflect.getValue(root), getKeys(), newVal);\n\t});\n\t// This prevents lazy evalutaion\n\tObservation.temporarilyBind(computeValue);\n\n\t// peek so no observable that might call getObservableValue_fromDynamicKey_fromObservable will re-evaluate if computeValue changes.\n\tcomputeValue.initialValue = ObservationRecorder.peekValue(computeValue);\n\tcomputeValue.parentHasKey = parentHasKey;\n\t// Todo:\n\t// 1. We should warn here if `initialValue` is undefined.  We can expose the warning function\n\t//    in can-view-scope and call it here.\n\t// 2. We should make this lazy if possible.  We can do that by making getter/setters for\n\t//    initialValue and parentHasKey (and possibly @@can.valueHasDependencies)\n\treturn computeValue;\n}\n\n// If not a Literal or an Arg, convert to an arg for caching.\nfunction convertToArgExpression(expr) {\n\tif(!(expr instanceof Arg) && !(expr instanceof Literal)) {\n\t\treturn new Arg(expr);\n\t} else {\n\t\treturn expr;\n\t}\n}\n\nfunction toComputeOrValue(value) {\n\t// convert to non observable value\n\tif(canReflect.isObservableLike(value)) {\n\t\t// we only want to do this for things that `should` have dependencies, but dont.\n\t\tif(canReflect.isValueLike(value) && canReflect.valueHasDependencies(value) === false) {\n\t\t\treturn canReflect.getValue(value);\n\t\t}\n\t\t// if compute data\n\t\tif(value.compute) {\n\t\t\treturn value.compute;\n\t\t} else {\n\t\t\treturn makeComputeLike(value);\n\t\t}\n\t}\n\treturn value;\n}\n\n// try to make it a compute no matter what.  This is useful for\n// ~ operator.\nfunction toCompute(value) {\n\tif(value) {\n\n\t\tif(value.isComputed) {\n\t\t\treturn value;\n\t\t}\n\t\tif(value.compute) {\n\t\t\treturn value.compute;\n\t\t} else {\n\t\t\treturn makeComputeLike(value);\n\t\t}\n\t}\n\treturn value;\n}\n\nmodule.exports = {\n\tgetObservableValue_fromDynamicKey_fromObservable: getObservableValue_fromDynamicKey_fromObservable,\n\tconvertToArgExpression: convertToArgExpression,\n\ttoComputeOrValue: toComputeOrValue,\n\ttoCompute: toCompute\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/src/expression-helpers.js?");

/***/ }),

/***/ "./node_modules/can-stache/src/expression.js":
/*!***************************************************!*\
  !*** ./node_modules/can-stache/src/expression.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ## Expression Types\n//\n// These expression types return a value. They are assembled by `expression.parse`.\nvar Arg = __webpack_require__(/*! ../expressions/arg */ \"./node_modules/can-stache/expressions/arg.js\");\nvar Literal = __webpack_require__(/*! ../expressions/literal */ \"./node_modules/can-stache/expressions/literal.js\");\nvar Hashes = __webpack_require__(/*! ../expressions/hashes */ \"./node_modules/can-stache/expressions/hashes.js\");\nvar Bracket = __webpack_require__(/*! ../expressions/bracket */ \"./node_modules/can-stache/expressions/bracket.js\");\nvar Call = __webpack_require__(/*! ../expressions/call */ \"./node_modules/can-stache/expressions/call.js\");\nvar Helper = __webpack_require__(/*! ../expressions/helper */ \"./node_modules/can-stache/expressions/helper.js\");\nvar Lookup = __webpack_require__(/*! ../expressions/lookup */ \"./node_modules/can-stache/expressions/lookup.js\");\n\nvar SetIdentifier = __webpack_require__(/*! ./set-identifier */ \"./node_modules/can-stache/src/set-identifier.js\");\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"./node_modules/can-stache/src/expression-helpers.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/can-stache/src/utils.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar last = utils.last;\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar sourceTextSymbol = canSymbol.for(\"can-stache.sourceText\");\n\n// ### Hash\n// A placeholder. This isn't actually used.\nvar Hash = function(){ }; // jshint ignore:line\n\n// NAME - \\w\n// KEY - foo, foo.bar, foo@bar, %foo (special), &foo (references), ../foo, ./foo\n// ARG - ~KEY, KEY, CALLEXPRESSION, PRIMITIVE\n// CALLEXPRESSION = KEY(ARG,ARG, NAME=ARG)\n// HELPEREXPRESSION = KEY ARG ARG NAME=ARG\n// DOT .NAME\n// AT @NAME\n//\nvar keyRegExp = /[\\w\\.\\\\\\-_@\\/\\&%]+/,\n\ttokensRegExp = /('.*?'|\".*?\"|=|[\\w\\.\\\\\\-_@\\/*%\\$]+|[\\(\\)]|,|\\~|\\[|\\]\\s*|\\s*(?=\\[))/g,\n\tbracketSpaceRegExp = /\\]\\s+/,\n\tliteralRegExp = /^('.*?'|\".*?\"|-?[0-9]+\\.?[0-9]*|true|false|null|undefined)$/;\n\nvar isTokenKey = function(token){\n\treturn keyRegExp.test(token);\n};\n\nvar testDot = /^[\\.@]\\w/;\nvar isAddingToExpression = function(token) {\n\n\treturn isTokenKey(token) && testDot.test(token);\n};\n\nvar ensureChildren = function(type) {\n\tif(!type.children) {\n\t\ttype.children = [];\n\t}\n\treturn type;\n};\n\nvar Stack = function(){\n\n\tthis.root = {children: [], type: \"Root\"};\n\tthis.current = this.root;\n\tthis.stack = [this.root];\n};\nassign(Stack.prototype,{\n\ttop: function(){\n\t\treturn last(this.stack);\n\t},\n\tisRootTop: function(){\n\t\treturn this.top() === this.root;\n\t},\n\tpopTo: function(types){\n\t\tthis.popUntil(types);\n\t\tthis.pop();\n\t},\n\tpop: function() {\n\t\tif(!this.isRootTop()) {\n\t\t\tthis.stack.pop();\n\t\t}\n\t},\n\tfirst: function(types){\n\t\tvar curIndex = this.stack.length - 1;\n\t\twhile( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {\n\t\t\tcurIndex--;\n\t\t}\n\t\treturn this.stack[curIndex];\n\t},\n\tfirstParent: function(types){\n\t\tvar curIndex = this.stack.length - 2;\n\t\twhile( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {\n\t\t\tcurIndex--;\n\t\t}\n\t\treturn this.stack[curIndex];\n\t},\n\tpopUntil: function(types){\n\t\twhile( types.indexOf(this.top().type) === -1 && !this.isRootTop() ) {\n\t\t\tthis.stack.pop();\n\t\t}\n\t\treturn this.top();\n\t},\n\taddTo: function(types, type){\n\t\tvar cur = this.popUntil(types);\n\t\tensureChildren(cur).children.push(type);\n\t},\n\taddToAndPush: function(types, type){\n\t\tthis.addTo(types, type);\n\t\tthis.stack.push(type);\n\t},\n\tpush: function(type) {\n\t\tthis.stack.push(type);\n\t},\n\ttopLastChild: function(){\n\t\treturn last(this.top().children);\n\t},\n\treplaceTopLastChild: function(type){\n\t\tvar children = ensureChildren(this.top()).children;\n\t\tchildren.pop();\n\t\tchildren.push(type);\n\t\treturn type;\n\t},\n\treplaceTopLastChildAndPush: function(type) {\n\t\tthis.replaceTopLastChild(type);\n\t\tthis.stack.push(type);\n\t},\n\treplaceTopAndPush: function(type){\n\t\tvar children;\n\t\tif(this.top() === this.root) {\n\t\t\tchildren = ensureChildren(this.top()).children;\n\t\t} else {\n\t\t\tthis.stack.pop();\n\t\t\t// get parent and clean\n\t\t\tchildren = ensureChildren(this.top()).children;\n\t\t}\n\n\t\tchildren.pop();\n\t\tchildren.push(type);\n\t\tthis.stack.push(type);\n\t\treturn type;\n\t}\n});\n\n// converts\n// - \"../foo\" -> \"../@foo\",\n// - \"foo\" -> \"@foo\",\n// - \".foo\" -> \"@foo\",\n// - \"./foo\" -> \"./@foo\"\n// - \"foo.bar\" -> \"foo@bar\"\nvar convertKeyToLookup = function(key){\n\tvar lastPath = key.lastIndexOf(\"./\");\n\tvar lastDot = key.lastIndexOf(\".\");\n\tif(lastDot > lastPath) {\n\t\treturn key.substr(0, lastDot)+\"@\"+key.substr(lastDot+1);\n\t}\n\tvar firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath+2;\n\tvar firstNonPathChar = key.charAt(firstNonPathCharIndex);\n\tif(firstNonPathChar === \".\" || firstNonPathChar === \"@\" ) {\n\t\treturn key.substr(0, firstNonPathCharIndex)+\"@\"+key.substr(firstNonPathCharIndex+1);\n\t} else {\n\t\treturn key.substr(0, firstNonPathCharIndex)+\"@\"+key.substr(firstNonPathCharIndex);\n\t}\n};\nvar convertToAtLookup = function(ast){\n\tif(ast.type === \"Lookup\") {\n\t\tcanReflect.setKeyValue(ast, sourceTextSymbol, ast.key);\n\t\tast.key = convertKeyToLookup(ast.key);\n\t}\n\treturn ast;\n};\n\nvar convertToHelperIfTopIsLookup = function(stack){\n\tvar top = stack.top();\n\t// if two scopes, that means a helper\n\tif(top && top.type === \"Lookup\") {\n\n\t\tvar base = stack.stack[stack.stack.length - 2];\n\t\t// That lookup shouldn't be part of a Helper already or\n\t\tif(base.type !== \"Helper\" && base) {\n\t\t\tstack.replaceTopAndPush({\n\t\t\t\ttype: \"Helper\",\n\t\t\t\tmethod: top\n\t\t\t});\n\t\t}\n\t}\n};\n\nvar expression = {\n\ttoComputeOrValue: expressionHelpers.toComputeOrValue,\n\tconvertKeyToLookup: convertKeyToLookup,\n\n\tLiteral: Literal,\n\tLookup: Lookup,\n\tArg: Arg,\n\tHash: Hash,\n\tHashes: Hashes,\n\tCall: Call,\n\tHelper: Helper,\n\tBracket: Bracket,\n\n\tSetIdentifier: SetIdentifier,\n\ttokenize: function(expression){\n\t\tvar tokens = [];\n\t\t(expression.trim() + ' ').replace(tokensRegExp, function (whole, arg) {\n\t\t\tif (bracketSpaceRegExp.test(arg)) {\n\t\t\t\ttokens.push(arg[0]);\n\t\t\t\ttokens.push(arg.slice(1));\n\t\t\t} else {\n\t\t\t\ttokens.push(arg);\n\t\t\t}\n\t\t});\n\t\treturn tokens;\n\t},\n\tlookupRules: {\n\t\t\"default\": function(ast, methodType, isArg){\n\t\t\treturn ast.type === \"Helper\" ? Helper : Lookup;\n\t\t},\n\t\t\"method\": function(ast, methodType, isArg){\n\t\t\treturn Lookup;\n\t\t}\n\t},\n\tmethodRules: {\n\t\t\"default\": function(ast){\n\t\t\treturn ast.type === \"Call\" ? Call : Helper;\n\t\t},\n\t\t\"call\": function(ast){\n\t\t\treturn Call;\n\t\t}\n\t},\n\t// ## expression.parse\n\t//\n\t// - {String} expressionString - A stache expression like \"abc foo()\"\n\t// - {Object} options\n\t//   - baseMethodType - Treat this like a Helper or Call.  Default to \"Helper\"\n\t//   - lookupRule - \"default\" or \"method\"\n\t//   - methodRule - \"default\" or \"call\"\n\tparse: function(expressionString, options){\n\t\toptions =  options || {};\n\t\tvar ast = this.ast(expressionString);\n\n\t\tif(!options.lookupRule) {\n\t\t\toptions.lookupRule = \"default\";\n\t\t}\n\t\tif(typeof options.lookupRule === \"string\") {\n\t\t\toptions.lookupRule = expression.lookupRules[options.lookupRule];\n\t\t}\n\t\tif(!options.methodRule) {\n\t\t\toptions.methodRule = \"default\";\n\t\t}\n\t\tif(typeof options.methodRule === \"string\") {\n\t\t\toptions.methodRule = expression.methodRules[options.methodRule];\n\t\t}\n\n\t\tvar expr = this.hydrateAst(ast, options, options.baseMethodType || \"Helper\");\n\n\t\treturn expr;\n\t},\n\thydrateAst: function(ast, options, methodType, isArg){\n\t\tvar hashes;\n\t\tif(ast.type === \"Lookup\") {\n\t\t\tvar LookupRule = options.lookupRule(ast, methodType, isArg);\n\t\t\tvar lookup = new LookupRule(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType), ast[sourceTextSymbol] );\n\t\t\treturn lookup;\n\t\t}\n\t\telse if(ast.type === \"Literal\") {\n\t\t\treturn new Literal(ast.value);\n\t\t}\n\t\telse if(ast.type === \"Arg\") {\n\t\t\treturn new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg),{compute: true});\n\t\t}\n\t\telse if(ast.type === \"Hash\") {\n\t\t\tthrow new Error(\"\");\n\t\t}\n\t\telse if(ast.type === \"Hashes\") {\n\t\t\thashes = {};\n\t\t\tast.children.forEach(function(hash){\n\t\t\t\thashes[hash.prop] = this.hydrateAst( hash.children[0], options, methodType, true );\n\t\t\t}, this);\n\t\t\treturn new Hashes(hashes);\n\t\t}\n\t\telse if(ast.type === \"Call\" || ast.type === \"Helper\") {\n\t\t\t//get all arguments and hashes\n\t\t\thashes = {};\n\t\t\tvar args = [],\n\t\t\t\tchildren = ast.children,\n\t\t\t\tExpressionType = options.methodRule(ast);\n\t\t\tif(children) {\n\t\t\t\tfor(var i = 0 ; i <children.length; i++) {\n\t\t\t\t\tvar child = children[i];\n\t\t\t\t\tif(child.type === \"Hashes\" && ast.type === \"Helper\" &&\n\t\t\t\t\t\t(ExpressionType !== Call)) {\n\n\t\t\t\t\t\tchild.children.forEach(function(hash){\n\t\t\t\t\t\t\thashes[hash.prop] = this.hydrateAst( hash.children[0], options, ast.type, true );\n\t\t\t\t\t\t}, this);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push( this.hydrateAst(child, options, ast.type, true) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\treturn new ExpressionType(this.hydrateAst(ast.method, options, ast.type),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\targs, hashes);\n\t\t} else if (ast.type === \"Bracket\") {\n\t\t\tvar originalKey;\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\toriginalKey = ast[canSymbol.for(\"can-stache.originalKey\")];\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\treturn new Bracket(\n\t\t\t\tthis.hydrateAst(ast.children[0], options),\n\t\t\t\tast.root ? this.hydrateAst(ast.root, options) : undefined,\n\t\t\t\toriginalKey\n\t\t\t);\n\t\t}\n\t},\n\tast: function(expression){\n\t\tvar tokens = this.tokenize(expression);\n\t\treturn this.parseAst(tokens, {\n\t\t\tindex: 0\n\t\t});\n\t},\n\tparseAst: function(tokens, cursor) {\n\t\t// jshint maxdepth: 6\n\t\tvar stack = new Stack(),\n\t\t\ttop,\n\t\t\tfirstParent,\n\t\t\tlastToken;\n\n\t\twhile(cursor.index < tokens.length) {\n\t\t\tvar token = tokens[cursor.index],\n\t\t\t\tnextToken = tokens[cursor.index+1];\n\n\t\t\tcursor.index++;\n\n\t\t\t// Hash\n\t\t\tif(nextToken === \"=\") {\n\t\t\t\t//convertToHelperIfTopIsLookup(stack);\n\t\t\t\ttop = stack.top();\n\n\t\t\t\t// If top is a Lookup, we might need to convert to a helper.\n\t\t\t\tif(top && top.type === \"Lookup\") {\n\t\t\t\t\t// Check if current Lookup is part of a Call, Helper, or Hash\n\t\t\t\t\t// If it happens to be first within a Call or Root, that means\n\t\t\t\t\t// this is helper syntax.\n\t\t\t\t\tfirstParent = stack.firstParent([\"Call\",\"Helper\",\"Hash\"]);\n\t\t\t\t\tif(firstParent.type === \"Call\" || firstParent.type === \"Root\") {\n\n\t\t\t\t\t\tstack.popUntil([\"Call\"]);\n\t\t\t\t\t\ttop = stack.top();\n\t\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\t\ttype: \"Helper\",\n\t\t\t\t\t\t\tmethod: top.type === \"Root\" ? last(top.children) : top\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfirstParent = stack.first([\"Call\",\"Helper\",\"Hashes\",\"Root\"]);\n\t\t\t\t// makes sure we are adding to Hashes if there already is one\n\t\t\t\t// otherwise we create one.\n\t\t\t\tvar hash = {type: \"Hash\", prop: token};\n\t\t\t\tif(firstParent.type === \"Hashes\") {\n\t\t\t\t\tstack.addToAndPush([\"Hashes\"], hash);\n\t\t\t\t} else {\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\",\"Root\"], {\n\t\t\t\t\t\ttype: \"Hashes\",\n\t\t\t\t\t\tchildren: [hash]\n\t\t\t\t\t});\n\t\t\t\t\tstack.push(hash);\n\t\t\t\t}\n\t\t\t\tcursor.index++;\n\n\t\t\t}\n\t\t\t// Literal\n\t\t\telse if(literalRegExp.test( token )) {\n\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\t// only add to hash if there's not already a child.\n\t\t\t\tfirstParent = stack.first([\"Helper\", \"Call\", \"Hash\", \"Bracket\"]);\n\t\t\t\tif(firstParent.type === \"Hash\" && (firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Bracket\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t} else if(firstParent.type === \"Bracket\" && (firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Hash\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t} else {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Hash\", \"Bracket\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// Lookup\n\t\t\telse if(keyRegExp.test(token)) {\n\t\t\t\tlastToken = stack.topLastChild();\n\t\t\t\tfirstParent = stack.first([\"Helper\", \"Call\", \"Hash\", \"Bracket\"]);\n\n\t\t\t\t// if we had `foo().bar`, we need to change to a Lookup that looks up from lastToken.\n\t\t\t\tif(lastToken && (lastToken.type === \"Call\" || lastToken.type === \"Bracket\" ) && isAddingToExpression(token)) {\n\t\t\t\t\tstack.replaceTopLastChildAndPush({\n\t\t\t\t\t\ttype: \"Lookup\",\n\t\t\t\t\t\troot: lastToken,\n\t\t\t\t\t\tkey: token.slice(1) // remove leading `.`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if(firstParent.type === 'Bracket') {\n\t\t\t\t\t// a Bracket expression without children means we have\n\t\t\t\t\t// parsed `foo[` of an expression like `foo[bar]`\n\t\t\t\t\t// so we know to add the Lookup as a child of the Bracket expression\n\t\t\t\t\tif (!(firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\t\tstack.addToAndPush([\"Bracket\"], {type: \"Lookup\", key: token});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// check if we are adding to a helper like `eq foo[bar] baz`\n\t\t\t\t\t\t// but not at the `.baz` of `eq foo[bar].baz xyz`\n\t\t\t\t\t\tif(stack.first([\"Helper\", \"Call\", \"Hash\", \"Arg\"]).type === 'Helper' && token[0] !== '.') {\n\t\t\t\t\t\t\tstack.addToAndPush([\"Helper\"], {type: \"Lookup\", key: token});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// otherwise, handle the `.baz` in expressions like `foo[bar].baz`\n\t\t\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\t\t\ttype: \"Lookup\",\n\t\t\t\t\t\t\t\tkey: token.slice(1),\n\t\t\t\t\t\t\t\troot: firstParent\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// if two scopes, that means a helper\n\t\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\", \"Arg\", \"Bracket\"], {type: \"Lookup\", key: token});\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// Arg\n\t\t\telse if(token === \"~\") {\n\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\"], {type: \"Arg\", key: token});\n\t\t\t}\n\t\t\t// Call\n\t\t\t// foo[bar()]\n\t\t\telse if(token === \"(\") {\n\t\t\t\ttop = stack.top();\n\t\t\t\tlastToken = stack.topLastChild();\n\t\t\t\tif(top.type === \"Lookup\") {\n\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\ttype: \"Call\",\n\t\t\t\t\t\tmethod: convertToAtLookup(top)\n\t\t\t\t\t});\n\n\t\t\t\t// Nested Call\n\t\t\t\t// foo()()\n\t\t\t\t} else if (lastToken && lastToken.type === \"Call\") {\n\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\ttype: \"Call\",\n\t\t\t\t\t\tmethod: lastToken\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Unable to understand expression \"+tokens.join(''));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// End Call\n\t\t\telse if(token === \")\") {\n\t\t\t\tstack.popTo([\"Call\"]);\n\t\t\t}\n\t\t\t// End Call argument\n\t\t\telse if(token === \",\") {\n\t\t\t\t// The {{let foo=zed, bar=car}} helper is not in a call\n\t\t\t\t// expression.\n\t\t\t\tvar call = stack.first([\"Call\"]);\n\t\t\t\tif(call.type !== \"Call\") {\n\t\t\t\t\tstack.popUntil([\"Hash\"]);\n\t\t\t\t} else {\n\t\t\t\t\tstack.popUntil([\"Call\"]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// Bracket\n\t\t\telse if(token === \"[\") {\n\t\t\t\ttop = stack.top();\n\t\t\t\tlastToken = stack.topLastChild();\n\n\t\t\t\t// foo()[bar] => top -> root, lastToken -> {t: call, m: \"@foo\"}\n\t\t\t\t// foo()[bar()] => same as above last thing we see was a call expression \"rotate\"\n\t\t\t\t// test['foo'][0] => lastToken => {root: test, t: Bracket, c: 'foo' }\n\t\t\t\t// log(thing['prop'][0]) =>\n\t\t\t\t//\n\t\t\t\t//     top -> {Call, children|args: [Bracket(Lookup(thing), c: ['[prop]'])]}\n\t\t\t\t//     last-> Bracket(Lookup(thing), c: ['[prop]'])\n\t\t\t\tif (lastToken && (lastToken.type === \"Call\" || lastToken.type === \"Bracket\"  )  ) {\n\t\t\t\t\t// must be on top of the stack as it recieves new stuff ...\n\t\t\t\t\t// however, what we really want is to\n\t\t\t\t\tstack.replaceTopLastChildAndPush({type: \"Bracket\", root: lastToken});\n\t\t\t\t} else if (top.type === \"Lookup\" || top.type === \"Bracket\") {\n\t\t\t\t\tvar bracket = {type: \"Bracket\", root: top};\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tcanReflect.setKeyValue(bracket, canSymbol.for(\"can-stache.originalKey\"), top.key);\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tstack.replaceTopAndPush(bracket);\n\t\t\t\t} else if (top.type === \"Call\") {\n\t\t\t\t\tstack.addToAndPush([\"Call\"], { type: \"Bracket\" });\n\t\t\t\t} else if (top === \" \") {\n\t\t\t\t\tstack.popUntil([\"Lookup\", \"Call\"]);\n\t\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\"], {type: \"Bracket\"});\n\t\t\t\t} else {\n\t\t\t\t\tstack.replaceTopAndPush({type: \"Bracket\"});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// End Bracket\n\t\t\telse if(token === \"]\") {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\telse if(token === \" \") {\n\t\t\t\tstack.push(token);\n\t\t\t}\n\t\t}\n\t\treturn stack.root.children[0];\n\t}\n};\n\nmodule.exports = expression;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/src/expression.js?");

/***/ }),

/***/ "./node_modules/can-stache/src/html_section.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-stache/src/html_section.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar target = __webpack_require__(/*! can-view-target */ \"./node_modules/can-view-target/can-view-target.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/can-stache/src/utils.js\");\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\n\nvar last = utils.last;\n\nvar decodeHTML = typeof document !== \"undefined\" && (function(){\n\tvar el = getDocument().createElement('div');\n\treturn function(html){\n\t\tif(html.indexOf(\"&\") === -1) {\n\t\t\treturn html.replace(/\\r\\n/g,\"\\n\");\n\t\t}\n\t\tel.innerHTML = html;\n\t\treturn el.childNodes.length === 0 ? \"\" : el.childNodes.item(0).nodeValue;\n\t};\n})();\n// ## HTMLSectionBuilder\n//\n// Contains a stack of HTMLSections.\n// An HTMLSection is created everytime a subsection is found. For example:\n//\n//     {{#if(items)}} {{#items}} X\n//\n// At the point X was being processed, there would be 2 HTMLSections in the\n// stack.  One for the content of `{{#if(items)}}` and the other for the\n// content of `{{#items}}`\nvar HTMLSectionBuilder = function(filename){\n\tif (filename) {\n\t\tthis.filename = filename;\n\t}\n\tthis.stack = [new HTMLSection()];\n};\n\n\nassign(HTMLSectionBuilder.prototype,utils.mixins);\n\nassign(HTMLSectionBuilder.prototype,{\n\tstartSubSection: function(process){\n\t\tvar newSection = new HTMLSection(process);\n\t\tthis.stack.push(newSection);\n\t\treturn newSection;\n\t},\n\t// Ends the current section and returns a renderer.\n\t// But only returns a renderer if there is a template.\n\tendSubSectionAndReturnRenderer: function(){\n\t\tif(this.last().isEmpty()) {\n\t\t\tthis.stack.pop();\n\t\t\treturn null;\n\t\t} else {\n\t\t\tvar htmlSection = this.endSection();\n\t\t\treturn utils.makeView(htmlSection.compiled.hydrate.bind(htmlSection.compiled));\n\t\t}\n\t},\n\tstartSection: function( process, commentName ) {\n\t\tvar newSection = new HTMLSection(process);\n\t\tthis.last().add({\n\t\t\tcomment: commentName || \"#section\",\n\t\t\tcallbacks: [newSection.targetCallback]\n\t\t});\n\t\tthis.last().add({\n\t\t\tcomment: \"can-end-placeholder\"\n\t\t});\n\t\t// adding a section within a section ...\n\t\t// the stack has section ...\n\t\tthis.stack.push(newSection);\n\t},\n\tendSection: function(){\n\t\tthis.last().compile();\n\t\treturn this.stack.pop();\n\t},\n\tinverse: function(){\n\t\tthis.last().inverse();\n\t},\n\tcompile: function(){\n\t\tvar compiled = this.stack.pop().compile();\n\t\t// ignore observations here.  the render fn\n\t\t//  itself doesn't need to be observable.\n\t\treturn utils.makeView( compiled.hydrate.bind(compiled) );\n\t},\n\tpush: function(chars){\n\t\tthis.last().push(chars);\n\t},\n\tpop: function(){\n\t\treturn this.last().pop();\n\t},\n\tremoveCurrentNode: function() {\n\t\tthis.last().removeCurrentNode();\n\t}\n});\n\nvar HTMLSection = function(process){\n\tthis.data = \"targetData\";\n\tthis.targetData = [];\n\t// A record of what targetData element we are within.\n\tthis.targetStack = [];\n\tvar self = this;\n\tthis.targetCallback = function(scope){\n\t\tprocess.call(this,\n\t\t\tscope,\n\t\t\tself.compiled.hydrate.bind(self.compiled),\n\t\t\tself.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled)  ) ;\n\t};\n};\nassign(HTMLSection.prototype,{\n\tinverse: function(){\n\t\tthis.inverseData = [];\n\t\tthis.data = \"inverseData\";\n\t},\n\t// Adds a DOM node.\n\tpush: function(data){\n\t\tthis.add(data);\n\t\tthis.targetStack.push(data);\n\t},\n\tpop: function(){\n\t\treturn this.targetStack.pop();\n\t},\n\tadd: function(data){\n\t\tif(typeof data === \"string\"){\n\t\t\tdata = decodeHTML(data);\n\t\t}\n\t\tif(this.targetStack.length) {\n\t\t\tlast(this.targetStack).children.push(data);\n\t\t} else {\n\t\t\tthis[this.data].push(data);\n\t\t}\n\t},\n\tcompile: function(){\n\t\tthis.compiled = target(this.targetData, getDocument());\n\t\tif(this.inverseData) {\n\t\t\tthis.inverseCompiled = target(this.inverseData, getDocument());\n\t\t\tdelete this.inverseData;\n\t\t}\n\t\tthis.targetStack = this.targetData = null;\n\t\treturn this.compiled;\n\t},\n\tremoveCurrentNode: function() {\n\t\tvar children = this.children();\n\t\treturn children.pop();\n\t},\n\tchildren: function(){\n\t\tif(this.targetStack.length) {\n\t\t\treturn last(this.targetStack).children;\n\t\t} else {\n\t\t\treturn this[this.data];\n\t\t}\n\t},\n\t// Returns if a section is empty\n\tisEmpty: function(){\n\t\treturn !this.targetData.length;\n\t}\n});\nHTMLSectionBuilder.HTMLSection = HTMLSection;\n\nmodule.exports = HTMLSectionBuilder;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/src/html_section.js?");

/***/ }),

/***/ "./node_modules/can-stache/src/key-observable.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache/src/key-observable.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ \"./node_modules/can-simple-observable/settable/settable.js\");\nvar stacheKey = __webpack_require__(/*! can-stache-key */ \"./node_modules/can-stache-key/can-stache-key.js\");\n\n\nfunction KeyObservable(root, key){\n    key = \"\"+key;\n    this.key = key;\n    this.root = root;\n    SettableObservable.call(this, function(){\n        return stacheKey.get(this,key);\n    }, root);\n}\n\nKeyObservable.prototype = Object.create(SettableObservable.prototype);\n\nKeyObservable.prototype.set = function(newVal) {\n    stacheKey.set(this.root,this.key, newVal);\n};\n\n\nmodule.exports = KeyObservable;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/src/key-observable.js?");

/***/ }),

/***/ "./node_modules/can-stache/src/mustache_core.js":
/*!******************************************************!*\
  !*** ./node_modules/can-stache/src/mustache_core.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n//\n// This provides helper utilities for Mustache processing. Currently,\n// only stache uses these helpers.  Ideally, these utilities could be used\n// in other libraries implementing Mustache-like features.\nvar live = __webpack_require__(/*! can-view-live */ \"./node_modules/can-view-live/can-view-live.js\");\nvar liveHelpers = __webpack_require__(/*! can-view-live/lib/helpers */ \"./node_modules/can-view-live/lib/helpers.js\");\n\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/can-stache/src/utils.js\");\nvar expression = __webpack_require__(/*! ./expression */ \"./node_modules/can-stache/src/expression.js\");\nvar frag = __webpack_require__(/*! can-fragment */ \"./node_modules/can-fragment/can-fragment.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"./node_modules/can-define-lazy-value/define-lazy-value.js\");\n\nvar toDOMSymbol = canSymbol.for(\"can.toDOM\");\n\n// Lazily lookup the context only if it's needed.\nfunction HelperOptions(scope, exprData, stringOnly) {\n\tthis.metadata = { rendered: false };\n\tthis.stringOnly = stringOnly;\n\tthis.scope = scope;\n\tthis.exprData = exprData;\n}\ndefineLazyValue(HelperOptions.prototype,\"context\", function(){\n\treturn this.scope.peek(\"this\");\n});\n\n\n\n\n// ## Helpers\n\nvar mustacheLineBreakRegExp = /(?:(^|\\r?\\n)(\\s*)(\\{\\{([\\s\\S]*)\\}\\}\\}?)([^\\S\\n\\r]*)($|\\r?\\n))|(\\{\\{([\\s\\S]*)\\}\\}\\}?)/g,\n\tmustacheWhitespaceRegExp = /\\s*\\{\\{--\\}\\}\\s*|\\s*(\\{\\{\\{?)-|-(\\}\\}\\}?)\\s*/g,\n\tk = function(){};\nvar viewInsertSymbol = canSymbol.for(\"can.viewInsert\");\n\n\n// DOM, safeString or the insertSymbol can opt-out of updating as text\nfunction valueShouldBeInsertedAsHTML(value) {\n\treturn value !== null && typeof value === \"object\" && (\n\t\ttypeof value[toDOMSymbol] === \"function\" ||\n\t\ttypeof value[viewInsertSymbol] === \"function\" ||\n\t\ttypeof value.nodeType === \"number\" );\n}\n\n\n\n\nvar core = {\n\texpression: expression,\n\t// ## mustacheCore.makeEvaluator\n\t// Given a scope and expression, returns a function that evaluates that expression in the scope.\n\t//\n\t// This function first reads lookup values in the args and hash.  Then it tries to figure out\n\t// if a helper is being called or a value is being read.  Finally, depending on\n\t// if it's a helper, or not, and which mode the expression is in, it returns\n\t// a function that can quickly evaluate the expression.\n\t/**\n\t * @hide\n\t * Given a mode and expression data, returns a function that evaluates that expression.\n\t * @param {can-view-scope} The scope in which the expression is evaluated.\n\t * @param {can.view.Options} The option helpers in which the expression is evaluated.\n\t * @param {String} mode Either null, #, ^. > is handled elsewhere\n\t * @param {Object} exprData Data about what was in the mustache expression\n\t * @param {renderer} [truthyRenderer] Used to render a subsection\n\t * @param {renderer} [falseyRenderer] Used to render the inverse subsection\n\t * @param {String} [stringOnly] A flag to indicate that only strings will be returned by subsections.\n\t * @return {Function} An 'evaluator' function that evaluates the expression.\n\t */\n\tmakeEvaluator: function (scope, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {\n\n\t\tif(mode === \"^\") {\n\t\t\tvar temp = truthyRenderer;\n\t\t\ttruthyRenderer = falseyRenderer;\n\t\t\tfalseyRenderer = temp;\n\t\t}\n\n\t\tvar value,\n\t\t\thelperOptions = new HelperOptions(scope , exprData, stringOnly);\n\t\t\t// set up renderers\n\t\t\tutils.createRenderers(helperOptions, scope ,truthyRenderer, falseyRenderer, stringOnly);\n\n\t\tif(exprData instanceof expression.Call) {\n\t\t\tvalue = exprData.value(scope, helperOptions);\n\t\t} else if (exprData instanceof expression.Bracket) {\n\t\t\tvalue = exprData.value(scope);\n\t\t} else if (exprData instanceof expression.Lookup) {\n\t\t\tvalue = exprData.value(scope);\n\t\t} else if (exprData instanceof expression.Literal) {\n\t\t\tvalue = exprData.value.bind(exprData);\n\t\t} else if (exprData instanceof expression.Helper && exprData.methodExpr instanceof expression.Bracket) {\n\t\t\t// Brackets get wrapped in Helpers when used in attributes\n\t\t\t// like `<p class=\"{{ foo[bar] }}\" />`\n\t\t\tvalue = exprData.methodExpr.value(scope, helperOptions);\n\t\t} else {\n\t\t\tvalue = exprData.value(scope, helperOptions);\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\t// {{#something()}}foo{{/something}}\n\t\t// return evaluator for no mode or rendered value if a renderer was called\n\t\tif(!mode || helperOptions.metadata.rendered) {\n\t\t\treturn value;\n\t\t} else if( mode === \"#\" || mode === \"^\" ) {\n\n\t\t\treturn function(){\n\t\t\t\t// Get the value\n\t\t\t\tvar finalValue = canReflect.getValue(value);\n\t\t\t\tvar result;\n\n\t\t\t\t// if options.fn or options.inverse was called, we take the observable's return value\n\t\t\t\t// as what should be put in the DOM.\n\t\t\t\tif(helperOptions.metadata.rendered) {\n\t\t\t\t\tresult = finalValue;\n\t\t\t\t}\n\t\t\t\t// If it's an array, render.\n\t\t\t\telse if ( typeof finalValue !== \"string\" && canReflect.isListLike(finalValue) ) {\n\t\t\t\t\tvar isObserveList = canReflect.isObservableLike(finalValue) &&\n\t\t\t\t\t\tcanReflect.isListLike(finalValue);\n\n\t\t\t\t\tif(canReflect.getKeyValue(finalValue, \"length\")) {\n\t\t\t\t\t\tif (stringOnly) {\n\t\t\t\t\t\t\tresult = utils.getItemsStringContent(finalValue, isObserveList, helperOptions);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult = frag(utils.getItemsFragContent(finalValue, helperOptions, scope));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = helperOptions.inverse(scope);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = finalValue ? helperOptions.fn(finalValue || scope) : helperOptions.inverse(scope);\n\t\t\t\t}\n\t\t\t\t// We always set the rendered result back to false.\n\t\t\t\t// - Future calls might change from returning a value to calling `.fn`\n\t\t\t\t// - We are calling `.fn` and `.inverse` ourselves.\n\t\t\t\thelperOptions.metadata.rendered = false;\n\t\t\t\treturn result;\n\t\t\t};\n\t\t} else {\n\t\t\t// not supported!\n\t\t}\n\t},\n\t// ## mustacheCore.makeLiveBindingPartialRenderer\n\t// Returns a renderer function that live binds a partial.\n\t/**\n\t * @hide\n\t * Returns a renderer function that live binds a partial.\n\t * @param {String} expressionString\n\t * @param {Object} state The html state of where the expression was found.\n\t * @return {function(this:HTMLElement,can-view-scope,can.view.Options)} A renderer function\n\t * live binds a partial.\n\t */\n\tmakeLiveBindingPartialRenderer: function(expressionString, state){\n\t\texpressionString = expressionString.trim();\n\t\tvar exprData,\n\t\t\t\tpartialName = expressionString.split(/\\s+/).shift();\n\n\t\tif(partialName !== expressionString) {\n\t\t\texprData = core.expression.parse(expressionString);\n\t\t}\n\n\t\treturn function(scope){\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tscope.set('scope.filename', state.filename);\n\t\t\t\tscope.set('scope.lineNumber', state.lineNo);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tvar partialFrag = new Observation(function(){\n\t\t\t\tvar localPartialName = partialName;\n\t\t\t\tvar partialScope = scope;\n\t\t\t\t// If the second parameter of a partial is a custom context\n\t\t\t\tif(exprData && exprData.argExprs.length === 1) {\n\t\t\t\t\tvar newContext = canReflect.getValue( exprData.argExprs[0].value(scope) );\n\t\t\t\t\tif(typeof newContext === \"undefined\") {\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tdev.warn('The context ('+ exprData.argExprs[0].key +') you passed into the' +\n\t\t\t\t\t\t\t\t'partial ('+ partialName +') is not defined in the scope!');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t}else{\n\t\t\t\t\t\tpartialScope = scope.add(newContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Look up partials in templateContext first\n\t\t\t\tvar partial = canReflect.getKeyValue(partialScope.templateContext.partials, localPartialName);\n\t\t\t\tvar renderer;\n\n\t\t\t\tif (partial) {\n\t\t\t\t\trenderer = function() {\n\t\t\t\t\t\treturn partial.render ? partial.render(partialScope)\n\t\t\t\t\t\t\t: partial(partialScope);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Use can.view to get and render the partial.\n\t\t\t\telse {\n\t\t\t\t\tvar scopePartialName = partialScope.read(localPartialName, {\n\t\t\t\t\t\tisArgument: true\n\t\t\t\t\t}).value;\n\n\t\t\t\t\tif (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {\n\t\t\t\t\t\treturn frag(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tif (scopePartialName) {\n\t\t\t\t\t\tlocalPartialName = scopePartialName;\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer = function() {\n\t\t\t\t\t\tif(typeof localPartialName === \"function\"){\n\t\t\t\t\t\t\treturn localPartialName(partialScope, {});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar domRenderer = core.getTemplateById(localPartialName);\n\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\t\tif (!domRenderer) {\n\t\t\t\t\t\t\t\t\tdev.warn(\n\t\t\t\t\t\t\t\t\t\t(state.filename ? state.filename + ':' : '') +\n\t\t\t\t\t\t\t\t\t\t(state.lineNo ? state.lineNo + ': ' : '') +\n\t\t\t\t\t\t\t\t\t\t'Unable to find partial \"' + localPartialName + '\".');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\treturn domRenderer ? domRenderer(partialScope, {}) : getDocument().createDocumentFragment();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar res = ObservationRecorder.ignore(renderer)();\n\t\t\t\treturn frag(res);\n\t\t\t});\n\n\t\t\tlive.html(this, partialFrag);\n\t\t};\n\t},\n\t// ## mustacheCore.makeStringBranchRenderer\n\t// Return a renderer function that evalutes to a string and caches\n\t// the evaluator on the scope.\n\t/**\n\t * @hide\n\t * Return a renderer function that evaluates to a string.\n\t * @param {String} mode\n\t * @param {can.stache.Expression} expression\n\t * @param {Object} state The html state of where the expression was found.\n\t * @return {function(can.view.Scope,can.view.Options, can-stache.view, can.view.renderer)}\n\t */\n\tmakeStringBranchRenderer: function(mode, expressionString, state){\n\t\tvar exprData = core.expression.parse(expressionString),\n\t\t\t// Use the full mustache expression as the cache key.\n\t\t\tfullExpression = mode+expressionString;\n\n\t\t// A branching renderer takes truthy and falsey renderer.\n\t\tvar branchRenderer = function branchRenderer(scope, truthyRenderer, falseyRenderer){\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tscope.set('scope.filename', state.filename);\n\t\t\t\tscope.set('scope.lineNumber', state.lineNo);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t// Check the scope's cache if the evaluator already exists for performance.\n\t\t\tvar evaluator = scope.__cache[fullExpression];\n\t\t\tif(mode || !evaluator) {\n\t\t\t\tevaluator = makeEvaluator( scope, mode, exprData, truthyRenderer, falseyRenderer, true);\n\t\t\t\tif(!mode) {\n\t\t\t\t\tscope.__cache[fullExpression] = evaluator;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar gotObservableValue = evaluator[canSymbol.for(\"can.onValue\")],\n\t\t\t\tres;\n\n\t\t\t// Run the evaluator and return the result.\n\t\t\tif(gotObservableValue) {\n\t\t\t\tres = canReflect.getValue(evaluator);\n\t\t\t} else {\n\t\t\t\tres = evaluator();\n\t\t\t}\n\n\t\t\tif (res == null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\treturn res.nodeType === 11 ? res.textContent : \"\"+res;\n\t\t};\n\n\t\tbranchRenderer.exprData = exprData;\n\n\t\treturn branchRenderer;\n\t},\n\t// ## mustacheCore.makeLiveBindingBranchRenderer\n\t// Return a renderer function that evaluates the mustache expression and\n\t// sets up live binding if a compute with dependencies is found. Otherwise,\n\t// the element's value is set.\n\t//\n\t// This function works by creating a `can.compute` from the mustache expression.\n\t// If the compute has dependent observables, it passes the compute to `can.view.live`; otherwise,\n\t// it updates the element's property based on the compute's value.\n\t/**\n\t * @hide\n\t * Returns a renderer function that evaluates the mustache expression.\n\t * @param {String} mode\n\t * @param {can.stache.Expression} expression\n\t * @param {Object} state The html state of where the expression was found.\n\t */\n\tmakeLiveBindingBranchRenderer: function(mode, expressionString, state){\n\t\t// Pre-process the expression.\n\t\tvar exprData = core.expression.parse(expressionString);\n\n\t\t// A branching renderer takes truthy and falsey renderer.\n\t\tvar branchRenderer = function branchRenderer(scope, truthyRenderer, falseyRenderer){\n\t\t\t// If this is within a tag, make sure we only get string values.\n\t\t\tvar stringOnly = state.tag;\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tscope.set('scope.filename', state.filename);\n\t\t\t\tscope.set('scope.lineNumber', state.lineNo);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\t// Get the evaluator. This does not need to be cached (probably) because if there\n\t\t\t// an observable value, it will be handled by `can.view.live`.\n\t\t\tvar evaluator = makeEvaluator( scope, mode, exprData, truthyRenderer, falseyRenderer, stringOnly );\n\n\t\t\t// Create a compute that can not be observed by other\n\t\t\t// computes. This is important because this renderer is likely called by\n\t\t\t// parent expressions.  If this value changes, the parent expressions should\n\t\t\t// not re-evaluate. We prevent that by making sure this compute is ignored by\n\t\t\t// everyone else.\n\t\t\t//var compute = can.compute(evaluator, null, false);\n\t\t\tvar gotObservableValue = evaluator[canSymbol.for(\"can.onValue\")];\n\t\t\tvar observable;\n\t\t\tif(gotObservableValue) {\n\t\t\t\tobservable = evaluator;\n\t\t\t} else {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tObject.defineProperty(evaluator,\"name\",{\n\t\t\t\t\t\tvalue: \"{{\"+(mode || \"\")+expressionString+\"}}\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\tobservable = new Observation(evaluator,null,{isObservable: false});\n\t\t\t}\n\n\t\t\t// Bind on the computeValue to set the cached value. This helps performance\n\t\t\t// so live binding can read a cached value instead of re-calculating.\n\t\t\tcanReflect.onValue(observable, k);\n\n\t\t\tvar value = canReflect.getValue(observable);\n\n\t\t\t// If value is a function and not a Lookup ({{foo}}),\n\t\t\t// it's a helper that returned a function and should be called.\n\t\t\tif(typeof value === \"function\" && !(exprData instanceof expression.Lookup)) {\n\n\t\t\t\t// A helper function should do it's own binding.  Similar to how\n\t\t\t\t// we prevented this function's compute from being noticed by parent expressions,\n\t\t\t\t// we hide any observables read in the function by saving any observables that\n\t\t\t\t// have been read and then setting them back which overwrites any `can.__observe` calls\n\t\t\t\t// performed in value.\n\t\t\t\tObservationRecorder.ignore(value)(this);\n\n\t\t\t}\n\t\t\t// If the computeValue has observable dependencies, setup live binding.\n\t\t\telse if( canReflect.valueHasDependencies(observable) ) {\n\t\t\t\t// Depending on where the template is, setup live-binding differently.\n\t\t\t\tif(state.attr) {\n\t\t\t\t\tlive.attr(this, state.attr, observable);\n\t\t\t\t}\n\t\t\t\telse if( state.tag )  {\n\t\t\t\t\tlive.attrs( this, observable );\n\t\t\t\t}\n\t\t\t\telse if(state.text && !valueShouldBeInsertedAsHTML(value)) {\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tif(value !== null && typeof value === \"object\") {\n\t\t\t\t\t\t\tdev.warn(\"Previously, the result of \"+\n\t\t\t\t\t\t\t\texpressionString+\" in \"+state.filename+\":\"+state.lineNo+\n\t\t\t\t\t\t\t\t\", was being inserted as HTML instead of TEXT. Please use stache.safeString(obj) \"+\n\t\t\t\t\t\t\t\t\"if you would like the object to be treated as HTML.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tlive.text(this, observable);\n\t\t\t\t} else {\n\t\t\t\t\tlive.html(this, observable);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If the computeValue has no observable dependencies, just set the value on the element.\n\t\t\telse {\n\n\t\t\t\tif(state.attr) {\n\t\t\t\t\tdomMutate.setAttribute(this, state.attr, value);\n\t\t\t\t}\n\t\t\t\telse if(state.tag) {\n\t\t\t\t\tlive.attrs(this, value);\n\t\t\t\t}\n\t\t\t\telse if(state.text && !valueShouldBeInsertedAsHTML(value)) {\n\t\t\t\t\tthis.nodeValue = liveHelpers.makeString(value);\n\t\t\t\t}\n\t\t\t\telse if( value != null ){\n\t\t\t\t\tif (typeof value[viewInsertSymbol] === \"function\") {\n\t\t\t\t\t\tvar insert = value[viewInsertSymbol]({});\n\t\t\t\t\t\tthis.parentNode.replaceChild( insert, this );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.parentNode.replaceChild(frag(value, this.ownerDocument), this);\n\t\t\t\t\t\t//domMutateNode.replaceChild.call(this.parentNode, frag(value, this.ownerDocument), this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Unbind the compute.\n\t\t\tcanReflect.offValue(observable, k);\n\t\t};\n\n\t\tbranchRenderer.exprData = exprData;\n\n\t\treturn branchRenderer;\n\t},\n\t// ## mustacheCore.splitModeFromExpression\n\t// Returns the mustache mode split from the rest of the expression.\n\t/**\n\t * @hide\n\t * Returns the mustache mode split from the rest of the expression.\n\t * @param {can.stache.Expression} expression\n\t * @param {Object} state The state of HTML where the expression was found.\n\t */\n\tsplitModeFromExpression: function(expression, state){\n\t\texpression = expression.trim();\n\t\tvar mode = expression.charAt(0);\n\n\t\tif( \"#/{&^>!<\".indexOf(mode) >= 0 ) {\n\t\t\texpression =  expression.substr(1).trim();\n\t\t} else {\n\t\t\tmode = null;\n\t\t}\n\t\t// Triple braces do nothing within a tag.\n\t\tif(mode === \"{\" && state.node) {\n\t\t\tmode = null;\n\t\t}\n\t\treturn {\n\t\t\tmode: mode,\n\t\t\texpression: expression\n\t\t};\n\t},\n\t// ## mustacheCore.cleanLineEndings\n\t// Removes line breaks accoding to the mustache specification.\n\t/**\n\t * @hide\n\t * Prunes line breaks accoding to the mustache specification.\n\t * @param {String} template\n\t * @return {String}\n\t */\n\tcleanLineEndings: function(template){\n\n\t\t// Finds mustache tags with space around them or no space around them.\n\t\treturn template.replace( mustacheLineBreakRegExp,\n\t\t\tfunction(whole,\n\t\t\t\treturnBefore,\n\t\t\t\tspaceBefore,\n\t\t\t\tspecial,\n\t\t\t\texpression,\n\t\t\t\tspaceAfter,\n\t\t\t\treturnAfter,\n\t\t\t\t// A mustache magic tag that has no space around it.\n\t\t\t\tspaceLessSpecial,\n\t\t\t\tspaceLessExpression,\n\t\t\t\tmatchIndex){\n\n\t\t\t// IE 8 will provide undefined\n\t\t\tspaceAfter = (spaceAfter || \"\");\n\t\t\treturnBefore = (returnBefore || \"\");\n\t\t\tspaceBefore = (spaceBefore || \"\");\n\n\t\t\tvar modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});\n\n\t\t\t// If it's a partial or tripple stache, leave in place.\n\t\t\tif(spaceLessSpecial || \">{\".indexOf( modeAndExpression.mode) >= 0) {\n\t\t\t\treturn whole;\n\t\t\t}  else if( \"^#!/\".indexOf(  modeAndExpression.mode ) >= 0 ) {\n\t\t\t\t// Return the magic tag and a trailing linebreak if this did not\n\t\t\t\t// start a new line and there was an end line.\n\t\t\t\t// Add a normalized leading space, if there was any leading space, in case this abuts a tag name\n\t\t\t\tspaceBefore = (returnBefore + spaceBefore) && \" \";\n\t\t\t\treturn spaceBefore+special+( matchIndex !== 0 && returnAfter.length ? returnBefore+\"\\n\" :\"\");\n\n\n\t\t\t} else {\n\t\t\t\t// There is no mode, return special with spaces around it.\n\t\t\t\treturn spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+\"\\n\" : \"\");\n\t\t\t}\n\n\t\t});\n\t},\n\t// ## mustacheCore.cleanWhitespaceControl\n\t// Removes whitespace according to the whitespace control.\n\t/**\n\t * @hide\n\t * Prunes whitespace according to the whitespace control.\n\t * @param {String} template\n\t * @return {String}\n\t */\n\tcleanWhitespaceControl: function(template) {\n\t\treturn template.replace(mustacheWhitespaceRegExp, \"$1$2\");\n\t},\n\tgetTemplateById: function(){}\n};\n\n// ## Local Variable Cache\n//\n// The following creates slightly more quickly accessible references of the following\n// core functions.\nvar makeEvaluator = core.makeEvaluator,\n\tsplitModeFromExpression = core.splitModeFromExpression;\n\nmodule.exports = core;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/src/mustache_core.js?");

/***/ }),

/***/ "./node_modules/can-stache/src/set-identifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-stache/src/set-identifier.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function SetIdentifier(value){\n\tthis.value = value;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/src/set-identifier.js?");

/***/ }),

/***/ "./node_modules/can-stache/src/text_section.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-stache/src/text_section.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar live = __webpack_require__(/*! can-view-live */ \"./node_modules/can-view-live/can-view-live.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/can-stache/src/utils.js\");\n\nvar domMutate = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\n\nvar noop = function(){};\n\nvar TextSectionBuilder = function(filename){\n\tif (filename) {\n\t\tthis.filename = filename;\n\t}\n\tthis.stack = [new TextSection()];\n};\n\nassign(TextSectionBuilder.prototype,utils.mixins);\n\nassign(TextSectionBuilder.prototype,{\n\t// Adds a subsection.\n\tstartSection: function(process){\n\t\tvar subSection = new TextSection();\n\t\tthis.last().add({process: process, truthy: subSection});\n\t\tthis.stack.push(subSection);\n\t},\n\tendSection: function(){\n\t\tthis.stack.pop();\n\t},\n\tinverse: function(){\n\t\tthis.stack.pop();\n\t\tvar falseySection = new TextSection();\n\t\tthis.last().last().falsey = falseySection;\n\t\tthis.stack.push(falseySection);\n\t},\n\tcompile: function(state){\n\n\t\tvar renderer = this.stack[0].compile();\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tObject.defineProperty(renderer,\"name\",{\n\t\t\t\tvalue: \"textSectionRenderer<\"+state.tag+\".\"+state.attr+\">\"\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn function(scope){\n\t\t\tfunction textSectionRender(){\n\t\t\t\treturn renderer(scope);\n\t\t\t}\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tObject.defineProperty(textSectionRender,\"name\",{\n\t\t\t\t\tvalue: \"textSectionRender<\"+state.tag+\".\"+state.attr+\">\"\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar observation = new Observation(textSectionRender, null, {isObservable: false});\n\n\t\t\tcanReflect.onValue(observation, noop);\n\n\t\t\tvar value = canReflect.getValue(observation);\n\t\t\tif( canReflect.valueHasDependencies( observation ) ) {\n\t\t\t\tif(state.textContentOnly) {\n\t\t\t\t\tlive.text(this, observation);\n\t\t\t\t}\n\t\t\t\telse if(state.attr) {\n\t\t\t\t\tlive.attr(this, state.attr, observation);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlive.attrs(this, observation, scope);\n\t\t\t\t}\n\t\t\t\tcanReflect.offValue(observation, noop);\n\t\t\t} else {\n\t\t\t\tif(state.textContentOnly) {\n\t\t\t\t\tthis.nodeValue = value;\n\t\t\t\t}\n\t\t\t\telse if(state.attr) {\n\t\t\t\t\tdomMutate.setAttribute.call(this, state.attr, value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlive.attrs(this, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\nvar passTruthyFalsey = function(process, truthy, falsey){\n\treturn function(scope){\n\t\treturn process.call(this, scope, truthy, falsey);\n\t};\n};\n\nvar TextSection = function(){\n\tthis.values = [];\n};\n\nassign( TextSection.prototype, {\n\tadd: function(data){\n\t\tthis.values.push(data);\n\t},\n\tlast: function(){\n\t\treturn this.values[this.values.length - 1];\n\t},\n\tcompile: function(){\n\t\tvar values = this.values,\n\t\t\tlen = values.length;\n\n\t\tfor(var i = 0 ; i < len; i++) {\n\t\t\tvar value = this.values[i];\n\t\t\tif(typeof value === \"object\") {\n\t\t\t\tvalues[i] = passTruthyFalsey( value.process,\n\t\t\t\t    value.truthy && value.truthy.compile(),\n\t\t\t\t    value.falsey && value.falsey.compile());\n\t\t\t}\n\t\t}\n\n\t\treturn function(scope){\n\t\t\tvar txt = \"\",\n\t\t\t\tvalue;\n\t\t\tfor(var i = 0; i < len; i++){\n\t\t\t\tvalue = values[i];\n\t\t\t\ttxt += typeof value === \"string\" ? value : value.call(this, scope);\n\t\t\t}\n\t\t\treturn txt;\n\t\t};\n\t}\n});\n\nmodule.exports = TextSectionBuilder;\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/src/text_section.js?");

/***/ }),

/***/ "./node_modules/can-stache/src/truthy-observable.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-stache/src/truthy-observable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nmodule.exports = function(observable){\n    return new Observation(function truthyObservation(){\n        var val = canReflect.getValue(observable);\n\n        return !!val;\n    });\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/src/truthy-observable.js?");

/***/ }),

/***/ "./node_modules/can-stache/src/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/can-stache/src/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Scope = __webpack_require__(/*! can-view-scope */ \"./node_modules/can-view-scope/can-view-scope.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar observationReader = __webpack_require__(/*! can-stache-key */ \"./node_modules/can-stache-key/can-stache-key.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar KeyObservable = __webpack_require__(/*! ./key-observable */ \"./node_modules/can-stache/src/key-observable.js\");\n\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar isViewSymbol = canSymbol.for(\"can.isView\");\n\n// this creates a noop that marks that a renderer was called\n// this is for situations where a helper function calls a renderer\n// that was not provided such as\n// {{#if false}} ... {{/if}}\n// with no {{else}}\nvar createNoOpRenderer = function (metadata) {\n\treturn function noop() {\n\t\tif (metadata) {\n\t\t\tmetadata.rendered = true;\n\t\t}\n\t};\n};\n\nmodule.exports = {\n\tlast: function(arr){\n\t\treturn arr !=null && arr[arr.length-1];\n\t},\n\t// A generic empty function\n\temptyHandler: function(){},\n\t// Converts a string like \"1\" into 1. \"null\" into null, etc.\n\t// This doesn't have to do full JSON, so removing eval would be good.\n\tjsonParse: function(str){\n\t\t// if it starts with a quote, assume a string.\n\t\tif(str[0] === \"'\") {\n\t\t\treturn str.substr(1, str.length -2);\n\t\t} else if(str === \"undefined\") {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\treturn JSON.parse(str);\n\t\t}\n\t},\n\tmixins: {\n\t\tlast: function(){\n\t\t\treturn this.stack[this.stack.length - 1];\n\t\t},\n\t\tadd: function(chars){\n\t\t\tthis.last().add(chars);\n\t\t},\n\t\tsubSectionDepth: function(){\n\t\t\treturn this.stack.length - 1;\n\t\t}\n\t},\n\t// Sets .fn and .inverse on a helperOptions object and makes sure\n\t// they can reference the current scope and options.\n\tcreateRenderers: function(helperOptions, scope, truthyRenderer, falseyRenderer, isStringOnly){\n\t\thelperOptions.fn = truthyRenderer ? this.makeRendererConvertScopes(truthyRenderer, scope, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);\n\t\thelperOptions.inverse = falseyRenderer ? this.makeRendererConvertScopes(falseyRenderer, scope, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);\n\t\thelperOptions.isSection = !!(truthyRenderer || falseyRenderer);\n\t},\n\t// Returns a new renderer function that makes sure any data or helpers passed\n\t// to it are converted to a can.view.Scope and a can.view.Options.\n\tmakeRendererConvertScopes: function (renderer, parentScope, observeObservables, metadata) {\n\t\tvar convertedRenderer = function (newScope, newOptions) {\n\t\t\t// prevent binding on fn.\n\t\t\t// If a non-scope value is passed, add that to the parent scope.\n\t\t\tif (newScope !== undefined && !(newScope instanceof Scope)) {\n\t\t\t\tif (parentScope) {\n\t\t\t\t\tnewScope = parentScope.add(newScope);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewScope = new Scope(newScope || {});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (metadata) {\n\t\t\t\tmetadata.rendered = true;\n\t\t\t}\n\n\t\t\tvar result = renderer(newScope || parentScope );\n\t\t\treturn result;\n\t\t};\n\t\treturn observeObservables ? convertedRenderer :\n\t\t\tObservationRecorder.ignore(convertedRenderer);\n\t},\n\tmakeView: function(renderer){\n\t\tvar view = ObservationRecorder.ignore(function(scope){\n\t\t\tif(!(scope instanceof Scope)) {\n\t\t\t\tscope = new Scope(scope);\n\t\t\t}\n\t\t\treturn renderer(scope);\n\t\t});\n\t\tview[isViewSymbol] = true;\n\t\treturn view;\n\t},\n\t// Calls the truthy subsection for each item in a list and returning them in a string.\n\tgetItemsStringContent: function(items, isObserveList, helperOptions){\n\t\tvar txt = \"\",\n\t\t\tlen = observationReader.get(items, 'length'),\n\t\t\tisObservable = canReflect.isObservableLike(items);\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar item = isObservable ? new KeyObservable(items, i) :items[i];\n\t\t\ttxt += helperOptions.fn(item);\n\t\t}\n\t\treturn txt;\n\t},\n\t// Calls the truthy subsection for each item in a list and returns them in a document Fragment.\n\tgetItemsFragContent: function(items, helperOptions, scope) {\n\t\tvar result = [],\n\t\t\tlen = observationReader.get(items, 'length'),\n\t\t\tisObservable = canReflect.isObservableLike(items),\n\t\t\thashExprs = helperOptions.exprData && helperOptions.exprData.hashExprs,\n\t\t\thashOptions;\n\n\t\t// Check if using hash\n\t\tif (canReflect.size(hashExprs) > 0) {\n\t\t\thashOptions = {};\n\t\t\tcanReflect.eachKey(hashExprs, function (exprs, key) {\n\t\t\t\thashOptions[exprs.key] = key;\n\t\t\t});\n\t\t}\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar aliases = {};\n\n\t\t\tvar item = isObservable ? new KeyObservable(items, i) :items[i];\n\n\t\t\tif (canReflect.size(hashOptions) > 0) {\n\t\t\t\tif (hashOptions.value) {\n\t\t\t\t\taliases[hashOptions.value] = item;\n\t\t\t\t}\n\t\t\t\tif (hashOptions.index) {\n\t\t\t\t\taliases[hashOptions.index] = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult.push(helperOptions.fn(\n\t\t\t\tscope\n\t\t\t\t.add(aliases, { notContext: true })\n\t\t\t\t.add({ index: i }, { special: true })\n\t\t\t\t.add(item))\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-stache/src/utils.js?");

/***/ }),

/***/ "./node_modules/can-stream-kefir/can-stream-kefir.js":
/*!***********************************************************!*\
  !*** ./node_modules/can-stream-kefir/can-stream-kefir.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Kefir = __webpack_require__(/*! can-kefir */ \"./node_modules/can-kefir/can-kefir.js\");\nvar compute = __webpack_require__(/*! can-compute */ \"./node_modules/can-compute/can-compute.js\");\nvar canStream = __webpack_require__(/*! can-stream */ \"./node_modules/can-stream/can-stream.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar getValueDependenciesSymbol = canSymbol.for('can.getValueDependencies');\nvar getKeyDependenciesSymbol = canSymbol.for('can.getKeyDependencies');\n\nvar canStreamKefir = {};\n\n/*\n * Converts all arguments passed into a single stream and resolves the resulting\n * streams into a single stream. Assumes all arguments are computes and last\n * argument is optionally a function.\n */\ncanStreamKefir.toStream = function (compute) {\n\tvar stream = Kefir.stream(function (emitter) {\n\t\tvar changeHandler = function (ev, newVal) {\n\t\t\temitter.emit(newVal);\n\t\t};\n\n\t\tcompute.on('change', changeHandler);\n\n\t\tvar currentValue = compute();\n\t\tif(currentValue !== undefined) {\n\t\t\temitter.emit(currentValue);\n\t\t}\n\n\t\treturn function () {\n\t\t\tcompute.off('change', changeHandler);\n\t\t};\n\t});\n\n\tstream[getValueDependenciesSymbol] = function getValueDependencies() {\n\t\treturn {\n\t\t\tvalueDependencies: new Set([compute])\n\t\t};\n\t};\n\n\treturn stream;\n};\n\ncanStreamKefir.toCompute = function(makeStream, context){\n\tvar emitter,\n\t\tlastValue,\n\t\tstreamHandler,\n\t\tlastSetValue;\n\n\tvar setterStream = Kefir.stream(function (e) {\n\t\temitter = e;\n\t\tif (lastSetValue !== undefined) {\n\t\t\temitter.emit(lastSetValue);\n\t\t}\n\t});\n\tvar valueStream = makeStream.call(context, setterStream);\n\n\t// Create a compute that will bind to the resolved stream when bound\n\tvar streamCompute = compute(undefined, {\n\t\t// When the compute is read, use that last value\n\t\tget: function () {\n\t\t\treturn lastValue;\n\t\t},\n\t\tset: function (val) {\n\t\t\tif(emitter) {\n\t\t\t\temitter.emit(val);\n\t\t\t} else {\n\t\t\t\tlastSetValue = val;\n\t\t\t}\n\t\t\treturn val;\n\t\t},\n\n\t\t// When the compute is bound, bind to the resolved stream\n\t\ton: function (updated) {\n\n\t\t\t// When the stream passes a new values, save a reference to it and call\n\t\t\t// the compute's internal `updated` method (which ultimately calls `get`)\n\t\t\tstreamHandler = function (val) {\n\t\t\t\tlastValue = val;\n\t\t\t\tupdated();\n\t\t\t};\n\t\t\tvalueStream.onValue(streamHandler);\n\t\t},\n\n\t\t// When the compute is unbound, unbind from the resolved stream\n\t\toff: function () {\n\t\t\tvalueStream.offValue(streamHandler);\n\t\t}\n\t});\n\n\t// the symbol should ideally be implemented in the compute wrapper instead of\n\t// the internal instance, this should be fixed once can-compute is removed\n\tvar _compute = streamCompute.computeInstance;\n\t_compute[getKeyDependenciesSymbol] = function getKeyDependencies(key) {\n\t\tif (key === 'change') {\n\t\t\treturn {\n\t\t\t\tvalueDependencies: new Set([valueStream])\n\t\t\t};\n\t\t}\n\t};\n\n\treturn streamCompute;\n};\n\nif (!namespace.streamKefir) {\n\t/*\n\t * Exposes a simple toStream method that takes an observable and event or propname and returns a Kefir stream object\n\t */\n\tmodule.exports = namespace.streamKefir = canStream(canStreamKefir);\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/can-stream-kefir/can-stream-kefir.js?");

/***/ }),

/***/ "./node_modules/can-stream/can-stream.js":
/*!***********************************************!*\
  !*** ./node_modules/can-stream/can-stream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar compute = __webpack_require__(/*! can-compute */ \"./node_modules/can-compute/can-compute.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar toComputeFromEvent = function(observable, eventName){\n\tvar handler,\n\t\tlastSet;\n\treturn compute(undefined, {\n\t\ton: function(updated) {\n\t\t\thandler = function(ev, val) {\n\t\t\t\tlastSet = assign({\n\t\t\t\t\targs: [].slice.call(arguments, 1)\n\t\t\t\t}, ev);\n\t\t\t\tupdated();\n\t\t\t};\n\t\t\tobservable.on(eventName, handler);\n\t\t},\n\t\toff: function(updated) {\n\t\t\tobservable.off(eventName, handler);\n\t\t\tlastSet = undefined;\n\t\t},\n\t\tget: function(){\n\t\t\treturn lastSet;\n\t\t}\n\t});\n};\n\n\nvar STREAM = function(canStreamInterface) {\n\n\tvar canStream;\n\n\tvar toStreamFromProperty = function(obs, propName) {\n\t\treturn canStreamInterface.toStream(compute(obs, propName));\n\t};\n\n\tvar toStreamFromEvent = function() {\n\t\tvar obs = arguments[0];\n\t\tvar eventName, propName, lastValue, internalCompute;\n\n\n\t\tif(arguments.length === 2) {\n\t\t\t//.toStreamFromEvent(obs, event);\n\n\t\t\tinternalCompute = toComputeFromEvent(obs,  arguments[1]);\n\n\t\t\treturn canStreamInterface.toStream(internalCompute);\n\t\t} else {\n\t\t\t//.toStreamFromEvent(obs, propName, event);\n\t\t\tpropName = arguments[1];\n\t\t\teventName = arguments[2];\n\t\t\tlastValue = obs[propName];\n\n\t\t\tvar valuePropCompute = compute(obs, propName);\n\n\t\t\tvar eventHandler;\n\t\t\tvar propChangeHandler;\n\n\t\t\tinternalCompute = compute(undefined,{\n\t\t\t\ton: function(updater){\n\t\t\t\t\teventHandler = function(ev, newVal, oldVal) {\n\t\t\t\t\t\tlastValue = newVal;\n\t\t\t\t\t\tupdater(lastValue);\n\t\t\t\t\t};\n\n\t\t\t\t\tpropChangeHandler = function(ev, newVal, oldVal) {\n\t\t\t\t\t\toldVal.off(eventName, eventHandler);\n\t\t\t\t\t\tnewVal.on(eventName, eventHandler);\n\t\t\t\t\t};\n\n\t\t\t\t\tvaluePropCompute.on('change', propChangeHandler);\n\n\t\t\t\t\tvaluePropCompute().on(eventName, eventHandler);\n\t\t\t\t},\n\t\t\t\toff: function(){\n\t\t\t\t\tvaluePropCompute().off(eventName, eventHandler);\n\t\t\t\t\tvaluePropCompute.off('change', propChangeHandler);\n\t\t\t\t},\n\t\t\t\tget: function(){\n\t\t\t\t\treturn lastValue;\n\t\t\t\t},\n\t\t\t\tset: function(val){\n\t\t\t\t\tthrow new Error(\"can-stream: you can't set this type of compute\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar stream = canStreamInterface.toStream(internalCompute);\n\n\t\t\treturn stream;\n\t\t}\n\t};\n\n\t//.toStream(observable, propAndOrEvent[,event])\n\tvar toStream = function() {\n\n\t\tif(arguments.length === 1) {\n\t\t\t//we expect it to be a compute:\n\t\t\treturn canStreamInterface.toStream(arguments[0]); //toStream(compute)\n\t\t}\n\t\telse if(arguments.length > 1) {\n\t\t\tvar obs = arguments[0];\n\t\t\tvar eventNameOrPropName = arguments[1].trim();\n\n\t\t\tif(eventNameOrPropName.indexOf(\" \") === -1) {\n\t\t\t\t//no space found (so addressing the first three)\n\t\t\t\tif(eventNameOrPropName.indexOf(\".\") === 0) {\n\t\t\t\t\t//starts with a dot\n\t\t\t\t\treturn canStream.toStreamFromProperty(obs, eventNameOrPropName.slice(1)); //toStream(obj, \"tasks\")\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn canStream.toStreamFromEvent(obs, eventNameOrPropName); //toStream( obj, \"close\")\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar splitEventNameAndProperty = eventNameOrPropName.split(\" \");\n\t\t\t\treturn canStream.toStreamFromEvent(obs, splitEventNameAndProperty[0].slice(1), splitEventNameAndProperty[1]);  //toStream(obj, \"tasks add\")\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t};\n\n\tvar toCompute = function(makeStream, context) {\n\t\tvar args = canReflect.toArray(arguments);\n\t\treturn canStreamInterface.toCompute.apply(this, args);\n\t};\n\n\tcanStream = toStream;\n\tcanStream.toStream = canStream;\n\tcanStream.toStreamFromProperty = toStreamFromProperty;\n\tcanStream.toStreamFromEvent = toStreamFromEvent;\n\tcanStream.toCompute = toCompute;\n\n\treturn canStream;\n};\nSTREAM.toComputeFromEvent = toComputeFromEvent;\n\nmodule.exports = namespace.stream = STREAM;\n\n\n//# sourceURL=webpack:///./node_modules/can-stream/can-stream.js?");

/***/ }),

/***/ "./node_modules/can-string-to-any/can-string-to-any.js":
/*!*************************************************************!*\
  !*** ./node_modules/can-string-to-any/can-string-to-any.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function(str){\n\tswitch(str) {\n\t\tcase \"NaN\":\n\t\tcase \"Infinity\":\n\t\t\treturn +str;\n\t\tcase \"null\":\n\t\t\treturn null;\n\t\tcase \"undefined\":\n\t\t\treturn undefined;\n\t\tcase \"true\":\n\t\tcase \"false\":\n\t\t\treturn str === \"true\";\n\t\tdefault:\n\t\t\tvar val = +str;\n\t\t\tif(!isNaN(val)) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn str;\n\t\t\t}\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-string-to-any/can-string-to-any.js?");

/***/ }),

/***/ "./node_modules/can-string/can-string.js":
/*!***********************************************!*\
  !*** ./node_modules/can-string/can-string.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ##string.js\n// _Miscellaneous string utility functions._\n// Several of the methods in this plugin use code adapted from Prototype\n// Prototype JavaScript framework, version 1.6.0.1.\n// Â© 2005-2007 Sam Stephenson\nvar strUndHash = /_|-/,\n\tstrColons = /\\=\\=/,\n\tstrWords = /([A-Z]+)([A-Z][a-z])/g,\n\tstrLowUp = /([a-z\\d])([A-Z])/g,\n\tstrDash = /([a-z\\d])([A-Z])/g,\n\tstrQuote = /\"/g,\n\tstrSingleQuote = /'/g,\n\tstrHyphenMatch = /-+(.)?/g,\n\tstrCamelMatch = /[a-z][A-Z]/g,\n\tconvertBadValues = function (content) {\n\t\t// Convert bad values into empty strings\n\t\tvar isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';\n\t\treturn '' + (isInvalid ? '' : content);\n\t};\n\nvar string = {\n\t/**\n\t * @function can-string.esc esc\n\t * @signature `string.esc(content)`\n\t * @param  {String} content a string\n\t * @return {String}         the string safely HTML-escaped\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * string.esc(\"<div>&nbsp;</div>\"); //-> \"&lt;div&gt;&amp;nbsp;&lt;/div&gt;\"\n\t * ```\n\t */\n\tesc: function (content) {\n\t\treturn convertBadValues(content)\n\t\t\t.replace(/&/g, '&amp;')\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t.replace(strQuote, '&#34;')\n\t\t\t.replace(strSingleQuote, '&#39;');\n\t},\n\t/**\n\t * @function can-string.capitalize capitalize\n\t * @signature `string.capitalize(s)`\n\t * @param  {String} s     the string to capitalize\n\t * @return {String}       the supplied string with the first character uppercased if it is a letter\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.capitalize(\"foo\")); // -> \"Foo\"\n\t * console.log(string.capitalize(\"123\")); // -> \"123\"\n\t * ```\n\t */\n\tcapitalize: function (s) {\n\t\t// Used to make newId.\n\t\treturn s.charAt(0)\n\t\t\t.toUpperCase() + s.slice(1);\n\t},\n\t/**\n\t * @function can-string.camelize camelize\n\t * @signature `string.camelize(s)`\n\t * @param  {String} str   the string to camelCase\n\t * @return {String}       the supplied string with hyphens removed and following letters capitalized.\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\n\t * console.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n\t * ```\n\t */\n\tcamelize: function (str) {\n\t\treturn convertBadValues(str)\n\t\t\t.replace(strHyphenMatch, function (match, chr) {\n\t\t\t\treturn chr ? chr.toUpperCase() : '';\n\t\t\t});\n\t},\n\t/**\n\t * @function can-string.hyphenate hyphenate\n\t * @signature `string.hyphenate(s)`\n\t * @param  {String} str   a string in camelCase\n\t * @return {String}       the supplied string with camelCase converted to hyphen-lowercase digraphs\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\n\t * console.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n\t * ```\n\t */\n\thyphenate: function (str) {\n\t\treturn convertBadValues(str)\n\t\t\t.replace(strCamelMatch, function (str) {\n\t\t\t\treturn str.charAt(0) + '-' + str.charAt(1)\n\t\t\t\t\t.toLowerCase();\n\t\t\t});\n\t},\n\t/**\n\t * @function can-string.pascalize pascalize\n\t * @signature `string.pascalize(s)`\n\t * @param  {String} str   the string in hyphen case | camelCase\n\t * @return {String}       the supplied string with hyphens | camelCase converted to PascalCase\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.pascalize(\"fooBar\")); // -> \"FooBar\"\n\t * console.log(string.pascalize(\"baz-bar\")); // -> \"BazBar\"\n\t * ```\n\t */\n\tpascalize: function (str) {\n\t\treturn string.capitalize(string.camelize(str));\n\t},\n\t/**\n\t * @function can-string.underscore underscore\n\t * @signature `string.underscore(s)`\n\t * @param  {String} str   a string in camelCase\n\t * @return {String}       the supplied string with camelCase converted to underscore-lowercase digraphs\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\n\t * console.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n\t * ```\n\t */\n\tunderscore: function (s) {\n\t\treturn s.replace(strColons, '/')\n\t\t\t.replace(strWords, '$1_$2')\n\t\t\t.replace(strLowUp, '$1_$2')\n\t\t\t.replace(strDash, '_')\n\t\t\t.toLowerCase();\n\t},\n\t/**\n\t * @property {RegExp} can-string.strUndHash strUndHash\n\t *\n\t * A regex which matches an underscore or hyphen character\n\t */\n\tundHash: strUndHash\n};\nmodule.exports = string;\n\n\n//# sourceURL=webpack:///./node_modules/can-string/can-string.js?");

/***/ }),

/***/ "./node_modules/can-super-model/can-super-model.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-super-model/can-super-model.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var connect = __webpack_require__(/*! can-connect */ \"./node_modules/can-connect/can-connect.js\");\n\nvar connectConstructor = __webpack_require__(/*! can-connect/constructor/constructor */ \"./node_modules/can-connect/constructor/constructor.js\");\nvar canMap = __webpack_require__(/*! can-connect/can/map/map */ \"./node_modules/can-connect/can/map/map.js\");\nvar canRef = __webpack_require__(/*! can-connect/can/ref/ref */ \"./node_modules/can-connect/can/ref/ref.js\");\nvar constructorStore = __webpack_require__(/*! can-connect/constructor/store/store */ \"./node_modules/can-connect/constructor/store/store.js\");\nvar dataCallbacks = __webpack_require__(/*! can-connect/data/callbacks/callbacks */ \"./node_modules/can-connect/data/callbacks/callbacks.js\");\nvar callbacksCache = __webpack_require__(/*! can-connect/data/callbacks-cache/callbacks-cache */ \"./node_modules/can-connect/data/callbacks-cache/callbacks-cache.js\");\nvar combineRequests = __webpack_require__(/*! can-connect/data/combine-requests/combine-requests */ \"./node_modules/can-connect/data/combine-requests/combine-requests.js\");\nvar localCache = __webpack_require__(/*! can-connect/data/localstorage-cache/localstorage-cache */ \"./node_modules/can-connect/data/localstorage-cache/localstorage-cache.js\");\nvar dataParse = __webpack_require__(/*! can-connect/data/parse/parse */ \"./node_modules/can-connect/data/parse/parse.js\");\nvar dataUrl = __webpack_require__(/*! can-connect/data/url/url */ \"./node_modules/can-connect/data/url/url.js\");\nvar fallThroughCache = __webpack_require__(/*! can-connect/fall-through-cache/fall-through-cache */ \"./node_modules/can-connect/fall-through-cache/fall-through-cache.js\");\nvar realTime = __webpack_require__(/*! can-connect/real-time/real-time */ \"./node_modules/can-connect/real-time/real-time.js\");\nvar callbacksOnce = __webpack_require__(/*! can-connect/constructor/callbacks-once/callbacks-once */ \"./node_modules/can-connect/constructor/callbacks-once/callbacks-once.js\");\nvar DefineList = __webpack_require__(/*! can-define/list/list */ \"./node_modules/can-define/list/list.js\");\nvar DefineMap = __webpack_require__(/*! can-define/map/map */ \"./node_modules/can-define/map/map.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar QueryLogic = __webpack_require__(/*! can-query-logic */ \"./node_modules/can-query-logic/can-query-logic.js\");\n\nfunction superModel(optionsOrUrl) {\n\n\t// If optionsOrUrl is a string, make options = {url: optionsOrUrl}\n\tvar options = (typeof optionsOrUrl === \"string\") ? {url: optionsOrUrl} : optionsOrUrl;\n\n\t// If options.Map or .List arenâ€™t provided, define them\n\tif (typeof options.Map === \"undefined\") {\n\t\toptions.Map = DefineMap.extend({seal: false}, {});\n\t}\n\tif (typeof options.List === \"undefined\") {\n\t\toptions.List = options.Map.List || DefineList.extend({\"#\": options.Map});\n\t}\n\n    options = canReflect.assignDeep({},options);\n\n    if(!options.name) {\n        options.name = canReflect.getName(options.Map)+\".connection\";\n    }\n    if(!options.queryLogic) {\n        options.queryLogic = new QueryLogic(options.Map);\n    }\n\n\tvar behaviors = [\n\t\tconnectConstructor,\n\t\tcanMap,\n\t\tcanRef,\n\t\tconstructorStore,\n\t\tdataCallbacks,\n\t\tcombineRequests,\n\t\tdataParse,\n\t\tdataUrl,\n\t\trealTime,\n\t\tcallbacksOnce];\n\n\tif(typeof localStorage !== \"undefined\") {\n\t\tif(!options.cacheConnection) {\n\t\t\toptions.cacheConnection = connect([localCache],{\n\t\t\t\tname: options.name+\".cacheConnection\",\n\t\t\t\tidProp: options.idProp,\n\t\t\t\tqueryLogic: options.queryLogic\n\t\t\t});\n\t\t}\n\t\tbehaviors.push(callbacksCache,fallThroughCache);\n\t}\n\treturn connect(behaviors,options);\n}\n\nmodule.exports = namespace.superModel = superModel;\n\n\n//# sourceURL=webpack:///./node_modules/can-super-model/can-super-model.js?");

/***/ }),

/***/ "./node_modules/can-symbol/can-symbol.js":
/*!***********************************************!*\
  !*** ./node_modules/can-symbol/can-symbol.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar supportsNativeSymbols = (function() {\n\tvar symbolExists = typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\";\n\n\tif (!symbolExists) {\n\t\treturn false;\n\t}\n\n\tvar symbol = Symbol(\"a symbol for testing symbols\");\n\treturn typeof symbol === \"symbol\";\n}());\n\nvar CanSymbol;\nif(supportsNativeSymbols) {\n\tCanSymbol = Symbol;\n} else {\n\n\tvar symbolNum = 0;\n\tCanSymbol = function CanSymbolPolyfill(description){\n\t\tvar symbolValue = \"@@symbol\"+(symbolNum++)+(description);\n\n\t\tvar symbol = {}; // make it object type\n\n\t\tObject.defineProperties(symbol, {\n\t\t\ttoString: {\n\t\t\t\tvalue: function(){\n\t\t\t\t\treturn symbolValue;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn symbol;\n\t};\n\n\tvar descriptionToSymbol = {};\n\tvar symbolToDescription = {};\n\n\t/**\n\t * @function can-symbol.for for\n\t * @parent  can-symbol/methods\n\t * @description  Get a symbol based on a known string identifier, or create it if it doesn't exist.\n\t *\n\t * @signature `canSymbol.for(String)`\n\t *\n\t * @param { String } description  The string value of the symbol\n\t * @return { CanSymbol } The globally unique and consistent symbol with the given string value.\n\t */\n\tCanSymbol.for = function(description){\n\t\tvar symbol = descriptionToSymbol[description];\n\t\tif(!symbol) {\n\t\t\tsymbol = descriptionToSymbol[description] = CanSymbol(description);\n\t\t\tsymbolToDescription[symbol] = description;\n\t\t}\n\t\treturn symbol;\n\t};\n\t/**\n\t * @function can-symbol.keyFor keyFor\n\t * @parent  can-symbol\n\t * @description  Get the description for a symbol.\n\t *\n\t * @signature `canSymbol.keyFor(CanSymbol)`\n\t *\n\t * @param { String } description  The string value of the symbol\n\t * @return { CanSymbol } The globally unique and consistent symbol with the given string value.\n\t */\n\tCanSymbol.keyFor = function(symbol) {\n\t\treturn symbolToDescription[symbol];\n\t};\n\t[\"hasInstance\",\"isConcatSpreadable\",\n\t\t\"iterator\",\"match\",\"prototype\",\"replace\",\"search\",\"species\",\"split\",\n\t\"toPrimitive\",\"toStringTag\",\"unscopables\"].forEach(function(name){\n\t\tCanSymbol[name] = CanSymbol(\"Symbol.\"+name);\n\t});\n}\n\n// Generate can. symbols.\n[\n\t// ======= Type detection ==========\n\t\"isMapLike\",\n\t\"isListLike\",\n\t\"isValueLike\",\n\t\"isFunctionLike\",\n\t// ======= Shape detection =========\n\t\"getOwnKeys\",\n\t\"getOwnKeyDescriptor\",\n\t\"proto\",\n\t// optional\n\t\"getOwnEnumerableKeys\",\n\t\"hasOwnKey\",\n\t\"hasKey\",\n\t\"size\",\n\t\"getName\",\n\t\"getIdentity\",\n\n\t// shape manipulation\n\t\"assignDeep\",\n\t\"updateDeep\",\n\n\t// ======= GET / SET\n\t\"getValue\",\n\t\"setValue\",\n\t\"getKeyValue\",\n\t\"setKeyValue\",\n\t\"updateValues\",\n\t\"addValue\",\n\t\"removeValues\",\n\t// ======= Call =========\n\t\"apply\",\n\t\"new\",\n\t// ======= Observe =========\n\t\"onValue\",\n\t\"offValue\",\n\t\"onKeyValue\",\n\t\"offKeyValue\",\n\t\"getKeyDependencies\",\n\t\"getValueDependencies\",\n\t\"keyHasDependencies\",\n\t\"valueHasDependencies\",\n\t\"onKeys\",\n\t\"onKeysAdded\",\n\t\"onKeysRemoved\",\n\t\"onPatches\"\n\t].forEach(function(name){\n\tCanSymbol.for(\"can.\"+name);\n});\n\nmodule.exports = namespace.Symbol = CanSymbol;\n\n\n//# sourceURL=webpack:///./node_modules/can-symbol/can-symbol.js?");

/***/ }),

/***/ "./node_modules/can-type/can-type.js":
/*!*******************************************!*\
  !*** ./node_modules/can-type/can-type.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canString = __webpack_require__(/*! can-string */ \"./node_modules/can-string/can-string.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n\nvar isMemberSymbol = canSymbol.for(\"can.isMember\");\nvar newSymbol = canSymbol.for(\"can.new\");\nvar getSchemaSymbol = canSymbol.for(\"can.getSchema\");\nvar baseTypeSymbol = canSymbol.for(\"can.baseType\");\nvar strictTypeOfSymbol = canSymbol.for(\"can.strictTypeOf\");\n\nvar type = exports;\n\nfunction makeSchema(values) {\n\treturn function(){\n\t\treturn {\n\t\t\ttype: \"Or\",\n\t\t\tvalues: values\n\t\t};\n\t};\n}\n\n// Default \"can.new\"\nfunction canNew(value) {\n\tif(this[isMemberSymbol](value)) {\n\t\treturn value;\n\t}\n\n\treturn canReflect.convert(value, this[baseTypeSymbol]);\n}\n\nfunction strictNew(value) {\n\tvar isMember = this[isMemberSymbol](value);\n\tif(!isMember) {\n\t\treturn check(this[baseTypeSymbol], value);\n\t}\n\treturn value;\n}\n\n// \"can.new\" for Booleans\nfunction booleanNew(value) {\n\tif (value === \"false\" || value=== \"0\") {\n\t\treturn false;\n\t}\n\treturn Boolean(value);\n}\n\nvar maybeValues = Object.freeze([null, undefined]);\n\nfunction check(Type, val) {\n\tvar valueType = canString.capitalize(typeof val);\n\tvar error = new Error('Type value ' + typeof val === \"string\" ? '\"' + val + '\"' : val + ' (' + valueType + ') is not of type ' + canReflect.getName(Type) + '.'\t);\n\terror.type = 'can-type-error';\n\tthrow error;\n}\n\nfunction makeIsMember(Type) {\n\tif(isMemberSymbol in Type) {\n\t\treturn Type[isMemberSymbol];\n\t}\n\treturn function(value) {\n\t\treturn value instanceof Type;\n\t};\n}\n\nfunction makeBaseType(Type) {\n\tvar typeObject = {};\n\ttypeObject[newSymbol] = canNew;\n\ttypeObject[isMemberSymbol] = makeIsMember(Type);\n\ttypeObject[baseTypeSymbol] = Type;\n\ttypeObject[getSchemaSymbol] = makeSchema([Type]);\n\tType[strictTypeOfSymbol] = typeObject[strictTypeOfSymbol] = typeObject;\n\treturn typeObject;\n}\n\nfunction makePrimitiveType(Type, typeString) {\n\tvar typeObject = makeBaseType(Type);\n\tif(Type === Boolean) {\n\t\ttypeObject[newSymbol] = booleanNew;\n\t\ttypeObject[getSchemaSymbol] = makeSchema([true, false]);\n\t}\n\ttypeObject[isMemberSymbol] = function(value) {\n\t\treturn typeof value === typeString;\n\t};\n\treturn typeObject;\n}\n\nfunction getBaseType(Type) {\n\tif(typeof Type === \"function\") {\n\t\tif(canReflect.hasOwnKey(Type, strictTypeOfSymbol)) {\n\t\t\treturn Type[strictTypeOfSymbol];\n\t\t}\n\t} else if(strictTypeOfSymbol in Type) {\n\t\treturn Type[strictTypeOfSymbol];\n\t}\n\treturn makeBaseType(Type);\n}\n\nfunction makeMaybe(Type) {\n\tvar isMember = Type[isMemberSymbol];\n\treturn function(value) {\n\t\treturn value == null || isMember.call(this, value);\n\t};\n}\n\nfunction makeMaybeSchema(baseType) {\n\tvar baseSchema = canReflect.getSchema(baseType);\n\tvar allValues = baseSchema.values.concat(maybeValues);\n\treturn makeSchema(allValues);\n}\n\nfunction inheritFrom(o, Type, property) {\n\tif(property in Type) {\n\t\to[property] = Type[property];\n\t}\n}\n\nfunction wrapName(wrapper, Type) {\n\tvar baseName = canReflect.getName(Type);\n\treturn \"type.\" + wrapper + \"(\" + baseName + \")\";\n}\n\ncanReflect.each({\n\t\"boolean\": Boolean,\n\t\"number\": Number,\n\t\"string\": String\n}, function(Type, typeString) {\n\tmakePrimitiveType(Type, typeString);\n});\n\nfunction isTypeObject(Type) {\n\tif(canReflect.isPrimitive(Type)) {\n\t\treturn false;\n\t}\n\n\treturn (newSymbol in Type) && (isMemberSymbol in Type);\n}\n\nfunction normalize(Type) {\n\tif(canReflect.isPrimitive(Type)) {\n\t\tthrow new Error(\"can-type: Unable to normalize primitive values.\");\n\t} else if(isTypeObject(Type)) {\n\t\treturn Type;\n\t} else {\n\t\treturn type.check(Type);\n\t}\n}\n\nfunction late(fn) {\n\tvar lateType = {};\n\tvar underlyingType;\n\tvar unwrap = function() {\n\t\tunderlyingType = type.normalize(fn());\n\t\tunwrap = function() { return underlyingType; };\n\t\treturn underlyingType;\n\t};\n\treturn canReflect.assignSymbols(lateType, {\n\t\t\"can.new\": function(val) {\n\t\t\treturn canReflect.new(unwrap(), val);\n\t\t},\n\t\t\"can.isMember\": function(val) {\n\t\t\treturn unwrap()[isMemberSymbol](val);\n\t\t}\n\t});\n}\n\nvar Any = canReflect.assignSymbols({}, {\n\t\"can.new\": function(val) { return val; },\n\t\"can.isMember\": function() { return true; }\n});\n\nfunction all(typeFn, Type) {\n\tvar typeObject = typeFn(Type);\n\ttypeObject[getSchemaSymbol] = function() {\n\t\tvar parentSchema = canReflect.getSchema(Type);\n\t\tvar schema = canReflect.assignMap({}, parentSchema);\n\t\tschema.keys = {};\n\t\tcanReflect.eachKey(parentSchema.keys, function(value, key) {\n\t\t\tschema.keys[key] = typeFn(value);\n\t\t});\n\t\treturn schema;\n\t};\n\n\tfunction Constructor(values) {\n\t\tvar schema = canReflect.getSchema(this);\n\t\tvar keys = schema.keys;\n\t\tvar convertedValues = {};\n\t\tcanReflect.eachKey(values || {}, function(value, key) {\n\t\t\tconvertedValues[key] = canReflect.convert(value, keys[key]);\n\t\t});\n\t\treturn canReflect.new(Type, convertedValues);\n\t}\n\n\tcanReflect.setName(Constructor, \"Converted<\" + canReflect.getName(Type) + \">\");\n\tConstructor.prototype = typeObject;\n\n\treturn Constructor;\n}\n\nvar Integer = {};\nInteger[newSymbol] = function(value) {\n\t// parseInt(notANumber) returns NaN\n\t// Since we always want an integer returned\n\t// using |0 instead.\n\treturn value | 0;\n};\nInteger[isMemberSymbol] = function(value) {\n\t// â€œpolyfillâ€ for Number.isInteger because itâ€™s not supported in IE11\n\treturn typeof value === \"number\" && isFinite(value) &&\n\t\tMath.floor(value) === value;\n};\nInteger[getSchemaSymbol] = makeSchema([Number]);\ncanReflect.setName(Integer, \"Integer\");\n\nfunction makeCache(fn) {\n\tvar cache = new WeakMap();\n\treturn function(Type) {\n\t\tif(cache.has(Type)) {\n\t\t\treturn cache.get(Type);\n\t\t}\n\t\tvar typeObject = fn.call(this, Type);\n\t\tcache.set(Type, typeObject);\n\t\treturn typeObject;\n\t};\n}\n\nexports.check = makeCache(function(Type) {\n\tvar o = Object.create(getBaseType(Type));\n\to[newSymbol] = strictNew;\n\tinheritFrom(o, Type, isMemberSymbol);\n\tinheritFrom(o, Type, getSchemaSymbol);\n\tcanReflect.setName(o, wrapName(\"check\", Type));\n\treturn o;\n});\n\nexports.convert = makeCache(function(Type) {\n\tvar o = Object.create(getBaseType(Type));\n\tinheritFrom(o, Type, isMemberSymbol);\n\tinheritFrom(o, Type, getSchemaSymbol);\n\tcanReflect.setName(o, wrapName(\"convert\", Type));\n\treturn o;\n});\n\nexports.maybe = makeCache(function(Type) {\n\tvar baseType = getBaseType(Type);\n\tvar desc = {};\n\tdesc[newSymbol] = {\n\t\tvalue: strictNew\n\t};\n\tdesc[isMemberSymbol] = {\n\t\tvalue: makeMaybe(baseType)\n\t};\n\tdesc[getSchemaSymbol] = {\n\t\tvalue: makeMaybeSchema(baseType)\n\t};\n\tvar o = Object.create(baseType, desc);\n\tcanReflect.setName(o, wrapName(\"maybe\", Type));\n\treturn o;\n});\n\nexports.maybeConvert = makeCache(function(Type) {\n\tvar baseType = getBaseType(Type);\n\tvar desc = {};\n\tdesc[isMemberSymbol] = {\n\t\tvalue: makeMaybe(baseType)\n\t};\n\tdesc[getSchemaSymbol] = {\n\t\tvalue: makeMaybeSchema(baseType)\n\t};\n\tvar o = Object.create(baseType, desc);\n\tcanReflect.setName(o, wrapName(\"maybeConvert\", Type));\n\treturn o;\n});\n\n//!steal-remove-start\n// type checking should not throw in production\nif(false) {}\n//!steal-remove-end\n\nexports.Any = Any;\nexports.Integer = Integer;\n\nexports.late = late;\nexports.isTypeObject = isTypeObject;\nexports.normalize = normalize;\nexports.all = all;\nexports.convertAll = all.bind(null, exports.convert);\nnamespace.type = exports;\n\n\n//# sourceURL=webpack:///./node_modules/can-type/can-type.js?");

/***/ }),

/***/ "./node_modules/can-types/can-types.js":
/*!*********************************************!*\
  !*** ./node_modules/can-types/can-types.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\n/**\n * @module {Object} can-types\n * @parent can-typed-data\n * @collection can-infrastructure\n * @package ./package.json\n * @description A stateful container for CanJS type information.\n *\n * @body\n *\n * ## Use\n *\n * `can-types` exports an object with placeholder functions that\n * can be used to provide default types or test if something is of a certain type.\n *\n * For example, `can-define/map/map` might overwrite `DefeaultMap` to return DefineMap\n *\n * ```js\n * types.DefaultMap = DefineMap;\n * ```\n */\n\nvar types = {\n\tisMapLike: function(obj){\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.warn('can-types.isMapLike(obj) is deprecated, please use `canReflect.isObservableLike(obj) && canReflect.isMapLike(obj)` instead.');\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn canReflect.isObservableLike(obj) && canReflect.isMapLike(obj);\n\t},\n\n\tisListLike: function(obj){\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.warn('can-types.isListLike(obj) is deprecated, please use `canReflect.isObservableLike(obj) && canReflect.isListLike(obj)` instead.');\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn canReflect.isObservableLike(obj) && canReflect.isListLike(obj);\n\t},\n\n\tisPromise: function(obj){\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.warn('can-types.isPromise is deprecated, please use canReflect.isPromise instead.');\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn canReflect.isPromise(obj);\n\t},\n\n\tisConstructor: function(func){\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.warn('can-types.isConstructor is deprecated, please use canReflect.isConstructorLike instead.');\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn canReflect.isConstructorLike(func);\n\t},\n\n\tisCallableForValue: function(obj){\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.warn('can-types.isCallableForValue(obj) is deprecated, please use `canReflect.isFunctionLike(obj) && !canReflect.isConstructorLike(obj)` instead.');\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn obj && canReflect.isFunctionLike(obj) && !canReflect.isConstructorLike(obj);\n\t},\n\n\tisCompute: function(obj){\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.warn('can-types.isCompute is deprecated.');\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn obj && obj.isComputed;\n\t},\n\n\tget iterator() {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.warn('can-types.iterator is deprecated, use `canSymbol.iterator || canSymbol.for(\"iterator\")` instead.');\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn canSymbol.iterator || canSymbol.for(\"iterator\");\n\t},\n\t/**\n\t * @property {Map} can-types.DefaultMap DefaultMap\n\t *\n\t * @option {Map}\n\t *\n\t *   The default map type to create if a map is needed.  If both [can-map] and [can-define/map/map]\n\t *   are imported, the default type will be [can-define/map/map].\n\t */\n\tDefaultMap: null,\n\t/**\n\t * @property {can-connect.List} can-types.DefaultList DefaultList\n\t *\n\t * @option {can-connect.List}\n\t *\n\t *   The default list type to create if a list is needed. If both [can-list] and [can-define/list/list]\n\t *   are imported, the default type will be [can-define/list/list].\n\t */\n\tDefaultList: null,\n\t/**\n\t * @function can-types.queueTask queueTask\n\t * @signature `types.queueTask(task)`\n\t *   Run code that will be queued at the end of the current batch.\n\t *   @param {Array} task\n\t */\n\tqueueTask: function(task){\n\t\tvar args = task[2] || [];\n\t\ttask[0].apply(task[1], args);\n\t},\n\t/**\n\t * @function can-types.wrapElement wrapElement\n\t * @signature `types.wrapElement(element)`\n\t *   Wraps an element into an object useful by DOM libraries ala jQuery.\n\t *\n\t *   @param {Node} element Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node).\n\t *   @return {{}} A wrapped object.\n\t */\n\twrapElement: function(element){\n\t\treturn element;\n\t},\n\t/**\n\t * @function can-types.unwrapElement unwrapElement\n\t * @signature `types.unwrapElement(object)`\n\t *   Unwraps an object that contains an element within.\n\t *\n\t *   @param {{}} object Any object that can be unwrapped into a Node.\n\t *   @return {Node} A Node.\n\t */\n\tunwrapElement: function(element){\n\t\treturn element;\n\t}\n};\n\nif (namespace.types) {\n\tthrow new Error(\"You can't have two versions of can-types, check your dependencies\");\n} else {\n\tmodule.exports = namespace.types = types;\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-types/can-types.js?");

/***/ }),

/***/ "./node_modules/can-validate-interface/index.js":
/*!******************************************************!*\
  !*** ./node_modules/can-validate-interface/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction flatten(arrays) {\n\treturn arrays.reduce(function(ret, val) {\n\t\treturn ret.concat(val);\n\t}, []);\n}\n\n// return a function that validates it's argument has all the properties in the interfacePropArrays\nfunction makeInterfaceValidator(interfacePropArrays) {\n\tvar props = flatten(interfacePropArrays);\n\n\treturn function(base) {\n\t\t\tvar missingProps = props.reduce(function(missing, prop) {\n\t\t\t\treturn prop in base ? missing : missing.concat(prop);\n\t\t\t}, []);\n\n\t\treturn missingProps.length ? {message:\"missing expected properties\", related: missingProps} : undefined;\n\t};\n}\n\nmodule.exports = makeInterfaceValidator;\n\n\n//# sourceURL=webpack:///./node_modules/can-validate-interface/index.js?");

/***/ }),

/***/ "./node_modules/can-validate-validatejs/can-validate-validatejs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/can-validate-validatejs/can-validate-validatejs.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar validatejs = __webpack_require__(/*! validate.js */ \"./node_modules/validate.js/validate.js\");\n\nvar makeValidator = function(constraints) {\n\treturn function(value) {\n\t\t// Returns an array or undefined\n\t\treturn validatejs.single(value, constraints);\n\t};\n};\n\nmakeValidator.many = function(constraints) {\n\treturn function(values) {\n\t\tvar rawErrors = validatejs(values, constraints, {\n\t\t\tformat: \"detailed\",\n\t\t\tfullMessages: false\n\t\t});\n\t\tvar errors;\n\n\t\tif (rawErrors) {\n\t\t\terrors = [];\n\t\t\tcanReflect.eachIndex(rawErrors, function(error) {\n\t\t\t\terrors.push({\n\t\t\t\t\tmessage: error.options.message || error.error,\n\t\t\t\t\trelated: [error.attribute]\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn errors;\n\t};\n};\n\nmakeValidator.validatejs = validatejs;\n\nmodule.exports = makeValidator;\n\n\n//# sourceURL=webpack:///./node_modules/can-validate-validatejs/can-validate-validatejs.js?");

/***/ }),

/***/ "./node_modules/can-validate/can-validate.js":
/*!***************************************************!*\
  !*** ./node_modules/can-validate/can-validate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar validate = {};\n\nvar helpers = {\n\t'object': function (normalizedErrors) {\n\t\tvar errors = normalizedErrors.length > 0 ? {}: undefined;\n\n\t\tcanReflect.eachIndex(normalizedErrors, function (error) {\n\t\t\tcanReflect.eachIndex(error.related, function (related) {\n\t\t\t\tif (!errors[related]) {\n\t\t\t\t\terrors[related] = [];\n\t\t\t\t}\n\t\t\t\terrors[related].push(error.message);\n\t\t\t});\n\t\t});\n\t\treturn errors;\n\t},\n\t'flat': function (normalizedErrors) {\n\t\tvar errors = normalizedErrors.length > 0 ? []: undefined;\n\t\tcanReflect.eachIndex(normalizedErrors, function (error) {\n\t\t\terrors.push(error.message);\n\t\t});\n\t\treturn errors;\n\t},\n\t'errors': function (normalizedErrors) {\n\t\treturn normalizedErrors.length > 0 ? normalizedErrors: undefined;\n\t},\n\t'errors-object': function (normalizedErrors) {\n\t\tvar errors = normalizedErrors.length > 0 ? {}: undefined;\n\t\tcanReflect.eachIndex(normalizedErrors, function (error) {\n\t\t\tcanReflect.eachIndex(error.related, function (related) {\n\t\t\t\tif (!errors[related]) {\n\t\t\t\t\terrors[related] = [];\n\t\t\t\t}\n\t\t\t\terrors[related].push(error);\n\t\t\t});\n\t\t});\n\t\treturn errors;\n\t}\n};\n\nvar parseErrorItem = function (rawErrors) {\n\tvar errors = [];\n\tif (typeof rawErrors === 'string') {\n\t\terrors.push({message: rawErrors, related: ['*']});\n\t}\n\tif (typeof rawErrors === 'object' && !Array.isArray(rawErrors)) {\n\t\t// Although related can be a string, internally, it is easier if it is\n\t\t// always an array\n\t\tif (rawErrors.related) {\n\t\t\tif (!Array.isArray(rawErrors.related)) {\n\t\t\t\trawErrors.related = [rawErrors.related];\n\t\t\t}\n\t\t} else {\n\t\t\trawErrors.related = '*';\n\t\t}\n\t\terrors.push(rawErrors);\n\t}\n\tif (Array.isArray(rawErrors)) {\n\t\tcanReflect.eachIndex(rawErrors, function (error) {\n\t\t\t[].push.apply(errors, parseErrorItem(error));\n\t\t});\n\t}\n\treturn errors;\n};\n\n// Takes errors and normalizes them\nvar normalizeErrors = function (rawErrors) {\n\tvar normalizedErrors = [];\n  if (\n    typeof rawErrors === 'string' ||\n    (typeof rawErrors === 'object' && !Array.isArray(rawErrors))\n  ) {\n\t\t// Only one error set, which we can assume was for a single property\n\t\trawErrors = [rawErrors];\n\t}\n\n  if (rawErrors != null) {\n    canReflect.eachIndex(rawErrors, function (error) {\n      [].push.apply(normalizedErrors, parseErrorItem(error));\n    });\n  }\n\n\treturn normalizedErrors;\n};\n\nvalidate.formatErrors = function (errors, format) {\n\tvar normalized = normalizeErrors(errors);\n\tif (format) {\n\t\tif (helpers[format]) {\n\t\t\treturn helpers[format](normalized);\n\t\t} else {\n\t\t\treturn normalized;\n\t\t}\n\t} else {\n\t\treturn normalized;\n\t}\n};\n\nmodule.exports = validate;\n\n\n//# sourceURL=webpack:///./node_modules/can-validate/can-validate.js?");

/***/ }),

/***/ "./node_modules/can-value/can-value.js":
/*!*********************************************!*\
  !*** ./node_modules/can-value/can-value.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canKey = __webpack_require__(/*! can-key */ \"./node_modules/can-key/can-key.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar keyObservable = __webpack_require__(/*! can-simple-observable/key/key */ \"./node_modules/can-simple-observable/key/key.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\nvar SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ \"./node_modules/can-simple-observable/settable/settable.js\");\n\nmodule.exports = namespace.value = {\n\tbind: function(object, keyPath) {\n\t\treturn keyObservable(object, keyPath);\n\t},\n\n\tfrom: function(object, keyPath) {\n\t\tvar observationFunction = function() {\n\t\t\treturn canKey.get(object, keyPath);\n\t\t};\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tvar objectName = canReflect.getName(object);\n\t\t\tObject.defineProperty(observationFunction, \"name\", {\n\t\t\t\tvalue: \"ValueFrom<\" + objectName + \".\" + keyPath + \">\"\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn new Observation(observationFunction);\n\t},\n\n\treturnedBy: function(getter, context, initialValue) {\n\t\tif(getter.length === 1) {\n\t\t\treturn new SettableObservable(getter, context, initialValue);\n\t\t} else {\n\t\t\treturn new Observation(getter, context);\n\t\t}\n\t},\n\n\tto: function(object, keyPath) {\n\t\tvar observable = keyObservable(object, keyPath);\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tcanReflect.assignSymbols(observable.onDependencyChange, {\n\t\t\t\t\"can.getChangesDependencyRecord\": function getChangesDependencyRecord() {\n\t\t\t\t\t// can-simple-observable/key/ creates an observation that walks along\n\t\t\t\t\t// the keyPath. In doing so, it implicitly registers the objects and\n\t\t\t\t\t// keys along the path as mutators of the observation; this means\n\t\t\t\t\t// getDependencyDataOf(...an object and key along the path) returns\n\t\t\t\t\t// whatIChange.derive.valueDependencies = [observable], which is not\n\t\t\t\t\t// true! The observable does not derive its value from the objects\n\t\t\t\t\t// along the keyPath. By implementing getChangesDependencyRecord and\n\t\t\t\t\t// returning undefined, calls to can.getWhatIChange() for any objects\n\t\t\t\t\t// along the keyPath will not include the observable.\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tvar symbolsToAssign = {\n\t\t\t// Remove the getValue symbol so the observable is only a setter\n\t\t\t\"can.getValue\": null\n\t\t};\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tsymbolsToAssign[\"can.getValueDependencies\"] = function getValueDependencies() {\n\t\t\t\t// Normally, getDependencyDataOf(observable) would include\n\t\t\t\t// whatChangesMe.derive.keyDependencies, and it would contain\n\t\t\t\t// the object and anything along keyPath. This symbol returns\n\t\t\t\t// undefined because this observable does not derive its value\n\t\t\t\t// from the object or anything along the keyPath, it only\n\t\t\t\t// mutates the last object in the keyPath.\n\t\t\t};\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn canReflect.assignSymbols(observable, symbolsToAssign);\n\t},\n\n\twith: function(initialValue) {\n\t\treturn new SimpleObservable(initialValue);\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-value/can-value.js?");

/***/ }),

/***/ "./node_modules/can-view-autorender/can-view-autorender.js":
/*!*****************************************************************!*\
  !*** ./node_modules/can-view-autorender/can-view-autorender.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canViewModel = __webpack_require__(/*! can-view-model */ \"./node_modules/can-view-model/can-view-model.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar camelize = __webpack_require__(/*! can-string */ \"./node_modules/can-string/can-string.js\").camelize;\nvar load = __webpack_require__(/*! can-import-module */ \"./node_modules/can-import-module/can-import-module.js\");\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"./node_modules/can-dom-events/can-dom-events.js\");\n\nvar ignoreAttributesRegExp = /^(dataViewId|class|id|type|src|style)$/i;\n\nvar typeMatch = /\\s*text\\/(stache)\\s*/;\nfunction isIn(element, type) {\n\twhile(element.parentNode) {\n\t\telement = element.parentNode;\n\t\tif(element.nodeName.toLowerCase() === type.toLowerCase()) {\n\t\t\treturn true;\n\t\t}\n\t}\n}\nfunction setAttr(el, attr, viewModel){\n\tvar camelized = camelize(attr);\n\tif (!ignoreAttributesRegExp.test(camelized) ) {\n\t\tvar value = el.getAttribute(attr);\n\n\t\tif(!canReflect.hasKey(viewModel, camelized)) {\n\t\t\tcanReflect.defineInstanceKey(viewModel.constructor, camelized, typeof value);\n\t\t}\n\t\tcanReflect.setKeyValue(viewModel, camelized, value);\n\t}\n}\nfunction insertAfter(ref, element) {\n\tif(ref.nextSibling){\n\t\tref.parentNode.insertBefore(element, ref.nextSibling);\n\t} else {\n\t\tref.parentNode.appendChild(element);\n\t}\n}\n\nfunction render(renderer, scope, el) {\n\tvar frag = renderer(scope);\n\tif( isIn(el, \"head\") ) {\n\t\tdocument.body.appendChild(frag);\n\t} else if(el.nodeName.toLowerCase() === \"script\") {\n\t\tinsertAfter(el, frag);\n\t} else {\n\t\tinsertAfter(el, frag);\n\t\tel.parentNode.removeChild(el);\n\t}\n}\nfunction setupScope(el) {\n\tvar scope = canViewModel(el);\n\n\tcanReflect.each(el.attributes || [], function(attr) {\n\t\tsetAttr(el, attr.name, scope);\n\t});\n\n\tdomEvents.addEventListener(el, \"attributes\", function(ev) {\n\t\tsetAttr(el, ev.attributeName, scope);\n\t});\n\n\treturn scope;\n}\n\nvar promise = new Promise(function(resolve, reject) {\n\tfunction autoload(){\n\t\tvar promises = [];\n\n\t\tcanReflect.each(document.querySelectorAll(\"[can-autorender]\"), function( el, i){\n\t\t\tel.style.display = \"none\";\n\n\t\t\tvar text = el.innerHTML || el.text,\n\t\t\t\ttypeAttr = el.getAttribute(\"type\"),\n\t\t\t\ttypeInfo = typeAttr.match( typeMatch ),\n\t\t\t\ttype = typeInfo && typeInfo[1],\n\t\t\t\ttypeModule = \"can-\" + type;\n\n\t\t\tpromises.push(load(typeModule).then(function(engine){\n\t\t\t\tif(engine.async) {\n\t\t\t\t\treturn engine.async(text).then(function(renderer){\n\t\t\t\t\t\trender(renderer, setupScope(el), el);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar renderer = engine(text);\n\t\t\t\t\trender(renderer, setupScope(el), el);\n\t\t\t\t}\n\t\t\t}));\n\n\t\t});\n\n\t\tPromise.all(promises).then(resolve, reject);\n\t}\n\n\tif (document.readyState === \"complete\") {\n\t\tautoload();\n\t} else {\n\t\tdomEvents.addEventListener(window, \"load\", autoload);\n\t}\n});\n\nmodule.exports = namespace.autorender = function autorender(success, error){\n\treturn promise.then(success, error);\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-view-autorender/can-view-autorender.js?");

/***/ }),

/***/ "./node_modules/can-view-callbacks/can-view-callbacks.js":
/*!***************************************************************!*\
  !*** ./node_modules/can-view-callbacks/can-view-callbacks.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar getGlobal = __webpack_require__(/*! can-globals/global/global */ \"./node_modules/can-globals/global/global.js\");\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar makeFrag = __webpack_require__(/*! can-fragment */ \"./node_modules/can-fragment/can-fragment.js\");\nvar globals = __webpack_require__(/*! can-globals */ \"./node_modules/can-globals/can-globals.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar callbackMapSymbol = canSymbol.for('can.callbackMap');\nvar initializeSymbol = canSymbol.for('can.initialize');\n\n//!steal-remove-start\nif (true) {\n\tvar requestedAttributes = {};\n}\n//!steal-remove-end\n\nvar tags = {};\n\n// WeakSet containing elements that have been rendered already\n// and therefore do not need to be rendered again\n\nvar automountEnabled = function(){\n\tvar document = globals.getKeyValue(\"document\");\n\tif(document == null || document.documentElement == null) {\n\t\treturn false;\n\t}\n\treturn document.documentElement.getAttribute(\"data-can-automount\") !== \"false\";\n};\n\nvar renderedElements = new WeakMap();\n\nvar mountElement = function (node) {\n\tvar tagName = node.tagName && node.tagName.toLowerCase();\n\tvar tagHandler = tags[tagName];\n\n\t// skip elements that already have a viewmodel or elements whose tags don't match a registered tag\n\t// or elements that have already been rendered\n\tif (tagHandler) {\n\t\tcallbacks.tagHandler(node, tagName, {});\n\t}\n};\n\nvar mutationObserverEnabled = false;\nvar disableMutationObserver;\nvar enableMutationObserver = function() {\n\tvar docEl = getDocument().documentElement;\n\n\tif (mutationObserverEnabled) {\n\t\tif (mutationObserverEnabled === docEl) {\n\t\t\treturn;\n\t\t}\n\t\t// if the document has changed, re-enable mutationObserver\n\t\tdisableMutationObserver();\n\t}\n\n\tvar undoOnInsertionHandler = domMutate.onConnected(docEl, function(mutation) {\n\t\tmountElement(mutation.target);\n\t});\n\tmutationObserverEnabled = true;\n\n\tdisableMutationObserver = function() {\n\t\tundoOnInsertionHandler();\n\t\tmutationObserverEnabled = false;\n\t};\n};\n\nvar renderTagsInDocument = function(tagName) {\n\tvar nodes = getDocument().getElementsByTagName(tagName);\n\n\tfor (var i=0, node; (node = nodes[i]) !== undefined; i++) {\n\t\tmountElement(node);\n\t}\n};\n\nvar attr = function (attributeName, attrHandler) {\n\tif(attrHandler) {\n\t\tif (typeof attributeName === \"string\") {\n\t\t\tattributes[attributeName] = attrHandler;\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tif(requestedAttributes[attributeName]) {\n\t\t\t\t\tdev.warn(\"can-view-callbacks: \" + attributeName+ \" custom attribute behavior requested before it was defined.  Make sure \"+attributeName+\" is defined before it is needed.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t} else {\n\t\t\tregExpAttributes.push({\n\t\t\t\tmatch: attributeName,\n\t\t\t\thandler: attrHandler\n\t\t\t});\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tObject.keys(requestedAttributes).forEach(function(requested){\n\t\t\t\t\tif(attributeName.test(requested)) {\n\t\t\t\t\t\tdev.warn(\"can-view-callbacks: \" + requested+ \" custom attribute behavior requested before it was defined.  Make sure \"+requested+\" is defined before it is needed.\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\t} else {\n\t\tvar cb = attributes[attributeName];\n\t\tif( !cb ) {\n\n\t\t\tfor( var i = 0, len = regExpAttributes.length; i < len; i++) {\n\t\t\t\tvar attrMatcher = regExpAttributes[i];\n\t\t\t\tif(attrMatcher.match.test(attributeName)) {\n\t\t\t\t\treturn attrMatcher.handler;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\trequestedAttributes[attributeName] = true;\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn cb;\n\t}\n};\n\nvar attrs = function(attrMap) {\n\tvar map = canReflect.getKeyValue(attrMap, callbackMapSymbol) || attrMap;\n\n\t// Only add bindings once.\n\tif(attrMaps.has(map)) {\n\t\treturn;\n\t} else {\n\t\t// Would prefer to use WeakSet but IE11 doesn't support it.\n\t\tattrMaps.set(map, true);\n\t}\n\n\tcanReflect.eachKey(map, function(callback, exp){\n\t\tattr(exp, callback);\n\t});\n};\n\nvar attributes = {},\n\tregExpAttributes = [],\n\tattrMaps = new WeakMap(),\n\tautomaticCustomElementCharacters = /[-\\:]/;\nvar defaultCallback = function () {};\n\nvar tag = function (tagName, tagHandler) {\n\tif(tagHandler) {\n\t\tvar validCustomElementName = automaticCustomElementCharacters.test(tagName),\n\t\t\ttagExists = typeof tags[tagName.toLowerCase()] !== 'undefined',\n\t\t\tcustomElementExists;\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (tagExists) {\n\t\t\t\tdev.warn(\"Custom tag: \" + tagName.toLowerCase() + \" is already defined\");\n\t\t\t}\n\n\t\t\tif (!validCustomElementName && tagName !== \"content\") {\n\t\t\t\tdev.warn(\"Custom tag: \" + tagName.toLowerCase() + \" hyphen missed\");\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\ttags[tagName.toLowerCase()] = tagHandler;\n\n\t\tif(automountEnabled()) {\n\t\t\tvar customElements = globals.getKeyValue(\"customElements\");\n\n\t\t\t// automatically render elements that have tagHandlers\n\t\t\t// If browser supports customElements, register the tag as a custom element\n\t\t\tif (customElements) {\n\t\t\t\tcustomElementExists = customElements.get(tagName.toLowerCase());\n\n\t\t\t\tif (validCustomElementName && !customElementExists) {\n\t\t\t\t\tvar CustomElement = function() {\n\t\t\t\t\t\treturn Reflect.construct(HTMLElement, [], CustomElement);\n\t\t\t\t\t};\n\n\t\t\t\t\tCustomElement.prototype = Object.create(HTMLElement.prototype);\n\t\t\t\t\tCustomElement.prototype.constructor = CustomElement;\n\n\t\t\t\t\tCustomElement.prototype.connectedCallback = function() {\n\t\t\t\t\t\tcallbacks.tagHandler(this, tagName.toLowerCase(), {});\n\t\t\t\t\t};\n\n\t\t\t\t\tcustomElements.define(tagName, CustomElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If browser doesn't support customElements, set up MutationObserver for\n\t\t\t// rendering elements when they are inserted in the page\n\t\t\t// and rendering elements that are already in the page\n\t\t\telse {\n\t\t\t\tenableMutationObserver();\n\t\t\t\trenderTagsInDocument(tagName);\n\t\t\t}\n\t\t} else if(mutationObserverEnabled) {\n\t\t\tdisableMutationObserver();\n\t\t}\n\t} else {\n\t\tvar cb;\n\n\t\t// if null is passed as tagHandler, remove tag\n\t\tif (tagHandler === null) {\n\t\t\tdelete tags[tagName.toLowerCase()];\n\t\t} else {\n\t\t\tcb = tags[tagName.toLowerCase()];\n\t\t}\n\n\t\tif(!cb && automaticCustomElementCharacters.test(tagName)) {\n\t\t\t// empty callback for things that look like special tags\n\t\t\tcb = defaultCallback;\n\t\t}\n\t\treturn cb;\n\t}\n\n};\n\nvar callbacks = {\n\t_tags: tags,\n\t_attributes: attributes,\n\t_regExpAttributes: regExpAttributes,\n\tdefaultCallback: defaultCallback,\n\ttag: tag,\n\tattr: attr,\n\tattrs: attrs,\n\t// handles calling back a tag callback\n\ttagHandler: function(el, tagName, tagData){\n\t\t// skip elements that have already been rendered\n\t\tif (renderedElements.has(el)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar scope = tagData.scope,\n\t\t\thelperTagCallback = scope && scope.templateContext.tags.get(tagName),\n\t\t\ttagCallback = helperTagCallback || tags[tagName] || el[initializeSymbol],\n\t\t\tres;\n\n\t\t// If this was an element like <foo-bar> that doesn't have a component, just render its content\n\t\tif(tagCallback) {\n\t\t\tres = ObservationRecorder.ignore(tagCallback)(el, tagData);\n\n\t\t\t// add the element to the Set of elements that have had their handlers called\n\t\t\t// this will prevent the handler from being called again when the element is inserted\n\t\t\trenderedElements.set(el, true);\n\t\t} else {\n\t\t\tres = scope;\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (!tagCallback) {\n\t\t\t\tvar GLOBAL = getGlobal();\n\t\t\t\tvar ceConstructor = getDocument().createElement(tagName).constructor;\n\t\t\t\t// If not registered as a custom element, the browser will use default constructors\n\t\t\t\tif (ceConstructor === GLOBAL.HTMLElement || ceConstructor === GLOBAL.HTMLUnknownElement) {\n\t\t\t\t\tdev.warn('can-view-callbacks: No custom element found for ' + tagName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// If the tagCallback gave us something to render with, and there is content within that element\n\t\t// render it!\n\t\tif (res && tagData.subtemplate) {\n\t\t\tif (scope !== res) {\n\t\t\t\tscope = scope.add(res);\n\t\t\t}\n\n\t\t\t//var nodeList = nodeLists.register([], undefined, tagData.parentNodeList || true, false);\n\t\t\t//nodeList.expression = \"<\" + el.tagName + \">\";\n\n\t\t\tvar result = tagData.subtemplate(scope, tagData.options);\n\t\t\tvar frag = typeof result === \"string\" ? makeFrag(result) : result;\n\t\t\tdomMutateNode.appendChild.call(el, frag);\n\t\t}\n\t}\n};\n\nnamespace.view = namespace.view || {};\n\nif (namespace.view.callbacks) {\n\tthrow new Error(\"You can't have two versions of can-view-callbacks, check your dependencies\");\n} else {\n\tmodule.exports = namespace.view.callbacks = callbacks;\n}\n\n\n//# sourceURL=webpack:///./node_modules/can-view-callbacks/can-view-callbacks.js?");

/***/ }),

/***/ "./node_modules/can-view-import/can-view-import.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-view-import/can-view-import.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar canData = __webpack_require__(/*! can-dom-data */ \"./node_modules/can-dom-data/can-dom-data.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar DOCUMENT = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\nvar importer = __webpack_require__(/*! can-import-module */ \"./node_modules/can-import-module/can-import-module.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\nvar viewCallbacks = __webpack_require__(/*! can-view-callbacks */ \"./node_modules/can-view-callbacks/can-view-callbacks.js\");\nvar tag = viewCallbacks.tag;\nvar canLog = __webpack_require__(/*! can-log/ */ \"./node_modules/can-log/can-log.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\nfunction setViewModel (element, viewModel) {\n\telement[canSymbol.for('can.viewModel')] = viewModel;\n}\n\nfunction processImport(el, tagData) {\n\n\tvar moduleName = el.getAttribute(\"from\");\n\t// If the module is part of the helpers pass that into can.import\n\t// as the parentName\n\tvar templateModule = tagData.scope.get(\"scope.helpers.module\");\n\tvar parentName = templateModule ? templateModule.id : undefined;\n\n\tif(!moduleName) {\n\t\treturn Promise.reject(\"No module name provided\");\n\t}\n\n\tvar importPromise = importer(moduleName, parentName);\n\timportPromise.catch(function(err) {\n\t\tcanLog.error(err);\n\t});\n\n\t// if this template was loaded by steal-stache, the module imported by this tag should already be loaded\n\t// we can provide it immediately by adding the `module` property to the tag viewModel\n\tvar tagImportMap = tagData.scope.get(\"tagImportMap\");\n\tif (tagImportMap && tagImportMap[moduleName]) {\n\t\timportPromise.module = tagImportMap[moduleName];\n\n\t\t// if a module binding is bound directly to a non-nested, undefined variable name, add it to the let context\n\t\tvar moduleBindings = Array.prototype.filter.call(el.attributes, function(attr) {\n\t\t\treturn /module(.*):to/.test(attr.name) && attr.value.indexOf('.') === -1 && !tagData.scope.find(attr.value);\n\t\t});\n\t\tvar letContext = tagData.scope.getScope(function(scope) {\n\t\t\treturn scope._meta.variable;\n\t\t});\n\t\tmoduleBindings.forEach(function(attr) {\n\t\t\t// add null variable in closest let context. null var will be populated by binding.\n\t\t\t// causes binding to be made to let context rather defaulting bind to VM.\n\t\t\tletContext._context[attr.value] = null;\n\t\t});\n\t}\n\n\t// Set the viewModel to the promise\n\tsetViewModel(el, importPromise);\n\tcanData.set(el, \"scope\", importPromise);\n\n\t// Set the scope\n\tvar scope = tagData.scope.add(importPromise, { notContext: true });\n\n\t// If there is a can-tag present we will hand-off rendering to that tag.\n\tvar handOffTag = el.getAttribute(\"can-tag\");\n\n\tif(handOffTag) {\n\t\tvar callback = tag(handOffTag);\n\n\t\t// Verify hand off tag has been registered. Callback can be undefined or noop.\n\t\tif (!callback || callback === viewCallbacks.defaultCallback) {\n\t\t\t//!steal-remove-start\n\t\t\tdev.error(new Error(\"The tag '\" + handOffTag + \"' has not been properly registered.\"));\n\t\t\t//!steal-remove-end\n\t\t} else {\n\t\t\tcanData.set(el, \"preventDataBindings\", true);\n\t\t\tcallback(el, assign(tagData, {\n\t\t\t\tscope: scope\n\t\t\t}));\n\t\t\tcanData.set(el, \"preventDataBindings\", false);\n\n\t\t\tsetViewModel(el, importPromise);\n\t\t\tcanData.set(el, \"scope\", importPromise);\n\t\t}\n\t}\n\telse {\n\n\t\tvar frag = tagData.subtemplate ?\n\t\t\ttagData.subtemplate(scope, tagData.options ) :\n\t\t\tDOCUMENT().createDocumentFragment();\n\n\n\t\tdomMutateNode.appendChild.call(el, frag);\n\t}\n}\n\n[\"can-import\", \"can-dynamic-import\"].forEach(function(tagName) {\n\ttag(tagName, processImport.bind({ tagName: tagName }));\n});\n\n\n//# sourceURL=webpack:///./node_modules/can-view-import/can-view-import.js?");

/***/ }),

/***/ "./node_modules/can-view-live/can-view-live.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-view-live/can-view-live.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\t\n * @module {{}} can-view-live can-view-live\t\n * @parent can-views\t\n * @collection can-infrastructure\t\n * @package ./package.json\t\n *\t\n * Setup live-binding between the DOM and a compute manually.\t\n *\t\n * @option {Object} An object with the live-binding methods:\t\n * [can-view-live.html], [can-view-live.list], [can-view-live.text], and\t\n * [can-view-live.attr].\t\n *\n *\t\n * @body\t\n *\t\n * ## Use\t\n *\t\n *  [can-view-live] is an object with utility methods for setting up\t\n *  live-binding in relation to different parts of the DOM and DOM elements.  For\t\n *  example, to make an `<h2>`'s text stay live with\t\n *  a compute:\t\n *\t\n *  ```js\t\n *  var live = require(\"can-view-live\");\t\n *  var text = canCompute(\"Hello World\");\t\n *  var textNode = $(\"h2\").text(\" \")[0].childNodes[0];\t\n *  live.text(textNode, text);\t\n *  ```\t\n *\t\n */\nvar live = {};\nlive.attr = __webpack_require__(/*! ./lib/attr */ \"./node_modules/can-view-live/lib/attr.js\");\nlive.attrs = __webpack_require__(/*! ./lib/attrs */ \"./node_modules/can-view-live/lib/attrs.js\");\nlive.html = __webpack_require__(/*! ./lib/html */ \"./node_modules/can-view-live/lib/html.js\");\nlive.list = __webpack_require__(/*! ./lib/list */ \"./node_modules/can-view-live/lib/list.js\");\nlive.text = __webpack_require__(/*! ./lib/text */ \"./node_modules/can-view-live/lib/text.js\");\n\n\nmodule.exports = live;\n\n\n//# sourceURL=webpack:///./node_modules/can-view-live/can-view-live.js?");

/***/ }),

/***/ "./node_modules/can-view-live/lib/attr.js":
/*!************************************************!*\
  !*** ./node_modules/can-view-live/lib/attr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar attr = __webpack_require__(/*! can-attribute-observable/behaviors */ \"./node_modules/can-attribute-observable/behaviors.js\");\nvar helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/can-view-live/lib/helpers.js\");\n\n/**\n * @function can-view-live.attr attr\n * @parent can-view-live\n *\n * @signature `live.attr(el, attributeName, observable)`\n *\n * Keep an attribute live to a [can-reflect]-ed observable.\n *\n * ```js\n * var div = document.createElement('div');\n * var value = new SimpleObservable(\"foo bar\");\n * live.attr(div,\"class\", value);\n * ```\n *\n * @param {HTMLElement} el The element whos attribute will be kept live.\n * @param {String} attributeName The attribute name.\n * @param {Object} observable An observable value.\n *\n * @body\n *\n * ## How it works\n *\n * This listens for the changes in the observable and uses those changes to\n * set the specified attribute.\n */\nmodule.exports = function(el, attributeName, compute) {\n\tvar handlerName = \"\";\n\t//!steal-remove-start\n\tif(true) {\n\t\t// register that the handler changes the parent element\n\t\thandlerName = \"live.attr update::\"+canReflect.getName(compute);\n\t}\n\t//!steal-remove-end\n\n\tnew helpers.ListenUntilRemovedAndInitialize(compute,\n\t\t\tfunction liveUpdateAttr(newVal) {\n\t\t\t\tattr.set(el,attributeName, newVal);\n\t\t\t},\n\t\t\tel,\n\t\t\t\"dom\",\n\t\t\thandlerName\n\t\t);\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-view-live/lib/attr.js?");

/***/ }),

/***/ "./node_modules/can-view-live/lib/attrs.js":
/*!*************************************************!*\
  !*** ./node_modules/can-view-live/lib/attrs.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// This provides live binding for stache attributes.\nvar viewCallbacks = __webpack_require__(/*! can-view-callbacks */ \"./node_modules/can-view-callbacks/can-view-callbacks.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/can-view-live/lib/helpers.js\");\n\nmodule.exports = function(el, compute, scope, options) {\n\tvar handlerName = \"\";\n\tif (!canReflect.isObservableLike(compute)) {\n\t\t// Non-live case (`compute` was not a compute):\n\t\t//  set all attributes on the element and don't\n\t\t//  worry about setting up live binding since there\n\t\t//  is not compute to bind on.\n\t\tvar attrs = helpers.getAttributeParts(compute);\n\t\tfor (var name in attrs) {\n\t\t\tdomMutateNode.setAttribute.call(el, name, attrs[name]);\n\t\t}\n\t\treturn;\n\t}\n\n\t//!steal-remove-start\n\tif(true) {\n\t\thandlerName = \"live.attrs update::\"+canReflect.getName(compute);\n\t}\n\t//!steal-remove-end\n\n\n\t// last set of attributes\n\tvar oldAttrs = {};\n\n\n\tnew helpers.ListenUntilRemovedAndInitialize(compute,\n\t\tfunction canViewLive_updateAttributes(newVal) {\n\t\t\tvar newAttrs = helpers.getAttributeParts(newVal),\n\t\t\t\tname;\n\t\t\tfor (name in newAttrs) {\n\t\t\t\tvar newValue = newAttrs[name],\n\t\t\t\t\t// `oldAttrs` was set on the last run of setAttrs in this context\n\t\t\t\t\t//  (for this element and compute)\n\t\t\t\t\toldValue = oldAttrs[name];\n\t\t\t\t// Only fire a callback\n\t\t\t\t//  if the value of the attribute has changed\n\t\t\t\tif (newValue !== oldValue) {\n\t\t\t\t\t// set on DOM attributes (dispatches an \"attributes\" event as well)\n\t\t\t\t\tdomMutateNode.setAttribute.call(el, name, newValue);\n\t\t\t\t\t// get registered callback for attribute name and fire\n\t\t\t\t\tvar callback = viewCallbacks.attr(name);\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback(el, {\n\t\t\t\t\t\t\tattributeName: name,\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\toptions: options\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// remove key found in new attrs from old attrs\n\t\t\t\tdelete oldAttrs[name];\n\t\t\t}\n\t\t\t// any attrs left at this point are not set on the element now,\n\t\t\t// so remove them.\n\t\t\tfor (name in oldAttrs) {\n\t\t\t\tdomMutateNode.removeAttribute.call(el, name);\n\t\t\t}\n\t\t\toldAttrs = newAttrs;\n\t\t},\n\t\tel,\n\t\t\"dom\",\n\t\thandlerName);\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-view-live/lib/attrs.js?");

/***/ }),

/***/ "./node_modules/can-view-live/lib/helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/can-view-live/lib/helpers.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"./node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\nvar parser = __webpack_require__(/*! can-view-parser */ \"./node_modules/can-view-parser/can-view-parser.js\");\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar isConnected = __webpack_require__(/*! can-dom-mutate/-is-connected */ \"./node_modules/can-dom-mutate/-is-connected.js\");\n\nvar setElementSymbol = canSymbol.for(\"can.setElement\");\nvar elementSymbol = canSymbol.for(\"can.element\");\n\nfunction ListenUntilRemovedAndInitialize(\n\tobservable,\n\thandler,\n\tplaceholder,\n\tqueueName,\n\thandlerName\n) {\n\tthis.observable = observable;\n\tthis.handler = handler;\n\tthis.placeholder = placeholder;\n\tthis.queueName = queueName;\n\tthis.handler[elementSymbol] = placeholder;\n\n\tif( observable[setElementSymbol] ) {\n\t\tobservable[setElementSymbol](placeholder);\n\t} else {\n\t\tconsole.warn(\"no can.setElement symbol on observable\", observable);\n\t}\n\n\t//!steal-remove-start\n\tif(true) {\n\t\t// register that the handler changes the parent element\n\t\tcanReflect.assignSymbols(handler, {\n\t\t\t\"can.getChangesDependencyRecord\": function() {\n\t\t\t\tvar s = new Set();\n\t\t\t\ts.add(placeholder);\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: s\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(handler, \"name\", {\n\t\t\tvalue: handlerName,\n\t\t});\n\n\t}\n\t//!steal-remove-end\n\n\tthis.setup();\n}\nListenUntilRemovedAndInitialize.prototype.setup = function() {\n\t// reinsertion case, not applicable during initial setup\n\tif(this.setupNodeReinserted) {\n\t\t// do not set up again if disconnected\n\t\tif(!isConnected.isConnected(this.placeholder)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.setupNodeReinserted();\n\t}\n\tthis.teardownNodeRemoved = domMutate.onNodeRemoved(this.placeholder,\n\t\tthis.teardown.bind(this));\n\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tcanReflectDeps.addMutatedBy(this.placeholder, this.observable);\n\t}\n\t//!steal-remove-end\n\n\tcanReflect.onValue(this.observable, this.handler, this.queueName);\n\tthis.handler(  canReflect.getValue(this.observable) );\n\n};\nListenUntilRemovedAndInitialize.prototype.teardown = function(){\n\t// do not teardown if still connected.\n\tif(isConnected.isConnected(this.placeholder)) {\n\t\treturn;\n\t}\n\tthis.teardownNodeRemoved();\n\tthis.setupNodeReinserted = domMutate.onNodeInserted(this.placeholder,\n\t\tthis.setup.bind(this));\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tcanReflectDeps.deleteMutatedBy(this.placeholder, this.observable);\n\t}\n\t//!steal-remove-end\n\tcanReflect.offValue(this.observable, this.handler, this.queueName);\n};\n\n\nmodule.exports = {\n\trange: {\n\t\tcreate: function(el, rangeName){\n\t\t\tvar start, end, next;\n\n\t\t\tif(el.nodeType === Node.COMMENT_NODE) {\n\t\t\t\tstart = el;\n\t\t\t\tnext = el.nextSibling;\n\t\t\t\tif(next && next.nodeType === Node.COMMENT_NODE && next.nodeValue === \"can-end-placeholder\") {\n\t\t\t\t\tend = next;\n\t\t\t\t\tend.nodeValue = \"/\" + (start.nodeValue = rangeName);\n\t\t\t\t} else {\n\t\t\t\t\tcanDev.warn(\"can-view-live: creating an end comment for \", rangeName, el);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcanDev.warn(\"can-view-live: forcing a comment range for \", rangeName, el);\n\t\t\t\tstart = el.ownerDocument.createComment( rangeName );\n\t\t\t\tel.parentNode.replaceChild( start, el );\n\t\t\t}\n\n\t\t\tif(!end) {\n\t\t\t\tend = el.ownerDocument.createComment( \"/\" + rangeName );\n\t\t\t\tstart.parentNode.insertBefore(end, start.nextSibling);\n\t\t\t}\n\n\t\t\treturn {start: start, end: end};\n\t\t},\n\t\tremove: function ( range ) {\n\t\t\t// TODO: Ideally this would be able to remove from the end, but\n\t\t\t// dispatch in the right order.\n\t\t\t// For now, we might want to remove nodes in the right order.\n\t\t\tvar parentNode = range.start.parentNode,\n\t\t\t\tcur = range.end.previousSibling,\n\t\t\t\tremove;\n\t\t\twhile(cur && cur !== range.start) {\n\t\t\t\tremove = cur;\n\t\t\t\tcur = cur.previousSibling;\n\t\t\t\tdomMutateNode.removeChild.call(parentNode, remove );\n\t\t\t}\n\n\t\t\tdomMutate.flushRecords();\n\t\t},\n\n\t\tupdate: function ( range, frag ) {\n\t\t\tvar parentNode = range.start.parentNode;\n\t\t\tif(parentNode) {\n\t\t\t\tdomMutateNode.insertBefore.call(parentNode, frag, range.end);\n\t\t\t\t// this makes it so `connected` events will be called immediately\n\t\t\t\tdomMutate.flushRecords();\n\t\t\t}\n\t\t}\n\t},\n\tListenUntilRemovedAndInitialize: ListenUntilRemovedAndInitialize,\n\tgetAttributeParts: function(newVal) {\n\t\tvar attrs = {},\n\t\t\tattr;\n\t\tparser.parseAttrs(newVal, {\n\t\t\tattrStart: function(name) {\n\t\t\t\tattrs[name] = \"\";\n\t\t\t\tattr = name;\n\t\t\t},\n\t\t\tattrValue: function(value) {\n\t\t\t\tattrs[attr] += value;\n\t\t\t},\n\t\t\tattrEnd: function() {}\n\t\t});\n\t\treturn attrs;\n\t},\n\t// #### addTextNodeIfNoChildren\n\t// Append an empty text node to a parent with no children;\n\t//  do nothing if the parent already has children.\n\taddTextNodeIfNoChildren: function(frag) {\n\t\tif (!frag.firstChild) {\n\t\t\tfrag.appendChild(frag.ownerDocument.createTextNode(\"\"));\n\t\t}\n\t},\n\t// #### makeString\n\t// any -> string converter (including nullish)\n\tmakeString: function(txt) {\n\t\treturn txt == null ? \"\" : \"\" + txt;\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-view-live/lib/helpers.js?");

/***/ }),

/***/ "./node_modules/can-view-live/lib/html.js":
/*!************************************************!*\
  !*** ./node_modules/can-view-live/lib/html.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar makeFragment = __webpack_require__(/*! can-fragment */ \"./node_modules/can-fragment/can-fragment.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/can-view-live/lib/helpers.js\");\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\n\nvar viewInsertSymbol = canSymbol.for(\"can.viewInsert\");\n\nfunction makeCommentFragment(comment) {\n\t\tvar doc = getDocument();\n\t\treturn makeFragment([\n\t\t\tdoc.createComment(comment),\n\t\t\tdoc.createComment(\"can-end-placeholder\")\n\t\t]);\n}\n\n/**\n * @function can-view-live.html html\n * @parent can-view-live\n * @release 2.0.4\n *\n * Live binds a compute's value to a collection of elements.\n *\n * @signature `live.html(el, compute, [parentNode])`\n *\n * `live.html` is used to setup incremental live-binding on a block of html.\n *\n * ```js\n * // a compute that changes its list\n * var greeting = compute(function(){\n *   return \"Welcome <i>\"+me.attr(\"name\")+\"</i>\"\n * });\n *\n * var placeholder = document.createTextNode(\" \");\n * $(\"#greeting\").append(placeholder);\n *\n * live.html(placeholder, greeting);\n * ```\n *\n * @param {HTMLElement} el An html element to replace with the live-section.\n *\n * @param {can.compute} compute A [can.compute] whose value is HTML.\n *\n * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is\n * a documentFragment.\n *\n *\n */\nmodule.exports = function(el, compute, viewInsertSymbolOptions) {\n\n\tvar observableName = \"\";\n\tvar updateRange = helpers.range.update;\n\n\t//!steal-remove-start\n\tif(true) {\n\t\t// register that the handler changes the parent element\n\t\tupdateRange = helpers.range.update.bind(null);\n\t\tobservableName = canReflect.getName(compute);\n\t\tObject.defineProperty(updateRange, \"name\", {\n\t\t\tvalue: \"live.html update::\"+observableName,\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tif (el.nodeType !== Node.COMMENT_NODE) {\n\t\tvar commentFrag = makeCommentFragment(observableName);\n\t\tvar startCommentNode = commentFrag.firstChild;\n\t\tel.parentNode.replaceChild(commentFrag, el);\n\t\tel = startCommentNode;\n\t}\n\n\t// replace element with a comment node\n\tvar range = helpers.range.create(el, observableName);\n\n\tvar useQueue = false;\n\tnew helpers.ListenUntilRemovedAndInitialize(compute,\n\t\tfunction canViewLive_updateHTML(val) {\n\n\t\t\t// If val has the can.viewInsert symbol, call it and get something usable for val back\n\t\t\tif (val && typeof val[viewInsertSymbol] === \"function\") {\n\t\t\t\tval = val[viewInsertSymbol](viewInsertSymbolOptions);\n\t\t\t}\n\n\t\t\tvar isFunction = typeof val === \"function\";\n\n\t\t\t// translate val into a document fragment if it's DOM-like\n\t\t\tvar frag = isFunction ?\n\t\t\t\tmakeCommentFragment(observableName) :\n\t\t\t\tmakeFragment(val);\n\n\t\t\tif(isFunction) {\n\t\t\t\tval(frag.firstChild);\n\t\t\t}\n\n\t\t\tif(useQueue === true) {\n\t\t\t\thelpers.range.remove(range);\n\t\t\t\tupdateRange(range, frag);\n\t\t\t} else {\n\t\t\t\thelpers.range.update(range, frag);\n\t\t\t\tuseQueue = true;\n\t\t\t}\n\t\t},\n\t\trange.start,\n\t\t\"dom\",\n\t\t\"live.html replace::\" + observableName);\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-view-live/lib/html.js?");

/***/ }),

/***/ "./node_modules/can-view-live/lib/list.js":
/*!************************************************!*\
  !*** ./node_modules/can-view-live/lib/list.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar frag = __webpack_require__(/*! can-fragment */ \"./node_modules/can-fragment/can-fragment.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\n\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"./node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\n\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\n\nvar Patcher = __webpack_require__(/*! can-diff/patcher/patcher */ \"./node_modules/can-diff/patcher/patcher.js\");\nvar patchSort = __webpack_require__(/*! can-diff/patch-sort/patch-sort */ \"./node_modules/can-diff/patch-sort/patch-sort.js\");\n\nvar SetObservable = __webpack_require__(/*! ./set-observable */ \"./node_modules/can-view-live/lib/set-observable.js\");\nvar helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/can-view-live/lib/helpers.js\");\n\nvar splice = [].splice;\n\n// #### renderAndAddRangeNode\n// a helper function that renders something and adds its nodeLists to newNodeLists\n// in the right way for stache.\nvar renderAndAddRangeNode = function(render, context, args, document) {\n\t\t// call the renderer, passing in the new nodeList as the last argument\n\t\tvar itemHTML = render.apply(context, args.concat()),\n\t\t\t// and put the output into a document fragment\n\t\t\titemFrag = frag(itemHTML);\n\n\t\tvar rangeNode = document.createTextNode(\"\");\n\t\titemFrag.appendChild(rangeNode);\n\t\treturn itemFrag;\n\t};\n\n\nfunction getFrag(first, last){\n\tvar frag = first.ownerDocument.createDocumentFragment();\n\tvar current,\n\t\tlastInserted;\n\t// hopefully this doesn't dispatch removed?\n\twhile(last !== first) {\n\t\tcurrent = last;\n\t\tlast = current.previousSibling;\n\t\tfrag.insertBefore(current, lastInserted);\n\t\tlastInserted = current;\n\t}\n\tfrag.insertBefore(last, lastInserted);\n\treturn frag;\n}\n\nvar onPatchesSymbol = canSymbol.for(\"can.onPatches\");\nvar offPatchesSymbol = canSymbol.for(\"can.offPatches\");\n\nfunction ListDOMPatcher(el, compute, render, context, falseyRender) {\n\tthis.patcher = new Patcher(compute);\n\tvar observableName = canReflect.getName(compute);\n\n\t// argument cleanup\n\n\t// function callback binding\n\n\t// argument saving -----\n\tthis.value = compute;\n\tthis.render = render;\n\tthis.context = context;\n\tthis.falseyRender = falseyRender;\n\tthis.range = helpers.range.create(el, observableName);\n\n\t// A mapping of indices to observables holding that index.\n\tthis.indexMap = [];\n\t// A mapping of each item's end node\n\tthis.itemEndNode = [];\n\n\t// A mapping of each item to its pending patches.\n\tthis.domQueue = [];\n\n\tthis.isValueLike = canReflect.isValueLike(this.value);\n\tthis.isObservableLike = canReflect.isObservableLike(this.value);\n\n\t// Setup binding and teardown to add and remove events\n\tthis.onPatches = this.onPatches.bind(this);\n\tthis.processDomQueue = this.processDomQueue.bind(this);\n\tthis.teardownValueBinding = this.teardownValueBinding.bind(this);\n\n\tthis.meta = {reasonLog: \"live.html add::\"+observableName, element: this.range.start};\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tObject.defineProperty(this.onPatches, \"name\", {\n\t\t\tvalue: \"live.list update::\"+canReflect.getName(compute),\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tthis.setupValueBinding();\n}\n\nvar onPatchesSymbol = canSymbol.for(\"can.onPatches\");\nvar offPatchesSymbol = canSymbol.for(\"can.offPatches\");\n\nListDOMPatcher.prototype = {\n\tsetupValueBinding: function() {\n\t\t// Teardown when the placeholder element is removed.\n\t\tthis.teardownNodeRemoved = domMutate.onNodeRemoved(this.range.start, this.teardownValueBinding);\n\n\t\t// Listen to when the patcher produces patches.\n\t\tthis.patcher[onPatchesSymbol](this.onPatches, \"notify\");\n\n\t\t// Initialize with the patcher's value\n\t\tif (this.patcher.currentList && this.patcher.currentList.length) {\n\t\t\tthis.add(this.patcher.currentList, 0);\n\t\t} else {\n\t\t\tthis.addFalseyIfEmpty();\n\t\t}\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tcanReflectDeps.addMutatedBy(this.range.start, this.patcher.observableOrList);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\tteardownValueBinding: function() {\n\n\t\tthis.exit = true;\n\t\t// Stop listening for teardowns\n\t\tthis.teardownNodeRemoved();\n\t\tthis.patcher[offPatchesSymbol](this.onPatches, \"notify\");\n\t\t// Todo: I bet this is no longer necessary?\n\t\t//this.remove({\n\t\t//\tlength: this.patcher.currentList ? this.patcher.currentList.length : 0\n\t\t//}, 0, true);\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tcanReflectDeps.deleteMutatedBy(this.range.start, this.patcher.observableOrList);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\tonPatches: function ListDOMPatcher_onPatches(patches) {\n\t\tif (this.exit) {\n\t\t\treturn;\n\t\t}\n\t\tvar sortedPatches = [];\n\t\tpatches.forEach(function(patch) {\n\t\t\tsortedPatches.push.apply(sortedPatches, patchSort([patch]));\n\t\t});\n\t\t// adjust so things can happen\n\t\tfor (var i = 0, patchLen = sortedPatches.length; i < patchLen; i++) {\n\t\t\tvar patch = sortedPatches[i];\n\t\t\tif (patch.type === \"move\") {\n\t\t\t\tthis.addToDomQueue(\n\t\t\t\t\tthis.move,\n\t\t\t\t\t[patch.toIndex, patch.fromIndex]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tif (patch.deleteCount) {\n\t\t\t\t\t// Remove any items scheduled for deletion from the patch.\n\t\t\t\t\tthis.addToDomQueue(this.remove, [{\n\t\t\t\t\t\tlength: patch.deleteCount\n\t\t\t\t\t}, patch.index]);\n\t\t\t\t}\n\t\t\t\tif (patch.insert && patch.insert.length) {\n\t\t\t\t\t// Insert any new items at the index\n\t\t\t\t\tthis.addToDomQueue(this.add, [patch.insert, patch.index]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\taddToDomQueue: function(fn, args) {\n\t\tthis.domQueue.push({\n\t\t\tfn: fn,\n\t\t\targs: args\n\t\t});\n\t\tqueues.domQueue.enqueue(this.processDomQueue, this, [this.domQueue], this.meta);\n\t},\n\tprocessDomQueue: function() {\n\t\tthis.domQueue.forEach(function(queueItem) {\n\t\t\tvar fn = queueItem.fn;\n\t\t\tvar args = queueItem.args;\n\t\t\tfn.apply(this, args);\n\t\t}.bind(this));\n\t\tthis.domQueue = [];\n\t},\n\tadd: function(items, index) {\n\t\t//if (!afterPreviousEvents) {\n\t\t//\treturn;\n\t\t//}\n\t\t// Collect new html and mappings\n\t\tvar ownerDocument = this.range.start.ownerDocument,\n\t\t\tfrag = ownerDocument.createDocumentFragment(),\n\t\t\tnewEndNodes = [],\n\t\t\tnewIndicies = [],\n\t\t\trender = this.render,\n\t\t\tcontext = this.context;\n\t\t// For each new item,\n\t\titems.forEach( function(item, key) {\n\n\t\t\tvar itemIndex = new SimpleObservable(key + index),\n\t\t\t\titemCompute = new SetObservable(item, function(newVal) {\n\t\t\t\t\tcanReflect.setKeyValue(this.patcher.currentList, itemIndex.get(), newVal );\n\t\t\t\t}.bind(this)),\n\t\t\t\titemFrag = renderAndAddRangeNode(render, context, [itemCompute, itemIndex], ownerDocument);\n\n\t\t\tnewEndNodes.push(itemFrag.lastChild);\n\t\t\t// Hookup the fragment (which sets up child live-bindings) and\n\t\t\t// add it to the collection of all added elements.\n\t\t\tfrag.appendChild(itemFrag);\n\t\t\t// track indicies;\n\t\t\tnewIndicies.push(itemIndex);\n\t\t}, this);\n\t\t// The position of elements is always after the initial text placeholder node\n\n\t\t// TODO: this should probably happen earlier.\n\t\t// remove falsey if there's something there\n\t\tif (!this.indexMap.length) {\n\t\t\t// remove all leftover things\n\t\t\thelpers.range.remove(this.range);\n\t\t\tthis.itemEndNode = [];\n\t\t}\n\t\t// figure out where we are placing things.\n\t\tvar placeholder,\n\t\t\tendNodesLength = this.itemEndNode.length;\n\t\tif(index === endNodesLength ) {\n\t\t\tplaceholder = this.range.end;\n\t\t} else if(index === 0) {\n\t\t\tplaceholder = this.range.start.nextSibling;\n\t\t} else if(index < endNodesLength) {\n\t\t\tplaceholder = this.itemEndNode[index - 1].nextSibling;\n\t\t} else {\n\t\t\tthrow new Error(\"Unable to place item\");\n\t\t}\n\n\t\tdomMutateNode.insertBefore.call(placeholder.parentNode,frag,placeholder);\n\n\t\tsplice.apply(this.itemEndNode, [\n\t\t\tindex,\n\t\t\t0\n\t\t].concat(newEndNodes));\n\n\t\t// update indices after insert point\n\t\tsplice.apply(this.indexMap, [\n\t\t\tindex,\n\t\t\t0\n\t\t].concat(newIndicies));\n\n\t\tfor (var i = index + newIndicies.length, len = this.indexMap.length; i < len; i++) {\n\t\t\tthis.indexMap[i].set(i);\n\t\t}\n\t},\n\tremove: function(items, index) {\n\t\t//if (!afterPreviousEvents) {\n\t\t//\treturn;\n\t\t//}\n\n\t\t// If this is because an element was removed, we should\n\t\t// check to make sure the live elements are still in the page.\n\t\t// If we did this during a teardown, it would cause an infinite loop.\n\t\t//if (!duringTeardown && this.data.teardownCheck(this.placeholder.parentNode)) {\n\t\t//\treturn;\n\t\t//}\n\t\tif (index < 0) {\n\t\t\tindex = this.indexMap.length + index;\n\t\t}\n\t\tvar removeStart;\n\t\tvar removeEnd;\n\t\tvar removeCount = items.length;\n\t\tvar endIndex = index + removeCount - 1;\n\t\tif(index === 0) {\n\t\t\tremoveStart = this.range.start;\n\t\t} else {\n\t\t\tremoveStart = this.itemEndNode[index - 1];\n\t\t}\n\t\tremoveEnd = this.itemEndNode[endIndex].nextSibling;\n\n\t\tthis.itemEndNode.splice(index, items.length);\n\n\t\tif (removeStart && removeEnd) {\n\t\t\thelpers.range.remove({start: removeStart, end: removeEnd});\n\t\t}\n\n\t\tvar indexMap = this.indexMap;\n\n\t\t// update indices after remove point\n\t\tindexMap.splice(index, items.length);\n\t\tfor (var i = index, len = indexMap.length; i < len; i++) {\n\t\t\tindexMap[i].set(i);\n\t\t}\n\n\t\t// don't remove elements during teardown.  Something else will probably be doing that.\n\t\tif (!this.exit) {\n\t\t\t// adds the falsey section if the list is empty\n\t\t\tthis.addFalseyIfEmpty();\n\t\t} else {\n\t\t\t// This probably isn't needed anymore as element removal will be propagated\n\t\t\t// nodeLists.unregister(this.masterNodeList);\n\t\t}\n\t},\n\t// #### addFalseyIfEmpty\n\t// Add the results of redering the \"falsey\" or inverse case render to the\n\t// master nodeList and the DOM if the live list is empty\n\taddFalseyIfEmpty: function() {\n\t\tif (this.falseyRender && this.indexMap.length === 0) {\n\t\t\t// If there are no items ... we should render the falsey template\n\t\t\tvar falseyFrag = renderAndAddRangeNode(this.falseyRender, this.currentList, [this.currentList], this.range.start.ownerDocument);\n\t\t\thelpers.range.update(this.range, falseyFrag);\n\t\t}\n\t},\n\tmove: function move(newIndex, currentIndex) {\n\t\t//if (!afterPreviousEvents) {\n\t\t//\treturn;\n\t\t//}\n\t\t// The position of elements is always after the initial text\n\t\t// placeholder node\n\n\n\t\tvar currentFirstNode,\n\t\t\tcurrentEndNode = this.itemEndNode[currentIndex];\n\t\tif( currentIndex > 0 ) {\n\t\t\tcurrentFirstNode = this.itemEndNode[currentIndex - 1].nextSibling;\n\t\t} else {\n\t\t\tcurrentFirstNode = this.range.start.nextSibling;\n\t\t}\n\t\tvar newIndexFirstNode;\n\t\tif (currentIndex < newIndex) {\n\t\t\t// we need to advance one spot, because removing at\n\t\t\t// current index will shift everything left\n\t\t\tnewIndexFirstNode = this.itemEndNode[newIndex].nextSibling;\n\t\t} else {\n\t\t\tif( newIndex > 0 ) {\n\t\t\t\tnewIndexFirstNode = this.itemEndNode[newIndex - 1].nextSibling;\n\t\t\t} else {\n\t\t\t\tnewIndexFirstNode = this.range.start.nextSibling;\n\t\t\t}\n\t\t}\n\t\t// need to put this at the newIndex\n\n\n\n\t\tvar frag = getFrag(currentFirstNode, currentEndNode);\n\t\tnewIndexFirstNode.parentNode.insertBefore(frag, newIndexFirstNode);\n\n\t\t// update endNodes\n\t\tthis.itemEndNode.splice(currentIndex, 1);\n\t\tthis.itemEndNode.splice(newIndex, 0,currentEndNode);\n\n\n\t\t// Update indexMap\n\t\tnewIndex = newIndex + 1;\n\t\tcurrentIndex = currentIndex + 1;\n\n\t\tvar indexMap = this.indexMap;\n\n\t\t// Convert back to a zero-based array index\n\t\tnewIndex = newIndex - 1;\n\t\tcurrentIndex = currentIndex - 1;\n\n\t\t// Grab the index compute from the `indexMap`\n\t\tvar indexCompute = indexMap[currentIndex];\n\n\t\t// Remove the index compute from the `indexMap`\n\t\t[].splice.apply(indexMap, [currentIndex, 1]);\n\n\t\t// Move the index compute to the correct index in the `indexMap`\n\t\t[].splice.apply(indexMap, [newIndex, 0, indexCompute]);\n\n\t\tvar i = Math.min(currentIndex, newIndex);\n\t\tvar len = indexMap.length;\n\n\t\tfor (i, len; i < len; i++) {\n\t\t\t// set each compute to have its current index in the map as its value\n\t\t\tindexMap[i].set(i);\n\t\t}\n\t}\n};\n\n\n\n/**\n * @function can-view-live.list list\n * @parent can-view-live\n * @release 2.0.4\n *\n * @signature `live.list(el, list, render, context)`\n *\n * Live binds a compute's list incrementally.\n *\n * ```js\n * // a compute that change's it's list\n * var todos = compute(function(){\n *   return new Todo.List({page: can.route.attr(\"page\")})\n * })\n *\n * var placeholder = document.createTextNode(\" \");\n * $(\"ul#todos\").append(placeholder);\n *\n * can.view.live.list(\n *   placeholder,\n *   todos,\n *   function(todo, index){\n *     return \"<li>\"+todo.attr(\"name\")+\"</li>\"\n *   });\n * ```\n *\n * @param {HTMLElement} el An html element to replace with the live-section.\n *\n * @param {Object} list An observable value or list type. If an observable value, it should contain\n * a falsey value or a list type.\n *\n * @param {function(this:*,*,index):String} render(index, index) A function that when called with\n * the incremental item to render and the index of the item in the list.\n *\n * @param {Object} context The `this` the `render` function will be called with.\n *\n * @body\n *\n * ## How it works\n *\n * If `list` is an observable value, `live.list` listens to changes in in that\n * observable value.  It will generally change from one list type (often a list type that implements `onPatches`)\n * to another.  When the value changes, a diff will be performed and the DOM updated.  Also, `live.list`\n * will listen to `.onPatches` on the new list and apply any patches emitted from it.\n *\n *\n */\nmodule.exports = function(el, list, render, context, falseyRender) {\n\tnew ListDOMPatcher(el, list, render, context, falseyRender);\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-view-live/lib/list.js?");

/***/ }),

/***/ "./node_modules/can-view-live/lib/set-observable.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-view-live/lib/set-observable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nfunction SetObservable(initialValue, setter) {\n\tthis.setter = setter;\n\n\tSimpleObservable.call(this, initialValue);\n}\n\nSetObservable.prototype = Object.create(SimpleObservable.prototype);\nSetObservable.prototype.constructor = SetObservable;\nSetObservable.prototype.set = function(newVal) {\n\tthis.setter(newVal);\n};\n\n\ncanReflect.assignSymbols(SetObservable.prototype, {\n\t\"can.setValue\": SetObservable.prototype.set\n});\n\nmodule.exports = SetObservable;\n\n\n//# sourceURL=webpack:///./node_modules/can-view-live/lib/set-observable.js?");

/***/ }),

/***/ "./node_modules/can-view-live/lib/text.js":
/*!************************************************!*\
  !*** ./node_modules/can-view-live/lib/text.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/can-view-live/lib/helpers.js\");\n\n/**\n * @function can-view-live.text text\n * @parent can-view-live\n * @release 2.0.4\n *\n * @signature `live.text(el, compute)`\n *\n * Replaces one element with some content while keeping [can-view-live.nodeLists nodeLists] data correct.\n */\nmodule.exports = function(el, compute) {\n\tvar handlerName = \"\";\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tif(arguments.length > 2) {\n\t\t\t// TODO: remove\n\t\t\tthrow new Error(\"too many arguments\");\n\n\t\t}\n\t\thandlerName = \"live.text update::\"+canReflect.getName(compute);\n\t}\n\t//!steal-remove-end\n\n\t// TODO: we can remove this at some point\n\tif (el.nodeType !== Node.TEXT_NODE) {\n\t\tvar textNode;\n\n\t\ttextNode = document.createTextNode(\"\");\n\t\tel.parentNode.replaceChild(textNode, el);\n\t\tel = textNode;\n\n\t}\n\n\tnew helpers.ListenUntilRemovedAndInitialize(compute, function liveTextUpdateTextNode(newVal) {\n\t\tel.nodeValue = helpers.makeString(newVal);\n\t},\n\tel,\n\t\"dom\", // TODO: should this still be domUI?\n\thandlerName);\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-view-live/lib/text.js?");

/***/ }),

/***/ "./node_modules/can-view-model/can-view-model.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-view-model/can-view-model.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar SimpleMap = __webpack_require__(/*! can-simple-map */ \"./node_modules/can-simple-map/can-simple-map.js\");\nvar ns = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\n\nvar viewModelSymbol = canSymbol.for('can.viewModel');\n\nmodule.exports = ns.viewModel = function (el, attr, val) {\n\tif (typeof el === \"string\") {\n\t\tel = getDocument().querySelector(el);\n\t} else if (canReflect.isListLike(el) && !el.nodeType) {\n\t\tel = el[0];\n\t}\n\n\tif (canReflect.isObservableLike(attr) && canReflect.isMapLike(attr)) {\n\t\tel[viewModelSymbol] = attr;\n\t\treturn;\n\t}\n\n\tvar scope = el[viewModelSymbol];\n\tif(!scope) {\n\t\tscope = new SimpleMap();\n\t\tel[viewModelSymbol] = scope;\n\t}\n\tswitch (arguments.length) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\treturn scope;\n\t\tcase 2:\n\t\t\treturn canReflect.getKeyValue(scope, attr);\n\t\tdefault:\n\t\t\tcanReflect.setKeyValue(scope, attr, val);\n\t\t\treturn el;\n\t}\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-view-model/can-view-model.js?");

/***/ }),

/***/ "./node_modules/can-view-parser/can-view-parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-view-parser/can-view-parser.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint maxdepth:7,node:true, latedef:false */\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\"),\n\tdev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\"),\n\tencoder = __webpack_require__(/*! can-attribute-encoder */ \"./node_modules/can-attribute-encoder/can-attribute-encoder.js\");\n\nfunction each(items, callback){\n\tfor ( var i = 0; i < items.length; i++ ) {\n\t\tcallback(items[i], i);\n\t}\n}\n\nfunction makeMap(str){\n\tvar obj = {}, items = str.split(\",\");\n\teach(items, function(name){\n\t\tobj[name] = true;\n\t});\n\treturn obj;\n}\n\nfunction handleIntermediate(intermediate, handler){\n\tfor(var i = 0, len = intermediate.length; i < len; i++) {\n\t\tvar item = intermediate[i];\n\t\thandler[item.tokenType].apply(handler, item.args);\n\t}\n\treturn intermediate;\n}\n\n//!steal-remove-start\nif (true) {\n\t//assign the function to a var to avoid jshint\n\t//\"Function declarations should not be placed in blocks\"\n\tvar countLines = function countLines(input) {\n\t\t// TODO: optimize?\n\t\treturn input.split('\\n').length - 1;\n\t};\n}\n//!steal-remove-end\n\nvar alphaNumeric = \"A-Za-z0-9\",\n\talphaNumericHU = \"-:_\"+alphaNumeric,\n\tmagicStart = \"{{\",\n\tendTag = new RegExp(\"^<\\\\/([\"+alphaNumericHU+\"]+)[^>]*>\"),\n\tmagicMatch = new RegExp(\"\\\\{\\\\{(![\\\\s\\\\S]*?!|[\\\\s\\\\S]*?)\\\\}\\\\}\\\\}?\",\"g\"),\n\tspace = /\\s/,\n\talphaRegex = new RegExp('['+ alphaNumeric + ']'),\n\tattributeRegexp = new RegExp(\"[\"+alphaNumericHU+\"]+\\s*=\\s*(\\\"[^\\\"]*\\\"|'[^']*')\");\n\n// Empty Elements - HTML 5\nvar empty = makeMap(\"area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed\");\n\n// Elements for which tag case matters - shouldn't be lowercased.\nvar caseMattersElements = makeMap(\"altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath\");\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar closeSelf = makeMap(\"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr\");\n\n// Special Elements (can contain anything)\nvar special = makeMap(\"script\");\n\n// Callback names on `handler`.\nvar tokenTypes = \"start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done\".split(\",\");\n\n//maps end characters to start characters\nvar startOppositesMap = {\"{\": \"}\", \"(\":\")\"};\n\nvar fn = function(){};\n\nvar HTMLParser = function (html, handler, returnIntermediate) {\n\tif(typeof html === \"object\") {\n\t\treturn handleIntermediate(html, handler);\n\t}\n\n\tvar intermediate = [];\n\thandler = handler || {};\n\tif(returnIntermediate) {\n\t\t// overwrite handlers so they add to intermediate\n\t\teach(tokenTypes, function(name){\n\t\t\tvar callback = handler[name] || fn;\n\t\t\thandler[name] = function(){\n\t\t\t\tif( callback.apply(this, arguments) !== false ) {\n\t\t\t\t\tvar end = arguments.length;\n\n\t\t\t\t\t// the intermediate is stringified in the compiled stache templates\n\t\t\t\t\t// so we want to trim the last item if it is the line number\n\t\t\t\t\tif (arguments[end - 1] === undefined) {\n\t\t\t\t\t\tend = arguments.length - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\t// but restore line number in dev mode\n\t\t\t\t\t\tend = arguments.length;\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tintermediate.push({\n\t\t\t\t\t\ttokenType: name,\n\t\t\t\t\t\targs: [].slice.call(arguments, 0, end),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tfunction parseStartTag(tag, tagName, rest, unary) {\n\t\ttagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();\n\n\t\tif (closeSelf[tagName] && stack.last() === tagName) {\n\t\t\tparseEndTag(\"\", tagName);\n\t\t}\n\n\t\tunary = empty[tagName] || !!unary;\n\t\thandler.start(tagName, unary, lineNo);\n\t\tif (!unary) {\n\t\t\tstack.push(tagName);\n\t\t}\n\n\t\t// find attribute or special\n\t\tHTMLParser.parseAttrs(rest, handler, lineNo);\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tlineNo += countLines(tag);\n\t\t}\n\t\t//!steal-remove-end\n\n\n\t\thandler.end(tagName, unary, lineNo);\n\n\t\tif(tagName === \"html\") {\n\t\t\tskipChars = true;\n\t\t}\n\t}\n\n\tfunction parseEndTag(tag, tagName) {\n\t\t// If no tag name is provided, clean shop\n\t\tvar pos;\n\t\tif (!tagName) {\n\t\t\tpos = 0;\n\t\t}\n\t\t// Find the closest opened tag of the same type\n\t\telse {\n\t\t\ttagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();\n\t\t\tfor (pos = stack.length - 1; pos >= 0; pos--) {\n\t\t\t\tif (stack[pos] === tagName) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (typeof tag === 'undefined') {\n\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\tif (handler.filename) {\n\t\t\t\t\t\tdev.warn(handler.filename + \": expected closing tag </\" + stack[pos] + \">\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdev.warn(\"expected closing tag </\" + stack[pos] + \">\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (pos < 0 || pos !== stack.length - 1) {\n\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\tif (handler.filename) {\n\t\t\t\t\t\tdev.warn(handler.filename + \":\" + lineNo + \": unexpected closing tag \" + tag + \" expected </\" + stack[stack.length - 1] + \">\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdev.warn(lineNo + \": unexpected closing tag \" + tag + \" expected </\" + stack[stack.length - 1] + \">\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (handler.filename) {\n\t\t\t\t\t\tdev.warn(handler.filename + \":\" + lineNo + \": unexpected closing tag \" + tag);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdev.warn(lineNo + \": unexpected closing tag \" + tag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif (pos >= 0) {\n\t\t\t// Close all the open elements, up the stack\n\t\t\tfor (var i = stack.length - 1; i >= pos; i--) {\n\t\t\t\tif (handler.close) {\n\t\t\t\t\thandler.close(stack[i], lineNo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the open elements from the stack\n\t\t\tstack.length = pos;\n\n\t\t\t// Don't add TextNodes after the <body> tag\n\t\t\tif(tagName === \"body\") {\n\t\t\t\tskipChars = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseMustache(mustache, inside){\n\t\tif(handler.special){\n\t\t\thandler.special(inside, lineNo);\n\t\t}\n\t}\n\n\tvar callChars = function(){\n\t\tif(charsText && !skipChars) {\n\t\t\tif(handler.chars) {\n\t\t\t\thandler.chars(charsText, lineNo);\n\t\t\t}\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tlineNo += countLines(charsText);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\n\t\tskipChars = false;\n\t\tcharsText = \"\";\n\t};\n\n\tvar index,\n\t\tchars,\n\t\tskipChars,\n\t\tmatch,\n\t\tlineNo,\n\t\tstack = [],\n\t\tlast = html,\n\t\t// an accumulating text for the next .chars callback\n\t\tcharsText = \"\";\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tlineNo = 1;\n\t}\n\t//!steal-remove-end\n\n\tstack.last = function () {\n\t\treturn this[this.length - 1];\n\t};\n\n\twhile (html) {\n\n\t\tchars = true;\n\n\t\t// Make sure we're not in a script or style element\n\t\tif (!stack.last() || !special[stack.last()]) {\n\n\t\t\t// Comment\n\t\t\tif (html.indexOf(\"<!--\") === 0) {\n\t\t\t\tindex = html.indexOf(\"-->\");\n\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tif (handler.comment) {\n\t\t\t\t\t\thandler.comment(html.substring(4, index), lineNo);\n\t\t\t\t\t}\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tlineNo += countLines(html.substring(0, index + 3));\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\thtml = html.substring(index + 3);\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t} else if (html.indexOf(\"</\") === 0) {\n\t\t\t\tmatch = html.match(endTag);\n\n\t\t\t\tif (match) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tmatch[0].replace(endTag, parseEndTag);\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tlineNo += countLines(html.substring(0, match[0].length));\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\thtml = html.substring(match[0].length);\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t\t// start tag\n\t\t\t} else if (html.indexOf(\"<\") === 0) {\n\t\t\t\tvar res = HTMLParser.searchStartTag(html);\n\n\t\t\t\tif(res) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tparseStartTag.apply(null, res.match);\n\n\t\t\t\t\thtml = res.html;\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t\t// magic tag\n\t\t\t} else if (html.indexOf(magicStart) === 0 ) {\n\t\t\t\tmatch = html.match(magicMatch);\n\n\t\t\t\tif (match) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tmatch[0].replace(magicMatch, parseMustache);\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tlineNo += countLines(html.substring(0, match[0].length));\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\thtml = html.substring(match[0].length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (chars) {\n\t\t\t\tindex = findBreak(html, magicStart);\n\t\t\t\tif(index === 0 && html === last) {\n\t\t\t\t\tcharsText += html.charAt(0);\n\t\t\t\t\thtml = html.substr(1);\n\t\t\t\t\tindex = findBreak(html, magicStart);\n\t\t\t\t}\n\n\t\t\t\tvar text = index < 0 ? html : html.substring(0, index);\n\t\t\t\thtml = index < 0 ? \"\" : html.substring(index);\n\n\t\t\t\tif (text) {\n\t\t\t\t\tcharsText += text;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\thtml = html.replace(new RegExp(\"([\\\\s\\\\S]*?)<\\/\" + stack.last() + \"[^>]*>\"), function (all, text) {\n\t\t\t\ttext = text.replace(/<!--([\\s\\S]*?)-->|<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1$2\");\n\t\t\t\tif (handler.chars) {\n\t\t\t\t\thandler.chars(text, lineNo);\n\t\t\t\t}\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tlineNo += countLines(text);\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\treturn \"\";\n\t\t\t});\n\n\t\t\tparseEndTag(\"\", stack.last());\n\t\t}\n\n\t\tif (html === last) {\n\t\t\tthrow new Error(\"Parse Error: \" + html);\n\t\t}\n\n\t\tlast = html;\n\t}\n\tcallChars();\n\t// Clean up any remaining tags\n\tparseEndTag();\n\n\n\thandler.done(lineNo);\n\treturn intermediate;\n};\n\nvar callAttrStart = function(state, curIndex, handler, rest, lineNo){\n\tvar attrName = rest.substring(typeof state.nameStart === \"number\" ? state.nameStart : curIndex, curIndex),\n\t\tnewAttrName = encoder.encode(attrName);\n\n\tstate.attrStart = newAttrName;\n\thandler.attrStart(state.attrStart, lineNo);\n\tstate.inName = false;\n};\n\nvar callAttrEnd = function(state, curIndex, handler, rest, lineNo){\n\tif(state.valueStart !== undefined && state.valueStart < curIndex) {\n\t\tvar val = rest.substring(state.valueStart, curIndex);\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tvar quotedVal, closedQuote;\n\t\t\tquotedVal = rest.substring(state.valueStart - 1, curIndex + 1);\n\t\t\tquotedVal = quotedVal.trim();\n\t\t\tclosedQuote = quotedVal.charAt(quotedVal.length - 1);\n\n\t\t\tif (state.inQuote !== closedQuote) {\n\t\t\t\tif (handler.filename) {\n\t\t\t\t\tdev.warn(handler.filename + \":\" + lineNo + \": End quote is missing for \" + val);\n\t\t\t\t} else {\n\t\t\t\t\tdev.warn(lineNo + \": End quote is missing for \" + val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t\thandler.attrValue(val, lineNo);\n\t}\n\t// if this never got to be inValue, like `DISABLED` then send a attrValue\n\t// else if(!state.inValue){\n\t// \thandler.attrValue(state.attrStart, lineNo);\n\t// }\n\n\thandler.attrEnd(state.attrStart, lineNo);\n\tstate.attrStart = undefined;\n\tstate.valueStart = undefined;\n\tstate.inValue = false;\n\tstate.inName = false;\n\tstate.lookingForEq = false;\n\tstate.inQuote = false;\n\tstate.lookingForName = true;\n};\n\nvar findBreak = function(str, magicStart) {\n\tvar magicLength = magicStart.length;\n\tfor(var i = 0, len = str.length; i < len; i++) {\n\t\tif(str[i] === \"<\" || str.substr(i, magicLength) === magicStart) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\nHTMLParser.parseAttrs = function(rest, handler, lineNo){\n\tif(!rest) {\n\t\treturn;\n\t}\n\n\tvar i = 0;\n\tvar curIndex;\n\tvar state = {\n\t\tinName: false,\n\t\tnameStart: undefined,\n\t\tinValue: false,\n\t\tvalueStart: undefined,\n\t\tinQuote: false,\n\t\tattrStart: undefined,\n\t\tlookingForName: true,\n\t\tlookingForValue: false,\n\t\tlookingForEq : false\n\t};\n\n\twhile(i < rest.length) {\n\t\tcurIndex = i;\n\t\tvar cur = rest.charAt(i);\n\t\ti++;\n\n\t\tif(magicStart === rest.substr(curIndex, magicStart.length) ) {\n\t\t\tif(state.inValue && curIndex > state.valueStart) {\n\t\t\t\thandler.attrValue(rest.substring(state.valueStart, curIndex), lineNo);\n\t\t\t}\n\t\t\t// `{{#foo}}DISABLED{{/foo}}`\n\t\t\telse if(state.inName && state.nameStart < curIndex) {\n\t\t\t\tcallAttrStart(state, curIndex, handler, rest, lineNo);\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t\t// foo={{bar}}\n\t\t\telse if(state.lookingForValue){\n\t\t\t\tstate.inValue = true;\n\t\t\t}\n\t\t\t// a {{bar}}\n\t\t\telse if(state.lookingForEq && state.attrStart) {\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\n\t\t\tmagicMatch.lastIndex = curIndex;\n\t\t\tvar match = magicMatch.exec(rest);\n\t\t\tif(match) {\n\t\t\t\thandler.special(match[1], lineNo);\n\t\t\t\t// i is already incremented\n\t\t\t\ti = curIndex + (match[0].length);\n\t\t\t\tif(state.inValue) {\n\t\t\t\t\tstate.valueStart = curIndex+match[0].length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(state.inValue) {\n\t\t\tif(state.inQuote) {\n\t\t\t\tif(cur === state.inQuote) {\n\t\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(space.test(cur)) {\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t}\n\t\t// if we hit an = outside a value\n\t\telse if(cur === \"=\" && (state.lookingForEq || state.lookingForName || state.inName)) {\n\t\t\t// if we haven't yet started this attribute `{{}}=foo` case:\n\t\t\tif(!state.attrStart) {\n\t\t\t\tcallAttrStart(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t\tstate.lookingForValue = true;\n\t\t\tstate.lookingForEq = false;\n\t\t\tstate.lookingForName = false;\n\t\t}\n\t\t// if we are currently in a name:\n\t\t//  when the name starts with `{` or `(`\n\t\t//  it isn't finished until the matching end character is found\n\t\t//  otherwise, a space finishes the name\n\t\telse if(state.inName) {\n\t\t\tvar started = rest[ state.nameStart ],\n\t\t\t\t\totherStart, otherOpposite;\n\t\t\tif(startOppositesMap[started] === cur) {\n\t\t\t\t//handle mismatched brackets: `{(})` or `({)}`\n\t\t\t\totherStart = started === \"{\" ? \"(\" : \"{\";\n\t\t\t\totherOpposite = startOppositesMap[otherStart];\n\n\t\t\t\tif(rest[curIndex+1] === otherOpposite){\n\t\t\t\t\tcallAttrStart(state, curIndex+2, handler, rest, lineNo);\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tcallAttrStart(state, curIndex+1, handler, rest, lineNo);\n\t\t\t\t}\n\n\t\t\t\tstate.lookingForEq = true;\n\t\t\t}\n\t\t\telse if(space.test(cur) && started !== \"{\" && started !== \"(\") {\n\t\t\t\t\tcallAttrStart(state, curIndex, handler, rest, lineNo);\n\t\t\t\t\tstate.lookingForEq = true;\n\t\t\t}\n\t\t}\n\t\telse if(state.lookingForName) {\n\t\t\tif(!space.test(cur)) {\n\t\t\t\t// might have just started a name, we need to close it\n\t\t\t\tif(state.attrStart) {\n\t\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t\t}\n\t\t\t\tstate.nameStart = curIndex;\n\t\t\t\tstate.inName = true;\n\t\t\t}\n\t\t}\n\t\telse if(state.lookingForValue) {\n\t\t\tif(!space.test(cur)) {\n\t\t\t\tstate.lookingForValue = false;\n\t\t\t\tstate.inValue = true;\n\t\t\t\tif(cur === \"'\" || cur === '\"') {\n\t\t\t\t\tstate.inQuote = cur;\n\t\t\t\t\tstate.valueStart = curIndex+1;\n\t\t\t\t} else {\n\t\t\t\t\tstate.valueStart = curIndex;\n\t\t\t\t}\n\t\t\t\t// if we are looking for a value\n\t\t\t\t// at the end of the loop we need callAttrEnd\n\t\t\t} else if (i === rest.length){\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(state.inName) {\n\t\tcallAttrStart(state, curIndex+1, handler, rest, lineNo);\n\t\tcallAttrEnd(state, curIndex+1, handler, rest, lineNo);\n\t} else if(state.lookingForEq || state.lookingForValue || state.inValue) {\n\t\tcallAttrEnd(state, curIndex+1, handler, rest, lineNo);\n\t}\n\tmagicMatch.lastIndex = 0;\n};\n\nHTMLParser.searchStartTag = function (html) {\n\tvar closingIndex = html.indexOf('>');\n\n\t// The first closing bracket we find might be in an attribute value.\n\t// Move through the attributes by regexp.\n\tvar attributeRange = attributeRegexp.exec(html.substring(1));\n\tvar afterAttributeOffset = 1;\n\t// if the closing index is after the next attribute...\n\twhile(attributeRange && closingIndex >= afterAttributeOffset + attributeRange.index) {\n\n\t\t// prepare to move to the attribute after this one by increasing the offset\n\t\tafterAttributeOffset += attributeRange.index + attributeRange[0].length;\n\t\t// if the closing index is before the new offset, then this closing index is inside\n\t\t//  an attribute value and should be ignored.  Find the *next* closing character.\n\t\twhile(closingIndex < afterAttributeOffset) {\n\t\t\tclosingIndex += html.substring(closingIndex + 1).indexOf('>') + 1;\n\t\t}\n\n\t\t// find the next attribute by starting from the new offset.\n\t\tattributeRange = attributeRegexp.exec(html.substring(afterAttributeOffset));\n\t}\n\n\t// if there is no closing bracket\n\t// <input class=\n\t// or if the tagName does not start with alphaNumer character\n\t// <_iaois>\n\t// it is not a startTag\n\tif(closingIndex === -1 || !(alphaRegex.test(html[1]))){\n\t\treturn null;\n\t}\n\n\tvar tagName, tagContent, match, rest = '', unary = '';\n\tvar startTag = html.substring(0, closingIndex + 1);\n\tvar isUnary = startTag[startTag.length-2] === '/';\n\tvar spaceIndex = startTag.search(space);\n\n\tif(isUnary){\n\t\tunary = '/';\n\t\ttagContent = startTag.substring(1, startTag.length-2).trim();\n\t} else {\n\t\ttagContent = startTag.substring(1, startTag.length-1).trim();\n\t}\n\n\tif(spaceIndex === -1){\n\t\ttagName = tagContent;\n\t} else {\n\t\t//spaceIndex needs to shift one to the left\n\t\tspaceIndex--;\n\t\ttagName = tagContent.substring(0, spaceIndex);\n\t\trest = tagContent.substring(spaceIndex);\n\t}\n\n\tmatch = [startTag, tagName, rest, unary];\n\n\treturn {\n\t\tmatch: match,\n\t\thtml: html.substring(startTag.length),\n\t};\n\n\n};\n\nmodule.exports = namespace.HTMLParser = HTMLParser;\n\n\n//# sourceURL=webpack:///./node_modules/can-view-parser/can-view-parser.js?");

/***/ }),

/***/ "./node_modules/can-view-scope/can-view-scope.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-view-scope/can-view-scope.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # can-view-scope.js\n//\n// This provides the ability to lookup values across a higherarchy of objects.  This is similar to\n// how closures work in JavaScript.\n//\n// This is done with the `Scope` type. It works by having a `_context` reference to\n// an object whose properties can be searched for values.  It also has a `_parent` reference\n// to the next Scope in which to check.  In this way, `Scope` is used to form a tree-like\n// structure.  Leaves and Nodes in the tree only point to their parent.\nvar stacheKey = __webpack_require__(/*! can-stache-key */ \"./node_modules/can-stache-key/can-stache-key.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar TemplateContext = __webpack_require__(/*! ./template-context */ \"./node_modules/can-view-scope/template-context.js\");\nvar makeComputeData = __webpack_require__(/*! ./compute_data */ \"./node_modules/can-view-scope/compute_data.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canLog = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"./node_modules/can-define-lazy-value/define-lazy-value.js\");\nvar stacheHelpers = __webpack_require__(/*! can-stache-helpers */ \"./node_modules/can-stache-helpers/can-stache-helpers.js\");\nvar LetContext = __webpack_require__(/*! ./let-context */ \"./node_modules/can-view-scope/let-context.js\");\n\n\n// ## Helpers\n\nfunction canHaveProperties(obj){\n\treturn obj != null;\n}\nfunction returnFalse(){\n\treturn false;\n}\n\n// ## Scope\n// Represents a node in the scope tree.\nfunction Scope(context, parent, meta) {\n\t// The object that will be looked on for values.\n\t// If the type of context is TemplateContext, there will be special rules for it.\n\tthis._context = context;\n\t// The next Scope object whose context should be looked on for values.\n\tthis._parent = parent;\n\t// If this is a special context, it can be labeled here.\n\t// Options are:\n\t// - `viewModel` - This is a viewModel. This is mostly used by can-component to make `scope.vm` work.\n\t// - `notContext` - This can't be looked within using `./` and `../`. It will be skipped.\n\t//   This is for virtual contexts like those used by `%index`. This is very much like\n\t//   `variable`.  Most things should switch to `variable` in the future.\n\t// - `special` - This can't be looked within using `./` and `../`. It will be skipped.\n\t//   This is for reading properties on the scope {{scope.index}}. It's different from variable\n\t//   because it's never lookup up like {{key}}.\n\t// - `variable` - This is used to define a variable (as opposed to \"normal\" context). These\n\t//   will also be skipped when using `./` and `../`.\n\tthis._meta = meta || {};\n\n\t// A cache that can be used to store computes used to look up within this scope.\n\t// For example if someone creates a compute to lookup `name`, another compute does not\n\t// need to be created.\n\tthis.__cache = {};\n}\n\nvar parentContextSearch = /(\\.\\.\\/)|(\\.\\/)|(this[\\.@])/g;\n\n// ## Static Methods\n// The following methods are exposed mostly for testing purposes.\nassign(Scope, {\n\t// ### Scope.read\n\t// Scope.read was moved to can-stache-key.read\n\t// can-stache-key.read reads properties from a parent. A much more complex version of getObject.\n\tread: stacheKey.read,\n\tTemplateContext: TemplateContext,\n\t// ### keyInfo(key)\n\t// Returns an object that details what the `key` means with the following:\n\t// ```js\n\t// {\n\t//   remainingKey, // what would be read on a context (or this)\n\t//   isScope, // if the scope itself is being read\n\t//   inScope, // if a key on the scope is being read\n\t//   parentContextWalkCount, // how many ../\n\t//   isContextBased // if a \"normal\" context is explicitly being read\n\t// }\n\t// ```\n\tkeyInfo: function(attr){\n\n\t\tif (attr === \"./\") {\n\t\t\tattr = \"this\";\n\t\t}\n\n\t\tvar info = {remainingKey: attr};\n\n\t\t// handle scope stuff first\n\t\tinfo.isScope = attr === \"scope\";\n\t\tif(info.isScope) {\n\t\t\treturn info;\n\t\t}\n\t\tvar firstSix = attr.substr(0, 6);\n\t\tinfo.isInScope =\n\t\t\tfirstSix === \"scope.\" ||\n\t\t\tfirstSix === \"scope@\";\n\t\tif(info.isInScope) {\n\t\t\tinfo.remainingKey = attr.substr(6);\n\t\t\treturn info;\n\t\t} else if(firstSix === \"scope/\") {\n\t\t\tinfo.walkScope = true;\n\t\t\tinfo.remainingKey = attr.substr(6);\n\t\t\treturn info;\n\t\t} else if(attr.substr(0, 7) === \"@scope/\") {\n\t\t\tinfo.walkScope = true;\n\t\t\tinfo.remainingKey = attr.substr(7);\n\t\t\treturn info;\n\t\t}\n\n\t\tinfo.parentContextWalkCount = 0;\n\t\t// Searches for `../` and other context specifiers\n\t\tinfo.remainingKey = attr.replace(parentContextSearch, function(token, parentContext, dotSlash, thisContext, index){\n\t\t\tinfo.isContextBased = true;\n\t\t\tif(parentContext !== undefined) {\n\t\t\t\tinfo.parentContextWalkCount++;\n\t\t\t}\n\t\t\treturn \"\";\n\t\t});\n\t\t// ../..\n\t\tif(info.remainingKey === \"..\") {\n\t\t\tinfo.parentContextWalkCount++;\n\t\t\tinfo.remainingKey = \"this\";\n\t\t}\n\t\telse if(info.remainingKey === \".\" || info.remainingKey === \"\") {\n\t\t\tinfo.remainingKey = \"this\";\n\t\t}\n\n\t\tif(info.remainingKey === \"this\") {\n\t\t\tinfo.isContextBased = true;\n\t\t}\n\t\treturn info;\n\t},\n\t// ### isTemplateContextOrCanNotHaveProperties\n\t// Returns `true` if a template context or a `null` or `undefined`\n\t// context.\n\tisTemplateContextOrCanNotHaveProperties: function(currentScope){\n\t\tvar currentContext = currentScope._context;\n\t\tif(currentContext instanceof TemplateContext) {\n\t\t\treturn true;\n\t\t} else if( !canHaveProperties(currentContext) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\t// ### shouldSkipIfSpecial\n\t// Return `true` if special.\n\tshouldSkipIfSpecial: function(currentScope){\n\t\tvar isSpecialContext = currentScope._meta.special === true;\n\t\tif (isSpecialContext === true) {\n\t\t\treturn true;\n\t\t}\n\t\tif( Scope.isTemplateContextOrCanNotHaveProperties(currentScope) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\t// ### shouldSkipEverythingButSpecial\n\t// Return `true` if not special.\n\tshouldSkipEverythingButSpecial: function(currentScope){\n\t\tvar isSpecialContext = currentScope._meta.special === true;\n\t\tif (isSpecialContext === false) {\n\t\t\treturn true;\n\t\t}\n\t\tif( Scope.isTemplateContextOrCanNotHaveProperties(currentScope) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\t// ### makeShouldExitOnSecondNormalContext\n\t// This will keep checking until we hit a second \"normal\" context.\n\tmakeShouldExitOnSecondNormalContext: function(){\n\t\tvar foundNormalContext = false;\n\t\treturn function shouldExitOnSecondNormalContext(currentScope){\n\t\t\tvar isNormalContext = !currentScope.isSpecial();\n\t\t\tvar shouldExit = isNormalContext && foundNormalContext;\n\t\t\t// leaks some state\n\t\t\tif(isNormalContext) {\n\t\t\t\tfoundNormalContext = true;\n\t\t\t}\n\t\t\treturn shouldExit;\n\t\t};\n\t},\n\t// ### makeShouldExitAfterFirstNormalContext\n\t// This will not check anything after the first normal context.\n\tmakeShouldExitAfterFirstNormalContext: function(){\n\t\tvar foundNormalContext = false;\n\t\treturn function shouldExitAfterFirstNormalContext(currentScope){\n\t\t\tif(foundNormalContext) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar isNormalContext = !currentScope.isSpecial();\n\t\t\t// leaks some state\n\t\t\tif(isNormalContext) {\n\t\t\t\tfoundNormalContext = true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t},\n\t// ### makeShouldSkipSpecialContexts\n\t// Skips `parentContextWalkCount` contexts. This is used to\n\t// walk past scopes when `../` is used.\n\tmakeShouldSkipSpecialContexts: function(parentContextWalkCount){\n\t\tvar walkCount = parentContextWalkCount || 0;\n\t\treturn function shouldSkipSpecialContexts(currentScope){\n\t\t\t// after walking past the correct number of contexts,\n\t\t\t// should not skip notContext scopes\n\t\t\t// so that ../foo can be used to read from a notContext scope\n\t\t\tif (walkCount < 0 && currentScope._meta.notContext) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif(currentScope.isSpecial()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\twalkCount--;\n\n\t\t\tif(walkCount < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t}\n});\n\n// ## Prototype methods\nassign(Scope.prototype, {\n\n\t// ### scope.add\n\t// Creates a new scope and sets the current scope to be the parent.\n\t// ```\n\t// var scope = new can.view.Scope([\n\t//   {name:\"Chris\"},\n\t//   {name: \"Justin\"}\n\t// ]).add({name: \"Brian\"});\n\t// scope.attr(\"name\") //-> \"Brian\"\n\t// ```\n\tadd: function(context, meta) {\n\t\tif (context !== this._context) {\n\t\t\treturn new this.constructor(context, this, meta);\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t},\n\n\t// ### scope.find\n\t// This is the equivalent of Can 3's scope walking.\n\tfind: function(attr, options) {\n\n\t\tvar keyReads = stacheKey.reads(attr);\n\t\tvar howToRead = {\n\t\t\tshouldExit: returnFalse,\n\t\t\tshouldSkip: Scope.shouldSkipIfSpecial,\n\t\t\tshouldLookForHelper: true,\n\t\t\tread: stacheKey.read\n\t\t};\n\t\tvar result = this._walk(keyReads, options, howToRead);\n\n\t\treturn result.value;\n\n\t},\n\t// ### scope.readFromSpecialContext\n\treadFromSpecialContext: function(key) {\n\t\treturn this._walk(\n\t\t\t[{key: key, at: false }],\n\t\t\t{ special: true },\n\t\t\t{\n\t\t\t\tshouldExit: returnFalse,\n\t\t\t\tshouldSkip: Scope.shouldSkipEverythingButSpecial,\n\t\t\t\tshouldLookForHelper: false,\n\t\t\t\tread: stacheKey.read\n\t\t\t}\n\t\t);\n\t},\n\n\t// ### scope.readFromTemplateContext\n\treadFromTemplateContext: function(key, readOptions) {\n\t\tvar keyReads = stacheKey.reads(key);\n\t\treturn stacheKey.read(this.templateContext, keyReads, readOptions);\n\t},\n\n\t// ### Scope.prototype.read\n\t// Reads from the scope chain and returns the first non-`undefined` value.\n\t// `read` deals mostly with setting up \"context based\" keys to start reading\n\t// from the right scope. Once the right scope is located, `_walk` is called.\n\t/**\n\t * @hide\n\t * @param {can.stache.key} attr A dot-separated path. Use `\"\\.\"` if you have a property name that includes a dot.\n\t * @param {can.view.Scope.readOptions} options that configure how this gets read.\n\t * @return {{}}\n\t *   @option {Object} parent the value's immediate parent\n\t *   @option {can.Map|can.compute} rootObserve the first observable to read from.\n\t *   @option {Array<String>} reads An array of properties that can be used to read from the rootObserve to get the value.\n\t *   @option {*} value the found value\n\t */\n\tread: function(attr, options) {\n\t\toptions = options || {};\n\t\treturn this.readKeyInfo(Scope.keyInfo(attr), options || {});\n\t},\n\treadKeyInfo: function(keyInfo, options){\n\n\t\t// Identify context based keys. Context based keys try to\n\t\t// specify a particular context a key should be within.\n\t\tvar readValue,\n\t\t\tkeyReads,\n\t\t\thowToRead = {\n\t\t\t\tread: options.read || stacheKey.read\n\t\t\t};\n\n\t\t// 1.A. Handle reading the scope itself\n\t\tif (keyInfo.isScope) {\n\t\t\treturn { value: this };\n\t\t}\n\t\t// 1.B. Handle reading something on the scope\n\t\telse if (keyInfo.isInScope) {\n\t\t\tkeyReads = stacheKey.reads(keyInfo.remainingKey);\n\t\t\t// check for a value on Scope.prototype\n\t\t\treadValue = stacheKey.read(this, keyReads, options);\n\n\t\t\t// otherwise, check the templateContext\n\t\t\tif (typeof readValue.value === 'undefined' && !readValue.parentHasKey) {\n\t\t\t\treadValue = this.readFromTemplateContext(keyInfo.remainingKey, options);\n\t\t\t}\n\n\t\t\treturn assign(readValue, {\n\t\t\t\tthisArg: keyReads.length > 0 ? readValue.parent : undefined\n\t\t\t});\n\t\t}\n\t\t// 1.C. Handle context-based reads. They should skip over special stuff.\n\t\t// this.key, ../.., .././foo\n\t\telse if (keyInfo.isContextBased) {\n\t\t\t// TODO: REMOVE\n\t\t\t// options && options.special === true && console.warn(\"SPECIAL!!!!\");\n\n\t\t\tif(keyInfo.remainingKey !== \"this\") {\n\t\t\t\tkeyReads = stacheKey.reads(keyInfo.remainingKey);\n\t\t\t} else {\n\t\t\t\tkeyReads = [];\n\t\t\t}\n\t\t\thowToRead.shouldExit = Scope.makeShouldExitOnSecondNormalContext();\n\t\t\thowToRead.shouldSkip = Scope.makeShouldSkipSpecialContexts(keyInfo.parentContextWalkCount);\n\t\t\thowToRead.shouldLookForHelper = true;\n\n\t\t\treturn this._walk(keyReads, options, howToRead);\n\t\t}\n\t\t// 1.D. Handle scope walking with scope/key\n\t\telse if(keyInfo.walkScope) {\n\t\t\thowToRead.shouldExit = returnFalse;\n\t\t\thowToRead.shouldSkip = Scope.shouldSkipIfSpecial;\n\t\t\thowToRead.shouldLookForHelper = true;\n\t\t\tkeyReads = stacheKey.reads(keyInfo.remainingKey);\n\n\t\t\treturn this._walk(keyReads, options, howToRead);\n\t\t}\n\t\t// 1.E. Handle reading without context clues\n\t\t// {{foo}}\n\t\telse {\n\t\t\tkeyReads = stacheKey.reads(keyInfo.remainingKey);\n\n\t\t\tvar isSpecialRead = options && options.special === true;\n\t\t\t// TODO: remove\n\t\t\t// options && options.special === true && console.warn(\"SPECIAL!!!!\");\n\n\t\t\thowToRead.shouldExit = Scope.makeShouldExitOnSecondNormalContext();\n\t\t\thowToRead.shouldSkip = isSpecialRead ? Scope.shouldSkipEverythingButSpecial : Scope.shouldSkipIfSpecial;\n\t\t\thowToRead.shouldLookForHelper = isSpecialRead ? false : true;\n\n\t\t\treturn this._walk(keyReads, options, howToRead);\n\t\t}\n\t},\n\n\n\t// ### scope._walk\n\t// This is used to walk up the scope chain.\n\t_walk: function(keyReads, options, howToRead) {\n\t\t// The current scope and context we are trying to find \"keyReads\" within.\n\t\tvar currentScope = this,\n\t\t\tcurrentContext,\n\n\t\t\t// If no value can be found, this is a list of of every observed\n\t\t\t// object and property name to observe.\n\t\t\tundefinedObserves = [],\n\n\t\t\t// Tracks the first found observe.\n\t\t\tcurrentObserve,\n\t\t\t// Tracks the reads to get the value from `currentObserve`.\n\t\t\tcurrentReads,\n\n\t\t\t// Tracks the most likely observable to use as a setter.\n\t\t\tsetObserveDepth = -1,\n\t\t\tcurrentSetReads,\n\t\t\tcurrentSetObserve,\n\n\t\t\treadOptions = assign({\n\t\t\t\t/* Store found observable, incase we want to set it as the rootObserve. */\n\t\t\t\tfoundObservable: function(observe, nameIndex) {\n\t\t\t\t\tcurrentObserve = observe;\n\t\t\t\t\tcurrentReads = keyReads.slice(nameIndex);\n\t\t\t\t},\n\t\t\t\tearlyExit: function(parentValue, nameIndex) {\n\t\t\t\t\tvar isVariableScope = currentScope._meta.variable === true,\n\t\t\t\t\t\tupdateSetObservable = false;\n\t\t\t\t\tif(isVariableScope === true && nameIndex === 0) {\n\t\t\t\t\t\t// we MUST have pre-defined the key in a variable scope\n\t\t\t\t\t\tupdateSetObservable = canReflect.hasKey( parentValue, keyReads[nameIndex].key);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdateSetObservable =\n\t\t\t\t\t\t\t// Has more matches\n\t\t\t\t\t\t\tnameIndex > setObserveDepth ||\n\t\t\t\t\t\t\t// The same number of matches but it has the key\n\t\t\t\t\t\t\tnameIndex === setObserveDepth && (typeof parentValue === \"object\" && canReflect.hasOwnKey( parentValue, keyReads[nameIndex].key));\n\t\t\t\t\t}\n\t\t\t\t\tif ( updateSetObservable ) {\n\t\t\t\t\t\tcurrentSetObserve = currentObserve;\n\t\t\t\t\t\tcurrentSetReads = currentReads;\n\t\t\t\t\t\tsetObserveDepth = nameIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, options);\n\n\n\n\t\tvar isRecording = ObservationRecorder.isRecording(),\n\t\t\treadAContext = false;\n\n\t\t// Goes through each scope context provided until it finds the key (attr). Once the key is found\n\t\t// then it's value is returned along with an observe, the current scope and reads.\n\t\t// While going through each scope context searching for the key, each observable found is returned and\n\t\t// saved so that either the observable the key is found in can be returned, or in the case the key is not\n\t\t// found in an observable the closest observable can be returned.\n\t\twhile (currentScope) {\n\n\t\t\tif(howToRead.shouldSkip(currentScope) === true) {\n\t\t\t\tcurrentScope = currentScope._parent;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(howToRead.shouldExit(currentScope) === true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treadAContext = true;\n\n\t\t\tcurrentContext = currentScope._context;\n\n\n\t\t\t// Prevent computes from temporarily observing the reading of observables.\n\t\t\tvar getObserves = ObservationRecorder.trap();\n\n\t\t\tvar data = howToRead.read(currentContext, keyReads, readOptions);\n\n\t\t\t// Retrieve the observes that were read.\n\t\t\tvar observes = getObserves();\n\t\t\t// If a **value was was found**, return value and location data.\n\t\t\tif (data.value !== undefined || data.parentHasKey) {\n\n\t\t\t\tif(!observes.length && isRecording) {\n\t\t\t\t\t// if we didn't actually observe anything\n\t\t\t\t\t// the reads and currentObserve don't mean anything\n\t\t\t\t\t// we just point to the current object so setting is fast\n\t\t\t\t\tcurrentObserve = data.parent;\n\t\t\t\t\tcurrentReads = keyReads.slice(keyReads.length - 1);\n\t\t\t\t} else {\n\t\t\t\t\tObservationRecorder.addMany(observes);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tscope: currentScope,\n\t\t\t\t\trootObserve: currentObserve,\n\t\t\t\t\tvalue: data.value,\n\t\t\t\t\treads: currentReads,\n\t\t\t\t\tthisArg: data.parent,\n\t\t\t\t\tparentHasKey: data.parentHasKey\n\t\t\t\t};\n\t\t\t}\n\t\t\t// Otherwise, save all observables that were read. If no value\n\t\t\t// is found, we will observe on all of them.\n\t\t\telse {\n\t\t\t\tundefinedObserves.push.apply(undefinedObserves, observes);\n\t\t\t}\n\n\t\t\tcurrentScope = currentScope._parent;\n\t\t}\n\n\t\t// The **value was not found** in the scope\n\t\t// if not looking for a \"special\" key, check in can-stache-helpers\n\t\tif (howToRead.shouldLookForHelper) {\n\t\t\tvar helper = this.getHelperOrPartial(keyReads);\n\n\t\t\tif (helper && helper.value) {\n\t\t\t\t// Don't return parent so `.bind` is not used.\n\t\t\t\treturn {value: helper.value};\n\t\t\t}\n\t\t}\n\n\t\t// The **value was not found**, return `undefined` for the value.\n\t\t// Make sure we listen to everything we checked for when the value becomes defined.\n\t\t// Once it becomes defined, we won't have to listen to so many things.\n\t\tObservationRecorder.addMany(undefinedObserves);\n\t\treturn {\n\t\t\tsetRoot: currentSetObserve,\n\t\t\treads: currentSetReads,\n\t\t\tvalue: undefined,\n\t\t\tnoContextAvailable: !readAContext\n\t\t};\n\t},\n\t// ### scope.getDataForScopeSet\n\t// Returns an object with data needed by `.set` to figure out what to set,\n\t// and how.\n\t// {\n\t//   parent: what is being set\n\t//   key: try setting a key value\n\t//   how: \"setValue\" | \"set\" | \"updateDeep\" | \"write\" | \"setKeyValue\"\n\t// }\n\t// This works by changing how `readKeyInfo` will read individual scopes.\n\t// Specifically, with something like `{{foo.bar}}` it will read `{{foo}}` and\n\t// only check if a `bar` property exists.\n\tgetDataForScopeSet: function getDataForScopeSet(key, options) {\n\t\tvar keyInfo = Scope.keyInfo(key);\n\t\tvar firstSearchedContext;\n\n\t\t// Overwrite the options to use this read.\n\t\tvar opts = assign({\n\t\t\t// This read is used by `._walk` to read from the scope.\n\t\t\t// This will use `hasKey` on the last property instead of reading it.\n\t\t\tread: function(context, keys){\n\n\t\t\t\t// If nothing can be found with the keys we are looking for, save the\n\t\t\t\t// first possible match.  This is where we will write to.\n\t\t\t\tif(firstSearchedContext === undefined && !(context instanceof LetContext)) {\n\t\t\t\t\tfirstSearchedContext = context;\n\t\t\t\t}\n\t\t\t\t// If we have multiple keys ...\n\t\t\t\tif(keys.length > 1) {\n\t\t\t\t\t// see if we can find the parent ...\n\t\t\t\t\tvar parentKeys = keys.slice(0, keys.length-1);\n\t\t\t\t\tvar parent = stacheKey.read(context, parentKeys, options).value;\n\n\t\t\t\t\t// If there is a parent, see if it has the last key\n\t\t\t\t\tif( parent != null && canReflect.hasKey(parent, keys[keys.length-1].key ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tparent: parent,\n\t\t\t\t\t\t\tparentHasKey: true,\n\t\t\t\t\t\t\tvalue: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If we have only one key, try to find a context with this key\n\t\t\t\telse if(keys.length === 1) {\n\t\t\t\t\tif( canReflect.hasKey(context, keys[0].key ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tparent: context,\n\t\t\t\t\t\t\tparentHasKey: true,\n\t\t\t\t\t\t\tvalue: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If we have no keys, we are reading `this`.\n\t\t\t\telse {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: context\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t},options);\n\n\n\t\t// Use the read above to figure out what we are probably writing to.\n\t\tvar readData = this.readKeyInfo(keyInfo, opts);\n\n\t\tif(keyInfo.remainingKey === \"this\") {\n\t\t\t// If we are setting a context, then return that context\n\t\t\treturn { parent: readData.value, how: \"setValue\" };\n\t\t}\n\t\t// Now we are trying to set a property on something.  Parent will\n\t\t// be the something we are setting a property on.\n\t\tvar parent;\n\n\t\tvar props = keyInfo.remainingKey.split(\".\");\n\t\tvar propName = props.pop();\n\n\t\t// If we got a `thisArg`, that's the parent.\n\t\tif(readData.thisArg) {\n\t\t\tparent = readData.thisArg;\n\t\t}\n\t\t// Otherwise, we didn't find anything, use the first searched context.\n\t\t// TODO: there is likely a bug here when trying to set foo.bar where nothing in the scope\n\t\t// has a foo.\n\t\telse if(firstSearchedContext) {\n\t\t\tparent = firstSearchedContext;\n\t\t}\n\n\t\tif (parent === undefined) {\n\t\t\treturn {\n\t\t\t\terror: \"Attempting to set a value at \" +\n\t\t\t\t\tkey + \" where the context is undefined.\"\n\t\t\t};\n\t\t}\n\t\t// Now we need to figure out how we would update this value.  The following does that.\n\t\tif(!canReflect.isObservableLike(parent) && canReflect.isObservableLike(parent[propName])) {\n\t\t\tif(canReflect.isMapLike(parent[propName])) {\n\t\t\t\treturn {\n\t\t\t\t\tparent: parent,\n\t\t\t\t\tkey: propName,\n\t\t\t\t\thow: \"updateDeep\",\n\t\t\t\t\twarn: \"can-view-scope: Merging data into \\\"\" +\n\t\t\t\t\t\tpropName + \"\\\" because its parent is non-observable\"\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if(canReflect.isValueLike(parent[propName])){\n\t\t\t\treturn { parent: parent, key: propName, how: \"setValue\" };\n\t\t\t} else {\n\t\t\t\treturn { parent: parent, how: \"write\", key: propName, passOptions: true };\n\t\t\t}\n\t\t} else {\n\t\t\treturn { parent: parent, how: \"write\", key: propName, passOptions: true };\n\t\t}\n\t},\n\n\t// ### scope.getHelper\n\t// read a helper from the templateContext or global helpers list\n\tgetHelper: function(keyReads) {\n\t\tconsole.warn(\".getHelper is deprecated, use .getHelperOrPartial\");\n\t\treturn this.getHelperOrPartial(keyReads);\n\t},\n\tgetHelperOrPartial: function(keyReads) {\n\t\t// try every template context\n\t\tvar scope = this, context, helper;\n\t\twhile (scope) {\n\t\t\tcontext = scope._context;\n\t\t\tif (context instanceof TemplateContext) {\n\t\t\t\thelper = stacheKey.read(context.helpers, keyReads, { proxyMethods: false });\n\t\t\t\tif(helper.value !== undefined) {\n\t\t\t\t\treturn helper;\n\t\t\t\t}\n\t\t\t\thelper = stacheKey.read(context.partials, keyReads, { proxyMethods: false });\n\t\t\t\tif(helper.value !== undefined) {\n\t\t\t\t\treturn helper;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscope = scope._parent;\n\t\t}\n\n\t\treturn stacheKey.read(stacheHelpers, keyReads, { proxyMethods: false });\n\t},\n\n\t// ### scope.get\n\t// Gets a value from the scope without being observable.\n\tget: function(key, options) {\n\n\t\toptions = assign({\n\t\t\tisArgument: true\n\t\t}, options);\n\n\t\tvar res = this.read(key, options);\n\t\treturn res.value;\n\t},\n\tpeek: ObservationRecorder.ignore(function(key, options) {\n\t\treturn this.get(key, options);\n\t}),\n\t// TODO: Remove in 6.0\n\tpeak: ObservationRecorder.ignore(function(key, options) {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tcanLog.warn('peak is deprecated, please use peek instead');\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn this.peek(key, options);\n\t}),\n\t// ### scope.getScope\n\t// Returns the first scope that passes the `tester` function.\n\tgetScope: function(tester) {\n\t\tvar scope = this;\n\t\twhile (scope) {\n\t\t\tif (tester(scope)) {\n\t\t\t\treturn scope;\n\t\t\t}\n\t\t\tscope = scope._parent;\n\t\t}\n\t},\n\t// ### scope.getContext\n\t// Returns the first context whose scope passes the `tester` function.\n\tgetContext: function(tester) {\n\t\tvar res = this.getScope(tester);\n\t\treturn res && res._context;\n\t},\n\t// ### scope.getTemplateContext\n\t// Returns the template context scope\n\t// This function isn't named right.\n\tgetTemplateContext: function() {\n\t\tvar lastScope;\n\n\t\t// find the first reference scope\n\t\tvar templateContext = this.getScope(function(scope) {\n\t\t\tlastScope = scope;\n\t\t\treturn scope._context instanceof TemplateContext;\n\t\t});\n\n\t\t// if there is no reference scope, add one as the root\n\t\tif(!templateContext) {\n\t\t\ttemplateContext = new Scope(new TemplateContext());\n\n\t\t\t// add templateContext to root of the scope chain so it\n\t\t\t// can be found using `getScope` next time it is looked up\n\t\t\tlastScope._parent = templateContext;\n\t\t}\n\t\treturn templateContext;\n\t},\n\taddTemplateContext: function(){\n\t\treturn this.add(new TemplateContext());\n\t},\n\taddLetContext: function(values){\n\t\treturn this.add(new LetContext(values || {}), {variable: true});\n\t},\n\t// ### scope.getRoot\n\t// Returns the top most context that is not a references scope.\n\t// Used by `.read` to provide `%root`.\n\tgetRoot: function() {\n\t\tvar cur = this,\n\t\t\tchild = this;\n\n\t\twhile (cur._parent) {\n\t\t\tchild = cur;\n\t\t\tcur = cur._parent;\n\t\t}\n\n\t\tif (cur._context instanceof TemplateContext) {\n\t\t\tcur = child;\n\t\t}\n\t\treturn cur._context;\n\t},\n\n\t// first viewModel scope\n\tgetViewModel: function() {\n\t\tvar vmScope = this.getScope(function(scope) {\n\t\t\treturn scope._meta.viewModel;\n\t\t});\n\n\t\treturn vmScope && vmScope._context;\n\t},\n\n\t// _top_ viewModel scope\n\tgetTop: function() {\n\t\tvar top;\n\n\t\tthis.getScope(function(scope) {\n\t\t\tif (scope._meta.viewModel) {\n\t\t\t\ttop = scope;\n\t\t\t}\n\n\t\t\t// walk entire scope tree\n\t\t\treturn false;\n\t\t});\n\n\t\treturn top && top._context;\n\t},\n\n\t// ### scope.getPathsForKey\n\t// Finds all paths that will return a value for a specific key\n\t// NOTE: this is for development purposes only and is removed in production\n\tgetPathsForKey: function getPathsForKey(key) {\n\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\tvar paths = {};\n\n\t\t\tvar getKeyDefinition = function(obj, key) {\n\t\t\t\tif (!obj || typeof obj !== \"object\") {\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\n\t\t\t\tvar keyExistsOnObj = key in obj;\n\t\t\t\tvar objHasKey = canReflect.hasKey(obj, key);\n\n\t\t\t\treturn {\n\t\t\t\t\tisDefined: keyExistsOnObj || objHasKey,\n\t\t\t\t\tisFunction: keyExistsOnObj && typeof obj[key] === \"function\"\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// scope.foo@bar -> bar\n\t\t\tvar reads = stacheKey.reads(key);\n\t\t\tvar keyParts = reads.map(function(read) {\n\t\t\t\treturn read.key;\n\t\t\t});\n\t\t\tvar scopeIndex = keyParts.indexOf(\"scope\");\n\n\t\t\tif (scopeIndex > -1) {\n\t\t\t\tkeyParts.splice(scopeIndex, 2);\n\t\t\t}\n\t\t\tvar normalizedKey = keyParts.join(\".\");\n\n\t\t\t// check scope.vm.<key>\n\t\t\tvar vm = this.getViewModel();\n\t\t\tvar vmKeyDefinition = getKeyDefinition(vm, normalizedKey);\n\n\t\t\tif (vmKeyDefinition.isDefined) {\n\t\t\t\tpaths[\"scope.vm.\" + normalizedKey + (vmKeyDefinition.isFunction ? \"()\" : \"\")] = vm;\n\t\t\t}\n\n\t\t\t// check scope.top.<key>\n\t\t\tvar top = this.getTop();\n\t\t\tvar topKeyDefinition = getKeyDefinition(top, normalizedKey);\n\n\t\t\tif (topKeyDefinition.isDefined) {\n\t\t\t\tpaths[\"scope.top.\" + normalizedKey + (topKeyDefinition.isFunction ? \"()\" : \"\")] = top;\n\t\t\t}\n\n\t\t\t// find specific paths (like ../key)\n\t\t\tvar cur = \"\";\n\n\t\t\tthis.getScope(function(scope) {\n\t\t\t\t// `notContext` and `special` contexts can't be read using `../`\n\t\t\t\tvar canBeRead = !scope.isSpecial();\n\n\t\t\t\tif (canBeRead) {\n\t\t\t\t\tvar contextKeyDefinition = getKeyDefinition(scope._context, normalizedKey);\n\t\t\t\t\tif (contextKeyDefinition.isDefined) {\n\t\t\t\t\t\tpaths[cur + normalizedKey + (contextKeyDefinition.isFunction ? \"()\" : \"\")] = scope._context;\n\t\t\t\t\t}\n\n\t\t\t\t\tcur += \"../\";\n\t\t\t\t}\n\n\t\t\t\t// walk entire scope tree\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\t\treturn paths;\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\n\t// ### scope.hasKey\n\t// returns whether or not this scope has the key\n\thasKey: function hasKey(key) {\n\t\tvar reads = stacheKey.reads(key);\n\t\tvar readValue;\n\n\t\tif (reads[0].key === \"scope\") {\n\t\t\t// read properties like `scope.vm.foo` directly from the scope\n\t\t\treadValue = stacheKey.read(this, reads.slice(1), key);\n\t\t} else {\n\t\t\t// read normal properties from the scope's context\n\t\t\treadValue = stacheKey.read(this._context, reads, key);\n\t\t}\n\n\t\treturn readValue.foundLastParent && readValue.parentHasKey;\n\t},\n\n\tset: function(key, value, options) {\n\t\toptions = options || {};\n\n\t\tvar data = this.getDataForScopeSet(key, options);\n\t\tvar parent = data.parent;\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (data.error) {\n\t\t\t\treturn canLog.error(data.error);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif (data.warn) {\n\t\t\tcanLog.warn(data.warn);\n\t\t}\n\n\t\tswitch (data.how) {\n\t\t\tcase \"set\":\n\t\t\t\tparent.set(data.key, value, data.passOptions ? options : undefined);\n\t\t\t\tbreak;\n\n\t\t\tcase \"write\":\n\t\t\t\tstacheKey.write(parent, data.key, value, options);\n\t\t\t\tbreak;\n\n\t\t\tcase \"setValue\":\n\t\t\t\tcanReflect.setValue(\"key\" in data ? parent[data.key] : parent, value);\n\t\t\t\tbreak;\n\n\t\t\tcase \"setKeyValue\":\n\t\t\t\tcanReflect.setKeyValue(parent, data.key, value);\n\t\t\t\tbreak;\n\n\t\t\tcase \"updateDeep\":\n\t\t\t\tcanReflect.updateDeep(parent[data.key], value);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\t// ### scope.attr\n\t// Gets or sets a value in the scope without being observable.\n\tattr: ObservationRecorder.ignore(function(key, value, options) {\n\t\tcanLog.warn(\"can-view-scope::attr is deprecated, please use peek, get or set\");\n\n\t\toptions = assign({\n\t\t\tisArgument: true\n\t\t}, options);\n\n\t\t// Allow setting a value on the context\n\t\tif (arguments.length === 2) {\n\t\t\treturn this.set(key, value, options);\n\n\t\t} else {\n\t\t\treturn this.get(key, options);\n\t\t}\n\t}),\n\n\t// ### scope.computeData\n\t// Finds the first location of the key in the scope and then provides a get-set compute that represents the key's value\n\t// and other information about where the value was found.\n\tcomputeData: function(key, options) {\n\t\treturn makeComputeData(this, key, options);\n\t},\n\n\t// ### scope.compute\n\t// Provides a get-set compute that represents a key's value.\n\tcompute: function(key, options) {\n\t\treturn this.computeData(key, options)\n\t\t\t.compute;\n\t},\n\t// ### scope.cloneFromRef\n\t//\n\t// This takes a scope and essentially copies its chain from\n\t// right before the last TemplateContext. And it does not include the ref.\n\t// this is a helper function to provide lexical semantics for refs.\n\t// This will not be needed for leakScope: false.\n\tcloneFromRef: function() {\n\t\tvar scopes = [];\n\t\tvar scope = this,\n\t\t\tcontext,\n\t\t\tparent;\n\t\twhile (scope) {\n\t\t\tcontext = scope._context;\n\t\t\tif (context instanceof TemplateContext) {\n\t\t\t\tparent = scope._parent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tscopes.unshift(scope);\n\t\t\tscope = scope._parent;\n\t\t}\n\t\tif (parent) {\n\t\t\tscopes.forEach(function(scope) {\n\t\t\t\t// For performance, re-use _meta, don't copy it.\n\t\t\t\tparent = parent.add(scope._context, scope._meta);\n\t\t\t});\n\t\t\treturn parent;\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t},\n\tisSpecial: function(){\n\t\treturn this._meta.notContext || this._meta.special || (this._context instanceof TemplateContext) || this._meta.variable;\n\t}\n});\n// Legacy name for _walk.\nScope.prototype._read = Scope.prototype._walk;\n\ncanReflect.assignSymbols(Scope.prototype, {\n\t\"can.hasKey\": Scope.prototype.hasKey\n});\n\nvar templateContextPrimitives = [\n\t\"filename\", \"lineNumber\"\n];\n\n// create getters/setters for primitives on the templateContext\n// scope.filename -> scope.readFromTemplateContext(\"filename\")\ntemplateContextPrimitives.forEach(function(key) {\n\tObject.defineProperty(Scope.prototype, key, {\n\t\tget: function() {\n\t\t\treturn this.readFromTemplateContext(key).value;\n\t\t},\n\t\tset: function(val) {\n\t\t\tthis.templateContext[key] = val;\n\t\t}\n\t});\n});\n\ndefineLazyValue(Scope.prototype, 'templateContext', function() {\n\treturn this.getTemplateContext()._context;\n});\n\ndefineLazyValue(Scope.prototype, 'root', function() {\n\tcanLog.warn('`scope.root` is deprecated. Use either `scope.top`: https://canjs.com/doc/can-stache/keys/scope.html#scope_top or `scope.vm`: https://canjs.com/doc/can-stache/keys/scope.html#scope_vm instead.');\n\treturn this.getRoot();\n});\n\ndefineLazyValue(Scope.prototype, 'vm', function() {\n\treturn this.getViewModel();\n});\n\ndefineLazyValue(Scope.prototype, 'top', function() {\n\treturn this.getTop();\n});\n\ndefineLazyValue(Scope.prototype, 'helpers', function() {\n\treturn stacheHelpers;\n});\n\nvar specialKeywords = [\n\t'index', 'key', 'element',\n\t'event', 'viewModel','arguments',\n\t'helperOptions', 'args'\n];\n\n// create getters for \"special\" keys\n// scope.index -> scope.readFromSpecialContext(\"index\")\nspecialKeywords.forEach(function(key) {\n\tObject.defineProperty(Scope.prototype, key, {\n\t\tget: function() {\n\t\t\treturn this.readFromSpecialContext(key).value;\n\t\t}\n\t});\n});\n\n\n//!steal-remove-start\nif (true) {\n\tScope.prototype.log = function() {\n\t\tvar scope = this;\n\t    var indent = \"\";\n\t\tvar contextType = \"\";\n\t\twhile(scope) {\n\t\t\tcontextType = scope._meta.notContext ? \" (notContext)\" :\n\t\t\t\tscope._meta.special ? \" (special)\" : \"\";\n\t\t\tconsole.log(indent, canReflect.getName(scope._context) + contextType, scope._context);\n\t        scope = scope._parent;\n\t        indent += \" \";\n\t    }\n\t};\n}\n//!steal-remove-end\n\n\nnamespace.view = namespace.view || {};\nmodule.exports = namespace.view.Scope = Scope;\n\n\n//# sourceURL=webpack:///./node_modules/can-view-scope/can-view-scope.js?");

/***/ }),

/***/ "./node_modules/can-view-scope/compute_data.js":
/*!*****************************************************!*\
  !*** ./node_modules/can-view-scope/compute_data.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ScopeKeyData = __webpack_require__(/*! ./scope-key-data */ \"./node_modules/can-view-scope/scope-key-data.js\");\n\nmodule.exports = function(scope, key, options){\n\treturn new ScopeKeyData(scope, key, options || {\n\t\targs: []\n\t});\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-view-scope/compute_data.js?");

/***/ }),

/***/ "./node_modules/can-view-scope/let-context.js":
/*!****************************************************!*\
  !*** ./node_modules/can-view-scope/let-context.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var SimpleMap = __webpack_require__(/*! can-simple-map */ \"./node_modules/can-simple-map/can-simple-map.js\");\n\n// ### LetContext\n// Instances of this are used to create a `let` variable context.\n\n// Like Object.create, but only keeps Symbols and properties in `propertiesToKeep`\nfunction objectCreateWithSymbolsAndSpecificProperties(obj, propertiesToKeep) {\n\tvar newObj = {};\n\n\t// copy over all Symbols from obj\n\tif (\"getOwnPropertySymbols\" in Object) {\n\t\tObject.getOwnPropertySymbols(obj).forEach(function(key) {\n\t\t\tnewObj[key] = obj[key];\n\t\t});\n\t}\n\n\t// copy over specific properties from obj (also fake Symbols properties for IE support);\n\tObject.getOwnPropertyNames(obj).forEach(function(key) {\n\t\tif (propertiesToKeep.indexOf(key) >= 0 || key.indexOf(\"@@symbol\") === 0) {\n\t\t\tnewObj[key] = obj[key];\n\t\t}\n\t});\n\n\treturn Object.create(newObj);\n}\n\nvar LetContext = SimpleMap.extend(\"LetContext\", {});\nLetContext.prototype = objectCreateWithSymbolsAndSpecificProperties(SimpleMap.prototype, [\n\t// SimpleMap properties\n\t\"setup\",\n\t\"attr\",\n\t\"serialize\",\n\t\"get\",\n\t\"set\",\n\t\"log\",\n\t// required by SimpleMap properties\n\t\"dispatch\",\n\t// Construct properties (not added by can-event-queue)\n\t\"constructorExtends\",\n\t\"newInstance\",\n\t\"_inherit\",\n\t\"_defineProperty\",\n\t\"_overwrite\",\n\t\"instance\",\n\t\"extend\",\n\t\"ReturnValue\",\n\t\"setup\",\n\t\"init\"\n]);\nLetContext.prototype.constructor = LetContext;\n\nmodule.exports = LetContext;\n\n\n//# sourceURL=webpack:///./node_modules/can-view-scope/let-context.js?");

/***/ }),

/***/ "./node_modules/can-view-scope/make-compute-like.js":
/*!**********************************************************!*\
  !*** ./node_modules/can-view-scope/make-compute-like.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar singleReference = __webpack_require__(/*! can-single-reference */ \"./node_modules/can-single-reference/can-single-reference.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n\nvar Compute = function(newVal){\n\tif(arguments.length) {\n\t\treturn canReflect.setValue(this, newVal);\n\t} else {\n\t\treturn canReflect.getValue(this);\n\t}\n};\n\nmodule.exports = function(observable) {\n    var compute = Compute.bind(observable);\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tObject.defineProperty(compute, \"name\", {\n\t\t\tvalue: \"Compute<\"+canReflect.getName(observable) + \">\",\n\t\t});\n\t}\n\t//!steal-remove-end\n\n    compute.on = compute.bind = compute.addEventListener = function(event, handler) {\n        var translationHandler = function(newVal, oldVal) {\n            handler.call(compute, {type:'change'}, newVal, oldVal);\n        };\n        singleReference.set(handler, this, translationHandler);\n        observable.on(translationHandler);\n    };\n    compute.off = compute.unbind = compute.removeEventListener = function(event, handler) {\n        observable.off( singleReference.getAndDelete(handler, this) );\n    };\n\n    canReflect.assignSymbols(compute, {\n        \"can.getValue\": function(){\n            return canReflect.getValue(observable);\n        },\n        \"can.setValue\": function(newVal){\n            return canReflect.setValue(observable, newVal);\n        },\n        \"can.onValue\": function(handler, queue){\n            return canReflect.onValue(observable, handler, queue);\n        },\n        \"can.offValue\": function(handler, queue){\n            return canReflect.offValue(observable, handler, queue);\n        },\n        \"can.valueHasDependencies\": function(){\n            return canReflect.valueHasDependencies(observable);\n        },\n        \"can.getPriority\": function(){\n    \t\treturn canReflect.getPriority( observable );\n    \t},\n    \t\"can.setPriority\": function(newPriority){\n    \t\tcanReflect.setPriority( observable, newPriority );\n    \t},\n\t\t\"can.isValueLike\": true,\n\t\t\"can.isFunctionLike\": false\n    });\n    compute.isComputed = true;\n    return compute;\n};\n\n\n//# sourceURL=webpack:///./node_modules/can-view-scope/make-compute-like.js?");

/***/ }),

/***/ "./node_modules/can-view-scope/scope-key-data.js":
/*!*******************************************************!*\
  !*** ./node_modules/can-view-scope/scope-key-data.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observation = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\nvar observeReader = __webpack_require__(/*! can-stache-key */ \"./node_modules/can-stache-key/can-stache-key.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"./node_modules/can-symbol/can-symbol.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar makeComputeLike = __webpack_require__(/*! ./make-compute-like */ \"./node_modules/can-view-scope/make-compute-like.js\");\nvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"./node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"./node_modules/can-event-queue/value/value.js\");\nvar stacheHelpers = __webpack_require__(/*! can-stache-helpers */ \"./node_modules/can-stache-helpers/can-stache-helpers.js\");\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"./node_modules/can-log/dev/dev.js\");\n\nvar dispatchSymbol = canSymbol.for(\"can.dispatch\");\nvar setElementSymbol = canSymbol.for(\"can.setElement\");\n\n// The goal of this is to create a high-performance compute that represents a key value from can.view.Scope.\n// If the key value is something like {{name}} and the context is a can.Map, a faster\n// binding path will be used where new rebindings don't need to be looked for with every change of\n// the observable property.\n// However, if the property changes to a compute, then the slower `can.compute.read` method of\n// observing values will be used.\n\n// ideally, we would know the order things were read.  If the last thing read\n// was something we can observe, and the value of it matched the value of the observation,\n// and the key matched the key of the observation\n// it's a fair bet that we can just listen to that last object.\n// If the `this` is not that object ... freak out.  Though `this` is not necessarily part of it.  can-observation could make\n// this work.\n\n\nvar getFastPathRoot = ObservationRecorder.ignore(function(computeData){\n\tif( computeData.reads &&\n\t\t\t\t// a single property read\n\t\t\t\tcomputeData.reads.length === 1 ) {\n\t\tvar root = computeData.root;\n\t\tif( root && root[canSymbol.for(\"can.getValue\")] ) {\n\t\t\troot = canReflect.getValue(root);\n\t\t}\n\t\t// on a map\n\t\treturn root && canReflect.isObservableLike(root) && canReflect.isMapLike(root) &&\n\t\t\t// that isn't calling a function\n\t\t\ttypeof root[computeData.reads[0].key] !== \"function\" && root;\n\t}\n\treturn;\n});\n\nvar isEventObject = function(obj){\n\treturn obj && typeof obj.batchNum === \"number\" && typeof obj.type === \"string\";\n};\n\nfunction getMutated(scopeKeyData){\n\t// The _thisArg is the value before the last `.`. For example if the key was `foo.bar.zed`,\n\t// _thisArg would be the value at foo.bar.\n\t// This should be improved as `foo.bar` might not be observable.\n\tvar value = ObservationRecorder.peekValue(scopeKeyData._thisArg);\n\n\t// Something like `string@split` would provide a primitive which can't be a mutated subject\n\treturn !canReflect.isPrimitive(value) ? value : scopeKeyData.root;\n}\n\nfunction callMutateWithRightArgs(method, mutated, reads, mutator){\n\tif(reads.length) {\n\t\tmethod.call(canReflectDeps,mutated, reads[ reads.length - 1 ].key ,mutator);\n\t} else {\n\t\tmethod.call(canReflectDeps,mutated ,mutator);\n\t}\n}\n\n\n\n\nvar warnOnUndefinedProperty;\n//!steal-remove-start\nif (true) {\n\twarnOnUndefinedProperty = function(options) {\n\t\tif ( options.key !== \"debugger\" && !options.parentHasKey) {\n\t\t\tvar filename = options.scope.peek('scope.filename');\n\t\t\tvar lineNumber = options.scope.peek('scope.lineNumber');\n\n\t\t\tvar reads = observeReader.reads(options.key);\n\t\t\tvar firstKey = reads[0].key;\n\t\t\tvar key = reads.map(function(read) {\n\t\t\t\treturn read.key + (read.at ? \"()\" : \"\");\n\t\t\t}).join(\".\");\n\t\t\tvar pathsForKey = options.scope.getPathsForKey(firstKey);\n\t\t\tvar paths = Object.keys( pathsForKey );\n\t\t\tvar firstKeyValue = options.scope.get(firstKey);\n\n\t\t\tvar includeSuggestions = paths.length && (paths.indexOf(firstKey) < 0);\n\n\t\t\tvar warning = [\n\t\t\t\t(filename ? filename + ':' : '') +\n\t\t\t\t\t(lineNumber ? lineNumber + ': ' : '') +\n\t\t\t\t\t'Unable to find key \"' + key + '\".'\n\t\t\t];\n\n\t\t\tif (includeSuggestions) {\n\t\t\t\twarning[0] = warning[0] + ' Did you mean' + (paths.length > 1 ? ' one of these' : '') + '?\\n';\n\t\t\t\tpaths.forEach(function(path) {\n\t\t\t\t\twarning.push('\\t\"' + path + '\" which will read from');\n\t\t\t\t\twarning.push(pathsForKey[path]);\n\t\t\t\t\twarning.push(\"\\n\");\n\t\t\t\t});\n\t\t\t} else if (firstKeyValue) {\n\t\t\t\twarning[0] = warning[0] + ' Found \"' + firstKey + '\" with value: %o\\n';\n\t\t\t}\n\n\t\t\tif (firstKeyValue) {\n\t\t\t\tdev.warn.apply(dev, [warning.join(\"\\n\"), firstKeyValue]);\n\t\t\t} else {\n\t\t\t\tdev.warn.apply(dev,\n\t\t\t\t\twarning\n\t\t\t\t);\n\t\t\t}\n\n\t\t}\n\t};\n}\n//!steal-remove-end\n\n// could we make this an observation first ... and have a getter for the compute?\n\n// This is a fast-path enabled Observation wrapper use many places in can-stache.\n// The goal of this is to:\n//\n// 1.  Make something that can be passed to can-view-live directly, hopefully\n//     avoiding creating expensive computes.  Instead we will only be creating\n//     `ScopeKeyData` which are thin wrappers.\nvar ScopeKeyData = function(scope, key, options){\n\n\tthis.startingScope = scope;\n\tthis.key = key;\n\tthis.read = this.read.bind(this);\n\tthis.dispatch = this.dispatch.bind(this);\n\n\t// special case debugger helper so that it is called with helperOtions\n\t// when you do {{debugger}} as it already is with {{debugger()}}\n\tif (key === \"debugger\") {\n\t\t// prevent \"Unable to find key\" warning\n\t\tthis.startingScope = { _context: stacheHelpers };\n\n\t\tthis.read = function() {\n\t\t\tvar helperOptions = { scope: scope };\n\t\t\tvar debuggerHelper = stacheHelpers[\"debugger\"];\n\t\t\treturn debuggerHelper(helperOptions);\n\t\t};\n\t}\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tObject.defineProperty(this.read, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".read\",\n\t\t});\n\t\tObject.defineProperty(this.dispatch, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".dispatch\",\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tvar observation = this.observation = new Observation(this.read, this);\n\tthis.options = assign({ observation: this.observation }, options);\n\n\t// things added later\n\tthis.fastPath = undefined;\n\tthis.root = undefined;\n\tthis.reads = undefined;\n\tthis.setRoot = undefined;\n\t// This is read by call expressions so it needs to be observable\n\tthis._thisArg = new SimpleObservable();\n\tthis.parentHasKey = undefined;\n\tvar valueDependencies = new Set();\n\tvalueDependencies.add(observation);\n\tthis.dependencies = {valueDependencies: valueDependencies};\n\n\t// This is basically what .get() should give, but it\n\t// isn't used to figure out the last value.\n\tthis._latestValue = undefined;\n};\n\nvalueEventBindings(ScopeKeyData.prototype);\n\nfunction fastOnBoundSet_Value() {\n\tthis._value = this.newVal;\n}\n\nfunction fastOnBoundSetValue() {\n\tthis.value = this.newVal;\n}\n\nassign(ScopeKeyData.prototype, {\n\tconstructor: ScopeKeyData,\n\tdispatch: function dispatch(newVal){\n\t\tvar old = this.value;\n\t\tthis._latestValue = this.value = newVal;\n\t\t// call the base implementation in can-event-queue\n\t\tthis[dispatchSymbol].call(this, this.value, old);\n\t},\n\tonBound: function onBound(){\n\t\tthis.bound = true;\n\t\tcanReflect.onValue(this.observation, this.dispatch, \"notify\");\n\t\t// TODO: we should check this sometime in the background.\n\t\tvar fastPathRoot = getFastPathRoot(this);\n\t\tif( fastPathRoot ) {\n\t\t\t// rewrite the observation to call its event handlers\n\t\t\tthis.toFastPath(fastPathRoot);\n\t\t}\n\t\tthis._latestValue = this.value = ObservationRecorder.peekValue(this.observation);\n\t},\n\tonUnbound: function onUnbound() {\n\t\tthis.bound = false;\n\t\tcanReflect.offValue(this.observation, this.dispatch, \"notify\");\n\t\tthis.toSlowPath();\n\t},\n\tset: function(newVal){\n\t\tvar root = this.root || this.setRoot;\n\t\tif(root) {\n\t\t\tif(this.reads.length) {\n\t\t\t\tobserveReader.write(root, this.reads, newVal, this.options);\n\t\t\t} else {\n\t\t\t\tcanReflect.setValue(root,newVal);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.startingScope.set(this.key, newVal, this.options);\n\t\t}\n\t},\n\tget: function() {\n\t\tif (ObservationRecorder.isRecording()) {\n\t\t\tObservationRecorder.add(this);\n\t\t\tif (!this.bound) {\n\t\t\t\tObservation.temporarilyBind(this);\n\t\t\t}\n\t\t}\n\n\t\tif (this.bound === true && this.fastPath === true) {\n\t\t\treturn this._latestValue;\n\t\t} else {\n\t\t\treturn ObservationRecorder.peekValue(this.observation);\n\t\t}\n\t},\n\ttoFastPath: function(fastPathRoot){\n\t\tvar self = this,\n\t\t\tobservation = this.observation;\n\n\t\tthis.fastPath = true;\n\n\t\t// there won't be an event in the future ...\n\t\tobservation.dependencyChange = function(target, newVal){\n\t\t\tif(isEventObject(newVal)) {\n\t\t\t\tthrow \"no event objects!\";\n\t\t\t}\n\t\t\t// but I think we will be able to get at it b/c there should only be one\n\t\t\t// dependency we are binding to ...\n\t\t\tif(target === fastPathRoot && typeof newVal !== \"function\") {\n\t\t\t\tself._latestValue = newVal;\n\t\t\t\tthis.newVal = newVal;\n\t\t\t} else {\n\t\t\t\t// restore\n\t\t\t\tself.toSlowPath();\n\t\t\t}\n\n\t\t\treturn Observation.prototype.dependencyChange.apply(this, arguments);\n\t\t};\n\n\t\tif (observation.hasOwnProperty(\"_value\")) {// can-observation 4.1+\n\t\t\tobservation.onBound = fastOnBoundSet_Value;\n\t\t} else {// can-observation < 4.1\n\t\t\tobservation.onBound = fastOnBoundSetValue;\n\t\t}\n\t},\n\ttoSlowPath: function(){\n\t\tthis.observation.dependencyChange = Observation.prototype.dependencyChange;\n\t\tthis.observation.onBound = Observation.prototype.onBound;\n\t\tthis.fastPath = false;\n\t},\n\tread: function(){\n\t\tvar data;\n\n\t\tif (this.root) {\n\t\t\t// if we've figured out a root observable, start reading from there\n\t\t\tdata = observeReader.read(this.root, this.reads, this.options);\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\t// remove old dependency\n\t\t\t\tif(this.reads.length) {\n\t\t\t\t\tcallMutateWithRightArgs(canReflectDeps.deleteMutatedBy, getMutated(this), this.reads,this);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\t// update thisArg and add new dependency\n\t\t\tthis.thisArg = data.parent;\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tvar valueDeps = new Set();\n\t\t\t\tvalueDeps.add(this);\n\t\t\t\tcallMutateWithRightArgs(canReflectDeps.addMutatedBy, data.parent || this.root, this.reads,{\n\t\t\t\t\tvalueDependencies: valueDeps\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn data.value;\n\t\t}\n\t\t// If the key has not already been located in a observable then we need to search the scope for the\n\t\t// key.  Once we find the key then we need to return it's value and if it is found in an observable\n\t\t// then we need to store the observable so the next time this compute is called it can grab the value\n\t\t// directly from the observable.\n\t\tdata = this.startingScope.read(this.key, this.options);\n\n\n\t\tthis.scope = data.scope;\n\t\tthis.reads = data.reads;\n\t\tthis.root = data.rootObserve;\n\t\tthis.setRoot = data.setRoot;\n\t\tthis.thisArg = data.thisArg;\n\t\tthis.parentHasKey = data.parentHasKey;\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (data.rootObserve) {\n\t\t\t\tvar rootValueDeps = new Set();\n\t\t\t\trootValueDeps.add(this);\n\t\t\t\tcallMutateWithRightArgs(canReflectDeps.addMutatedBy, getMutated(this), data.reads,{\n\t\t\t\t\tvalueDependencies: rootValueDeps\n\t\t\t\t});\n\t\t\t}\n\t\t\tif(data.value === undefined && this.options.warnOnMissingKey === true) {\n\t\t\t\twarnOnUndefinedProperty({\n\t\t\t\t\tscope: this.startingScope,\n\t\t\t\t\tkey: this.key,\n\t\t\t\t\tparentHasKey: data.parentHasKey\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn data.value;\n\t},\n\thasDependencies: function(){\n\t\t// ScopeKeyData is unique in that when these things are read, it will temporarily bind\n\t\t// to make sure the right value is returned. This is for can-stache.\n\t\t// Helpers warns about a missing helper.\n\t\tif (!this.bound) {\n\t\t\tObservation.temporarilyBind(this);\n\t\t}\n\t\treturn canReflect.valueHasDependencies( this.observation );\n\t}\n});\n\nObject.defineProperty(ScopeKeyData.prototype, \"thisArg\", {\n\tget: function(){\n\t\treturn this._thisArg.get();\n\t},\n\tset: function(newVal) {\n\t\tthis._thisArg.set(newVal);\n\t}\n});\n\nvar scopeKeyDataPrototype = {\n\t\"can.getValue\": ScopeKeyData.prototype.get,\n\t\"can.setValue\": ScopeKeyData.prototype.set,\n\t\"can.valueHasDependencies\": ScopeKeyData.prototype.hasDependencies,\n\t\"can.getValueDependencies\": function() {\n\t\treturn this.dependencies;\n\t},\n\t\"can.getPriority\": function(){\n\t\treturn canReflect.getPriority( this.observation );\n\t},\n\t\"can.setPriority\": function(newPriority){\n\t\tcanReflect.setPriority( this.observation, newPriority );\n\t},\n\t\"can.setElement\": function(element) {\n\t\tthis.observation[setElementSymbol](element);\n\t}\n};\n\n//!steal-remove-start\nif (true) {\n\tscopeKeyDataPrototype[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"{{\" + this.key + \"}}\";\n\t};\n}\n//!steal-remove-end\ncanReflect.assignSymbols(ScopeKeyData.prototype, scopeKeyDataPrototype);\n\n// Creates a compute-like for legacy reasons ...\nObject.defineProperty(ScopeKeyData.prototype, \"compute\", {\n\tget: function(){\n\t\tvar compute = makeComputeLike(this);\n\n\t\tObject.defineProperty(this, \"compute\", {\n\t\t\tvalue: compute,\n\t\t\twritable: false,\n\t\t\tconfigurable: false\n\t\t});\n\t\treturn compute;\n\t},\n\tconfigurable: true\n});\n\nObject.defineProperty(ScopeKeyData.prototype, \"initialValue\", {\n\tget: function(){\n\t\tif (!this.bound) {\n\t\t\tObservation.temporarilyBind(this);\n\t\t}\n\t\treturn ObservationRecorder.peekValue(this);\n\t},\n\tset: function(){\n\t\tthrow new Error(\"initialValue should not be set\");\n\t},\n\tconfigurable: true\n});\n\nmodule.exports = ScopeKeyData;\n\n\n//# sourceURL=webpack:///./node_modules/can-view-scope/scope-key-data.js?");

/***/ }),

/***/ "./node_modules/can-view-scope/template-context.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-view-scope/template-context.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar SimpleMap = __webpack_require__(/*! can-simple-map */ \"./node_modules/can-simple-map/can-simple-map.js\");\n\nvar TemplateContext = function(options) {\n\toptions = options || {};\n\tthis.vars = new SimpleMap(options.vars || {});\n\tthis.helpers = new SimpleMap(options.helpers || {});\n\tthis.partials = new SimpleMap(options.partials || {});\n\tthis.tags = new SimpleMap(options.tags || {});\n};\n\nmodule.exports = TemplateContext;\n\n\n//# sourceURL=webpack:///./node_modules/can-view-scope/template-context.js?");

/***/ }),

/***/ "./node_modules/can-view-target/can-view-target.js":
/*!*********************************************************!*\
  !*** ./node_modules/can-view-target/can-view-target.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint maxdepth:7 */\n/* jshint latedef:false */\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"./node_modules/can-globals/document/document.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\nvar MUTATION_OBSERVER = __webpack_require__(/*! can-globals/mutation-observer/mutation-observer */ \"./node_modules/can-globals/mutation-observer/mutation-observer.js\");\n\n// if an object or a function\n// convert into what it should look like\n// then the modification can happen in place\n// but it has to have more than the current node\n// blah!\nvar processNodes = function(nodes, paths, location, document){\n\tvar frag = document.createDocumentFragment();\n\n\tfor(var i = 0, len = nodes.length; i < len; i++) {\n\t\tvar node = nodes[i];\n\t\tfrag.appendChild( processNode(node,paths,location.concat(i), document) );\n\t}\n\treturn frag;\n},\n\tkeepsTextNodes =  typeof document !== \"undefined\" && (function(){\n\t\tvar testFrag = document.createDocumentFragment();\n\t\tvar div = document.createElement(\"div\");\n\n\t\tdiv.appendChild(document.createTextNode(\"\"));\n\t\tdiv.appendChild(document.createTextNode(\"\"));\n\t\ttestFrag.appendChild(div);\n\n\t\tvar cloned  = testFrag.cloneNode(true);\n\n\t\treturn cloned.firstChild.childNodes.length === 2;\n\t})(),\n\tclonesWork = typeof document !== \"undefined\" && (function(){\n\t\t// Since html5shiv is required to support custom elements, assume cloning\n\t\t// works in any browser that doesn't have html5shiv\n\n\t\t// Clone an element containing a custom tag to see if the innerHTML is what we\n\t\t// expect it to be, or if not it probably was created outside of the document's\n\t\t// namespace.\n\t\tvar el = document.createElement('a');\n\t\tel.innerHTML = \"<xyz></xyz>\";\n\t\tvar clone = el.cloneNode(true);\n\t\tvar works = clone.innerHTML === \"<xyz></xyz>\";\n\t\tvar MO, observer;\n\n\t\tif(works) {\n\t\t\t// Cloning text nodes with dashes seems to create multiple nodes in IE11 when\n\t\t\t// MutationObservers of subtree modifications are used on the documentElement.\n\t\t\t// Since this is not what we expect we have to include detecting it here as well.\n\t\t\tel = document.createDocumentFragment();\n\t\t\tel.appendChild(document.createTextNode('foo-bar'));\n\n\t\t\tMO = MUTATION_OBSERVER();\n\n\t\t\tif (MO) {\n\t\t\t\tobserver = new MO(function() {});\n\t\t\t\tobserver.observe(document.documentElement, { childList: true, subtree: true });\n\n\t\t\t\tclone = el.cloneNode(true);\n\n\t\t\t\tobserver.disconnect();\n\t\t\t} else {\n\t\t\t\tclone = el.cloneNode(true);\n\t\t\t}\n\n\t\t\treturn clone.childNodes.length === 1;\n\t\t}\n\n\t\treturn works;\n\t})(),\n\tnamespacesWork = typeof document !== \"undefined\" && !!document.createElementNS;\n\n/**\n * @function cloneNode\n * @hide\n *\n * A custom cloneNode function to be used in browsers that properly support cloning\n * of custom tags (IE8 for example). Fixes it by doing some manual cloning that\n * uses innerHTML instead, which has been shimmed.\n *\n * @param {DocumentFragment} frag A document fragment to clone\n * @return {DocumentFragment} a new fragment that is a clone of the provided argument\n */\nvar cloneNode = clonesWork ?\n\tfunction(el){\n\t\treturn el.cloneNode(true);\n\t} :\n\tfunction(node){\n\t\tvar document = node.ownerDocument;\n\t\tvar copy;\n\n\t\tif(node.nodeType === 1) {\n\t\t\tif(node.namespaceURI !== 'http://www.w3.org/1999/xhtml' && namespacesWork && document.createElementNS) {\n\t\t\t\tcopy = document.createElementNS(node.namespaceURI, node.nodeName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcopy = document.createElement(node.nodeName);\n\t\t\t}\n\t\t} else if(node.nodeType === 3){\n\t\t\tcopy = document.createTextNode(node.nodeValue);\n\t\t} else if(node.nodeType === 8) {\n\t\t\tcopy = document.createComment(node.nodeValue);\n\t\t} else if(node.nodeType === 11) {\n\t\t\tcopy = document.createDocumentFragment();\n\t\t}\n\n\t\tif(node.attributes) {\n\t\t\tvar attributes = node.attributes;\n\t\t\tfor (var i = 0; i < attributes.length; i++) {\n\t\t\t\tvar attribute = attributes[i];\n\t\t\t\tif (attribute && attribute.specified) {\n\t\t\t\t\t// If the attribute has a namespace set the namespace \n\t\t\t\t\t// otherwise it will be set to null\n\t\t\t\t\tif (attribute.namespaceURI) {\n\t\t\t\t\t\tcopy.setAttributeNS(attribute.namespaceURI, attribute.nodeName || attribute.name, attribute.nodeValue || attribute.value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcopy.setAttribute(attribute.nodeName || attribute.name, attribute.nodeValue || attribute.value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(node && node.firstChild) {\n\t\t\tvar child = node.firstChild;\n\n\t\t\twhile(child) {\n\t\t\t\tcopy.appendChild( cloneNode(child) );\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\t\t}\n\n\t\treturn copy;\n\t};\n\nfunction processNode(node, paths, location, document){\n\tvar callback,\n\t\tloc = location,\n\t\tnodeType = typeof node,\n\t\tel,\n\t\tp,\n\t\ti , len;\n\tvar getCallback = function(){\n\t\tif(!callback) {\n\t\t\tcallback  = {\n\t\t\t\tpath: location,\n\t\t\t\tcallbacks: []\n\t\t\t};\n\t\t\tpaths.push(callback);\n\t\t\tloc = [];\n\t\t}\n\t\treturn callback;\n\t};\n\n\tif(nodeType === \"object\") {\n\t\tif( node.tag ) {\n\t\t\tif(namespacesWork && node.namespace) {\n\t\t\t\tel = document.createElementNS(node.namespace, node.tag);\n\t\t\t} else {\n\t\t\t\tel = document.createElement(node.tag);\n\t\t\t}\n\n\t\t\tif(node.attrs) {\n\t\t\t\tfor(var attrName in node.attrs) {\n\t\t\t\t\tvar value = node.attrs[attrName];\n\t\t\t\t\tif(typeof value === \"function\"){\n\t\t\t\t\t\tgetCallback().callbacks.push({\n\t\t\t\t\t\t\tcallback:  value\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (value !== null && typeof value === \"object\" && value.namespaceURI) {\n\t\t\t\t\t\tel.setAttributeNS(value.namespaceURI,attrName,value.value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdomMutate.setAttribute.call(el, attrName, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(node.attributes) {\n\t\t\t\tfor(i = 0, len = node.attributes.length; i < len; i++ ) {\n\t\t\t\t\tgetCallback().callbacks.push({callback: node.attributes[i]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(node.children && node.children.length) {\n\t\t\t\t// add paths\n\t\t\t\tif(callback) {\n\t\t\t\t\tp = callback.paths = [];\n\t\t\t\t} else {\n\t\t\t\t\tp = paths;\n\t\t\t\t}\n\n\t\t\t\tel.appendChild( processNodes(node.children, p, loc, document) );\n\t\t\t}\n\t\t} else if(node.comment) {\n\t\t\tel = document.createComment(node.comment);\n\n\t\t\tif(node.callbacks) {\n\t\t\t\tfor(i = 0, len = node.callbacks.length; i < len; i++ ) {\n\t\t\t\t\tgetCallback().callbacks.push({callback: node.callbacks[i]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t} else if(nodeType === \"string\"){\n\n\t\tel = document.createTextNode(node);\n\n\t} else if(nodeType === \"function\") {\n\n\t\tif(keepsTextNodes) {\n\t\t\tel = document.createTextNode(\"\");\n\t\t\tgetCallback().callbacks.push({\n\t\t\t\tcallback: node\n\t\t\t});\n\t\t} else {\n\t\t\tel = document.createComment(\"~\");\n\t\t\tgetCallback().callbacks.push({\n\t\t\t\tcallback: function(){\n\t\t\t\t\tvar el = document.createTextNode(\"\");\n\t\t\t\t\tdomMutate.replaceChild.call(this.parentNode, el, this);\n\t\t\t\t\treturn node.apply(el,arguments );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t}\n\treturn el;\n}\n\nfunction getCallbacks(el, pathData, elementCallbacks){\n\tvar path = pathData.path,\n\t\tcallbacks = pathData.callbacks,\n\t\tpaths = pathData.paths,\n\t\tchild = el,\n\t\tpathLength = path ? path.length : 0,\n\t\tpathsLength = paths ? paths.length : 0;\n\n\tfor(var i = 0; i < pathLength; i++) {\n\t\tchild = child.childNodes.item(path[i]);\n\t}\n\n\tfor( i= 0 ; i < pathsLength; i++) {\n\t\tgetCallbacks(child, paths[i], elementCallbacks);\n\t}\n\n\telementCallbacks.push({element: child, callbacks: callbacks});\n}\n\nfunction hydrateCallbacks(callbacks, args) {\n\tvar len = callbacks.length,\n\t\tcallbacksLength,\n\t\tcallbackElement,\n\t\tcallbackData;\n\n\tfor(var i = 0; i < len; i++) {\n\t\tcallbackData = callbacks[i];\n\t\tcallbacksLength = callbackData.callbacks.length;\n\t\tcallbackElement = callbackData.element;\n\t\tfor(var c = 0; c < callbacksLength; c++) {\n\t\t\tcallbackData.callbacks[c].callback.apply(callbackElement, args);\n\t\t}\n\t}\n}\n\nfunction makeTarget(nodes, doc){\n\tvar paths = [];\n\tvar frag = processNodes(nodes, paths, [], doc || getDocument());\n\treturn {\n\t\tpaths: paths,\n\t\tclone: frag,\n\t\thydrate: function(){\n\t\t\tvar cloned = cloneNode(this.clone);\n\t\t\tvar args = [];\n\t\t\tfor (var a = 0, ref = args.length = arguments.length; a < ref; a++) {\n\t\t\t\targs[a] = arguments[a];\n\t\t\t} // see https://jsperf.com/nodelist-to-array\n\n\t\t\tvar callbacks = [];\n\t\t\tfor(var i = 0; i < paths.length; i++) {\n\t\t\t\tgetCallbacks(cloned, paths[i], callbacks);\n\t\t\t}\n\t\t\thydrateCallbacks(callbacks, args);\n\n\t\t\treturn cloned;\n\t\t}\n\t};\n}\nmakeTarget.keepsTextNodes = keepsTextNodes;\nmakeTarget.cloneNode = cloneNode;\n\nnamespace.view = namespace.view || {};\nmodule.exports = namespace.view.target = makeTarget;\n\n\n//# sourceURL=webpack:///./node_modules/can-view-target/can-view-target.js?");

/***/ }),

/***/ "./node_modules/can/can.js":
/*!*********************************!*\
  !*** ./node_modules/can/can.js ***!
  \*********************************/
/*! exports provided: value, Observation, ObservationRecorder, SimpleMap, ObservableObject, ObservableArray, fromAttribute, bind, mapEventBindings, valueEventBindings, SimpleObservable, AsyncObservable, keyObservable, ResolverObservable, SettableObservable, SetterObservable, StacheElement, stache, stacheBindings, stacheRouteHelpers, viewCallbacks, viewLive, viewModel, viewParser, Scope, target, fixture, QueryLogic, realtimeRestModel, restModel, connect, localStore, memoryStore, route, RouteHash, RoutePushstate, param, deparam, assign, defineLazyValue, diff, globals, key, KeyTree, makeMap, parseURI, queues, string, stringToAny, ajax, attributeEncoder, childNodes, domData, domEvents, addJQueryEvents, domMutate, domMutateNode, domMutateDomEvents, fragment, makeInterfaceValidator, cid, Construct, MaybeBoolean, MaybeDate, MaybeNumber, MaybeString, can, Reflect, reflectDependencies, reflectPromise, type, debug, defineBackup, defineStream, defineStreamKefir, kefir, Kefir, observe, stream, streamKefir, makeMapCompat, stacheConverters, viewAutorender, superModel, connectFeathers, connectTag, fixtureSocket, ndjsonStream, connectNDJSON, connectCanSession, constructSuper, RouteMock, defineValidateValidatejs, validate, validateValidatejs, DeepObservable, radioChangeEvent, enterEvent, observableMixin, defineMixin, define, DefineMap, DefineList, defineRealtimeRestModel, defineRestModel, compute, CanMap, CanList, canMapDefine, Component, set, Control */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/can/core.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"value\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"value\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Observation\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Observation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ObservationRecorder\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"ObservationRecorder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SimpleMap\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"SimpleMap\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ObservableObject\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"ObservableObject\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ObservableArray\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"ObservableArray\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"fromAttribute\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"fromAttribute\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"bind\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"bind\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"mapEventBindings\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"mapEventBindings\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"valueEventBindings\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"valueEventBindings\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SimpleObservable\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"SimpleObservable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AsyncObservable\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"AsyncObservable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"keyObservable\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"keyObservable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ResolverObservable\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"ResolverObservable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SettableObservable\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"SettableObservable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SetterObservable\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"SetterObservable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StacheElement\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"StacheElement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stache\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"stache\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stacheBindings\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"stacheBindings\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stacheRouteHelpers\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"stacheRouteHelpers\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"viewCallbacks\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"viewCallbacks\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"viewLive\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"viewLive\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"viewModel\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"viewModel\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"viewParser\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"viewParser\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Scope\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"target\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"target\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"fixture\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"fixture\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"QueryLogic\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"QueryLogic\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"realtimeRestModel\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"realtimeRestModel\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"restModel\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"restModel\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"connect\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"connect\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"localStore\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"localStore\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"memoryStore\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"memoryStore\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"route\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"route\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RouteHash\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"RouteHash\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RoutePushstate\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"RoutePushstate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"param\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"param\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"deparam\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"deparam\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"assign\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineLazyValue\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"defineLazyValue\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"diff\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"diff\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"globals\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"globals\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"key\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"key\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"KeyTree\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"KeyTree\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"makeMap\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"makeMap\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parseURI\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"parseURI\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"queues\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"queues\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"string\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"string\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stringToAny\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"stringToAny\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ajax\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"ajax\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"attributeEncoder\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"attributeEncoder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"childNodes\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"childNodes\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"domData\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"domData\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"domEvents\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"domEvents\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addJQueryEvents\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"addJQueryEvents\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"domMutate\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"domMutate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"domMutateNode\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"domMutateNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"domMutateDomEvents\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"domMutateDomEvents\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"fragment\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"fragment\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"makeInterfaceValidator\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"makeInterfaceValidator\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"cid\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"cid\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Construct\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Construct\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MaybeBoolean\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"MaybeBoolean\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MaybeDate\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"MaybeDate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MaybeNumber\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"MaybeNumber\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MaybeString\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"MaybeString\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"can\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"can\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Reflect\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Reflect\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"reflectDependencies\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"reflectDependencies\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"reflectPromise\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"reflectPromise\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"type\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"type\"]; });\n\n/* harmony import */ var _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ecosystem.js */ \"./node_modules/can/ecosystem.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"debug\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"debug\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineBackup\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"defineBackup\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineStream\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"defineStream\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineStreamKefir\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"defineStreamKefir\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"kefir\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"kefir\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Kefir\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"Kefir\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"observe\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"observe\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stream\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"stream\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"streamKefir\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"streamKefir\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"makeMapCompat\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"makeMapCompat\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stacheConverters\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"stacheConverters\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"viewAutorender\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"viewAutorender\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"superModel\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"superModel\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"connectFeathers\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"connectFeathers\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"connectTag\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"connectTag\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"fixtureSocket\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"fixtureSocket\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ndjsonStream\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"ndjsonStream\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"connectNDJSON\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"connectNDJSON\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"connectCanSession\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"connectCanSession\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"constructSuper\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"constructSuper\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RouteMock\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"RouteMock\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineValidateValidatejs\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"defineValidateValidatejs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"validate\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"validate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"validateValidatejs\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"validateValidatejs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DeepObservable\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"DeepObservable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"radioChangeEvent\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"radioChangeEvent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"enterEvent\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"enterEvent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"observableMixin\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"observableMixin\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineMixin\", function() { return _ecosystem_js__WEBPACK_IMPORTED_MODULE_1__[\"defineMixin\"]; });\n\n/* harmony import */ var _legacy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legacy.js */ \"./node_modules/can/legacy.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"define\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"define\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DefineMap\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"DefineMap\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DefineList\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"DefineList\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineRealtimeRestModel\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"defineRealtimeRestModel\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineRestModel\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"defineRestModel\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"compute\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"compute\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CanMap\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"CanMap\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CanList\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"CanList\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"canMapDefine\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"canMapDefine\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"Component\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"set\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Control\", function() { return _legacy_js__WEBPACK_IMPORTED_MODULE_2__[\"Control\"]; });\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/can/can.js?");

/***/ }),

/***/ "./node_modules/can/core.js":
/*!**********************************!*\
  !*** ./node_modules/can/core.js ***!
  \**********************************/
/*! exports provided: value, Observation, ObservationRecorder, SimpleMap, ObservableObject, ObservableArray, fromAttribute, bind, mapEventBindings, valueEventBindings, SimpleObservable, AsyncObservable, keyObservable, ResolverObservable, SettableObservable, SetterObservable, StacheElement, stache, stacheBindings, stacheRouteHelpers, viewCallbacks, viewLive, viewModel, viewParser, Scope, target, fixture, QueryLogic, realtimeRestModel, restModel, connect, localStore, memoryStore, route, RouteHash, RoutePushstate, param, deparam, assign, defineLazyValue, diff, globals, key, KeyTree, makeMap, parseURI, queues, string, stringToAny, ajax, attributeEncoder, childNodes, domData, domEvents, addJQueryEvents, domMutate, domMutateNode, domMutateDomEvents, fragment, makeInterfaceValidator, cid, Construct, MaybeBoolean, MaybeDate, MaybeNumber, MaybeString, default, can, Reflect, reflectDependencies, reflectPromise, type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _es_can_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./es/can-value */ \"./node_modules/can/es/can-value.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"value\", function() { return _es_can_value__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _es_can_observation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./es/can-observation */ \"./node_modules/can/es/can-observation.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Observation\", function() { return _es_can_observation__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _es_can_observation_recorder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./es/can-observation-recorder */ \"./node_modules/can/es/can-observation-recorder.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ObservationRecorder\", function() { return _es_can_observation_recorder__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _es_can_simple_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./es/can-simple-map */ \"./node_modules/can/es/can-simple-map.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SimpleMap\", function() { return _es_can_simple_map__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _es_can_observable_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./es/can-observable-object */ \"./node_modules/can/es/can-observable-object.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ObservableObject\", function() { return _es_can_observable_object__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _es_can_observable_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./es/can-observable-array */ \"./node_modules/can/es/can-observable-array.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ObservableArray\", function() { return _es_can_observable_array__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony import */ var can_observable_bindings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! can-observable-bindings */ \"./node_modules/can-observable-bindings/can-observable-bindings.js\");\n/* harmony import */ var can_observable_bindings__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(can_observable_bindings__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"fromAttribute\", function() { return can_observable_bindings__WEBPACK_IMPORTED_MODULE_6__[\"fromAttribute\"]; });\n\n/* harmony import */ var _es_can_bind__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./es/can-bind */ \"./node_modules/can/es/can-bind.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"bind\", function() { return _es_can_bind__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; });\n\n/* harmony import */ var _es_can_event_queue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./es/can-event-queue */ \"./node_modules/can/es/can-event-queue.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"mapEventBindings\", function() { return _es_can_event_queue__WEBPACK_IMPORTED_MODULE_8__[\"mapEventBindings\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"valueEventBindings\", function() { return _es_can_event_queue__WEBPACK_IMPORTED_MODULE_8__[\"valueEventBindings\"]; });\n\n/* harmony import */ var _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./es/can-simple-observable */ \"./node_modules/can/es/can-simple-observable.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SimpleObservable\", function() { return _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AsyncObservable\", function() { return _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_9__[\"AsyncObservable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"keyObservable\", function() { return _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_9__[\"keyObservable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ResolverObservable\", function() { return _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_9__[\"ResolverObservable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SettableObservable\", function() { return _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_9__[\"SettableObservable\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SetterObservable\", function() { return _es_can_simple_observable__WEBPACK_IMPORTED_MODULE_9__[\"SetterObservable\"]; });\n\n/* harmony import */ var _es_can_stache_element__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./es/can-stache-element */ \"./node_modules/can/es/can-stache-element.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StacheElement\", function() { return _es_can_stache_element__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; });\n\n/* harmony import */ var _es_can_stache__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./es/can-stache */ \"./node_modules/can/es/can-stache.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stache\", function() { return _es_can_stache__WEBPACK_IMPORTED_MODULE_11__[\"default\"]; });\n\n/* harmony import */ var _es_can_stache_bindings__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./es/can-stache-bindings */ \"./node_modules/can/es/can-stache-bindings.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stacheBindings\", function() { return _es_can_stache_bindings__WEBPACK_IMPORTED_MODULE_12__[\"default\"]; });\n\n/* harmony import */ var _es_can_stache_route_helpers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./es/can-stache-route-helpers */ \"./node_modules/can/es/can-stache-route-helpers.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stacheRouteHelpers\", function() { return _es_can_stache_route_helpers__WEBPACK_IMPORTED_MODULE_13__[\"default\"]; });\n\n/* harmony import */ var _es_can_view_callbacks__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./es/can-view-callbacks */ \"./node_modules/can/es/can-view-callbacks.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"viewCallbacks\", function() { return _es_can_view_callbacks__WEBPACK_IMPORTED_MODULE_14__[\"default\"]; });\n\n/* harmony import */ var _es_can_view_live__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./es/can-view-live */ \"./node_modules/can/es/can-view-live.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"viewLive\", function() { return _es_can_view_live__WEBPACK_IMPORTED_MODULE_15__[\"default\"]; });\n\n/* harmony import */ var _es_can_view_model__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./es/can-view-model */ \"./node_modules/can/es/can-view-model.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"viewModel\", function() { return _es_can_view_model__WEBPACK_IMPORTED_MODULE_16__[\"default\"]; });\n\n/* harmony import */ var _es_can_view_parser__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./es/can-view-parser */ \"./node_modules/can/es/can-view-parser.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"viewParser\", function() { return _es_can_view_parser__WEBPACK_IMPORTED_MODULE_17__[\"default\"]; });\n\n/* harmony import */ var _es_can_view_scope__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./es/can-view-scope */ \"./node_modules/can/es/can-view-scope.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Scope\", function() { return _es_can_view_scope__WEBPACK_IMPORTED_MODULE_18__[\"default\"]; });\n\n/* harmony import */ var _es_can_view_target__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./es/can-view-target */ \"./node_modules/can/es/can-view-target.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"target\", function() { return _es_can_view_target__WEBPACK_IMPORTED_MODULE_19__[\"default\"]; });\n\n/* harmony import */ var _es_can_fixture__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./es/can-fixture */ \"./node_modules/can/es/can-fixture.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"fixture\", function() { return _es_can_fixture__WEBPACK_IMPORTED_MODULE_20__[\"default\"]; });\n\n/* harmony import */ var _es_can_query_logic__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./es/can-query-logic */ \"./node_modules/can/es/can-query-logic.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"QueryLogic\", function() { return _es_can_query_logic__WEBPACK_IMPORTED_MODULE_21__[\"default\"]; });\n\n/* harmony import */ var _es_can_realtime_rest_model__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./es/can-realtime-rest-model */ \"./node_modules/can/es/can-realtime-rest-model.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"realtimeRestModel\", function() { return _es_can_realtime_rest_model__WEBPACK_IMPORTED_MODULE_22__[\"default\"]; });\n\n/* harmony import */ var _es_can_rest_model__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./es/can-rest-model */ \"./node_modules/can/es/can-rest-model.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"restModel\", function() { return _es_can_rest_model__WEBPACK_IMPORTED_MODULE_23__[\"default\"]; });\n\n/* harmony import */ var _es_can_connect__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./es/can-connect */ \"./node_modules/can/es/can-connect.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"connect\", function() { return _es_can_connect__WEBPACK_IMPORTED_MODULE_24__[\"default\"]; });\n\n/* harmony import */ var _es_can_local_store__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./es/can-local-store */ \"./node_modules/can/es/can-local-store.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"localStore\", function() { return _es_can_local_store__WEBPACK_IMPORTED_MODULE_25__[\"default\"]; });\n\n/* harmony import */ var _es_can_memory_store__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./es/can-memory-store */ \"./node_modules/can/es/can-memory-store.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"memoryStore\", function() { return _es_can_memory_store__WEBPACK_IMPORTED_MODULE_26__[\"default\"]; });\n\n/* harmony import */ var _es_can_route__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./es/can-route */ \"./node_modules/can/es/can-route.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"route\", function() { return _es_can_route__WEBPACK_IMPORTED_MODULE_27__[\"default\"]; });\n\n/* harmony import */ var _es_can_route_hash__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./es/can-route-hash */ \"./node_modules/can/es/can-route-hash.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RouteHash\", function() { return _es_can_route_hash__WEBPACK_IMPORTED_MODULE_28__[\"default\"]; });\n\n/* harmony import */ var _es_can_route_pushstate__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./es/can-route-pushstate */ \"./node_modules/can/es/can-route-pushstate.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RoutePushstate\", function() { return _es_can_route_pushstate__WEBPACK_IMPORTED_MODULE_29__[\"default\"]; });\n\n/* harmony import */ var _es_can_param__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./es/can-param */ \"./node_modules/can/es/can-param.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"param\", function() { return _es_can_param__WEBPACK_IMPORTED_MODULE_30__[\"default\"]; });\n\n/* harmony import */ var _es_can_deparam__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./es/can-deparam */ \"./node_modules/can/es/can-deparam.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"deparam\", function() { return _es_can_deparam__WEBPACK_IMPORTED_MODULE_31__[\"default\"]; });\n\n/* harmony import */ var _es_can_assign__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./es/can-assign */ \"./node_modules/can/es/can-assign.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return _es_can_assign__WEBPACK_IMPORTED_MODULE_32__[\"default\"]; });\n\n/* harmony import */ var _es_can_define_lazy_value__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./es/can-define-lazy-value */ \"./node_modules/can/es/can-define-lazy-value.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineLazyValue\", function() { return _es_can_define_lazy_value__WEBPACK_IMPORTED_MODULE_33__[\"default\"]; });\n\n/* harmony import */ var _es_can_diff__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./es/can-diff */ \"./node_modules/can/es/can-diff.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"diff\", function() { return _es_can_diff__WEBPACK_IMPORTED_MODULE_34__[\"default\"]; });\n\n/* harmony import */ var _es_can_globals__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./es/can-globals */ \"./node_modules/can/es/can-globals.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"globals\", function() { return _es_can_globals__WEBPACK_IMPORTED_MODULE_35__[\"default\"]; });\n\n/* harmony import */ var _es_can_key__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./es/can-key */ \"./node_modules/can/es/can-key.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"key\", function() { return _es_can_key__WEBPACK_IMPORTED_MODULE_36__[\"default\"]; });\n\n/* harmony import */ var _es_can_key_tree__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./es/can-key-tree */ \"./node_modules/can/es/can-key-tree.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"KeyTree\", function() { return _es_can_key_tree__WEBPACK_IMPORTED_MODULE_37__[\"default\"]; });\n\n/* harmony import */ var _es_can_make_map__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./es/can-make-map */ \"./node_modules/can/es/can-make-map.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"makeMap\", function() { return _es_can_make_map__WEBPACK_IMPORTED_MODULE_38__[\"default\"]; });\n\n/* harmony import */ var _es_can_parse_uri__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./es/can-parse-uri */ \"./node_modules/can/es/can-parse-uri.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parseURI\", function() { return _es_can_parse_uri__WEBPACK_IMPORTED_MODULE_39__[\"default\"]; });\n\n/* harmony import */ var _es_can_queues__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./es/can-queues */ \"./node_modules/can/es/can-queues.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"queues\", function() { return _es_can_queues__WEBPACK_IMPORTED_MODULE_40__[\"default\"]; });\n\n/* harmony import */ var _es_can_string__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./es/can-string */ \"./node_modules/can/es/can-string.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"string\", function() { return _es_can_string__WEBPACK_IMPORTED_MODULE_41__[\"default\"]; });\n\n/* harmony import */ var _es_can_string_to_any__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./es/can-string-to-any */ \"./node_modules/can/es/can-string-to-any.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stringToAny\", function() { return _es_can_string_to_any__WEBPACK_IMPORTED_MODULE_42__[\"default\"]; });\n\n/* harmony import */ var _es_can_ajax__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./es/can-ajax */ \"./node_modules/can/es/can-ajax.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ajax\", function() { return _es_can_ajax__WEBPACK_IMPORTED_MODULE_43__[\"default\"]; });\n\n/* harmony import */ var _es_can_attribute_encoder__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./es/can-attribute-encoder */ \"./node_modules/can/es/can-attribute-encoder.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"attributeEncoder\", function() { return _es_can_attribute_encoder__WEBPACK_IMPORTED_MODULE_44__[\"default\"]; });\n\n/* harmony import */ var _es_can_child_nodes__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./es/can-child-nodes */ \"./node_modules/can/es/can-child-nodes.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"childNodes\", function() { return _es_can_child_nodes__WEBPACK_IMPORTED_MODULE_45__[\"default\"]; });\n\n/* harmony import */ var _es_can_dom_data__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./es/can-dom-data */ \"./node_modules/can/es/can-dom-data.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"domData\", function() { return _es_can_dom_data__WEBPACK_IMPORTED_MODULE_46__[\"default\"]; });\n\n/* harmony import */ var _es_can_dom_events__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./es/can-dom-events */ \"./node_modules/can/es/can-dom-events.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"domEvents\", function() { return _es_can_dom_events__WEBPACK_IMPORTED_MODULE_47__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addJQueryEvents\", function() { return _es_can_dom_events__WEBPACK_IMPORTED_MODULE_47__[\"addJQueryEvents\"]; });\n\n/* harmony import */ var _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./es/can-dom-mutate */ \"./node_modules/can/es/can-dom-mutate.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"domMutate\", function() { return _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_48__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"domMutateNode\", function() { return _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_48__[\"domMutateNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"domMutateDomEvents\", function() { return _es_can_dom_mutate__WEBPACK_IMPORTED_MODULE_48__[\"domMutateDomEvents\"]; });\n\n/* harmony import */ var _es_can_fragment__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./es/can-fragment */ \"./node_modules/can/es/can-fragment.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"fragment\", function() { return _es_can_fragment__WEBPACK_IMPORTED_MODULE_49__[\"default\"]; });\n\n/* harmony import */ var _es_can_validate_interface__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./es/can-validate-interface */ \"./node_modules/can/es/can-validate-interface.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"makeInterfaceValidator\", function() { return _es_can_validate_interface__WEBPACK_IMPORTED_MODULE_50__[\"default\"]; });\n\n/* harmony import */ var can_cid__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! can-cid */ \"./node_modules/can-cid/can-cid.js\");\n/* harmony import */ var can_cid__WEBPACK_IMPORTED_MODULE_51___default = /*#__PURE__*/__webpack_require__.n(can_cid__WEBPACK_IMPORTED_MODULE_51__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"cid\", function() { return can_cid__WEBPACK_IMPORTED_MODULE_51___default.a; });\n/* harmony import */ var can_construct__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! can-construct */ \"./node_modules/can-construct/can-construct.js\");\n/* harmony import */ var can_construct__WEBPACK_IMPORTED_MODULE_52___default = /*#__PURE__*/__webpack_require__.n(can_construct__WEBPACK_IMPORTED_MODULE_52__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Construct\", function() { return can_construct__WEBPACK_IMPORTED_MODULE_52___default.a; });\n/* harmony import */ var _es_can_data_types__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./es/can-data-types */ \"./node_modules/can/es/can-data-types.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MaybeBoolean\", function() { return _es_can_data_types__WEBPACK_IMPORTED_MODULE_53__[\"MaybeBoolean\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MaybeDate\", function() { return _es_can_data_types__WEBPACK_IMPORTED_MODULE_53__[\"MaybeDate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MaybeNumber\", function() { return _es_can_data_types__WEBPACK_IMPORTED_MODULE_53__[\"MaybeNumber\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MaybeString\", function() { return _es_can_data_types__WEBPACK_IMPORTED_MODULE_53__[\"MaybeString\"]; });\n\n/* harmony import */ var _es_can_namespace__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./es/can-namespace */ \"./node_modules/can/es/can-namespace.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return _es_can_namespace__WEBPACK_IMPORTED_MODULE_54__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"can\", function() { return _es_can_namespace__WEBPACK_IMPORTED_MODULE_54__[\"default\"]; });\n\n/* harmony import */ var _es_can_reflect__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./es/can-reflect */ \"./node_modules/can/es/can-reflect.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Reflect\", function() { return _es_can_reflect__WEBPACK_IMPORTED_MODULE_55__[\"default\"]; });\n\n/* harmony import */ var _es_can_reflect_dependencies__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./es/can-reflect-dependencies */ \"./node_modules/can/es/can-reflect-dependencies.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"reflectDependencies\", function() { return _es_can_reflect_dependencies__WEBPACK_IMPORTED_MODULE_56__[\"default\"]; });\n\n/* harmony import */ var _es_can_reflect_promise__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./es/can-reflect-promise */ \"./node_modules/can/es/can-reflect-promise.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"reflectPromise\", function() { return _es_can_reflect_promise__WEBPACK_IMPORTED_MODULE_57__[\"default\"]; });\n\n/* harmony import */ var _es_can_type__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./es/can-type */ \"./node_modules/can/es/can-type.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"type\", function() { return _es_can_type__WEBPACK_IMPORTED_MODULE_58__[\"default\"]; });\n\n/* harmony import */ var _enable_can_debug__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./enable-can-debug */ \"./node_modules/can/enable-can-debug.js\");\n// __ Observables __\n\n// -> Core\n\n\n\n\n\n\n\n\n// -> Infrastruture\n\n\n\n\n\n// __ Views __\n\n\n// -> Core\n\n\n\n\n// -> Infrastruture\n\n\n\n\n\n\n\n\n// __ Data Models __\n\n// -> Core\n\n\n\n\n\n// -> Infrastruture\n\n\n\n\n\n// __ Routing __\n\n// -> Core\n\n\n\n\n// -> Infrastruture\n\n\n\n\n// __ JS Utilities __\n\n// -> Infrastruture\n\n\n\n\n\n\n\n\n\n\n\n\n\n// __ DOM Utilities __\n\n// -> Infrastruture\n\n\n\n\n\n\n\n\n\n// __ Data Validation\n\n// -> Infrastruture\n\n\n\n// __ Typed Data __\n\n// -> Infrastruture\n\n\n\n\n\n\n\n\n// __ Data Validation__\n// -> Core\n\n\n// __ Enable Devtools __\n//!steal-remove-start\n\n//!steal-remove-end\n\n\n//# sourceURL=webpack:///./node_modules/can/core.js?");

/***/ }),

/***/ "./node_modules/can/ecosystem.js":
/*!***************************************!*\
  !*** ./node_modules/can/ecosystem.js ***!
  \***************************************/
/*! exports provided: debug, defineBackup, defineStream, defineStreamKefir, kefir, Kefir, observe, stream, streamKefir, makeMapCompat, stacheConverters, viewAutorender, superModel, connectFeathers, connectTag, fixtureSocket, ndjsonStream, connectNDJSON, connectCanSession, constructSuper, RouteMock, defineValidateValidatejs, validate, validateValidatejs, DeepObservable, radioChangeEvent, enterEvent, observableMixin, defineMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _es_can_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./es/can-debug */ \"./node_modules/can/es/can-debug.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"debug\", function() { return _es_can_debug__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _es_can_define_backup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./es/can-define-backup */ \"./node_modules/can/es/can-define-backup.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineBackup\", function() { return _es_can_define_backup__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _es_can_define_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./es/can-define-stream */ \"./node_modules/can/es/can-define-stream.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineStream\", function() { return _es_can_define_stream__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _es_can_define_stream_kefir__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./es/can-define-stream-kefir */ \"./node_modules/can/es/can-define-stream-kefir.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineStreamKefir\", function() { return _es_can_define_stream_kefir__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _es_can_kefir__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./es/can-kefir */ \"./node_modules/can/es/can-kefir.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"kefir\", function() { return _es_can_kefir__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Kefir\", function() { return _es_can_kefir__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _es_can_observe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./es/can-observe */ \"./node_modules/can/es/can-observe.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"observe\", function() { return _es_can_observe__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony import */ var _es_can_stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./es/can-stream */ \"./node_modules/can/es/can-stream.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stream\", function() { return _es_can_stream__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; });\n\n/* harmony import */ var _es_can_stream_kefir__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./es/can-stream-kefir */ \"./node_modules/can/es/can-stream-kefir.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"streamKefir\", function() { return _es_can_stream_kefir__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; });\n\n/* harmony import */ var _es_can_map_compat__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./es/can-map-compat */ \"./node_modules/can/es/can-map-compat.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"makeMapCompat\", function() { return _es_can_map_compat__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n/* harmony import */ var _es_can_stache_converters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./es/can-stache-converters */ \"./node_modules/can/es/can-stache-converters.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stacheConverters\", function() { return _es_can_stache_converters__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; });\n\n/* harmony import */ var _es_can_view_autorender__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./es/can-view-autorender */ \"./node_modules/can/es/can-view-autorender.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"viewAutorender\", function() { return _es_can_view_autorender__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; });\n\n/* harmony import */ var _es_can_super_model__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./es/can-super-model */ \"./node_modules/can/es/can-super-model.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"superModel\", function() { return _es_can_super_model__WEBPACK_IMPORTED_MODULE_11__[\"default\"]; });\n\n/* harmony import */ var _es_can_connect_feathers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./es/can-connect-feathers */ \"./node_modules/can/es/can-connect-feathers.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"connectFeathers\", function() { return _es_can_connect_feathers__WEBPACK_IMPORTED_MODULE_12__[\"default\"]; });\n\n/* harmony import */ var _es_can_connect_tag__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./es/can-connect-tag */ \"./node_modules/can/es/can-connect-tag.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"connectTag\", function() { return _es_can_connect_tag__WEBPACK_IMPORTED_MODULE_13__[\"default\"]; });\n\n/* harmony import */ var _es_can_fixture_socket__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./es/can-fixture-socket */ \"./node_modules/can/es/can-fixture-socket.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"fixtureSocket\", function() { return _es_can_fixture_socket__WEBPACK_IMPORTED_MODULE_14__[\"default\"]; });\n\n/* harmony import */ var _es_can_ndjson_stream__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./es/can-ndjson-stream */ \"./node_modules/can/es/can-ndjson-stream.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ndjsonStream\", function() { return _es_can_ndjson_stream__WEBPACK_IMPORTED_MODULE_15__[\"default\"]; });\n\n/* harmony import */ var _es_can_connect_ndjson__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./es/can-connect-ndjson */ \"./node_modules/can/es/can-connect-ndjson.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"connectNDJSON\", function() { return _es_can_connect_ndjson__WEBPACK_IMPORTED_MODULE_16__[\"default\"]; });\n\n/* harmony import */ var _es_can_connect_session__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./es/can-connect-session */ \"./node_modules/can/es/can-connect-session.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"connectCanSession\", function() { return _es_can_connect_session__WEBPACK_IMPORTED_MODULE_17__[\"default\"]; });\n\n/* harmony import */ var _es_can_construct_super__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./es/can-construct-super */ \"./node_modules/can/es/can-construct-super.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"constructSuper\", function() { return _es_can_construct_super__WEBPACK_IMPORTED_MODULE_18__[\"default\"]; });\n\n/* harmony import */ var _es_can_route_mock__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./es/can-route-mock */ \"./node_modules/can/es/can-route-mock.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RouteMock\", function() { return _es_can_route_mock__WEBPACK_IMPORTED_MODULE_19__[\"default\"]; });\n\n/* harmony import */ var _es_can_define_validate_validatejs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./es/can-define-validate-validatejs */ \"./node_modules/can/es/can-define-validate-validatejs.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineValidateValidatejs\", function() { return _es_can_define_validate_validatejs__WEBPACK_IMPORTED_MODULE_20__[\"default\"]; });\n\n/* harmony import */ var _es_can_validate__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./es/can-validate */ \"./node_modules/can/es/can-validate.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"validate\", function() { return _es_can_validate__WEBPACK_IMPORTED_MODULE_21__[\"default\"]; });\n\n/* harmony import */ var _es_can_validate_validatejs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./es/can-validate-validatejs */ \"./node_modules/can/es/can-validate-validatejs.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"validateValidatejs\", function() { return _es_can_validate_validatejs__WEBPACK_IMPORTED_MODULE_22__[\"default\"]; });\n\n/* harmony import */ var _es_can_deep_observable__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./es/can-deep-observable */ \"./node_modules/can/es/can-deep-observable.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DeepObservable\", function() { return _es_can_deep_observable__WEBPACK_IMPORTED_MODULE_23__[\"default\"]; });\n\n/* harmony import */ var _es_can_event_dom_radiochange__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./es/can-event-dom-radiochange */ \"./node_modules/can/es/can-event-dom-radiochange.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"radioChangeEvent\", function() { return _es_can_event_dom_radiochange__WEBPACK_IMPORTED_MODULE_24__[\"default\"]; });\n\n/* harmony import */ var _es_can_event_dom_enter__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./es/can-event-dom-enter */ \"./node_modules/can/es/can-event-dom-enter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"enterEvent\", function() { return _es_can_event_dom_enter__WEBPACK_IMPORTED_MODULE_25__[\"default\"]; });\n\n/* harmony import */ var _es_can_observable_mixin__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./es/can-observable-mixin */ \"./node_modules/can/es/can-observable-mixin.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"observableMixin\", function() { return _es_can_observable_mixin__WEBPACK_IMPORTED_MODULE_26__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineMixin\", function() { return _es_can_observable_mixin__WEBPACK_IMPORTED_MODULE_26__[\"default\"]; });\n\n// Observables\n\n\n\n\n\n\n\n\n\n\n// Views\n\n\n\n\n// Data Modeling\n\n\n\n\n\n\n\n\n// Typed Data\n\n\n// Routing\n\n\n\n// Data Validation\n\n\n\n\n\n// DOM Utilities\n\n\n\n // legacy\n\n\n//# sourceURL=webpack:///./node_modules/can/ecosystem.js?");

/***/ }),

/***/ "./node_modules/can/enable-can-debug.js":
/*!**********************************************!*\
  !*** ./node_modules/can/enable-can-debug.js ***!
  \**********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _es_can_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./es/can-debug */ \"./node_modules/can/es/can-debug.js\");\n\n\n//!steal-remove-start\nif(true) {\n\tObject(_es_can_debug__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n}\n//!steal-remove-end\n\n\n//# sourceURL=webpack:///./node_modules/can/enable-can-debug.js?");

/***/ }),

/***/ "./node_modules/can/es/can-ajax.js":
/*!*****************************************!*\
  !*** ./node_modules/can/es/can-ajax.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_ajax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-ajax */ \"./node_modules/can-ajax/dist/cjs/can-ajax.js\");\n/* harmony import */ var can_ajax__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_ajax__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_ajax__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-ajax.js?");

/***/ }),

/***/ "./node_modules/can/es/can-assign.js":
/*!*******************************************!*\
  !*** ./node_modules/can/es/can-assign.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-assign */ \"./node_modules/can-assign/can-assign.js\");\n/* harmony import */ var can_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_assign__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_assign__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-assign.js?");

/***/ }),

/***/ "./node_modules/can/es/can-attribute-encoder.js":
/*!******************************************************!*\
  !*** ./node_modules/can/es/can-attribute-encoder.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_attribute_encoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-attribute-encoder */ \"./node_modules/can-attribute-encoder/can-attribute-encoder.js\");\n/* harmony import */ var can_attribute_encoder__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_attribute_encoder__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_attribute_encoder__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-attribute-encoder.js?");

/***/ }),

/***/ "./node_modules/can/es/can-bind.js":
/*!*****************************************!*\
  !*** ./node_modules/can/es/can-bind.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_bind__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-bind */ \"./node_modules/can-bind/can-bind.js\");\n/* harmony import */ var can_bind__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_bind__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_bind__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-bind.js?");

/***/ }),

/***/ "./node_modules/can/es/can-child-nodes.js":
/*!************************************************!*\
  !*** ./node_modules/can/es/can-child-nodes.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_child_nodes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-child-nodes */ \"./node_modules/can-child-nodes/can-child-nodes.js\");\n/* harmony import */ var can_child_nodes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_child_nodes__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_child_nodes__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-child-nodes.js?");

/***/ }),

/***/ "./node_modules/can/es/can-component.js":
/*!**********************************************!*\
  !*** ./node_modules/can/es/can-component.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-component */ \"./node_modules/can-component/can-component.js\");\n/* harmony import */ var can_component__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_component__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_component__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-component.js?");

/***/ }),

/***/ "./node_modules/can/es/can-compute.js":
/*!********************************************!*\
  !*** ./node_modules/can/es/can-compute.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_compute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-compute */ \"./node_modules/can-compute/can-compute.js\");\n/* harmony import */ var can_compute__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_compute__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_compute__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-compute.js?");

/***/ }),

/***/ "./node_modules/can/es/can-connect-feathers.js":
/*!*****************************************************!*\
  !*** ./node_modules/can/es/can-connect-feathers.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_connect_feathers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-connect-feathers */ \"./node_modules/can-connect-feathers/can-connect-feathers.js\");\n/* harmony import */ var can_connect_feathers__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_connect_feathers__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_connect_feathers__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-connect-feathers.js?");

/***/ }),

/***/ "./node_modules/can/es/can-connect-ndjson.js":
/*!***************************************************!*\
  !*** ./node_modules/can/es/can-connect-ndjson.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_connect_ndjson__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-connect-ndjson */ \"./node_modules/can-connect-ndjson/can-connect-ndjson.js\");\n/* harmony import */ var can_connect_ndjson__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_connect_ndjson__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_connect_ndjson__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-connect-ndjson.js?");

/***/ }),

/***/ "./node_modules/can/es/can-connect-session.js":
/*!****************************************************!*\
  !*** ./node_modules/can/es/can-connect-session.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_connect_can_session_session__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-connect/can/session/session */ \"./node_modules/can-connect/can/session/session.js\");\n/* harmony import */ var can_connect_can_session_session__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_connect_can_session_session__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_connect_can_session_session__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-connect-session.js?");

/***/ }),

/***/ "./node_modules/can/es/can-connect-tag.js":
/*!************************************************!*\
  !*** ./node_modules/can/es/can-connect-tag.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_connect_tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-connect-tag */ \"./node_modules/can-connect-tag/can-connect-tag.js\");\n/* harmony import */ var can_connect_tag__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_connect_tag__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_connect_tag__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-connect-tag.js?");

/***/ }),

/***/ "./node_modules/can/es/can-connect.js":
/*!********************************************!*\
  !*** ./node_modules/can/es/can-connect.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_connect_all__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-connect/all */ \"./node_modules/can-connect/all.js\");\n/* harmony import */ var can_connect_all__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_connect_all__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_connect_all__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-connect.js?");

/***/ }),

/***/ "./node_modules/can/es/can-construct-super.js":
/*!****************************************************!*\
  !*** ./node_modules/can/es/can-construct-super.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_construct_super__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-construct-super */ \"./node_modules/can-construct-super/can-construct-super.js\");\n/* harmony import */ var can_construct_super__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_construct_super__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_construct_super__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-construct-super.js?");

/***/ }),

/***/ "./node_modules/can/es/can-control.js":
/*!********************************************!*\
  !*** ./node_modules/can/es/can-control.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_control__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-control */ \"./node_modules/can-control/can-control.js\");\n/* harmony import */ var can_control__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_control__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_control__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-control.js?");

/***/ }),

/***/ "./node_modules/can/es/can-data-types.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-data-types.js ***!
  \***********************************************/
/*! exports provided: MaybeBoolean, MaybeDate, MaybeNumber, MaybeString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_data_types_maybe_boolean_maybe_boolean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-data-types/maybe-boolean/maybe-boolean */ \"./node_modules/can-data-types/maybe-boolean/maybe-boolean.js\");\n/* harmony import */ var can_data_types_maybe_boolean_maybe_boolean__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_data_types_maybe_boolean_maybe_boolean__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"MaybeBoolean\", function() { return can_data_types_maybe_boolean_maybe_boolean__WEBPACK_IMPORTED_MODULE_0___default.a; });\n/* harmony import */ var can_data_types_maybe_date_maybe_date__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! can-data-types/maybe-date/maybe-date */ \"./node_modules/can-data-types/maybe-date/maybe-date.js\");\n/* harmony import */ var can_data_types_maybe_date_maybe_date__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(can_data_types_maybe_date_maybe_date__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"MaybeDate\", function() { return can_data_types_maybe_date_maybe_date__WEBPACK_IMPORTED_MODULE_1___default.a; });\n/* harmony import */ var can_data_types_maybe_number_maybe_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! can-data-types/maybe-number/maybe-number */ \"./node_modules/can-data-types/maybe-number/maybe-number.js\");\n/* harmony import */ var can_data_types_maybe_number_maybe_number__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(can_data_types_maybe_number_maybe_number__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"MaybeNumber\", function() { return can_data_types_maybe_number_maybe_number__WEBPACK_IMPORTED_MODULE_2___default.a; });\n/* harmony import */ var can_data_types_maybe_string_maybe_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! can-data-types/maybe-string/maybe-string */ \"./node_modules/can-data-types/maybe-string/maybe-string.js\");\n/* harmony import */ var can_data_types_maybe_string_maybe_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(can_data_types_maybe_string_maybe_string__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"MaybeString\", function() { return can_data_types_maybe_string_maybe_string__WEBPACK_IMPORTED_MODULE_3___default.a; });\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-data-types.js?");

/***/ }),

/***/ "./node_modules/can/es/can-debug.js":
/*!******************************************!*\
  !*** ./node_modules/can/es/can-debug.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-debug */ \"./node_modules/can-debug/can-debug.js\");\n/* harmony import */ var can_debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_debug__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-debug.js?");

/***/ }),

/***/ "./node_modules/can/es/can-deep-observable.js":
/*!****************************************************!*\
  !*** ./node_modules/can/es/can-deep-observable.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_deep_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-deep-observable */ \"./node_modules/can-deep-observable/can-deep-observable.js\");\n/* harmony import */ var can_deep_observable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_deep_observable__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_deep_observable__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-deep-observable.js?");

/***/ }),

/***/ "./node_modules/can/es/can-define-backup.js":
/*!**************************************************!*\
  !*** ./node_modules/can/es/can-define-backup.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_define_backup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-define-backup */ \"./node_modules/can-define-backup/can-define-backup.js\");\n/* harmony import */ var can_define_backup__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_define_backup__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_define_backup__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-define-backup.js?");

/***/ }),

/***/ "./node_modules/can/es/can-define-lazy-value.js":
/*!******************************************************!*\
  !*** ./node_modules/can/es/can-define-lazy-value.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_define_lazy_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-define-lazy-value */ \"./node_modules/can-define-lazy-value/define-lazy-value.js\");\n/* harmony import */ var can_define_lazy_value__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_define_lazy_value__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_define_lazy_value__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-define-lazy-value.js?");

/***/ }),

/***/ "./node_modules/can/es/can-define-realtime-rest-model.js":
/*!***************************************************************!*\
  !*** ./node_modules/can/es/can-define-realtime-rest-model.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_define_realtime_rest_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-define-realtime-rest-model */ \"./node_modules/can-define-realtime-rest-model/can-define-realtime-rest-model.js\");\n/* harmony import */ var can_define_realtime_rest_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_define_realtime_rest_model__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_define_realtime_rest_model__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-define-realtime-rest-model.js?");

/***/ }),

/***/ "./node_modules/can/es/can-define-rest-model.js":
/*!******************************************************!*\
  !*** ./node_modules/can/es/can-define-rest-model.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_define_rest_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-define-rest-model */ \"./node_modules/can-define-rest-model/can-define-rest-model.js\");\n/* harmony import */ var can_define_rest_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_define_rest_model__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_define_rest_model__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-define-rest-model.js?");

/***/ }),

/***/ "./node_modules/can/es/can-define-stream-kefir.js":
/*!********************************************************!*\
  !*** ./node_modules/can/es/can-define-stream-kefir.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_define_stream_kefir__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-define-stream-kefir */ \"./node_modules/can-define-stream-kefir/can-define-stream-kefir.js\");\n/* harmony import */ var can_define_stream_kefir__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_define_stream_kefir__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_define_stream_kefir__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-define-stream-kefir.js?");

/***/ }),

/***/ "./node_modules/can/es/can-define-stream.js":
/*!**************************************************!*\
  !*** ./node_modules/can/es/can-define-stream.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_define_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-define-stream */ \"./node_modules/can-define-stream/can-define-stream.js\");\n/* harmony import */ var can_define_stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_define_stream__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_define_stream__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-define-stream.js?");

/***/ }),

/***/ "./node_modules/can/es/can-define-validate-validatejs.js":
/*!***************************************************************!*\
  !*** ./node_modules/can/es/can-define-validate-validatejs.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_define_validate_validatejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-define-validate-validatejs */ \"./node_modules/can-define-validate-validatejs/can-define-validate-validatejs.js\");\n/* harmony import */ var can_define_validate_validatejs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_define_validate_validatejs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_define_validate_validatejs__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-define-validate-validatejs.js?");

/***/ }),

/***/ "./node_modules/can/es/can-define.js":
/*!*******************************************!*\
  !*** ./node_modules/can/es/can-define.js ***!
  \*******************************************/
/*! exports provided: define, DefineMap, DefineList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-define */ \"./node_modules/can-define/can-define.js\");\n/* harmony import */ var can_define__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_define__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"define\", function() { return can_define__WEBPACK_IMPORTED_MODULE_0___default.a; });\n/* harmony import */ var can_define_map_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! can-define/map/map */ \"./node_modules/can-define/map/map.js\");\n/* harmony import */ var can_define_map_map__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(can_define_map_map__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"DefineMap\", function() { return can_define_map_map__WEBPACK_IMPORTED_MODULE_1___default.a; });\n/* harmony import */ var can_define_list_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! can-define/list/list */ \"./node_modules/can-define/list/list.js\");\n/* harmony import */ var can_define_list_list__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(can_define_list_list__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"DefineList\", function() { return can_define_list_list__WEBPACK_IMPORTED_MODULE_2___default.a; });\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-define.js?");

/***/ }),

/***/ "./node_modules/can/es/can-deparam.js":
/*!********************************************!*\
  !*** ./node_modules/can/es/can-deparam.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_deparam__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-deparam */ \"./node_modules/can-deparam/can-deparam.js\");\n/* harmony import */ var can_deparam__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_deparam__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_deparam__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-deparam.js?");

/***/ }),

/***/ "./node_modules/can/es/can-diff.js":
/*!*****************************************!*\
  !*** ./node_modules/can/es/can-diff.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_diff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-diff */ \"./node_modules/can-diff/can-diff.js\");\n/* harmony import */ var can_diff__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_diff__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_diff__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-diff.js?");

/***/ }),

/***/ "./node_modules/can/es/can-dom-data.js":
/*!*********************************************!*\
  !*** ./node_modules/can/es/can-dom-data.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_dom_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-dom-data */ \"./node_modules/can-dom-data/can-dom-data.js\");\n/* harmony import */ var can_dom_data__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_dom_data__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_dom_data__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-dom-data.js?");

/***/ }),

/***/ "./node_modules/can/es/can-dom-events.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-dom-events.js ***!
  \***********************************************/
/*! exports provided: default, addJQueryEvents */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_dom_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-dom-events */ \"./node_modules/can-dom-events/can-dom-events.js\");\n/* harmony import */ var can_dom_events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_dom_events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_dom_events__WEBPACK_IMPORTED_MODULE_0___default.a; });\n/* harmony import */ var can_dom_events_helpers_add_jquery_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! can-dom-events/helpers/add-jquery-events */ \"./node_modules/can-dom-events/helpers/add-jquery-events.js\");\n/* harmony import */ var can_dom_events_helpers_add_jquery_events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(can_dom_events_helpers_add_jquery_events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"addJQueryEvents\", function() { return can_dom_events_helpers_add_jquery_events__WEBPACK_IMPORTED_MODULE_1___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-dom-events.js?");

/***/ }),

/***/ "./node_modules/can/es/can-dom-mutate.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-dom-mutate.js ***!
  \***********************************************/
/*! exports provided: default, domMutateNode, domMutateDomEvents */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_dom_mutate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-dom-mutate */ \"./node_modules/can-dom-mutate/can-dom-mutate.js\");\n/* harmony import */ var can_dom_mutate__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_dom_mutate__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_dom_mutate__WEBPACK_IMPORTED_MODULE_0___default.a; });\n/* harmony import */ var can_dom_mutate_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! can-dom-mutate/node */ \"./node_modules/can-dom-mutate/node.js\");\n/* harmony import */ var can_dom_mutate_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(can_dom_mutate_node__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"domMutateNode\", function() { return can_dom_mutate_node__WEBPACK_IMPORTED_MODULE_1___default.a; });\n/* harmony import */ var can_dom_mutate_dom_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! can-dom-mutate/dom-events */ \"./node_modules/can-dom-mutate/dom-events.js\");\n/* harmony import */ var can_dom_mutate_dom_events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(can_dom_mutate_dom_events__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"domMutateDomEvents\", function() { return can_dom_mutate_dom_events__WEBPACK_IMPORTED_MODULE_2___default.a; });\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-dom-mutate.js?");

/***/ }),

/***/ "./node_modules/can/es/can-event-dom-enter.js":
/*!****************************************************!*\
  !*** ./node_modules/can/es/can-event-dom-enter.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_event_dom_enter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-event-dom-enter */ \"./node_modules/can-event-dom-enter/can-event-dom-enter.js\");\n/* harmony import */ var can_event_dom_enter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_event_dom_enter__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_event_dom_enter__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-event-dom-enter.js?");

/***/ }),

/***/ "./node_modules/can/es/can-event-dom-radiochange.js":
/*!**********************************************************!*\
  !*** ./node_modules/can/es/can-event-dom-radiochange.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_event_dom_radiochange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-event-dom-radiochange */ \"./node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js\");\n/* harmony import */ var can_event_dom_radiochange__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_event_dom_radiochange__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_event_dom_radiochange__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-event-dom-radiochange.js?");

/***/ }),

/***/ "./node_modules/can/es/can-event-queue.js":
/*!************************************************!*\
  !*** ./node_modules/can/es/can-event-queue.js ***!
  \************************************************/
/*! exports provided: mapEventBindings, valueEventBindings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_event_queue_map_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-event-queue/map/map */ \"./node_modules/can-event-queue/map/map.js\");\n/* harmony import */ var can_event_queue_map_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_event_queue_map_map__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"mapEventBindings\", function() { return can_event_queue_map_map__WEBPACK_IMPORTED_MODULE_0___default.a; });\n/* harmony import */ var can_event_queue_value_value__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! can-event-queue/value/value */ \"./node_modules/can-event-queue/value/value.js\");\n/* harmony import */ var can_event_queue_value_value__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(can_event_queue_value_value__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"valueEventBindings\", function() { return can_event_queue_value_value__WEBPACK_IMPORTED_MODULE_1___default.a; });\n\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-event-queue.js?");

/***/ }),

/***/ "./node_modules/can/es/can-fixture-socket.js":
/*!***************************************************!*\
  !*** ./node_modules/can/es/can-fixture-socket.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_fixture_socket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-fixture-socket */ \"./node_modules/can-fixture-socket/can-fixture-socket.js\");\n/* harmony import */ var can_fixture_socket__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_fixture_socket__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_fixture_socket__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-fixture-socket.js?");

/***/ }),

/***/ "./node_modules/can/es/can-fixture.js":
/*!********************************************!*\
  !*** ./node_modules/can/es/can-fixture.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_fixture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-fixture */ \"./node_modules/can-fixture/fixture.js\");\n/* harmony import */ var can_fixture__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_fixture__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_fixture__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-fixture.js?");

/***/ }),

/***/ "./node_modules/can/es/can-fragment.js":
/*!*********************************************!*\
  !*** ./node_modules/can/es/can-fragment.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_fragment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-fragment */ \"./node_modules/can-fragment/can-fragment.js\");\n/* harmony import */ var can_fragment__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_fragment__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_fragment__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-fragment.js?");

/***/ }),

/***/ "./node_modules/can/es/can-globals.js":
/*!********************************************!*\
  !*** ./node_modules/can/es/can-globals.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-globals */ \"./node_modules/can-globals/can-globals.js\");\n/* harmony import */ var can_globals__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_globals__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_globals__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-globals.js?");

/***/ }),

/***/ "./node_modules/can/es/can-kefir.js":
/*!******************************************!*\
  !*** ./node_modules/can/es/can-kefir.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_kefir__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-kefir */ \"./node_modules/can-kefir/can-kefir.js\");\n/* harmony import */ var can_kefir__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_kefir__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_kefir__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-kefir.js?");

/***/ }),

/***/ "./node_modules/can/es/can-key-tree.js":
/*!*********************************************!*\
  !*** ./node_modules/can/es/can-key-tree.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_key_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-key-tree */ \"./node_modules/can-key-tree/can-key-tree.js\");\n/* harmony import */ var can_key_tree__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_key_tree__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_key_tree__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-key-tree.js?");

/***/ }),

/***/ "./node_modules/can/es/can-key.js":
/*!****************************************!*\
  !*** ./node_modules/can/es/can-key.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_key__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-key */ \"./node_modules/can-key/can-key.js\");\n/* harmony import */ var can_key__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_key__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_key__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-key.js?");

/***/ }),

/***/ "./node_modules/can/es/can-list.js":
/*!*****************************************!*\
  !*** ./node_modules/can/es/can-list.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-list */ \"./node_modules/can-list/can-list.js\");\n/* harmony import */ var can_list__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_list__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_list__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-list.js?");

/***/ }),

/***/ "./node_modules/can/es/can-local-store.js":
/*!************************************************!*\
  !*** ./node_modules/can/es/can-local-store.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_local_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-local-store */ \"./node_modules/can-local-store/can-local-store.js\");\n/* harmony import */ var can_local_store__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_local_store__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_local_store__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-local-store.js?");

/***/ }),

/***/ "./node_modules/can/es/can-make-map.js":
/*!*********************************************!*\
  !*** ./node_modules/can/es/can-make-map.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_make_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-make-map */ \"./node_modules/can-make-map/can-make-map.js\");\n/* harmony import */ var can_make_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_make_map__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_make_map__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-make-map.js?");

/***/ }),

/***/ "./node_modules/can/es/can-map-compat.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-map-compat.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_map_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-map-compat */ \"./node_modules/can-map-compat/can-map-compat.js\");\n/* harmony import */ var can_map_compat__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_map_compat__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_map_compat__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-map-compat.js?");

/***/ }),

/***/ "./node_modules/can/es/can-map-define.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-map-define.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_map_define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-map-define */ \"./node_modules/can-map-define/can-map-define.js\");\n/* harmony import */ var can_map_define__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_map_define__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_map_define__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-map-define.js?");

/***/ }),

/***/ "./node_modules/can/es/can-map.js":
/*!****************************************!*\
  !*** ./node_modules/can/es/can-map.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-map */ \"./node_modules/can-map/can-map.js\");\n/* harmony import */ var can_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_map__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_map__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-map.js?");

/***/ }),

/***/ "./node_modules/can/es/can-memory-store.js":
/*!*************************************************!*\
  !*** ./node_modules/can/es/can-memory-store.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_memory_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-memory-store */ \"./node_modules/can-memory-store/can-memory-store.js\");\n/* harmony import */ var can_memory_store__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_memory_store__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_memory_store__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-memory-store.js?");

/***/ }),

/***/ "./node_modules/can/es/can-namespace.js":
/*!**********************************************!*\
  !*** ./node_modules/can/es/can-namespace.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-namespace */ \"./node_modules/can-namespace/can-namespace.js\");\n/* harmony import */ var can_namespace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_namespace__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_namespace__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-namespace.js?");

/***/ }),

/***/ "./node_modules/can/es/can-ndjson-stream.js":
/*!**************************************************!*\
  !*** ./node_modules/can/es/can-ndjson-stream.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_ndjson_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-ndjson-stream */ \"./node_modules/can-ndjson-stream/can-ndjson-stream.js\");\n/* harmony import */ var can_ndjson_stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_ndjson_stream__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_ndjson_stream__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-ndjson-stream.js?");

/***/ }),

/***/ "./node_modules/can/es/can-observable-array.js":
/*!*****************************************************!*\
  !*** ./node_modules/can/es/can-observable-array.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_observable_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-observable-array */ \"./node_modules/can-observable-array/dist/can-observable-array.js\");\n/* harmony import */ var can_observable_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_observable_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_observable_array__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-observable-array.js?");

/***/ }),

/***/ "./node_modules/can/es/can-observable-mixin.js":
/*!*****************************************************!*\
  !*** ./node_modules/can/es/can-observable-mixin.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_observable_mixin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-observable-mixin */ \"./node_modules/can-observable-mixin/dist/mixins.js\");\n/* harmony import */ var can_observable_mixin__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_observable_mixin__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_observable_mixin__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-observable-mixin.js?");

/***/ }),

/***/ "./node_modules/can/es/can-observable-object.js":
/*!******************************************************!*\
  !*** ./node_modules/can/es/can-observable-object.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_observable_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-observable-object */ \"./node_modules/can-observable-object/dist/can-observable-object.js\");\n/* harmony import */ var can_observable_object__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_observable_object__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_observable_object__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-observable-object.js?");

/***/ }),

/***/ "./node_modules/can/es/can-observation-recorder.js":
/*!*********************************************************!*\
  !*** ./node_modules/can/es/can-observation-recorder.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_observation_recorder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-observation-recorder */ \"./node_modules/can-observation-recorder/can-observation-recorder.js\");\n/* harmony import */ var can_observation_recorder__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_observation_recorder__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_observation_recorder__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-observation-recorder.js?");

/***/ }),

/***/ "./node_modules/can/es/can-observation.js":
/*!************************************************!*\
  !*** ./node_modules/can/es/can-observation.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_observation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-observation */ \"./node_modules/can-observation/can-observation.js\");\n/* harmony import */ var can_observation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_observation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_observation__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-observation.js?");

/***/ }),

/***/ "./node_modules/can/es/can-observe.js":
/*!********************************************!*\
  !*** ./node_modules/can/es/can-observe.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_observe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-observe */ \"./node_modules/can-observe/can-observe.js\");\n/* harmony import */ var can_observe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_observe__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_observe__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-observe.js?");

/***/ }),

/***/ "./node_modules/can/es/can-param.js":
/*!******************************************!*\
  !*** ./node_modules/can/es/can-param.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_param__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-param */ \"./node_modules/can-param/can-param.js\");\n/* harmony import */ var can_param__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_param__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_param__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-param.js?");

/***/ }),

/***/ "./node_modules/can/es/can-parse-uri.js":
/*!**********************************************!*\
  !*** ./node_modules/can/es/can-parse-uri.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_parse_uri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-parse-uri */ \"./node_modules/can-parse-uri/can-parse-uri.js\");\n/* harmony import */ var can_parse_uri__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_parse_uri__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_parse_uri__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-parse-uri.js?");

/***/ }),

/***/ "./node_modules/can/es/can-query-logic.js":
/*!************************************************!*\
  !*** ./node_modules/can/es/can-query-logic.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_query_logic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-query-logic */ \"./node_modules/can-query-logic/can-query-logic.js\");\n/* harmony import */ var can_query_logic__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_query_logic__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_query_logic__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-query-logic.js?");

/***/ }),

/***/ "./node_modules/can/es/can-queues.js":
/*!*******************************************!*\
  !*** ./node_modules/can/es/can-queues.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_queues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-queues */ \"./node_modules/can-queues/can-queues.js\");\n/* harmony import */ var can_queues__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_queues__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_queues__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-queues.js?");

/***/ }),

/***/ "./node_modules/can/es/can-realtime-rest-model.js":
/*!********************************************************!*\
  !*** ./node_modules/can/es/can-realtime-rest-model.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_realtime_rest_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-realtime-rest-model */ \"./node_modules/can-realtime-rest-model/can-realtime-rest-model.js\");\n/* harmony import */ var can_realtime_rest_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_realtime_rest_model__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_realtime_rest_model__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-realtime-rest-model.js?");

/***/ }),

/***/ "./node_modules/can/es/can-reflect-dependencies.js":
/*!*********************************************************!*\
  !*** ./node_modules/can/es/can-reflect-dependencies.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_reflect_dependencies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-reflect-dependencies */ \"./node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\n/* harmony import */ var can_reflect_dependencies__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_reflect_dependencies__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_reflect_dependencies__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-reflect-dependencies.js?");

/***/ }),

/***/ "./node_modules/can/es/can-reflect-promise.js":
/*!****************************************************!*\
  !*** ./node_modules/can/es/can-reflect-promise.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_reflect_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-reflect-promise */ \"./node_modules/can-reflect-promise/can-reflect-promise.js\");\n/* harmony import */ var can_reflect_promise__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_reflect_promise__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_reflect_promise__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-reflect-promise.js?");

/***/ }),

/***/ "./node_modules/can/es/can-reflect.js":
/*!********************************************!*\
  !*** ./node_modules/can/es/can-reflect.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_reflect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-reflect */ \"./node_modules/can-reflect/can-reflect.js\");\n/* harmony import */ var can_reflect__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_reflect__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_reflect__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-reflect.js?");

/***/ }),

/***/ "./node_modules/can/es/can-rest-model.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-rest-model.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_rest_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-rest-model */ \"./node_modules/can-rest-model/can-rest-model.js\");\n/* harmony import */ var can_rest_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_rest_model__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_rest_model__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-rest-model.js?");

/***/ }),

/***/ "./node_modules/can/es/can-route-hash.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-route-hash.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_route_hash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-route-hash */ \"./node_modules/can-route-hash/can-route-hash.js\");\n/* harmony import */ var can_route_hash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_route_hash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_route_hash__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-route-hash.js?");

/***/ }),

/***/ "./node_modules/can/es/can-route-mock.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-route-mock.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_route_mock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-route-mock */ \"./node_modules/can-route-mock/can-route-mock.js\");\n/* harmony import */ var can_route_mock__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_route_mock__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_route_mock__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-route-mock.js?");

/***/ }),

/***/ "./node_modules/can/es/can-route-pushstate.js":
/*!****************************************************!*\
  !*** ./node_modules/can/es/can-route-pushstate.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_route_pushstate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-route-pushstate */ \"./node_modules/can-route-pushstate/can-route-pushstate.js\");\n/* harmony import */ var can_route_pushstate__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_route_pushstate__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_route_pushstate__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-route-pushstate.js?");

/***/ }),

/***/ "./node_modules/can/es/can-route.js":
/*!******************************************!*\
  !*** ./node_modules/can/es/can-route.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_route__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-route */ \"./node_modules/can-route/can-route.js\");\n/* harmony import */ var can_route__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_route__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_route__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-route.js?");

/***/ }),

/***/ "./node_modules/can/es/can-set-legacy.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-set-legacy.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_set_legacy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-set-legacy */ \"./node_modules/can-set-legacy/can-set-legacy.js\");\n/* harmony import */ var can_set_legacy__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_set_legacy__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_set_legacy__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-set-legacy.js?");

/***/ }),

/***/ "./node_modules/can/es/can-simple-map.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-simple-map.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_simple_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-simple-map */ \"./node_modules/can-simple-map/can-simple-map.js\");\n/* harmony import */ var can_simple_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_simple_map__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_simple_map__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-simple-map.js?");

/***/ }),

/***/ "./node_modules/can/es/can-simple-observable.js":
/*!******************************************************!*\
  !*** ./node_modules/can/es/can-simple-observable.js ***!
  \******************************************************/
/*! exports provided: default, AsyncObservable, keyObservable, ResolverObservable, SettableObservable, SetterObservable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_simple_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-simple-observable */ \"./node_modules/can-simple-observable/can-simple-observable.js\");\n/* harmony import */ var can_simple_observable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_simple_observable__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_simple_observable__WEBPACK_IMPORTED_MODULE_0___default.a; });\n/* harmony import */ var can_simple_observable_async_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! can-simple-observable/async/async */ \"./node_modules/can-simple-observable/async/async.js\");\n/* harmony import */ var can_simple_observable_async_async__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(can_simple_observable_async_async__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"AsyncObservable\", function() { return can_simple_observable_async_async__WEBPACK_IMPORTED_MODULE_1___default.a; });\n/* harmony import */ var can_simple_observable_key_key__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! can-simple-observable/key/key */ \"./node_modules/can-simple-observable/key/key.js\");\n/* harmony import */ var can_simple_observable_key_key__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(can_simple_observable_key_key__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"keyObservable\", function() { return can_simple_observable_key_key__WEBPACK_IMPORTED_MODULE_2___default.a; });\n/* harmony import */ var can_simple_observable_resolver_resolver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! can-simple-observable/resolver/resolver */ \"./node_modules/can-simple-observable/resolver/resolver.js\");\n/* harmony import */ var can_simple_observable_resolver_resolver__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(can_simple_observable_resolver_resolver__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"ResolverObservable\", function() { return can_simple_observable_resolver_resolver__WEBPACK_IMPORTED_MODULE_3___default.a; });\n/* harmony import */ var can_simple_observable_settable_settable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! can-simple-observable/settable/settable */ \"./node_modules/can-simple-observable/settable/settable.js\");\n/* harmony import */ var can_simple_observable_settable_settable__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(can_simple_observable_settable_settable__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"SettableObservable\", function() { return can_simple_observable_settable_settable__WEBPACK_IMPORTED_MODULE_4___default.a; });\n/* harmony import */ var can_simple_observable_setter_setter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! can-simple-observable/setter/setter */ \"./node_modules/can-simple-observable/setter/setter.js\");\n/* harmony import */ var can_simple_observable_setter_setter__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(can_simple_observable_setter_setter__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"SetterObservable\", function() { return can_simple_observable_setter_setter__WEBPACK_IMPORTED_MODULE_5___default.a; });\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-simple-observable.js?");

/***/ }),

/***/ "./node_modules/can/es/can-stache-bindings.js":
/*!****************************************************!*\
  !*** ./node_modules/can/es/can-stache-bindings.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_stache_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\n/* harmony import */ var can_stache_bindings__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_stache_bindings__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_stache_bindings__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-stache-bindings.js?");

/***/ }),

/***/ "./node_modules/can/es/can-stache-converters.js":
/*!******************************************************!*\
  !*** ./node_modules/can/es/can-stache-converters.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_stache_converters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-stache-converters */ \"./node_modules/can-stache-converters/can-stache-converters.js\");\n/* harmony import */ var can_stache_converters__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_stache_converters__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_stache_converters__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-stache-converters.js?");

/***/ }),

/***/ "./node_modules/can/es/can-stache-element.js":
/*!***************************************************!*\
  !*** ./node_modules/can/es/can-stache-element.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_stache_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-stache-element */ \"./node_modules/can-stache-element/dist/can-stache-element.js\");\n/* harmony import */ var can_stache_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_stache_element__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_stache_element__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-stache-element.js?");

/***/ }),

/***/ "./node_modules/can/es/can-stache-route-helpers.js":
/*!*********************************************************!*\
  !*** ./node_modules/can/es/can-stache-route-helpers.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_stache_route_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-stache-route-helpers */ \"./node_modules/can-stache-route-helpers/can-stache-route-helpers.js\");\n/* harmony import */ var can_stache_route_helpers__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_stache_route_helpers__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_stache_route_helpers__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-stache-route-helpers.js?");

/***/ }),

/***/ "./node_modules/can/es/can-stache.js":
/*!*******************************************!*\
  !*** ./node_modules/can/es/can-stache.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_stache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-stache */ \"./node_modules/can-stache/can-stache.js\");\n/* harmony import */ var can_stache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_stache__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_stache__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-stache.js?");

/***/ }),

/***/ "./node_modules/can/es/can-stream-kefir.js":
/*!*************************************************!*\
  !*** ./node_modules/can/es/can-stream-kefir.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_stream_kefir__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-stream-kefir */ \"./node_modules/can-stream-kefir/can-stream-kefir.js\");\n/* harmony import */ var can_stream_kefir__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_stream_kefir__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_stream_kefir__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-stream-kefir.js?");

/***/ }),

/***/ "./node_modules/can/es/can-stream.js":
/*!*******************************************!*\
  !*** ./node_modules/can/es/can-stream.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-stream */ \"./node_modules/can-stream/can-stream.js\");\n/* harmony import */ var can_stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_stream__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_stream__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-stream.js?");

/***/ }),

/***/ "./node_modules/can/es/can-string-to-any.js":
/*!**************************************************!*\
  !*** ./node_modules/can/es/can-string-to-any.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_string_to_any__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-string-to-any */ \"./node_modules/can-string-to-any/can-string-to-any.js\");\n/* harmony import */ var can_string_to_any__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_string_to_any__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_string_to_any__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-string-to-any.js?");

/***/ }),

/***/ "./node_modules/can/es/can-string.js":
/*!*******************************************!*\
  !*** ./node_modules/can/es/can-string.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-string */ \"./node_modules/can-string/can-string.js\");\n/* harmony import */ var can_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_string__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_string__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-string.js?");

/***/ }),

/***/ "./node_modules/can/es/can-super-model.js":
/*!************************************************!*\
  !*** ./node_modules/can/es/can-super-model.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_super_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-super-model */ \"./node_modules/can-super-model/can-super-model.js\");\n/* harmony import */ var can_super_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_super_model__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_super_model__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-super-model.js?");

/***/ }),

/***/ "./node_modules/can/es/can-type.js":
/*!*****************************************!*\
  !*** ./node_modules/can/es/can-type.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-type */ \"./node_modules/can-type/can-type.js\");\n/* harmony import */ var can_type__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_type__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_type__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-type.js?");

/***/ }),

/***/ "./node_modules/can/es/can-validate-interface.js":
/*!*******************************************************!*\
  !*** ./node_modules/can/es/can-validate-interface.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_validate_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-validate-interface */ \"./node_modules/can-validate-interface/index.js\");\n/* harmony import */ var can_validate_interface__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_validate_interface__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_validate_interface__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-validate-interface.js?");

/***/ }),

/***/ "./node_modules/can/es/can-validate-validatejs.js":
/*!********************************************************!*\
  !*** ./node_modules/can/es/can-validate-validatejs.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_validate_validatejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-validate-validatejs */ \"./node_modules/can-validate-validatejs/can-validate-validatejs.js\");\n/* harmony import */ var can_validate_validatejs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_validate_validatejs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_validate_validatejs__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-validate-validatejs.js?");

/***/ }),

/***/ "./node_modules/can/es/can-validate.js":
/*!*********************************************!*\
  !*** ./node_modules/can/es/can-validate.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_validate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-validate */ \"./node_modules/can-validate/can-validate.js\");\n/* harmony import */ var can_validate__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_validate__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_validate__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-validate.js?");

/***/ }),

/***/ "./node_modules/can/es/can-value.js":
/*!******************************************!*\
  !*** ./node_modules/can/es/can-value.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-value */ \"./node_modules/can-value/can-value.js\");\n/* harmony import */ var can_value__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_value__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_value__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-value.js?");

/***/ }),

/***/ "./node_modules/can/es/can-view-autorender.js":
/*!****************************************************!*\
  !*** ./node_modules/can/es/can-view-autorender.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_view_autorender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-view-autorender */ \"./node_modules/can-view-autorender/can-view-autorender.js\");\n/* harmony import */ var can_view_autorender__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_view_autorender__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_view_autorender__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-view-autorender.js?");

/***/ }),

/***/ "./node_modules/can/es/can-view-callbacks.js":
/*!***************************************************!*\
  !*** ./node_modules/can/es/can-view-callbacks.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_view_callbacks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-view-callbacks */ \"./node_modules/can-view-callbacks/can-view-callbacks.js\");\n/* harmony import */ var can_view_callbacks__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_view_callbacks__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_view_callbacks__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-view-callbacks.js?");

/***/ }),

/***/ "./node_modules/can/es/can-view-live.js":
/*!**********************************************!*\
  !*** ./node_modules/can/es/can-view-live.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_view_live__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-view-live */ \"./node_modules/can-view-live/can-view-live.js\");\n/* harmony import */ var can_view_live__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_view_live__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_view_live__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-view-live.js?");

/***/ }),

/***/ "./node_modules/can/es/can-view-model.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-view-model.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_view_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-view-model */ \"./node_modules/can-view-model/can-view-model.js\");\n/* harmony import */ var can_view_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_view_model__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_view_model__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-view-model.js?");

/***/ }),

/***/ "./node_modules/can/es/can-view-parser.js":
/*!************************************************!*\
  !*** ./node_modules/can/es/can-view-parser.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_view_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-view-parser */ \"./node_modules/can-view-parser/can-view-parser.js\");\n/* harmony import */ var can_view_parser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_view_parser__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_view_parser__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-view-parser.js?");

/***/ }),

/***/ "./node_modules/can/es/can-view-scope.js":
/*!***********************************************!*\
  !*** ./node_modules/can/es/can-view-scope.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_view_scope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-view-scope */ \"./node_modules/can-view-scope/can-view-scope.js\");\n/* harmony import */ var can_view_scope__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_view_scope__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_view_scope__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-view-scope.js?");

/***/ }),

/***/ "./node_modules/can/es/can-view-target.js":
/*!************************************************!*\
  !*** ./node_modules/can/es/can-view-target.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var can_view_target__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! can-view-target */ \"./node_modules/can-view-target/can-view-target.js\");\n/* harmony import */ var can_view_target__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(can_view_target__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return can_view_target__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./node_modules/can/es/can-view-target.js?");

/***/ }),

/***/ "./node_modules/can/legacy.js":
/*!************************************!*\
  !*** ./node_modules/can/legacy.js ***!
  \************************************/
/*! exports provided: define, DefineMap, DefineList, defineRealtimeRestModel, defineRestModel, compute, CanMap, CanList, canMapDefine, Component, set, Control */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _es_can_define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./es/can-define */ \"./node_modules/can/es/can-define.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"define\", function() { return _es_can_define__WEBPACK_IMPORTED_MODULE_0__[\"define\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DefineMap\", function() { return _es_can_define__WEBPACK_IMPORTED_MODULE_0__[\"DefineMap\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DefineList\", function() { return _es_can_define__WEBPACK_IMPORTED_MODULE_0__[\"DefineList\"]; });\n\n/* harmony import */ var _es_can_define_realtime_rest_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./es/can-define-realtime-rest-model */ \"./node_modules/can/es/can-define-realtime-rest-model.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineRealtimeRestModel\", function() { return _es_can_define_realtime_rest_model__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _es_can_define_rest_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./es/can-define-rest-model */ \"./node_modules/can/es/can-define-rest-model.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineRestModel\", function() { return _es_can_define_rest_model__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _es_can_compute__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./es/can-compute */ \"./node_modules/can/es/can-compute.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"compute\", function() { return _es_can_compute__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _es_can_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./es/can-map */ \"./node_modules/can/es/can-map.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CanMap\", function() { return _es_can_map__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _es_can_list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./es/can-list */ \"./node_modules/can/es/can-list.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CanList\", function() { return _es_can_list__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony import */ var _es_can_map_define__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./es/can-map-define */ \"./node_modules/can/es/can-map-define.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"canMapDefine\", function() { return _es_can_map_define__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; });\n\n/* harmony import */ var _es_can_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./es/can-component */ \"./node_modules/can/es/can-component.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _es_can_component__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; });\n\n/* harmony import */ var _es_can_set_legacy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./es/can-set-legacy */ \"./node_modules/can/es/can-set-legacy.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return _es_can_set_legacy__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n/* harmony import */ var _es_can_control__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./es/can-control */ \"./node_modules/can/es/can-control.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Control\", function() { return _es_can_control__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; });\n\n// Observables\n\n\n\n\n\n\n\n\n// Views\n\n\n// Data Models\n\n\n// DOM Utilities\n\n\n\n//# sourceURL=webpack:///./node_modules/can/legacy.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/feathers-authentication-popups/lib/feathers-authentication-popups.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/feathers-authentication-popups/lib/feathers-authentication-popups.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.authAgent = undefined;\nexports.default = openLoginPopup;\nexports.getCenterCoordinates = getCenterCoordinates;\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/node-libs-browser/node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.authAgent = new _events2.default();\n\nvar authAgent = exports.authAgent = window.authAgent;\n\n/*\n * A helper template to that opens the provided URL in a centered popup.\n * Accepts an `options` object with `width` and `height` number properties.\n */\nfunction openLoginPopup(url) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var width = options.width || 1024;\n  var height = options.height || 640;\n\n  var _getCenterCoordinates = getCenterCoordinates(window, width, height),\n      top = _getCenterCoordinates.top,\n      left = _getCenterCoordinates.left;\n\n  var params = 'width=' + width + ', height=' + height + ', top=' + top + ', left=' + left;\n  return window.open(url, 'authWindow', params);\n}\n\n/*\n * Returns the coordinates to center a popup window in the viewport with\n * the provided width and height args.\n */\nfunction getCenterCoordinates(window, width, height) {\n  return {\n    left: window.screenX + (window.outerWidth - width) / 2,\n    top: window.screenY + (window.outerHeight - height) / 2\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/feathers-authentication-popups/lib/feathers-authentication-popups.js?");

/***/ }),

/***/ "./node_modules/jwt-decode/lib/atob.js":
/*!*********************************************!*\
  !*** ./node_modules/jwt-decode/lib/atob.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * The code was extracted from:\n * https://github.com/davidchambers/Base64.js\n */\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction InvalidCharacterError(message) {\n  this.message = message;\n}\n\nInvalidCharacterError.prototype = new Error();\nInvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\nfunction polyfill (input) {\n  var str = String(input).replace(/=+$/, '');\n  if (str.length % 4 == 1) {\n    throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n  }\n  for (\n    // initialize result and counters\n    var bc = 0, bs, buffer, idx = 0, output = '';\n    // get next character\n    buffer = str.charAt(idx++);\n    // character found in table? initialize bit storage and add its ascii value;\n    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n      // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n  ) {\n    // try to find character in table (0-63, not found => -1)\n    buffer = chars.indexOf(buffer);\n  }\n  return output;\n}\n\n\nmodule.exports = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;\n\n\n//# sourceURL=webpack:///./node_modules/jwt-decode/lib/atob.js?");

/***/ }),

/***/ "./node_modules/jwt-decode/lib/base64_url_decode.js":
/*!**********************************************************!*\
  !*** ./node_modules/jwt-decode/lib/base64_url_decode.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var atob = __webpack_require__(/*! ./atob */ \"./node_modules/jwt-decode/lib/atob.js\");\n\nfunction b64DecodeUnicode(str) {\n  return decodeURIComponent(atob(str).replace(/(.)/g, function (m, p) {\n    var code = p.charCodeAt(0).toString(16).toUpperCase();\n    if (code.length < 2) {\n      code = '0' + code;\n    }\n    return '%' + code;\n  }));\n}\n\nmodule.exports = function(str) {\n  var output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  switch (output.length % 4) {\n    case 0:\n      break;\n    case 2:\n      output += \"==\";\n      break;\n    case 3:\n      output += \"=\";\n      break;\n    default:\n      throw \"Illegal base64url string!\";\n  }\n\n  try{\n    return b64DecodeUnicode(output);\n  } catch (err) {\n    return atob(output);\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/jwt-decode/lib/base64_url_decode.js?");

/***/ }),

/***/ "./node_modules/jwt-decode/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/jwt-decode/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar base64_url_decode = __webpack_require__(/*! ./base64_url_decode */ \"./node_modules/jwt-decode/lib/base64_url_decode.js\");\n\nfunction InvalidTokenError(message) {\n  this.message = message;\n}\n\nInvalidTokenError.prototype = new Error();\nInvalidTokenError.prototype.name = 'InvalidTokenError';\n\nmodule.exports = function (token,options) {\n  if (typeof token !== 'string') {\n    throw new InvalidTokenError('Invalid token specified');\n  }\n\n  options = options || {};\n  var pos = options.header === true ? 0 : 1;\n  try {\n    return JSON.parse(base64_url_decode(token.split('.')[pos]));\n  } catch (e) {\n    throw new InvalidTokenError('Invalid token specified: ' + e.message);\n  }\n};\n\nmodule.exports.InvalidTokenError = InvalidTokenError;\n\n\n//# sourceURL=webpack:///./node_modules/jwt-decode/lib/index.js?");

/***/ }),

/***/ "./node_modules/kefir/dist/kefir.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/kefir/dist/kefir.esm.js ***!
  \**********************************************/
/*! exports provided: dissableDeprecationWarnings, Kefir, Observable, Stream, Property, never, later, interval, sequentially, fromPoll, withInterval, fromCallback, fromNodeCallback, fromEvents, stream, constant, constantError, fromPromise, fromESObservable, combine, zip, merge, concat, Pool, pool, repeat, staticLand, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dissableDeprecationWarnings\", function() { return dissableDeprecationWarnings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Kefir\", function() { return Kefir; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Observable\", function() { return Observable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Stream\", function() { return Stream; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Property\", function() { return Property; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"never\", function() { return never; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"later\", function() { return later; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"interval\", function() { return interval; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sequentially\", function() { return sequentially; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromPoll\", function() { return fromPoll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"withInterval\", function() { return withInterval; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromCallback\", function() { return fromCallback; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromNodeCallback\", function() { return fromNodeCallback; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromEvents\", function() { return fromEvents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stream\", function() { return stream; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"constant\", function() { return constant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"constantError\", function() { return constantError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromPromise\", function() { return fromPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromESObservable\", function() { return fromESObservable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"combine\", function() { return combine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zip\", function() { return zip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"merge\", function() { return merge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"concat\", function() { return concat$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pool\", function() { return Pool; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pool\", function() { return pool; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"repeat\", function() { return repeat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticLand\", function() { return staticLand; });\n/*! Kefir.js v3.8.7\n *  https://github.com/kefirjs/kefir\n */\n\nfunction createObj(proto) {\n  var F = function () {};\n  F.prototype = proto;\n  return new F();\n}\n\nfunction extend(target /*, mixin1, mixin2...*/) {\n  var length = arguments.length,\n      i = void 0,\n      prop = void 0;\n  for (i = 1; i < length; i++) {\n    for (prop in arguments[i]) {\n      target[prop] = arguments[i][prop];\n    }\n  }\n  return target;\n}\n\nfunction inherit(Child, Parent /*, mixin1, mixin2...*/) {\n  var length = arguments.length,\n      i = void 0;\n  Child.prototype = createObj(Parent.prototype);\n  Child.prototype.constructor = Child;\n  for (i = 2; i < length; i++) {\n    extend(Child.prototype, arguments[i]);\n  }\n  return Child;\n}\n\nvar NOTHING = ['<nothing>'];\nvar END = 'end';\nvar VALUE = 'value';\nvar ERROR = 'error';\nvar ANY = 'any';\n\nfunction concat(a, b) {\n  var result = void 0,\n      length = void 0,\n      i = void 0,\n      j = void 0;\n  if (a.length === 0) {\n    return b;\n  }\n  if (b.length === 0) {\n    return a;\n  }\n  j = 0;\n  result = new Array(a.length + b.length);\n  length = a.length;\n  for (i = 0; i < length; i++, j++) {\n    result[j] = a[i];\n  }\n  length = b.length;\n  for (i = 0; i < length; i++, j++) {\n    result[j] = b[i];\n  }\n  return result;\n}\n\nfunction find(arr, value) {\n  var length = arr.length,\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    if (arr[i] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction findByPred(arr, pred) {\n  var length = arr.length,\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    if (pred(arr[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction cloneArray(input) {\n  var length = input.length,\n      result = new Array(length),\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    result[i] = input[i];\n  }\n  return result;\n}\n\nfunction remove(input, index) {\n  var length = input.length,\n      result = void 0,\n      i = void 0,\n      j = void 0;\n  if (index >= 0 && index < length) {\n    if (length === 1) {\n      return [];\n    } else {\n      result = new Array(length - 1);\n      for (i = 0, j = 0; i < length; i++) {\n        if (i !== index) {\n          result[j] = input[i];\n          j++;\n        }\n      }\n      return result;\n    }\n  } else {\n    return input;\n  }\n}\n\nfunction map(input, fn) {\n  var length = input.length,\n      result = new Array(length),\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    result[i] = fn(input[i]);\n  }\n  return result;\n}\n\nfunction forEach(arr, fn) {\n  var length = arr.length,\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    fn(arr[i]);\n  }\n}\n\nfunction fillArray(arr, value) {\n  var length = arr.length,\n      i = void 0;\n  for (i = 0; i < length; i++) {\n    arr[i] = value;\n  }\n}\n\nfunction contains(arr, value) {\n  return find(arr, value) !== -1;\n}\n\nfunction slide(cur, next, max) {\n  var length = Math.min(max, cur.length + 1),\n      offset = cur.length - length + 1,\n      result = new Array(length),\n      i = void 0;\n  for (i = offset; i < length; i++) {\n    result[i - offset] = cur[i];\n  }\n  result[length - 1] = next;\n  return result;\n}\n\nfunction callSubscriber(type, fn, event) {\n  if (type === ANY) {\n    fn(event);\n  } else if (type === event.type) {\n    if (type === VALUE || type === ERROR) {\n      fn(event.value);\n    } else {\n      fn();\n    }\n  }\n}\n\nfunction Dispatcher() {\n  this._items = [];\n  this._spies = [];\n  this._inLoop = 0;\n  this._removedItems = null;\n}\n\nextend(Dispatcher.prototype, {\n  add: function (type, fn) {\n    this._items = concat(this._items, [{ type: type, fn: fn }]);\n    return this._items.length;\n  },\n  remove: function (type, fn) {\n    var index = findByPred(this._items, function (x) {\n      return x.type === type && x.fn === fn;\n    });\n\n    // if we're currently in a notification loop,\n    // remember this subscriber was removed\n    if (this._inLoop !== 0 && index !== -1) {\n      if (this._removedItems === null) {\n        this._removedItems = [];\n      }\n      this._removedItems.push(this._items[index]);\n    }\n\n    this._items = remove(this._items, index);\n    return this._items.length;\n  },\n  addSpy: function (fn) {\n    this._spies = concat(this._spies, [fn]);\n    return this._spies.length;\n  },\n\n\n  // Because spies are only ever a function that perform logging as\n  // their only side effect, we don't need the same complicated\n  // removal logic like in remove()\n  removeSpy: function (fn) {\n    this._spies = remove(this._spies, this._spies.indexOf(fn));\n    return this._spies.length;\n  },\n  dispatch: function (event) {\n    this._inLoop++;\n    for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {\n      spies[i](event);\n    }\n\n    for (var _i = 0, items = this._items; _i < items.length; _i++) {\n      // cleanup was called\n      if (this._items === null) {\n        break;\n      }\n\n      // this subscriber was removed\n      if (this._removedItems !== null && contains(this._removedItems, items[_i])) {\n        continue;\n      }\n\n      callSubscriber(items[_i].type, items[_i].fn, event);\n    }\n    this._inLoop--;\n    if (this._inLoop === 0) {\n      this._removedItems = null;\n    }\n  },\n  cleanup: function () {\n    this._items = null;\n    this._spies = null;\n  }\n});\n\nfunction Observable() {\n  this._dispatcher = new Dispatcher();\n  this._active = false;\n  this._alive = true;\n  this._activating = false;\n  this._logHandlers = null;\n  this._spyHandlers = null;\n}\n\nextend(Observable.prototype, {\n  _name: 'observable',\n\n  _onActivation: function () {},\n  _onDeactivation: function () {},\n  _setActive: function (active) {\n    if (this._active !== active) {\n      this._active = active;\n      if (active) {\n        this._activating = true;\n        this._onActivation();\n        this._activating = false;\n      } else {\n        this._onDeactivation();\n      }\n    }\n  },\n  _clear: function () {\n    this._setActive(false);\n    this._dispatcher.cleanup();\n    this._dispatcher = null;\n    this._logHandlers = null;\n  },\n  _emit: function (type, x) {\n    switch (type) {\n      case VALUE:\n        return this._emitValue(x);\n      case ERROR:\n        return this._emitError(x);\n      case END:\n        return this._emitEnd();\n    }\n  },\n  _emitValue: function (value) {\n    if (this._alive) {\n      this._dispatcher.dispatch({ type: VALUE, value: value });\n    }\n  },\n  _emitError: function (value) {\n    if (this._alive) {\n      this._dispatcher.dispatch({ type: ERROR, value: value });\n    }\n  },\n  _emitEnd: function () {\n    if (this._alive) {\n      this._alive = false;\n      this._dispatcher.dispatch({ type: END });\n      this._clear();\n    }\n  },\n  _on: function (type, fn) {\n    if (this._alive) {\n      this._dispatcher.add(type, fn);\n      this._setActive(true);\n    } else {\n      callSubscriber(type, fn, { type: END });\n    }\n    return this;\n  },\n  _off: function (type, fn) {\n    if (this._alive) {\n      var count = this._dispatcher.remove(type, fn);\n      if (count === 0) {\n        this._setActive(false);\n      }\n    }\n    return this;\n  },\n  onValue: function (fn) {\n    return this._on(VALUE, fn);\n  },\n  onError: function (fn) {\n    return this._on(ERROR, fn);\n  },\n  onEnd: function (fn) {\n    return this._on(END, fn);\n  },\n  onAny: function (fn) {\n    return this._on(ANY, fn);\n  },\n  offValue: function (fn) {\n    return this._off(VALUE, fn);\n  },\n  offError: function (fn) {\n    return this._off(ERROR, fn);\n  },\n  offEnd: function (fn) {\n    return this._off(END, fn);\n  },\n  offAny: function (fn) {\n    return this._off(ANY, fn);\n  },\n  observe: function (observerOrOnValue, onError, onEnd) {\n    var _this = this;\n    var closed = false;\n\n    var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? { value: observerOrOnValue, error: onError, end: onEnd } : observerOrOnValue;\n\n    var handler = function (event) {\n      if (event.type === END) {\n        closed = true;\n      }\n      if (event.type === VALUE && observer.value) {\n        observer.value(event.value);\n      } else if (event.type === ERROR && observer.error) {\n        observer.error(event.value);\n      } else if (event.type === END && observer.end) {\n        observer.end(event.value);\n      }\n    };\n\n    this.onAny(handler);\n\n    return {\n      unsubscribe: function () {\n        if (!closed) {\n          _this.offAny(handler);\n          closed = true;\n        }\n      },\n\n      get closed() {\n        return closed;\n      }\n    };\n  },\n\n\n  // A and B must be subclasses of Stream and Property (order doesn't matter)\n  _ofSameType: function (A, B) {\n    return A.prototype.getType() === this.getType() ? A : B;\n  },\n  setName: function (sourceObs /* optional */, selfName) {\n    this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;\n    return this;\n  },\n  log: function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n    var isCurrent = void 0;\n    var handler = function (event) {\n      var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';\n      if (event.type === END) {\n        console.log(name, type);\n      } else {\n        console.log(name, type, event.value);\n      }\n    };\n\n    if (this._alive) {\n      if (!this._logHandlers) {\n        this._logHandlers = [];\n      }\n      this._logHandlers.push({ name: name, handler: handler });\n    }\n\n    isCurrent = true;\n    this.onAny(handler);\n    isCurrent = false;\n\n    return this;\n  },\n  offLog: function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n    if (this._logHandlers) {\n      var handlerIndex = findByPred(this._logHandlers, function (obj) {\n        return obj.name === name;\n      });\n      if (handlerIndex !== -1) {\n        this.offAny(this._logHandlers[handlerIndex].handler);\n        this._logHandlers.splice(handlerIndex, 1);\n      }\n    }\n\n    return this;\n  },\n  spy: function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n    var handler = function (event) {\n      var type = '<' + event.type + '>';\n      if (event.type === END) {\n        console.log(name, type);\n      } else {\n        console.log(name, type, event.value);\n      }\n    };\n    if (this._alive) {\n      if (!this._spyHandlers) {\n        this._spyHandlers = [];\n      }\n      this._spyHandlers.push({ name: name, handler: handler });\n      this._dispatcher.addSpy(handler);\n    }\n    return this;\n  },\n  offSpy: function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n    if (this._spyHandlers) {\n      var handlerIndex = findByPred(this._spyHandlers, function (obj) {\n        return obj.name === name;\n      });\n      if (handlerIndex !== -1) {\n        this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);\n        this._spyHandlers.splice(handlerIndex, 1);\n      }\n    }\n    return this;\n  }\n});\n\n// extend() can't handle `toString` in IE8\nObservable.prototype.toString = function () {\n  return '[' + this._name + ']';\n};\n\nfunction Stream() {\n  Observable.call(this);\n}\n\ninherit(Stream, Observable, {\n  _name: 'stream',\n\n  getType: function () {\n    return 'stream';\n  }\n});\n\nfunction Property() {\n  Observable.call(this);\n  this._currentEvent = null;\n}\n\ninherit(Property, Observable, {\n  _name: 'property',\n\n  _emitValue: function (value) {\n    if (this._alive) {\n      this._currentEvent = { type: VALUE, value: value };\n      if (!this._activating) {\n        this._dispatcher.dispatch({ type: VALUE, value: value });\n      }\n    }\n  },\n  _emitError: function (value) {\n    if (this._alive) {\n      this._currentEvent = { type: ERROR, value: value };\n      if (!this._activating) {\n        this._dispatcher.dispatch({ type: ERROR, value: value });\n      }\n    }\n  },\n  _emitEnd: function () {\n    if (this._alive) {\n      this._alive = false;\n      if (!this._activating) {\n        this._dispatcher.dispatch({ type: END });\n      }\n      this._clear();\n    }\n  },\n  _on: function (type, fn) {\n    if (this._alive) {\n      this._dispatcher.add(type, fn);\n      this._setActive(true);\n    }\n    if (this._currentEvent !== null) {\n      callSubscriber(type, fn, this._currentEvent);\n    }\n    if (!this._alive) {\n      callSubscriber(type, fn, { type: END });\n    }\n    return this;\n  },\n  getType: function () {\n    return 'property';\n  }\n});\n\nvar neverS = new Stream();\nneverS._emitEnd();\nneverS._name = 'never';\n\nfunction never() {\n  return neverS;\n}\n\nfunction timeBased(mixin) {\n  function AnonymousStream(wait, options) {\n    var _this = this;\n\n    Stream.call(this);\n    this._wait = wait;\n    this._intervalId = null;\n    this._$onTick = function () {\n      return _this._onTick();\n    };\n    this._init(options);\n  }\n\n  inherit(AnonymousStream, Stream, {\n    _init: function () {},\n    _free: function () {},\n    _onTick: function () {},\n    _onActivation: function () {\n      this._intervalId = setInterval(this._$onTick, this._wait);\n    },\n    _onDeactivation: function () {\n      if (this._intervalId !== null) {\n        clearInterval(this._intervalId);\n        this._intervalId = null;\n      }\n    },\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._$onTick = null;\n      this._free();\n    }\n  }, mixin);\n\n  return AnonymousStream;\n}\n\nvar S = timeBased({\n  _name: 'later',\n\n  _init: function (_ref) {\n    var x = _ref.x;\n\n    this._x = x;\n  },\n  _free: function () {\n    this._x = null;\n  },\n  _onTick: function () {\n    this._emitValue(this._x);\n    this._emitEnd();\n  }\n});\n\nfunction later(wait, x) {\n  return new S(wait, { x: x });\n}\n\nvar S$1 = timeBased({\n  _name: 'interval',\n\n  _init: function (_ref) {\n    var x = _ref.x;\n\n    this._x = x;\n  },\n  _free: function () {\n    this._x = null;\n  },\n  _onTick: function () {\n    this._emitValue(this._x);\n  }\n});\n\nfunction interval(wait, x) {\n  return new S$1(wait, { x: x });\n}\n\nvar S$2 = timeBased({\n  _name: 'sequentially',\n\n  _init: function (_ref) {\n    var xs = _ref.xs;\n\n    this._xs = cloneArray(xs);\n  },\n  _free: function () {\n    this._xs = null;\n  },\n  _onTick: function () {\n    if (this._xs.length === 1) {\n      this._emitValue(this._xs[0]);\n      this._emitEnd();\n    } else {\n      this._emitValue(this._xs.shift());\n    }\n  }\n});\n\nfunction sequentially(wait, xs) {\n  return xs.length === 0 ? never() : new S$2(wait, { xs: xs });\n}\n\nvar S$3 = timeBased({\n  _name: 'fromPoll',\n\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _onTick: function () {\n    var fn = this._fn;\n    this._emitValue(fn());\n  }\n});\n\nfunction fromPoll(wait, fn) {\n  return new S$3(wait, { fn: fn });\n}\n\nfunction emitter(obs) {\n  function value(x) {\n    obs._emitValue(x);\n    return obs._active;\n  }\n\n  function error(x) {\n    obs._emitError(x);\n    return obs._active;\n  }\n\n  function end() {\n    obs._emitEnd();\n    return obs._active;\n  }\n\n  function event(e) {\n    obs._emit(e.type, e.value);\n    return obs._active;\n  }\n\n  return {\n    value: value,\n    error: error,\n    end: end,\n    event: event,\n\n    // legacy\n    emit: value,\n    emitEvent: event\n  };\n}\n\nvar S$4 = timeBased({\n  _name: 'withInterval',\n\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n    this._emitter = emitter(this);\n  },\n  _free: function () {\n    this._fn = null;\n    this._emitter = null;\n  },\n  _onTick: function () {\n    var fn = this._fn;\n    fn(this._emitter);\n  }\n});\n\nfunction withInterval(wait, fn) {\n  return new S$4(wait, { fn: fn });\n}\n\nfunction S$5(fn) {\n  Stream.call(this);\n  this._fn = fn;\n  this._unsubscribe = null;\n}\n\ninherit(S$5, Stream, {\n  _name: 'stream',\n\n  _onActivation: function () {\n    var fn = this._fn;\n    var unsubscribe = fn(emitter(this));\n    this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;\n\n    // fix https://github.com/kefirjs/kefir/issues/35\n    if (!this._active) {\n      this._callUnsubscribe();\n    }\n  },\n  _callUnsubscribe: function () {\n    if (this._unsubscribe !== null) {\n      this._unsubscribe();\n      this._unsubscribe = null;\n    }\n  },\n  _onDeactivation: function () {\n    this._callUnsubscribe();\n  },\n  _clear: function () {\n    Stream.prototype._clear.call(this);\n    this._fn = null;\n  }\n});\n\nfunction stream(fn) {\n  return new S$5(fn);\n}\n\nfunction fromCallback(callbackConsumer) {\n  var called = false;\n\n  return stream(function (emitter) {\n    if (!called) {\n      callbackConsumer(function (x) {\n        emitter.emit(x);\n        emitter.end();\n      });\n      called = true;\n    }\n  }).setName('fromCallback');\n}\n\nfunction fromNodeCallback(callbackConsumer) {\n  var called = false;\n\n  return stream(function (emitter) {\n    if (!called) {\n      callbackConsumer(function (error, x) {\n        if (error) {\n          emitter.error(error);\n        } else {\n          emitter.emit(x);\n        }\n        emitter.end();\n      });\n      called = true;\n    }\n  }).setName('fromNodeCallback');\n}\n\nfunction spread(fn, length) {\n  switch (length) {\n    case 0:\n      return function () {\n        return fn();\n      };\n    case 1:\n      return function (a) {\n        return fn(a[0]);\n      };\n    case 2:\n      return function (a) {\n        return fn(a[0], a[1]);\n      };\n    case 3:\n      return function (a) {\n        return fn(a[0], a[1], a[2]);\n      };\n    case 4:\n      return function (a) {\n        return fn(a[0], a[1], a[2], a[3]);\n      };\n    default:\n      return function (a) {\n        return fn.apply(null, a);\n      };\n  }\n}\n\nfunction apply(fn, c, a) {\n  var aLength = a ? a.length : 0;\n  if (c == null) {\n    switch (aLength) {\n      case 0:\n        return fn();\n      case 1:\n        return fn(a[0]);\n      case 2:\n        return fn(a[0], a[1]);\n      case 3:\n        return fn(a[0], a[1], a[2]);\n      case 4:\n        return fn(a[0], a[1], a[2], a[3]);\n      default:\n        return fn.apply(null, a);\n    }\n  } else {\n    switch (aLength) {\n      case 0:\n        return fn.call(c);\n      default:\n        return fn.apply(c, a);\n    }\n  }\n}\n\nfunction fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {\n  return stream(function (emitter) {\n    var handler = transformer ? function () {\n      emitter.emit(apply(transformer, this, arguments));\n    } : function (x) {\n      emitter.emit(x);\n    };\n\n    sub(handler);\n    return function () {\n      return unsub(handler);\n    };\n  }).setName('fromSubUnsub');\n}\n\nvar pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];\n\nfunction fromEvents(target, eventName, transformer) {\n  var sub = void 0,\n      unsub = void 0;\n\n  for (var i = 0; i < pairs.length; i++) {\n    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {\n      sub = pairs[i][0];\n      unsub = pairs[i][1];\n      break;\n    }\n  }\n\n  if (sub === undefined) {\n    throw new Error(\"target don't support any of \" + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');\n  }\n\n  return fromSubUnsub(function (handler) {\n    return target[sub](eventName, handler);\n  }, function (handler) {\n    return target[unsub](eventName, handler);\n  }, transformer).setName('fromEvents');\n}\n\n// HACK:\n//   We don't call parent Class constructor, but instead putting all necessary\n//   properties into prototype to simulate ended Property\n//   (see Propperty and Observable classes).\n\nfunction P(value) {\n  this._currentEvent = { type: 'value', value: value, current: true };\n}\n\ninherit(P, Property, {\n  _name: 'constant',\n  _active: false,\n  _activating: false,\n  _alive: false,\n  _dispatcher: null,\n  _logHandlers: null\n});\n\nfunction constant(x) {\n  return new P(x);\n}\n\n// HACK:\n//   We don't call parent Class constructor, but instead putting all necessary\n//   properties into prototype to simulate ended Property\n//   (see Propperty and Observable classes).\n\nfunction P$1(value) {\n  this._currentEvent = { type: 'error', value: value, current: true };\n}\n\ninherit(P$1, Property, {\n  _name: 'constantError',\n  _active: false,\n  _activating: false,\n  _alive: false,\n  _dispatcher: null,\n  _logHandlers: null\n});\n\nfunction constantError(x) {\n  return new P$1(x);\n}\n\nfunction createConstructor(BaseClass, name) {\n  return function AnonymousObservable(source, options) {\n    var _this = this;\n\n    BaseClass.call(this);\n    this._source = source;\n    this._name = source._name + '.' + name;\n    this._init(options);\n    this._$handleAny = function (event) {\n      return _this._handleAny(event);\n    };\n  };\n}\n\nfunction createClassMethods(BaseClass) {\n  return {\n    _init: function () {},\n    _free: function () {},\n    _handleValue: function (x) {\n      this._emitValue(x);\n    },\n    _handleError: function (x) {\n      this._emitError(x);\n    },\n    _handleEnd: function () {\n      this._emitEnd();\n    },\n    _handleAny: function (event) {\n      switch (event.type) {\n        case VALUE:\n          return this._handleValue(event.value);\n        case ERROR:\n          return this._handleError(event.value);\n        case END:\n          return this._handleEnd();\n      }\n    },\n    _onActivation: function () {\n      this._source.onAny(this._$handleAny);\n    },\n    _onDeactivation: function () {\n      this._source.offAny(this._$handleAny);\n    },\n    _clear: function () {\n      BaseClass.prototype._clear.call(this);\n      this._source = null;\n      this._$handleAny = null;\n      this._free();\n    }\n  };\n}\n\nfunction createStream(name, mixin) {\n  var S = createConstructor(Stream, name);\n  inherit(S, Stream, createClassMethods(Stream), mixin);\n  return S;\n}\n\nfunction createProperty(name, mixin) {\n  var P = createConstructor(Property, name);\n  inherit(P, Property, createClassMethods(Property), mixin);\n  return P;\n}\n\nvar P$2 = createProperty('toProperty', {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._getInitialCurrent = fn;\n  },\n  _onActivation: function () {\n    if (this._getInitialCurrent !== null) {\n      var getInitial = this._getInitialCurrent;\n      this._emitValue(getInitial());\n    }\n    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n  }\n});\n\nfunction toProperty(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (fn !== null && typeof fn !== 'function') {\n    throw new Error('You should call toProperty() with a function or no arguments.');\n  }\n  return new P$2(obs, { fn: fn });\n}\n\nvar S$6 = createStream('changes', {\n  _handleValue: function (x) {\n    if (!this._activating) {\n      this._emitValue(x);\n    }\n  },\n  _handleError: function (x) {\n    if (!this._activating) {\n      this._emitError(x);\n    }\n  }\n});\n\nfunction changes(obs) {\n  return new S$6(obs);\n}\n\nfunction fromPromise(promise) {\n  var called = false;\n\n  var result = stream(function (emitter) {\n    if (!called) {\n      var onValue = function (x) {\n        emitter.emit(x);\n        emitter.end();\n      };\n      var onError = function (x) {\n        emitter.error(x);\n        emitter.end();\n      };\n      var _promise = promise.then(onValue, onError);\n\n      // prevent libraries like 'Q' or 'when' from swallowing exceptions\n      if (_promise && typeof _promise.done === 'function') {\n        _promise.done();\n      }\n\n      called = true;\n    }\n  });\n\n  return toProperty(result, null).setName('fromPromise');\n}\n\nfunction getGlodalPromise() {\n  if (typeof Promise === 'function') {\n    return Promise;\n  } else {\n    throw new Error(\"There isn't default Promise, use shim or parameter\");\n  }\n}\n\nvar toPromise = function (obs) {\n  var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();\n\n  var last = null;\n  return new Promise(function (resolve, reject) {\n    obs.onAny(function (event) {\n      if (event.type === END && last !== null) {\n        (last.type === VALUE ? resolve : reject)(last.value);\n        last = null;\n      } else {\n        last = event;\n      }\n    });\n  });\n};\n\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n}\n\n/* global window */\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {}\n\nvar result = symbolObservablePonyfill(root);\n\n// this file contains some hot JS modules systems stuff\n\nvar $$observable = result.default ? result.default : result;\n\nfunction fromESObservable(_observable) {\n  var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;\n  return stream(function (emitter) {\n    var unsub = observable.subscribe({\n      error: function (error) {\n        emitter.error(error);\n        emitter.end();\n      },\n      next: function (value) {\n        emitter.emit(value);\n      },\n      complete: function () {\n        emitter.end();\n      }\n    });\n\n    if (unsub.unsubscribe) {\n      return function () {\n        unsub.unsubscribe();\n      };\n    } else {\n      return unsub;\n    }\n  }).setName('fromESObservable');\n}\n\nfunction ESObservable(observable) {\n  this._observable = observable.takeErrors(1);\n}\n\nextend(ESObservable.prototype, {\n  subscribe: function (observerOrOnNext, onError, onComplete) {\n    var _this = this;\n\n    var observer = typeof observerOrOnNext === 'function' ? { next: observerOrOnNext, error: onError, complete: onComplete } : observerOrOnNext;\n\n    var fn = function (event) {\n      if (event.type === END) {\n        closed = true;\n      }\n\n      if (event.type === VALUE && observer.next) {\n        observer.next(event.value);\n      } else if (event.type === ERROR && observer.error) {\n        observer.error(event.value);\n      } else if (event.type === END && observer.complete) {\n        observer.complete(event.value);\n      }\n    };\n\n    this._observable.onAny(fn);\n    var closed = false;\n\n    var subscription = {\n      unsubscribe: function () {\n        closed = true;\n        _this._observable.offAny(fn);\n      },\n      get closed() {\n        return closed;\n      }\n    };\n    return subscription;\n  }\n});\n\n// Need to assign directly b/c Symbols aren't enumerable.\nESObservable.prototype[$$observable] = function () {\n  return this;\n};\n\nfunction toESObservable() {\n  return new ESObservable(this);\n}\n\nfunction collect(source, keys, values) {\n  for (var prop in source) {\n    if (source.hasOwnProperty(prop)) {\n      keys.push(prop);\n      values.push(source[prop]);\n    }\n  }\n}\n\nfunction defaultErrorsCombinator(errors) {\n  var latestError = void 0;\n  for (var i = 0; i < errors.length; i++) {\n    if (errors[i] !== undefined) {\n      if (latestError === undefined || latestError.index < errors[i].index) {\n        latestError = errors[i];\n      }\n    }\n  }\n  return latestError.error;\n}\n\nfunction Combine(active, passive, combinator) {\n  var _this = this;\n\n  Stream.call(this);\n  this._activeCount = active.length;\n  this._sources = concat(active, passive);\n  this._combinator = combinator;\n  this._aliveCount = 0;\n  this._latestValues = new Array(this._sources.length);\n  this._latestErrors = new Array(this._sources.length);\n  fillArray(this._latestValues, NOTHING);\n  this._emitAfterActivation = false;\n  this._endAfterActivation = false;\n  this._latestErrorIndex = 0;\n\n  this._$handlers = [];\n\n  var _loop = function (i) {\n    _this._$handlers.push(function (event) {\n      return _this._handleAny(i, event);\n    });\n  };\n\n  for (var i = 0; i < this._sources.length; i++) {\n    _loop(i);\n  }\n}\n\ninherit(Combine, Stream, {\n  _name: 'combine',\n\n  _onActivation: function () {\n    this._aliveCount = this._activeCount;\n\n    // we need to suscribe to _passive_ sources before _active_\n    // (see https://github.com/kefirjs/kefir/issues/98)\n    for (var i = this._activeCount; i < this._sources.length; i++) {\n      this._sources[i].onAny(this._$handlers[i]);\n    }\n    for (var _i = 0; _i < this._activeCount; _i++) {\n      this._sources[_i].onAny(this._$handlers[_i]);\n    }\n\n    if (this._emitAfterActivation) {\n      this._emitAfterActivation = false;\n      this._emitIfFull();\n    }\n    if (this._endAfterActivation) {\n      this._emitEnd();\n    }\n  },\n  _onDeactivation: function () {\n    var length = this._sources.length,\n        i = void 0;\n    for (i = 0; i < length; i++) {\n      this._sources[i].offAny(this._$handlers[i]);\n    }\n  },\n  _emitIfFull: function () {\n    var hasAllValues = true;\n    var hasErrors = false;\n    var length = this._latestValues.length;\n    var valuesCopy = new Array(length);\n    var errorsCopy = new Array(length);\n\n    for (var i = 0; i < length; i++) {\n      valuesCopy[i] = this._latestValues[i];\n      errorsCopy[i] = this._latestErrors[i];\n\n      if (valuesCopy[i] === NOTHING) {\n        hasAllValues = false;\n      }\n\n      if (errorsCopy[i] !== undefined) {\n        hasErrors = true;\n      }\n    }\n\n    if (hasAllValues) {\n      var combinator = this._combinator;\n      this._emitValue(combinator(valuesCopy));\n    }\n    if (hasErrors) {\n      this._emitError(defaultErrorsCombinator(errorsCopy));\n    }\n  },\n  _handleAny: function (i, event) {\n    if (event.type === VALUE || event.type === ERROR) {\n      if (event.type === VALUE) {\n        this._latestValues[i] = event.value;\n        this._latestErrors[i] = undefined;\n      }\n      if (event.type === ERROR) {\n        this._latestValues[i] = NOTHING;\n        this._latestErrors[i] = {\n          index: this._latestErrorIndex++,\n          error: event.value\n        };\n      }\n\n      if (i < this._activeCount) {\n        if (this._activating) {\n          this._emitAfterActivation = true;\n        } else {\n          this._emitIfFull();\n        }\n      }\n    } else {\n      // END\n\n      if (i < this._activeCount) {\n        this._aliveCount--;\n        if (this._aliveCount === 0) {\n          if (this._activating) {\n            this._endAfterActivation = true;\n          } else {\n            this._emitEnd();\n          }\n        }\n      }\n    }\n  },\n  _clear: function () {\n    Stream.prototype._clear.call(this);\n    this._sources = null;\n    this._latestValues = null;\n    this._latestErrors = null;\n    this._combinator = null;\n    this._$handlers = null;\n  }\n});\n\nfunction combineAsArray(active) {\n  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var combinator = arguments[2];\n\n  if (!Array.isArray(passive)) {\n    throw new Error('Combine can only combine active and passive collections of the same type.');\n  }\n\n  combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {\n    return x;\n  };\n  return active.length === 0 ? never() : new Combine(active, passive, combinator);\n}\n\nfunction combineAsObject(active) {\n  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var combinator = arguments[2];\n\n  if (typeof passive !== 'object' || Array.isArray(passive)) {\n    throw new Error('Combine can only combine active and passive collections of the same type.');\n  }\n\n  var keys = [],\n      activeObservables = [],\n      passiveObservables = [];\n\n  collect(active, keys, activeObservables);\n  collect(passive, keys, passiveObservables);\n\n  var objectify = function (values) {\n    var event = {};\n    for (var i = values.length - 1; 0 <= i; i--) {\n      event[keys[i]] = values[i];\n    }\n    return combinator ? combinator(event) : event;\n  };\n\n  return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);\n}\n\nfunction combine(active, passive, combinator) {\n  if (typeof passive === 'function') {\n    combinator = passive;\n    passive = undefined;\n  }\n\n  return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);\n}\n\nvar Observable$2 = {\n  empty: function () {\n    return never();\n  },\n\n\n  // Monoid based on merge() seems more useful than one based on concat().\n  concat: function (a, b) {\n    return a.merge(b);\n  },\n  of: function (x) {\n    return constant(x);\n  },\n  map: function (fn, obs) {\n    return obs.map(fn);\n  },\n  bimap: function (fnErr, fnVal, obs) {\n    return obs.mapErrors(fnErr).map(fnVal);\n  },\n\n\n  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get\n  // different (not very useful) behavior. But spec requires that if method can be derived\n  // it must have the same behavior as hand-written method. We intentionally violate the spec\n  // in hope that it won't cause many troubles in practice. And in return we have more useful type.\n  ap: function (obsFn, obsVal) {\n    return combine([obsFn, obsVal], function (fn, val) {\n      return fn(val);\n    });\n  },\n  chain: function (fn, obs) {\n    return obs.flatMap(fn);\n  }\n};\n\n\n\nvar staticLand = Object.freeze({\n\tObservable: Observable$2\n});\n\nvar mixin = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    this._emitValue(fn(x));\n  }\n};\n\nvar S$7 = createStream('map', mixin);\nvar P$3 = createProperty('map', mixin);\n\nvar id = function (x) {\n  return x;\n};\n\nfunction map$1(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;\n\n  return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });\n}\n\nvar mixin$1 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    if (fn(x)) {\n      this._emitValue(x);\n    }\n  }\n};\n\nvar S$8 = createStream('filter', mixin$1);\nvar P$4 = createProperty('filter', mixin$1);\n\nvar id$1 = function (x) {\n  return x;\n};\n\nfunction filter(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;\n\n  return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });\n}\n\nvar mixin$2 = {\n  _init: function (_ref) {\n    var n = _ref.n;\n\n    this._n = n;\n    if (n <= 0) {\n      this._emitEnd();\n    }\n  },\n  _handleValue: function (x) {\n    if (this._n === 0) {\n      return;\n    }\n    this._n--;\n    this._emitValue(x);\n    if (this._n === 0) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$9 = createStream('take', mixin$2);\nvar P$5 = createProperty('take', mixin$2);\n\nfunction take(obs, n) {\n  return new (obs._ofSameType(S$9, P$5))(obs, { n: n });\n}\n\nvar mixin$3 = {\n  _init: function (_ref) {\n    var n = _ref.n;\n\n    this._n = n;\n    if (n <= 0) {\n      this._emitEnd();\n    }\n  },\n  _handleError: function (x) {\n    if (this._n === 0) {\n      return;\n    }\n    this._n--;\n    this._emitError(x);\n    if (this._n === 0) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$10 = createStream('takeErrors', mixin$3);\nvar P$6 = createProperty('takeErrors', mixin$3);\n\nfunction takeErrors(obs, n) {\n  return new (obs._ofSameType(S$10, P$6))(obs, { n: n });\n}\n\nvar mixin$4 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    if (fn(x)) {\n      this._emitValue(x);\n    } else {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$11 = createStream('takeWhile', mixin$4);\nvar P$7 = createProperty('takeWhile', mixin$4);\n\nvar id$2 = function (x) {\n  return x;\n};\n\nfunction takeWhile(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;\n\n  return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });\n}\n\nvar mixin$5 = {\n  _init: function () {\n    this._lastValue = NOTHING;\n  },\n  _free: function () {\n    this._lastValue = null;\n  },\n  _handleValue: function (x) {\n    this._lastValue = x;\n  },\n  _handleEnd: function () {\n    if (this._lastValue !== NOTHING) {\n      this._emitValue(this._lastValue);\n    }\n    this._emitEnd();\n  }\n};\n\nvar S$12 = createStream('last', mixin$5);\nvar P$8 = createProperty('last', mixin$5);\n\nfunction last(obs) {\n  return new (obs._ofSameType(S$12, P$8))(obs);\n}\n\nvar mixin$6 = {\n  _init: function (_ref) {\n    var n = _ref.n;\n\n    this._n = Math.max(0, n);\n  },\n  _handleValue: function (x) {\n    if (this._n === 0) {\n      this._emitValue(x);\n    } else {\n      this._n--;\n    }\n  }\n};\n\nvar S$13 = createStream('skip', mixin$6);\nvar P$9 = createProperty('skip', mixin$6);\n\nfunction skip(obs, n) {\n  return new (obs._ofSameType(S$13, P$9))(obs, { n: n });\n}\n\nvar mixin$7 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    if (this._fn !== null && !fn(x)) {\n      this._fn = null;\n    }\n    if (this._fn === null) {\n      this._emitValue(x);\n    }\n  }\n};\n\nvar S$14 = createStream('skipWhile', mixin$7);\nvar P$10 = createProperty('skipWhile', mixin$7);\n\nvar id$3 = function (x) {\n  return x;\n};\n\nfunction skipWhile(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;\n\n  return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });\n}\n\nvar mixin$8 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n    this._prev = NOTHING;\n  },\n  _free: function () {\n    this._fn = null;\n    this._prev = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    if (this._prev === NOTHING || !fn(this._prev, x)) {\n      this._prev = x;\n      this._emitValue(x);\n    }\n  }\n};\n\nvar S$15 = createStream('skipDuplicates', mixin$8);\nvar P$11 = createProperty('skipDuplicates', mixin$8);\n\nvar eq = function (a, b) {\n  return a === b;\n};\n\nfunction skipDuplicates(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;\n\n  return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });\n}\n\nvar mixin$9 = {\n  _init: function (_ref) {\n    var fn = _ref.fn,\n        seed = _ref.seed;\n\n    this._fn = fn;\n    this._prev = seed;\n  },\n  _free: function () {\n    this._prev = null;\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    if (this._prev !== NOTHING) {\n      var fn = this._fn;\n      this._emitValue(fn(this._prev, x));\n    }\n    this._prev = x;\n  }\n};\n\nvar S$16 = createStream('diff', mixin$9);\nvar P$12 = createProperty('diff', mixin$9);\n\nfunction defaultFn(a, b) {\n  return [a, b];\n}\n\nfunction diff(obs, fn) {\n  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n\n  return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });\n}\n\nvar P$13 = createProperty('scan', {\n  _init: function (_ref) {\n    var fn = _ref.fn,\n        seed = _ref.seed;\n\n    this._fn = fn;\n    this._seed = seed;\n    if (seed !== NOTHING) {\n      this._emitValue(seed);\n    }\n  },\n  _free: function () {\n    this._fn = null;\n    this._seed = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    if (this._currentEvent === null || this._currentEvent.type === ERROR) {\n      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));\n    } else {\n      this._emitValue(fn(this._currentEvent.value, x));\n    }\n  }\n});\n\nfunction scan(obs, fn) {\n  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n\n  return new P$13(obs, { fn: fn, seed: seed });\n}\n\nvar mixin$10 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    var xs = fn(x);\n    for (var i = 0; i < xs.length; i++) {\n      this._emitValue(xs[i]);\n    }\n  }\n};\n\nvar S$17 = createStream('flatten', mixin$10);\n\nvar id$4 = function (x) {\n  return x;\n};\n\nfunction flatten(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;\n\n  return new S$17(obs, { fn: fn });\n}\n\nvar END_MARKER = {};\n\nvar mixin$11 = {\n  _init: function (_ref) {\n    var _this = this;\n\n    var wait = _ref.wait;\n\n    this._wait = Math.max(0, wait);\n    this._buff = [];\n    this._$shiftBuff = function () {\n      var value = _this._buff.shift();\n      if (value === END_MARKER) {\n        _this._emitEnd();\n      } else {\n        _this._emitValue(value);\n      }\n    };\n  },\n  _free: function () {\n    this._buff = null;\n    this._$shiftBuff = null;\n  },\n  _handleValue: function (x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      this._buff.push(x);\n      setTimeout(this._$shiftBuff, this._wait);\n    }\n  },\n  _handleEnd: function () {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      this._buff.push(END_MARKER);\n      setTimeout(this._$shiftBuff, this._wait);\n    }\n  }\n};\n\nvar S$18 = createStream('delay', mixin$11);\nvar P$14 = createProperty('delay', mixin$11);\n\nfunction delay(obs, wait) {\n  return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });\n}\n\nvar now = Date.now ? function () {\n  return Date.now();\n} : function () {\n  return new Date().getTime();\n};\n\nvar mixin$12 = {\n  _init: function (_ref) {\n    var _this = this;\n\n    var wait = _ref.wait,\n        leading = _ref.leading,\n        trailing = _ref.trailing;\n\n    this._wait = Math.max(0, wait);\n    this._leading = leading;\n    this._trailing = trailing;\n    this._trailingValue = null;\n    this._timeoutId = null;\n    this._endLater = false;\n    this._lastCallTime = 0;\n    this._$trailingCall = function () {\n      return _this._trailingCall();\n    };\n  },\n  _free: function () {\n    this._trailingValue = null;\n    this._$trailingCall = null;\n  },\n  _handleValue: function (x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      var curTime = now();\n      if (this._lastCallTime === 0 && !this._leading) {\n        this._lastCallTime = curTime;\n      }\n      var remaining = this._wait - (curTime - this._lastCallTime);\n      if (remaining <= 0) {\n        this._cancelTrailing();\n        this._lastCallTime = curTime;\n        this._emitValue(x);\n      } else if (this._trailing) {\n        this._cancelTrailing();\n        this._trailingValue = x;\n        this._timeoutId = setTimeout(this._$trailingCall, remaining);\n      }\n    }\n  },\n  _handleEnd: function () {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      if (this._timeoutId) {\n        this._endLater = true;\n      } else {\n        this._emitEnd();\n      }\n    }\n  },\n  _cancelTrailing: function () {\n    if (this._timeoutId !== null) {\n      clearTimeout(this._timeoutId);\n      this._timeoutId = null;\n    }\n  },\n  _trailingCall: function () {\n    this._emitValue(this._trailingValue);\n    this._timeoutId = null;\n    this._trailingValue = null;\n    this._lastCallTime = !this._leading ? 0 : now();\n    if (this._endLater) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$19 = createStream('throttle', mixin$12);\nvar P$15 = createProperty('throttle', mixin$12);\n\nfunction throttle(obs, wait) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref2$leading = _ref2.leading,\n      leading = _ref2$leading === undefined ? true : _ref2$leading,\n      _ref2$trailing = _ref2.trailing,\n      trailing = _ref2$trailing === undefined ? true : _ref2$trailing;\n\n  return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });\n}\n\nvar mixin$13 = {\n  _init: function (_ref) {\n    var _this = this;\n\n    var wait = _ref.wait,\n        immediate = _ref.immediate;\n\n    this._wait = Math.max(0, wait);\n    this._immediate = immediate;\n    this._lastAttempt = 0;\n    this._timeoutId = null;\n    this._laterValue = null;\n    this._endLater = false;\n    this._$later = function () {\n      return _this._later();\n    };\n  },\n  _free: function () {\n    this._laterValue = null;\n    this._$later = null;\n  },\n  _handleValue: function (x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      this._lastAttempt = now();\n      if (this._immediate && !this._timeoutId) {\n        this._emitValue(x);\n      }\n      if (!this._timeoutId) {\n        this._timeoutId = setTimeout(this._$later, this._wait);\n      }\n      if (!this._immediate) {\n        this._laterValue = x;\n      }\n    }\n  },\n  _handleEnd: function () {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      if (this._timeoutId && !this._immediate) {\n        this._endLater = true;\n      } else {\n        this._emitEnd();\n      }\n    }\n  },\n  _later: function () {\n    var last = now() - this._lastAttempt;\n    if (last < this._wait && last >= 0) {\n      this._timeoutId = setTimeout(this._$later, this._wait - last);\n    } else {\n      this._timeoutId = null;\n      if (!this._immediate) {\n        this._emitValue(this._laterValue);\n        this._laterValue = null;\n      }\n      if (this._endLater) {\n        this._emitEnd();\n      }\n    }\n  }\n};\n\nvar S$20 = createStream('debounce', mixin$13);\nvar P$16 = createProperty('debounce', mixin$13);\n\nfunction debounce(obs, wait) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref2$immediate = _ref2.immediate,\n      immediate = _ref2$immediate === undefined ? false : _ref2$immediate;\n\n  return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });\n}\n\nvar mixin$14 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleError: function (x) {\n    var fn = this._fn;\n    this._emitError(fn(x));\n  }\n};\n\nvar S$21 = createStream('mapErrors', mixin$14);\nvar P$17 = createProperty('mapErrors', mixin$14);\n\nvar id$5 = function (x) {\n  return x;\n};\n\nfunction mapErrors(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;\n\n  return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });\n}\n\nvar mixin$15 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleError: function (x) {\n    var fn = this._fn;\n    if (fn(x)) {\n      this._emitError(x);\n    }\n  }\n};\n\nvar S$22 = createStream('filterErrors', mixin$15);\nvar P$18 = createProperty('filterErrors', mixin$15);\n\nvar id$6 = function (x) {\n  return x;\n};\n\nfunction filterErrors(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;\n\n  return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });\n}\n\nvar mixin$16 = {\n  _handleValue: function () {}\n};\n\nvar S$23 = createStream('ignoreValues', mixin$16);\nvar P$19 = createProperty('ignoreValues', mixin$16);\n\nfunction ignoreValues(obs) {\n  return new (obs._ofSameType(S$23, P$19))(obs);\n}\n\nvar mixin$17 = {\n  _handleError: function () {}\n};\n\nvar S$24 = createStream('ignoreErrors', mixin$17);\nvar P$20 = createProperty('ignoreErrors', mixin$17);\n\nfunction ignoreErrors(obs) {\n  return new (obs._ofSameType(S$24, P$20))(obs);\n}\n\nvar mixin$18 = {\n  _handleEnd: function () {}\n};\n\nvar S$25 = createStream('ignoreEnd', mixin$18);\nvar P$21 = createProperty('ignoreEnd', mixin$18);\n\nfunction ignoreEnd(obs) {\n  return new (obs._ofSameType(S$25, P$21))(obs);\n}\n\nvar mixin$19 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleEnd: function () {\n    var fn = this._fn;\n    this._emitValue(fn());\n    this._emitEnd();\n  }\n};\n\nvar S$26 = createStream('beforeEnd', mixin$19);\nvar P$22 = createProperty('beforeEnd', mixin$19);\n\nfunction beforeEnd(obs, fn) {\n  return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });\n}\n\nvar mixin$20 = {\n  _init: function (_ref) {\n    var min = _ref.min,\n        max = _ref.max;\n\n    this._max = max;\n    this._min = min;\n    this._buff = [];\n  },\n  _free: function () {\n    this._buff = null;\n  },\n  _handleValue: function (x) {\n    this._buff = slide(this._buff, x, this._max);\n    if (this._buff.length >= this._min) {\n      this._emitValue(this._buff);\n    }\n  }\n};\n\nvar S$27 = createStream('slidingWindow', mixin$20);\nvar P$23 = createProperty('slidingWindow', mixin$20);\n\nfunction slidingWindow(obs, max) {\n  var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });\n}\n\nvar mixin$21 = {\n  _init: function (_ref) {\n    var fn = _ref.fn,\n        flushOnEnd = _ref.flushOnEnd;\n\n    this._fn = fn;\n    this._flushOnEnd = flushOnEnd;\n    this._buff = [];\n  },\n  _free: function () {\n    this._buff = null;\n  },\n  _flush: function () {\n    if (this._buff !== null && this._buff.length !== 0) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n  _handleValue: function (x) {\n    this._buff.push(x);\n    var fn = this._fn;\n    if (!fn(x)) {\n      this._flush();\n    }\n  },\n  _handleEnd: function () {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  }\n};\n\nvar S$28 = createStream('bufferWhile', mixin$21);\nvar P$24 = createProperty('bufferWhile', mixin$21);\n\nvar id$7 = function (x) {\n  return x;\n};\n\nfunction bufferWhile(obs, fn) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref2$flushOnEnd = _ref2.flushOnEnd,\n      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n  return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });\n}\n\nvar mixin$22 = {\n  _init: function (_ref) {\n    var count = _ref.count,\n        flushOnEnd = _ref.flushOnEnd;\n\n    this._count = count;\n    this._flushOnEnd = flushOnEnd;\n    this._buff = [];\n  },\n  _free: function () {\n    this._buff = null;\n  },\n  _flush: function () {\n    if (this._buff !== null && this._buff.length !== 0) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n  _handleValue: function (x) {\n    this._buff.push(x);\n    if (this._buff.length >= this._count) {\n      this._flush();\n    }\n  },\n  _handleEnd: function () {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  }\n};\n\nvar S$29 = createStream('bufferWithCount', mixin$22);\nvar P$25 = createProperty('bufferWithCount', mixin$22);\n\nfunction bufferWhile$1(obs, count) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref2$flushOnEnd = _ref2.flushOnEnd,\n      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n  return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });\n}\n\nvar mixin$23 = {\n  _init: function (_ref) {\n    var _this = this;\n\n    var wait = _ref.wait,\n        count = _ref.count,\n        flushOnEnd = _ref.flushOnEnd;\n\n    this._wait = wait;\n    this._count = count;\n    this._flushOnEnd = flushOnEnd;\n    this._intervalId = null;\n    this._$onTick = function () {\n      return _this._flush();\n    };\n    this._buff = [];\n  },\n  _free: function () {\n    this._$onTick = null;\n    this._buff = null;\n  },\n  _flush: function () {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n  _handleValue: function (x) {\n    this._buff.push(x);\n    if (this._buff.length >= this._count) {\n      clearInterval(this._intervalId);\n      this._flush();\n      this._intervalId = setInterval(this._$onTick, this._wait);\n    }\n  },\n  _handleEnd: function () {\n    if (this._flushOnEnd && this._buff.length !== 0) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n  _onActivation: function () {\n    this._intervalId = setInterval(this._$onTick, this._wait);\n    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n  },\n  _onDeactivation: function () {\n    if (this._intervalId !== null) {\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n    }\n    this._source.offAny(this._$handleAny); // copied from patterns/one-source\n  }\n};\n\nvar S$30 = createStream('bufferWithTimeOrCount', mixin$23);\nvar P$26 = createProperty('bufferWithTimeOrCount', mixin$23);\n\nfunction bufferWithTimeOrCount(obs, wait, count) {\n  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref2$flushOnEnd = _ref2.flushOnEnd,\n      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n  return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });\n}\n\nfunction xformForObs(obs) {\n  return {\n    '@@transducer/step': function (res, input) {\n      obs._emitValue(input);\n      return null;\n    },\n    '@@transducer/result': function () {\n      obs._emitEnd();\n      return null;\n    }\n  };\n}\n\nvar mixin$24 = {\n  _init: function (_ref) {\n    var transducer = _ref.transducer;\n\n    this._xform = transducer(xformForObs(this));\n  },\n  _free: function () {\n    this._xform = null;\n  },\n  _handleValue: function (x) {\n    if (this._xform['@@transducer/step'](null, x) !== null) {\n      this._xform['@@transducer/result'](null);\n    }\n  },\n  _handleEnd: function () {\n    this._xform['@@transducer/result'](null);\n  }\n};\n\nvar S$31 = createStream('transduce', mixin$24);\nvar P$27 = createProperty('transduce', mixin$24);\n\nfunction transduce(obs, transducer) {\n  return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });\n}\n\nvar mixin$25 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._handler = fn;\n    this._emitter = emitter(this);\n  },\n  _free: function () {\n    this._handler = null;\n    this._emitter = null;\n  },\n  _handleAny: function (event) {\n    this._handler(this._emitter, event);\n  }\n};\n\nvar S$32 = createStream('withHandler', mixin$25);\nvar P$28 = createProperty('withHandler', mixin$25);\n\nfunction withHandler(obs, fn) {\n  return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });\n}\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction Zip(sources, combinator) {\n  var _this = this;\n\n  Stream.call(this);\n\n  this._buffers = map(sources, function (source) {\n    return isArray(source) ? cloneArray(source) : [];\n  });\n  this._sources = map(sources, function (source) {\n    return isArray(source) ? never() : source;\n  });\n\n  this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n    return x;\n  };\n  this._aliveCount = 0;\n\n  this._$handlers = [];\n\n  var _loop = function (i) {\n    _this._$handlers.push(function (event) {\n      return _this._handleAny(i, event);\n    });\n  };\n\n  for (var i = 0; i < this._sources.length; i++) {\n    _loop(i);\n  }\n}\n\ninherit(Zip, Stream, {\n  _name: 'zip',\n\n  _onActivation: function () {\n    // if all sources are arrays\n    while (this._isFull()) {\n      this._emit();\n    }\n\n    var length = this._sources.length;\n    this._aliveCount = length;\n    for (var i = 0; i < length && this._active; i++) {\n      this._sources[i].onAny(this._$handlers[i]);\n    }\n  },\n  _onDeactivation: function () {\n    for (var i = 0; i < this._sources.length; i++) {\n      this._sources[i].offAny(this._$handlers[i]);\n    }\n  },\n  _emit: function () {\n    var values = new Array(this._buffers.length);\n    for (var i = 0; i < this._buffers.length; i++) {\n      values[i] = this._buffers[i].shift();\n    }\n    var combinator = this._combinator;\n    this._emitValue(combinator(values));\n  },\n  _isFull: function () {\n    for (var i = 0; i < this._buffers.length; i++) {\n      if (this._buffers[i].length === 0) {\n        return false;\n      }\n    }\n    return true;\n  },\n  _handleAny: function (i, event) {\n    if (event.type === VALUE) {\n      this._buffers[i].push(event.value);\n      if (this._isFull()) {\n        this._emit();\n      }\n    }\n    if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n    if (event.type === END) {\n      this._aliveCount--;\n      if (this._aliveCount === 0) {\n        this._emitEnd();\n      }\n    }\n  },\n  _clear: function () {\n    Stream.prototype._clear.call(this);\n    this._sources = null;\n    this._buffers = null;\n    this._combinator = null;\n    this._$handlers = null;\n  }\n});\n\nfunction zip(observables, combinator /* Function | falsey */) {\n  return observables.length === 0 ? never() : new Zip(observables, combinator);\n}\n\nvar id$8 = function (x) {\n  return x;\n};\n\nfunction AbstractPool() {\n  var _this = this;\n\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$queueLim = _ref.queueLim,\n      queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim,\n      _ref$concurLim = _ref.concurLim,\n      concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim,\n      _ref$drop = _ref.drop,\n      drop = _ref$drop === undefined ? 'new' : _ref$drop;\n\n  Stream.call(this);\n\n  this._queueLim = queueLim < 0 ? -1 : queueLim;\n  this._concurLim = concurLim < 0 ? -1 : concurLim;\n  this._drop = drop;\n  this._queue = [];\n  this._curSources = [];\n  this._$handleSubAny = function (event) {\n    return _this._handleSubAny(event);\n  };\n  this._$endHandlers = [];\n  this._currentlyAdding = null;\n\n  if (this._concurLim === 0) {\n    this._emitEnd();\n  }\n}\n\ninherit(AbstractPool, Stream, {\n  _name: 'abstractPool',\n\n  _add: function (obj, toObs /* Function | falsey */) {\n    toObs = toObs || id$8;\n    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {\n      this._addToCur(toObs(obj));\n    } else {\n      if (this._queueLim === -1 || this._queue.length < this._queueLim) {\n        this._addToQueue(toObs(obj));\n      } else if (this._drop === 'old') {\n        this._removeOldest();\n        this._add(obj, toObs);\n      }\n    }\n  },\n  _addAll: function (obss) {\n    var _this2 = this;\n\n    forEach(obss, function (obs) {\n      return _this2._add(obs);\n    });\n  },\n  _remove: function (obs) {\n    if (this._removeCur(obs) === -1) {\n      this._removeQueue(obs);\n    }\n  },\n  _addToQueue: function (obs) {\n    this._queue = concat(this._queue, [obs]);\n  },\n  _addToCur: function (obs) {\n    if (this._active) {\n      // HACK:\n      //\n      // We have two optimizations for cases when `obs` is ended. We don't want\n      // to add such observable to the list, but only want to emit events\n      // from it (if it has some).\n      //\n      // Instead of this hacks, we could just did following,\n      // but it would be 5-8 times slower:\n      //\n      //     this._curSources = concat(this._curSources, [obs]);\n      //     this._subscribe(obs);\n      //\n\n      // #1\n      // This one for cases when `obs` already ended\n      // e.g., Kefir.constant() or Kefir.never()\n      if (!obs._alive) {\n        if (obs._currentEvent) {\n          this._emit(obs._currentEvent.type, obs._currentEvent.value);\n        }\n        // The _emit above could have caused this stream to end.\n        if (this._active) {\n          if (this._queue.length !== 0) {\n            this._pullQueue();\n          } else if (this._curSources.length === 0) {\n            this._onEmpty();\n          }\n        }\n        return;\n      }\n\n      // #2\n      // This one is for cases when `obs` going to end synchronously on\n      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})\n      this._currentlyAdding = obs;\n      obs.onAny(this._$handleSubAny);\n      this._currentlyAdding = null;\n      if (obs._alive) {\n        this._curSources = concat(this._curSources, [obs]);\n        if (this._active) {\n          this._subToEnd(obs);\n        }\n      } else {\n        if (this._queue.length !== 0) {\n          this._pullQueue();\n        } else if (this._curSources.length === 0) {\n          this._onEmpty();\n        }\n      }\n    } else {\n      this._curSources = concat(this._curSources, [obs]);\n    }\n  },\n  _subToEnd: function (obs) {\n    var _this3 = this;\n\n    var onEnd = function () {\n      return _this3._removeCur(obs);\n    };\n    this._$endHandlers.push({ obs: obs, handler: onEnd });\n    obs.onEnd(onEnd);\n  },\n  _subscribe: function (obs) {\n    obs.onAny(this._$handleSubAny);\n\n    // it can become inactive in responce of subscribing to `obs.onAny` above\n    if (this._active) {\n      this._subToEnd(obs);\n    }\n  },\n  _unsubscribe: function (obs) {\n    obs.offAny(this._$handleSubAny);\n\n    var onEndI = findByPred(this._$endHandlers, function (obj) {\n      return obj.obs === obs;\n    });\n    if (onEndI !== -1) {\n      obs.offEnd(this._$endHandlers[onEndI].handler);\n      this._$endHandlers.splice(onEndI, 1);\n    }\n  },\n  _handleSubAny: function (event) {\n    if (event.type === VALUE) {\n      this._emitValue(event.value);\n    } else if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n  },\n  _removeQueue: function (obs) {\n    var index = find(this._queue, obs);\n    this._queue = remove(this._queue, index);\n    return index;\n  },\n  _removeCur: function (obs) {\n    if (this._active) {\n      this._unsubscribe(obs);\n    }\n    var index = find(this._curSources, obs);\n    this._curSources = remove(this._curSources, index);\n    if (index !== -1) {\n      if (this._queue.length !== 0) {\n        this._pullQueue();\n      } else if (this._curSources.length === 0) {\n        this._onEmpty();\n      }\n    }\n    return index;\n  },\n  _removeOldest: function () {\n    this._removeCur(this._curSources[0]);\n  },\n  _pullQueue: function () {\n    if (this._queue.length !== 0) {\n      this._queue = cloneArray(this._queue);\n      this._addToCur(this._queue.shift());\n    }\n  },\n  _onActivation: function () {\n    for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {\n      this._subscribe(sources[i]);\n    }\n  },\n  _onDeactivation: function () {\n    for (var i = 0, sources = this._curSources; i < sources.length; i++) {\n      this._unsubscribe(sources[i]);\n    }\n    if (this._currentlyAdding !== null) {\n      this._unsubscribe(this._currentlyAdding);\n    }\n  },\n  _isEmpty: function () {\n    return this._curSources.length === 0;\n  },\n  _onEmpty: function () {},\n  _clear: function () {\n    Stream.prototype._clear.call(this);\n    this._queue = null;\n    this._curSources = null;\n    this._$handleSubAny = null;\n    this._$endHandlers = null;\n  }\n});\n\nfunction Merge(sources) {\n  AbstractPool.call(this);\n  this._addAll(sources);\n  this._initialised = true;\n}\n\ninherit(Merge, AbstractPool, {\n  _name: 'merge',\n\n  _onEmpty: function () {\n    if (this._initialised) {\n      this._emitEnd();\n    }\n  }\n});\n\nfunction merge(observables) {\n  return observables.length === 0 ? never() : new Merge(observables);\n}\n\nfunction S$33(generator) {\n  var _this = this;\n\n  Stream.call(this);\n  this._generator = generator;\n  this._source = null;\n  this._inLoop = false;\n  this._iteration = 0;\n  this._$handleAny = function (event) {\n    return _this._handleAny(event);\n  };\n}\n\ninherit(S$33, Stream, {\n  _name: 'repeat',\n\n  _handleAny: function (event) {\n    if (event.type === END) {\n      this._source = null;\n      this._getSource();\n    } else {\n      this._emit(event.type, event.value);\n    }\n  },\n  _getSource: function () {\n    if (!this._inLoop) {\n      this._inLoop = true;\n      var generator = this._generator;\n      while (this._source === null && this._alive && this._active) {\n        this._source = generator(this._iteration++);\n        if (this._source) {\n          this._source.onAny(this._$handleAny);\n        } else {\n          this._emitEnd();\n        }\n      }\n      this._inLoop = false;\n    }\n  },\n  _onActivation: function () {\n    if (this._source) {\n      this._source.onAny(this._$handleAny);\n    } else {\n      this._getSource();\n    }\n  },\n  _onDeactivation: function () {\n    if (this._source) {\n      this._source.offAny(this._$handleAny);\n    }\n  },\n  _clear: function () {\n    Stream.prototype._clear.call(this);\n    this._generator = null;\n    this._source = null;\n    this._$handleAny = null;\n  }\n});\n\nvar repeat = function (generator) {\n  return new S$33(generator);\n};\n\nfunction concat$1(observables) {\n  return repeat(function (index) {\n    return observables.length > index ? observables[index] : false;\n  }).setName('concat');\n}\n\nfunction Pool() {\n  AbstractPool.call(this);\n}\n\ninherit(Pool, AbstractPool, {\n  _name: 'pool',\n\n  plug: function (obs) {\n    this._add(obs);\n    return this;\n  },\n  unplug: function (obs) {\n    this._remove(obs);\n    return this;\n  }\n});\n\nfunction FlatMap(source, fn, options) {\n  var _this = this;\n\n  AbstractPool.call(this, options);\n  this._source = source;\n  this._fn = fn;\n  this._mainEnded = false;\n  this._lastCurrent = null;\n  this._$handleMain = function (event) {\n    return _this._handleMain(event);\n  };\n}\n\ninherit(FlatMap, AbstractPool, {\n  _onActivation: function () {\n    AbstractPool.prototype._onActivation.call(this);\n    if (this._active) {\n      this._source.onAny(this._$handleMain);\n    }\n  },\n  _onDeactivation: function () {\n    AbstractPool.prototype._onDeactivation.call(this);\n    this._source.offAny(this._$handleMain);\n    this._hadNoEvSinceDeact = true;\n  },\n  _handleMain: function (event) {\n    if (event.type === VALUE) {\n      // Is latest value before deactivation survived, and now is 'current' on this activation?\n      // We don't want to handle such values, to prevent to constantly add\n      // same observale on each activation/deactivation when our main source\n      // is a `Kefir.conatant()` for example.\n      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n      if (!sameCurr) {\n        this._add(event.value, this._fn);\n      }\n      this._lastCurrent = event.value;\n      this._hadNoEvSinceDeact = false;\n    }\n\n    if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n\n    if (event.type === END) {\n      if (this._isEmpty()) {\n        this._emitEnd();\n      } else {\n        this._mainEnded = true;\n      }\n    }\n  },\n  _onEmpty: function () {\n    if (this._mainEnded) {\n      this._emitEnd();\n    }\n  },\n  _clear: function () {\n    AbstractPool.prototype._clear.call(this);\n    this._source = null;\n    this._lastCurrent = null;\n    this._$handleMain = null;\n  }\n});\n\nfunction FlatMapErrors(source, fn) {\n  FlatMap.call(this, source, fn);\n}\n\ninherit(FlatMapErrors, FlatMap, {\n  // Same as in FlatMap, only VALUE/ERROR flipped\n  _handleMain: function (event) {\n    if (event.type === ERROR) {\n      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n      if (!sameCurr) {\n        this._add(event.value, this._fn);\n      }\n      this._lastCurrent = event.value;\n      this._hadNoEvSinceDeact = false;\n    }\n\n    if (event.type === VALUE) {\n      this._emitValue(event.value);\n    }\n\n    if (event.type === END) {\n      if (this._isEmpty()) {\n        this._emitEnd();\n      } else {\n        this._mainEnded = true;\n      }\n    }\n  }\n});\n\nfunction createConstructor$1(BaseClass, name) {\n  return function AnonymousObservable(primary, secondary, options) {\n    var _this = this;\n\n    BaseClass.call(this);\n    this._primary = primary;\n    this._secondary = secondary;\n    this._name = primary._name + '.' + name;\n    this._lastSecondary = NOTHING;\n    this._$handleSecondaryAny = function (event) {\n      return _this._handleSecondaryAny(event);\n    };\n    this._$handlePrimaryAny = function (event) {\n      return _this._handlePrimaryAny(event);\n    };\n    this._init(options);\n  };\n}\n\nfunction createClassMethods$1(BaseClass) {\n  return {\n    _init: function () {},\n    _free: function () {},\n    _handlePrimaryValue: function (x) {\n      this._emitValue(x);\n    },\n    _handlePrimaryError: function (x) {\n      this._emitError(x);\n    },\n    _handlePrimaryEnd: function () {\n      this._emitEnd();\n    },\n    _handleSecondaryValue: function (x) {\n      this._lastSecondary = x;\n    },\n    _handleSecondaryError: function (x) {\n      this._emitError(x);\n    },\n    _handleSecondaryEnd: function () {},\n    _handlePrimaryAny: function (event) {\n      switch (event.type) {\n        case VALUE:\n          return this._handlePrimaryValue(event.value);\n        case ERROR:\n          return this._handlePrimaryError(event.value);\n        case END:\n          return this._handlePrimaryEnd(event.value);\n      }\n    },\n    _handleSecondaryAny: function (event) {\n      switch (event.type) {\n        case VALUE:\n          return this._handleSecondaryValue(event.value);\n        case ERROR:\n          return this._handleSecondaryError(event.value);\n        case END:\n          this._handleSecondaryEnd(event.value);\n          this._removeSecondary();\n      }\n    },\n    _removeSecondary: function () {\n      if (this._secondary !== null) {\n        this._secondary.offAny(this._$handleSecondaryAny);\n        this._$handleSecondaryAny = null;\n        this._secondary = null;\n      }\n    },\n    _onActivation: function () {\n      if (this._secondary !== null) {\n        this._secondary.onAny(this._$handleSecondaryAny);\n      }\n      if (this._active) {\n        this._primary.onAny(this._$handlePrimaryAny);\n      }\n    },\n    _onDeactivation: function () {\n      if (this._secondary !== null) {\n        this._secondary.offAny(this._$handleSecondaryAny);\n      }\n      this._primary.offAny(this._$handlePrimaryAny);\n    },\n    _clear: function () {\n      BaseClass.prototype._clear.call(this);\n      this._primary = null;\n      this._secondary = null;\n      this._lastSecondary = null;\n      this._$handleSecondaryAny = null;\n      this._$handlePrimaryAny = null;\n      this._free();\n    }\n  };\n}\n\nfunction createStream$1(name, mixin) {\n  var S = createConstructor$1(Stream, name);\n  inherit(S, Stream, createClassMethods$1(Stream), mixin);\n  return S;\n}\n\nfunction createProperty$1(name, mixin) {\n  var P = createConstructor$1(Property, name);\n  inherit(P, Property, createClassMethods$1(Property), mixin);\n  return P;\n}\n\nvar mixin$26 = {\n  _handlePrimaryValue: function (x) {\n    if (this._lastSecondary !== NOTHING && this._lastSecondary) {\n      this._emitValue(x);\n    }\n  },\n  _handleSecondaryEnd: function () {\n    if (this._lastSecondary === NOTHING || !this._lastSecondary) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$34 = createStream$1('filterBy', mixin$26);\nvar P$29 = createProperty$1('filterBy', mixin$26);\n\nfunction filterBy(primary, secondary) {\n  return new (primary._ofSameType(S$34, P$29))(primary, secondary);\n}\n\nvar id2 = function (_, x) {\n  return x;\n};\n\nfunction sampledBy(passive, active, combinator) {\n  var _combinator = combinator ? function (a, b) {\n    return combinator(b, a);\n  } : id2;\n  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');\n}\n\nvar mixin$27 = {\n  _handlePrimaryValue: function (x) {\n    if (this._lastSecondary !== NOTHING) {\n      this._emitValue(x);\n    }\n  },\n  _handleSecondaryEnd: function () {\n    if (this._lastSecondary === NOTHING) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$35 = createStream$1('skipUntilBy', mixin$27);\nvar P$30 = createProperty$1('skipUntilBy', mixin$27);\n\nfunction skipUntilBy(primary, secondary) {\n  return new (primary._ofSameType(S$35, P$30))(primary, secondary);\n}\n\nvar mixin$28 = {\n  _handleSecondaryValue: function () {\n    this._emitEnd();\n  }\n};\n\nvar S$36 = createStream$1('takeUntilBy', mixin$28);\nvar P$31 = createProperty$1('takeUntilBy', mixin$28);\n\nfunction takeUntilBy(primary, secondary) {\n  return new (primary._ofSameType(S$36, P$31))(primary, secondary);\n}\n\nvar mixin$29 = {\n  _init: function () {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$flushOnEnd = _ref.flushOnEnd,\n        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n\n    this._buff = [];\n    this._flushOnEnd = flushOnEnd;\n  },\n  _free: function () {\n    this._buff = null;\n  },\n  _flush: function () {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n  _handlePrimaryEnd: function () {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n  _onActivation: function () {\n    this._primary.onAny(this._$handlePrimaryAny);\n    if (this._alive && this._secondary !== null) {\n      this._secondary.onAny(this._$handleSecondaryAny);\n    }\n  },\n  _handlePrimaryValue: function (x) {\n    this._buff.push(x);\n  },\n  _handleSecondaryValue: function () {\n    this._flush();\n  },\n  _handleSecondaryEnd: function () {\n    if (!this._flushOnEnd) {\n      this._emitEnd();\n    }\n  }\n};\n\nvar S$37 = createStream$1('bufferBy', mixin$29);\nvar P$32 = createProperty$1('bufferBy', mixin$29);\n\nfunction bufferBy(primary, secondary, options /* optional */) {\n  return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);\n}\n\nvar mixin$30 = {\n  _init: function () {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$flushOnEnd = _ref.flushOnEnd,\n        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd,\n        _ref$flushOnChange = _ref.flushOnChange,\n        flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;\n\n    this._buff = [];\n    this._flushOnEnd = flushOnEnd;\n    this._flushOnChange = flushOnChange;\n  },\n  _free: function () {\n    this._buff = null;\n  },\n  _flush: function () {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n  _handlePrimaryEnd: function () {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n  _handlePrimaryValue: function (x) {\n    this._buff.push(x);\n    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {\n      this._flush();\n    }\n  },\n  _handleSecondaryEnd: function () {\n    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {\n      this._emitEnd();\n    }\n  },\n  _handleSecondaryValue: function (x) {\n    if (this._flushOnChange && !x) {\n      this._flush();\n    }\n\n    // from default _handleSecondaryValue\n    this._lastSecondary = x;\n  }\n};\n\nvar S$38 = createStream$1('bufferWhileBy', mixin$30);\nvar P$33 = createProperty$1('bufferWhileBy', mixin$30);\n\nfunction bufferWhileBy(primary, secondary, options /* optional */) {\n  return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);\n}\n\nvar f = function () {\n  return false;\n};\nvar t = function () {\n  return true;\n};\n\nfunction awaiting(a, b) {\n  var result = merge([map$1(a, t), map$1(b, f)]);\n  result = skipDuplicates(result);\n  result = toProperty(result, f);\n  return result.setName(a, 'awaiting');\n}\n\nvar mixin$31 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleValue: function (x) {\n    var fn = this._fn;\n    var result = fn(x);\n    if (result.convert) {\n      this._emitError(result.error);\n    } else {\n      this._emitValue(x);\n    }\n  }\n};\n\nvar S$39 = createStream('valuesToErrors', mixin$31);\nvar P$34 = createProperty('valuesToErrors', mixin$31);\n\nvar defFn = function (x) {\n  return { convert: true, error: x };\n};\n\nfunction valuesToErrors(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;\n\n  return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });\n}\n\nvar mixin$32 = {\n  _init: function (_ref) {\n    var fn = _ref.fn;\n\n    this._fn = fn;\n  },\n  _free: function () {\n    this._fn = null;\n  },\n  _handleError: function (x) {\n    var fn = this._fn;\n    var result = fn(x);\n    if (result.convert) {\n      this._emitValue(result.value);\n    } else {\n      this._emitError(x);\n    }\n  }\n};\n\nvar S$40 = createStream('errorsToValues', mixin$32);\nvar P$35 = createProperty('errorsToValues', mixin$32);\n\nvar defFn$1 = function (x) {\n  return { convert: true, value: x };\n};\n\nfunction errorsToValues(obs) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;\n\n  return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });\n}\n\nvar mixin$33 = {\n  _handleError: function (x) {\n    this._emitError(x);\n    this._emitEnd();\n  }\n};\n\nvar S$41 = createStream('endOnError', mixin$33);\nvar P$36 = createProperty('endOnError', mixin$33);\n\nfunction endOnError(obs) {\n  return new (obs._ofSameType(S$41, P$36))(obs);\n}\n\n// Create a stream\n// -----------------------------------------------------------------------------\n\n// () -> Stream\n// (number, any) -> Stream\n// (number, any) -> Stream\n// (number, Array<any>) -> Stream\n// (number, Function) -> Stream\n// (number, Function) -> Stream\n// (Function) -> Stream\n// (Function) -> Stream\n// Target = {addEventListener, removeEventListener}|{addListener, removeListener}|{on, off}\n// (Target, string, Function|undefined) -> Stream\n// (Function) -> Stream\n// Create a property\n// -----------------------------------------------------------------------------\n\n// (any) -> Property\n// (any) -> Property\n// Convert observables\n// -----------------------------------------------------------------------------\n\n// (Stream|Property, Function|undefined) -> Property\nObservable.prototype.toProperty = function (fn) {\n  return toProperty(this, fn);\n};\n\n// (Stream|Property) -> Stream\nObservable.prototype.changes = function () {\n  return changes(this);\n};\n\n// Interoperation with other implimentations\n// -----------------------------------------------------------------------------\n\n// (Promise) -> Property\n// (Stream|Property, Function|undefined) -> Promise\nObservable.prototype.toPromise = function (Promise) {\n  return toPromise(this, Promise);\n};\n\n// (ESObservable) -> Stream\n// (Stream|Property) -> ES7 Observable\nObservable.prototype.toESObservable = toESObservable;\nObservable.prototype[$$observable] = toESObservable;\n\n// Modify an observable\n// -----------------------------------------------------------------------------\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.map = function (fn) {\n  return map$1(this, fn);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.filter = function (fn) {\n  return filter(this, fn);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nObservable.prototype.take = function (n) {\n  return take(this, n);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nObservable.prototype.takeErrors = function (n) {\n  return takeErrors(this, n);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.takeWhile = function (fn) {\n  return takeWhile(this, fn);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nObservable.prototype.last = function () {\n  return last(this);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nObservable.prototype.skip = function (n) {\n  return skip(this, n);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.skipWhile = function (fn) {\n  return skipWhile(this, fn);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.skipDuplicates = function (fn) {\n  return skipDuplicates(this, fn);\n};\n\n// (Stream, Function|falsey, any|undefined) -> Stream\n// (Property, Function|falsey, any|undefined) -> Property\nObservable.prototype.diff = function (fn, seed) {\n  return diff(this, fn, seed);\n};\n\n// (Stream|Property, Function, any|undefined) -> Property\nObservable.prototype.scan = function (fn, seed) {\n  return scan(this, fn, seed);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.flatten = function (fn) {\n  return flatten(this, fn);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nObservable.prototype.delay = function (wait) {\n  return delay(this, wait);\n};\n\n// Options = {leading: boolean|undefined, trailing: boolean|undefined}\n// (Stream, number, Options|undefined) -> Stream\n// (Property, number, Options|undefined) -> Property\nObservable.prototype.throttle = function (wait, options) {\n  return throttle(this, wait, options);\n};\n\n// Options = {immediate: boolean|undefined}\n// (Stream, number, Options|undefined) -> Stream\n// (Property, number, Options|undefined) -> Property\nObservable.prototype.debounce = function (wait, options) {\n  return debounce(this, wait, options);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.mapErrors = function (fn) {\n  return mapErrors(this, fn);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.filterErrors = function (fn) {\n  return filterErrors(this, fn);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nObservable.prototype.ignoreValues = function () {\n  return ignoreValues(this);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nObservable.prototype.ignoreErrors = function () {\n  return ignoreErrors(this);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nObservable.prototype.ignoreEnd = function () {\n  return ignoreEnd(this);\n};\n\n// (Stream, Function) -> Stream\n// (Property, Function) -> Property\nObservable.prototype.beforeEnd = function (fn) {\n  return beforeEnd(this, fn);\n};\n\n// (Stream, number, number|undefined) -> Stream\n// (Property, number, number|undefined) -> Property\nObservable.prototype.slidingWindow = function (max, min) {\n  return slidingWindow(this, max, min);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, Function|falsey, Options|undefined) -> Stream\n// (Property, Function|falsey, Options|undefined) -> Property\nObservable.prototype.bufferWhile = function (fn, options) {\n  return bufferWhile(this, fn, options);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nObservable.prototype.bufferWithCount = function (count, options) {\n  return bufferWhile$1(this, count, options);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, number, number, Options|undefined) -> Stream\n// (Property, number, number, Options|undefined) -> Property\nObservable.prototype.bufferWithTimeOrCount = function (wait, count, options) {\n  return bufferWithTimeOrCount(this, wait, count, options);\n};\n\n// (Stream, Function) -> Stream\n// (Property, Function) -> Property\nObservable.prototype.transduce = function (transducer) {\n  return transduce(this, transducer);\n};\n\n// (Stream, Function) -> Stream\n// (Property, Function) -> Property\nObservable.prototype.withHandler = function (fn) {\n  return withHandler(this, fn);\n};\n\n// (Stream, Stream -> a) -> a\n// (Property, Property -> a) -> a\nObservable.prototype.thru = function (fn) {\n  return fn(this);\n};\n\n// Combine observables\n// -----------------------------------------------------------------------------\n\n// (Array<Stream|Property>, Function|undefiend) -> Stream\n// (Array<Stream|Property>, Array<Stream|Property>, Function|undefiend) -> Stream\nObservable.prototype.combine = function (other, combinator) {\n  return combine([this, other], combinator);\n};\n\n// (Array<Stream|Property>, Function|undefiend) -> Stream\nObservable.prototype.zip = function (other, combinator) {\n  return zip([this, other], combinator);\n};\n\n// (Array<Stream|Property>) -> Stream\nObservable.prototype.merge = function (other) {\n  return merge([this, other]);\n};\n\n// (Array<Stream|Property>) -> Stream\nObservable.prototype.concat = function (other) {\n  return concat$1([this, other]);\n};\n\n// () -> Pool\nvar pool = function () {\n  return new Pool();\n};\n\n// (Function) -> Stream\n// Options = {concurLim: number|undefined, queueLim: number|undefined, drop: 'old'|'new'|undefiend}\n// (Stream|Property, Function|falsey, Options|undefined) -> Stream\nObservable.prototype.flatMap = function (fn) {\n  return new FlatMap(this, fn).setName(this, 'flatMap');\n};\nObservable.prototype.flatMapLatest = function (fn) {\n  return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');\n};\nObservable.prototype.flatMapFirst = function (fn) {\n  return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');\n};\nObservable.prototype.flatMapConcat = function (fn) {\n  return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');\n};\nObservable.prototype.flatMapConcurLimit = function (fn, limit) {\n  return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');\n};\n\n// (Stream|Property, Function|falsey) -> Stream\nObservable.prototype.flatMapErrors = function (fn) {\n  return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');\n};\n\n// Combine two observables\n// -----------------------------------------------------------------------------\n\n// (Stream, Stream|Property) -> Stream\n// (Property, Stream|Property) -> Property\nObservable.prototype.filterBy = function (other) {\n  return filterBy(this, other);\n};\n\n// (Stream, Stream|Property, Function|undefiend) -> Stream\n// (Property, Stream|Property, Function|undefiend) -> Property\nObservable.prototype.sampledBy = function (other, combinator) {\n  return sampledBy(this, other, combinator);\n};\n\n// (Stream, Stream|Property) -> Stream\n// (Property, Stream|Property) -> Property\nObservable.prototype.skipUntilBy = function (other) {\n  return skipUntilBy(this, other);\n};\n\n// (Stream, Stream|Property) -> Stream\n// (Property, Stream|Property) -> Property\nObservable.prototype.takeUntilBy = function (other) {\n  return takeUntilBy(this, other);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, Stream|Property, Options|undefined) -> Stream\n// (Property, Stream|Property, Options|undefined) -> Property\nObservable.prototype.bufferBy = function (other, options) {\n  return bufferBy(this, other, options);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, Stream|Property, Options|undefined) -> Stream\n// (Property, Stream|Property, Options|undefined) -> Property\nObservable.prototype.bufferWhileBy = function (other, options) {\n  return bufferWhileBy(this, other, options);\n};\n\n// Deprecated\n// -----------------------------------------------------------------------------\n\nvar DEPRECATION_WARNINGS = true;\nfunction dissableDeprecationWarnings() {\n  DEPRECATION_WARNINGS = false;\n}\n\nfunction warn(msg) {\n  if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {\n    var msg2 = '\\nHere is an Error object for you containing the call stack:';\n    console.warn(msg, msg2, new Error());\n  }\n}\n\n// (Stream|Property, Stream|Property) -> Property\nObservable.prototype.awaiting = function (other) {\n  warn('You are using deprecated .awaiting() method, see https://github.com/kefirjs/kefir/issues/145');\n  return awaiting(this, other);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.valuesToErrors = function (fn) {\n  warn('You are using deprecated .valuesToErrors() method, see https://github.com/kefirjs/kefir/issues/149');\n  return valuesToErrors(this, fn);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nObservable.prototype.errorsToValues = function (fn) {\n  warn('You are using deprecated .errorsToValues() method, see https://github.com/kefirjs/kefir/issues/149');\n  return errorsToValues(this, fn);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nObservable.prototype.endOnError = function () {\n  warn('You are using deprecated .endOnError() method, see https://github.com/kefirjs/kefir/issues/150');\n  return endOnError(this);\n};\n\n// Exports\n// --------------------------------------------------------------------------\n\nvar Kefir = {\n  Observable: Observable,\n  Stream: Stream,\n  Property: Property,\n  never: never,\n  later: later,\n  interval: interval,\n  sequentially: sequentially,\n  fromPoll: fromPoll,\n  withInterval: withInterval,\n  fromCallback: fromCallback,\n  fromNodeCallback: fromNodeCallback,\n  fromEvents: fromEvents,\n  stream: stream,\n  constant: constant,\n  constantError: constantError,\n  fromPromise: fromPromise,\n  fromESObservable: fromESObservable,\n  combine: combine,\n  zip: zip,\n  merge: merge,\n  concat: concat$1,\n  Pool: Pool,\n  pool: pool,\n  repeat: repeat,\n  staticLand: staticLand\n};\n\nKefir.Kefir = Kefir;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Kefir);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/kefir/dist/kefir.esm.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/events/events.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/events/events.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/validate.js/validate.js":
/*!**********************************************!*\
  !*** ./node_modules/validate.js/validate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {/*!\n * validate.js 0.11.1\n *\n * (c) 2013-2016 Nicklas Ansman, 2013 Wrapp\n * Validate.js may be freely distributed under the MIT license.\n * For all details and documentation:\n * http://validatejs.org/\n */\n\n(function(exports, module, define) {\n  \"use strict\";\n\n  // The main function that calls the validators specified by the constraints.\n  // The options are the following:\n  //   - format (string) - An option that controls how the returned value is formatted\n  //     * flat - Returns a flat array of just the error messages\n  //     * grouped - Returns the messages grouped by attribute (default)\n  //     * detailed - Returns an array of the raw validation data\n  //   - fullMessages (boolean) - If `true` (default) the attribute name is prepended to the error.\n  //\n  // Please note that the options are also passed to each validator.\n  var validate = function(attributes, constraints, options) {\n    options = v.extend({}, v.options, options);\n\n    var results = v.runValidations(attributes, constraints, options)\n      , attr\n      , validator;\n\n    for (attr in results) {\n      for (validator in results[attr]) {\n        if (v.isPromise(results[attr][validator])) {\n          throw new Error(\"Use validate.async if you want support for promises\");\n        }\n      }\n    }\n    return validate.processValidationResults(results, options);\n  };\n\n  var v = validate;\n\n  // Copies over attributes from one or more sources to a single destination.\n  // Very much similar to underscore's extend.\n  // The first argument is the target object and the remaining arguments will be\n  // used as sources.\n  v.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(source) {\n      for (var attr in source) {\n        obj[attr] = source[attr];\n      }\n    });\n    return obj;\n  };\n\n  v.extend(validate, {\n    // This is the version of the library as a semver.\n    // The toString function will allow it to be coerced into a string\n    version: {\n      major: 0,\n      minor: 11,\n      patch: 1,\n      metadata: null,\n      toString: function() {\n        var version = v.format(\"%{major}.%{minor}.%{patch}\", v.version);\n        if (!v.isEmpty(v.version.metadata)) {\n          version += \"+\" + v.version.metadata;\n        }\n        return version;\n      }\n    },\n\n    // Below is the dependencies that are used in validate.js\n\n    // The constructor of the Promise implementation.\n    // If you are using Q.js, RSVP or any other A+ compatible implementation\n    // override this attribute to be the constructor of that promise.\n    // Since jQuery promises aren't A+ compatible they won't work.\n    Promise: typeof Promise !== \"undefined\" ? Promise : /* istanbul ignore next */ null,\n\n    EMPTY_STRING_REGEXP: /^\\s*$/,\n\n    // Runs the validators specified by the constraints object.\n    // Will return an array of the format:\n    //     [{attribute: \"<attribute name>\", error: \"<validation result>\"}, ...]\n    runValidations: function(attributes, constraints, options) {\n      var results = []\n        , attr\n        , validatorName\n        , value\n        , validators\n        , validator\n        , validatorOptions\n        , error;\n\n      if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {\n        attributes = v.collectFormValues(attributes);\n      }\n\n      // Loops through each constraints, finds the correct validator and run it.\n      for (attr in constraints) {\n        value = v.getDeepObjectValue(attributes, attr);\n        // This allows the constraints for an attribute to be a function.\n        // The function will be called with the value, attribute name, the complete dict of\n        // attributes as well as the options and constraints passed in.\n        // This is useful when you want to have different\n        // validations depending on the attribute value.\n        validators = v.result(constraints[attr], value, attributes, attr, options, constraints);\n\n        for (validatorName in validators) {\n          validator = v.validators[validatorName];\n\n          if (!validator) {\n            error = v.format(\"Unknown validator %{name}\", {name: validatorName});\n            throw new Error(error);\n          }\n\n          validatorOptions = validators[validatorName];\n          // This allows the options to be a function. The function will be\n          // called with the value, attribute name, the complete dict of\n          // attributes as well as the options and constraints passed in.\n          // This is useful when you want to have different\n          // validations depending on the attribute value.\n          validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);\n          if (!validatorOptions) {\n            continue;\n          }\n          results.push({\n            attribute: attr,\n            value: value,\n            validator: validatorName,\n            globalOptions: options,\n            attributes: attributes,\n            options: validatorOptions,\n            error: validator.call(validator,\n                value,\n                validatorOptions,\n                attr,\n                attributes,\n                options)\n          });\n        }\n      }\n\n      return results;\n    },\n\n    // Takes the output from runValidations and converts it to the correct\n    // output format.\n    processValidationResults: function(errors, options) {\n      errors = v.pruneEmptyErrors(errors, options);\n      errors = v.expandMultipleErrors(errors, options);\n      errors = v.convertErrorMessages(errors, options);\n\n      var format = options.format || \"grouped\";\n\n      if (typeof v.formatters[format] === 'function') {\n        errors = v.formatters[format](errors);\n      } else {\n        throw new Error(v.format(\"Unknown format %{format}\", options));\n      }\n\n      return v.isEmpty(errors) ? undefined : errors;\n    },\n\n    // Runs the validations with support for promises.\n    // This function will return a promise that is settled when all the\n    // validation promises have been completed.\n    // It can be called even if no validations returned a promise.\n    async: function(attributes, constraints, options) {\n      options = v.extend({}, v.async.options, options);\n\n      var WrapErrors = options.wrapErrors || function(errors) {\n        return errors;\n      };\n\n      // Removes unknown attributes\n      if (options.cleanAttributes !== false) {\n        attributes = v.cleanAttributes(attributes, constraints);\n      }\n\n      var results = v.runValidations(attributes, constraints, options);\n\n      return new v.Promise(function(resolve, reject) {\n        v.waitForResults(results).then(function() {\n          var errors = v.processValidationResults(results, options);\n          if (errors) {\n            reject(new WrapErrors(errors, options, attributes, constraints));\n          } else {\n            resolve(attributes);\n          }\n        }, function(err) {\n          reject(err);\n        });\n      });\n    },\n\n    single: function(value, constraints, options) {\n      options = v.extend({}, v.single.options, options, {\n        format: \"flat\",\n        fullMessages: false\n      });\n      return v({single: value}, {single: constraints}, options);\n    },\n\n    // Returns a promise that is resolved when all promises in the results array\n    // are settled. The promise returned from this function is always resolved,\n    // never rejected.\n    // This function modifies the input argument, it replaces the promises\n    // with the value returned from the promise.\n    waitForResults: function(results) {\n      // Create a sequence of all the results starting with a resolved promise.\n      return results.reduce(function(memo, result) {\n        // If this result isn't a promise skip it in the sequence.\n        if (!v.isPromise(result.error)) {\n          return memo;\n        }\n\n        return memo.then(function() {\n          return result.error.then(function(error) {\n            result.error = error || null;\n          });\n        });\n      }, new v.Promise(function(r) { r(); })); // A resolved promise\n    },\n\n    // If the given argument is a call: function the and: function return the value\n    // otherwise just return the value. Additional arguments will be passed as\n    // arguments to the function.\n    // Example:\n    // ```\n    // result('foo') // 'foo'\n    // result(Math.max, 1, 2) // 2\n    // ```\n    result: function(value) {\n      var args = [].slice.call(arguments, 1);\n      if (typeof value === 'function') {\n        value = value.apply(null, args);\n      }\n      return value;\n    },\n\n    // Checks if the value is a number. This function does not consider NaN a\n    // number like many other `isNumber` functions do.\n    isNumber: function(value) {\n      return typeof value === 'number' && !isNaN(value);\n    },\n\n    // Returns false if the object is not a function\n    isFunction: function(value) {\n      return typeof value === 'function';\n    },\n\n    // A simple check to verify that the value is an integer. Uses `isNumber`\n    // and a simple modulo check.\n    isInteger: function(value) {\n      return v.isNumber(value) && value % 1 === 0;\n    },\n\n    // Checks if the value is a boolean\n    isBoolean: function(value) {\n      return typeof value === 'boolean';\n    },\n\n    // Uses the `Object` function to check if the given argument is an object.\n    isObject: function(obj) {\n      return obj === Object(obj);\n    },\n\n    // Simply checks if the object is an instance of a date\n    isDate: function(obj) {\n      return obj instanceof Date;\n    },\n\n    // Returns false if the object is `null` of `undefined`\n    isDefined: function(obj) {\n      return obj !== null && obj !== undefined;\n    },\n\n    // Checks if the given argument is a promise. Anything with a `then`\n    // function is considered a promise.\n    isPromise: function(p) {\n      return !!p && v.isFunction(p.then);\n    },\n\n    isJqueryElement: function(o) {\n      return o && v.isString(o.jquery);\n    },\n\n    isDomElement: function(o) {\n      if (!o) {\n        return false;\n      }\n\n      if (!o.querySelectorAll || !o.querySelector) {\n        return false;\n      }\n\n      if (v.isObject(document) && o === document) {\n        return true;\n      }\n\n      // http://stackoverflow.com/a/384380/699304\n      /* istanbul ignore else */\n      if (typeof HTMLElement === \"object\") {\n        return o instanceof HTMLElement;\n      } else {\n        return o &&\n          typeof o === \"object\" &&\n          o !== null &&\n          o.nodeType === 1 &&\n          typeof o.nodeName === \"string\";\n      }\n    },\n\n    isEmpty: function(value) {\n      var attr;\n\n      // Null and undefined are empty\n      if (!v.isDefined(value)) {\n        return true;\n      }\n\n      // functions are non empty\n      if (v.isFunction(value)) {\n        return false;\n      }\n\n      // Whitespace only strings are empty\n      if (v.isString(value)) {\n        return v.EMPTY_STRING_REGEXP.test(value);\n      }\n\n      // For arrays we use the length property\n      if (v.isArray(value)) {\n        return value.length === 0;\n      }\n\n      // Dates have no attributes but aren't empty\n      if (v.isDate(value)) {\n        return false;\n      }\n\n      // If we find at least one property we consider it non empty\n      if (v.isObject(value)) {\n        for (attr in value) {\n          return false;\n        }\n        return true;\n      }\n\n      return false;\n    },\n\n    // Formats the specified strings with the given values like so:\n    // ```\n    // format(\"Foo: %{foo}\", {foo: \"bar\"}) // \"Foo bar\"\n    // ```\n    // If you want to write %{...} without having it replaced simply\n    // prefix it with % like this `Foo: %%{foo}` and it will be returned\n    // as `\"Foo: %{foo}\"`\n    format: v.extend(function(str, vals) {\n      if (!v.isString(str)) {\n        return str;\n      }\n      return str.replace(v.format.FORMAT_REGEXP, function(m0, m1, m2) {\n        if (m1 === '%') {\n          return \"%{\" + m2 + \"}\";\n        } else {\n          return String(vals[m2]);\n        }\n      });\n    }, {\n      // Finds %{key} style patterns in the given string\n      FORMAT_REGEXP: /(%?)%\\{([^\\}]+)\\}/g\n    }),\n\n    // \"Prettifies\" the given string.\n    // Prettifying means replacing [.\\_-] with spaces as well as splitting\n    // camel case words.\n    prettify: function(str) {\n      if (v.isNumber(str)) {\n        // If there are more than 2 decimals round it to two\n        if ((str * 100) % 1 === 0) {\n          return \"\" + str;\n        } else {\n          return parseFloat(Math.round(str * 100) / 100).toFixed(2);\n        }\n      }\n\n      if (v.isArray(str)) {\n        return str.map(function(s) { return v.prettify(s); }).join(\", \");\n      }\n\n      if (v.isObject(str)) {\n        return str.toString();\n      }\n\n      // Ensure the string is actually a string\n      str = \"\" + str;\n\n      return str\n        // Splits keys separated by periods\n        .replace(/([^\\s])\\.([^\\s])/g, '$1 $2')\n        // Removes backslashes\n        .replace(/\\\\+/g, '')\n        // Replaces - and - with space\n        .replace(/[_-]/g, ' ')\n        // Splits camel cased words\n        .replace(/([a-z])([A-Z])/g, function(m0, m1, m2) {\n          return \"\" + m1 + \" \" + m2.toLowerCase();\n        })\n        .toLowerCase();\n    },\n\n    stringifyValue: function(value) {\n      return v.prettify(value);\n    },\n\n    isString: function(value) {\n      return typeof value === 'string';\n    },\n\n    isArray: function(value) {\n      return {}.toString.call(value) === '[object Array]';\n    },\n\n    // Checks if the object is a hash, which is equivalent to an object that\n    // is neither an array nor a function.\n    isHash: function(value) {\n      return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);\n    },\n\n    contains: function(obj, value) {\n      if (!v.isDefined(obj)) {\n        return false;\n      }\n      if (v.isArray(obj)) {\n        return obj.indexOf(value) !== -1;\n      }\n      return value in obj;\n    },\n\n    unique: function(array) {\n      if (!v.isArray(array)) {\n        return array;\n      }\n      return array.filter(function(el, index, array) {\n        return array.indexOf(el) == index;\n      });\n    },\n\n    forEachKeyInKeypath: function(object, keypath, callback) {\n      if (!v.isString(keypath)) {\n        return undefined;\n      }\n\n      var key = \"\"\n        , i\n        , escape = false;\n\n      for (i = 0; i < keypath.length; ++i) {\n        switch (keypath[i]) {\n          case '.':\n            if (escape) {\n              escape = false;\n              key += '.';\n            } else {\n              object = callback(object, key, false);\n              key = \"\";\n            }\n            break;\n\n          case '\\\\':\n            if (escape) {\n              escape = false;\n              key += '\\\\';\n            } else {\n              escape = true;\n            }\n            break;\n\n          default:\n            escape = false;\n            key += keypath[i];\n            break;\n        }\n      }\n\n      return callback(object, key, true);\n    },\n\n    getDeepObjectValue: function(obj, keypath) {\n      if (!v.isObject(obj)) {\n        return undefined;\n      }\n\n      return v.forEachKeyInKeypath(obj, keypath, function(obj, key) {\n        if (v.isObject(obj)) {\n          return obj[key];\n        }\n      });\n    },\n\n    // This returns an object with all the values of the form.\n    // It uses the input name as key and the value as value\n    // So for example this:\n    // <input type=\"text\" name=\"email\" value=\"foo@bar.com\" />\n    // would return:\n    // {email: \"foo@bar.com\"}\n    collectFormValues: function(form, options) {\n      var values = {}\n        , i\n        , j\n        , input\n        , inputs\n        , option\n        , value;\n\n      if (v.isJqueryElement(form)) {\n        form = form[0];\n      }\n\n      if (!form) {\n        return values;\n      }\n\n      options = options || {};\n\n      inputs = form.querySelectorAll(\"input[name], textarea[name]\");\n      for (i = 0; i < inputs.length; ++i) {\n        input = inputs.item(i);\n\n        if (v.isDefined(input.getAttribute(\"data-ignored\"))) {\n          continue;\n        }\n\n        value = v.sanitizeFormValue(input.value, options);\n        if (input.type === \"number\") {\n          value = value ? +value : null;\n        } else if (input.type === \"checkbox\") {\n          if (input.attributes.value) {\n            if (!input.checked) {\n              value = values[input.name] || null;\n            }\n          } else {\n            value = input.checked;\n          }\n        } else if (input.type === \"radio\") {\n          if (!input.checked) {\n            value = values[input.name] || null;\n          }\n        }\n        values[input.name] = value;\n      }\n\n      inputs = form.querySelectorAll(\"select[name]\");\n      for (i = 0; i < inputs.length; ++i) {\n        input = inputs.item(i);\n        if (input.multiple) {\n          value = [];\n          for (j in input.options) {\n            option = input.options[j];\n            if (option.selected) {\n              value.push(v.sanitizeFormValue(option.value, options));\n            }\n          }\n        } else {\n          value = v.sanitizeFormValue(input.options[input.selectedIndex].value, options);\n        }\n        values[input.name] = value;\n      }\n\n      return values;\n    },\n\n    sanitizeFormValue: function(value, options) {\n      if (options.trim && v.isString(value)) {\n        value = value.trim();\n      }\n\n      if (options.nullify !== false && value === \"\") {\n        return null;\n      }\n      return value;\n    },\n\n    capitalize: function(str) {\n      if (!v.isString(str)) {\n        return str;\n      }\n      return str[0].toUpperCase() + str.slice(1);\n    },\n\n    // Remove all errors who's error attribute is empty (null or undefined)\n    pruneEmptyErrors: function(errors) {\n      return errors.filter(function(error) {\n        return !v.isEmpty(error.error);\n      });\n    },\n\n    // In\n    // [{error: [\"err1\", \"err2\"], ...}]\n    // Out\n    // [{error: \"err1\", ...}, {error: \"err2\", ...}]\n    //\n    // All attributes in an error with multiple messages are duplicated\n    // when expanding the errors.\n    expandMultipleErrors: function(errors) {\n      var ret = [];\n      errors.forEach(function(error) {\n        // Removes errors without a message\n        if (v.isArray(error.error)) {\n          error.error.forEach(function(msg) {\n            ret.push(v.extend({}, error, {error: msg}));\n          });\n        } else {\n          ret.push(error);\n        }\n      });\n      return ret;\n    },\n\n    // Converts the error mesages by prepending the attribute name unless the\n    // message is prefixed by ^\n    convertErrorMessages: function(errors, options) {\n      options = options || {};\n\n      var ret = [];\n      errors.forEach(function(errorInfo) {\n        var error = v.result(errorInfo.error,\n            errorInfo.value,\n            errorInfo.attribute,\n            errorInfo.options,\n            errorInfo.attributes,\n            errorInfo.globalOptions);\n\n        if (!v.isString(error)) {\n          ret.push(errorInfo);\n          return;\n        }\n\n        if (error[0] === '^') {\n          error = error.slice(1);\n        } else if (options.fullMessages !== false) {\n          error = v.capitalize(v.prettify(errorInfo.attribute)) + \" \" + error;\n        }\n        error = error.replace(/\\\\\\^/g, \"^\");\n        error = v.format(error, {value: v.stringifyValue(errorInfo.value)});\n        ret.push(v.extend({}, errorInfo, {error: error}));\n      });\n      return ret;\n    },\n\n    // In:\n    // [{attribute: \"<attributeName>\", ...}]\n    // Out:\n    // {\"<attributeName>\": [{attribute: \"<attributeName>\", ...}]}\n    groupErrorsByAttribute: function(errors) {\n      var ret = {};\n      errors.forEach(function(error) {\n        var list = ret[error.attribute];\n        if (list) {\n          list.push(error);\n        } else {\n          ret[error.attribute] = [error];\n        }\n      });\n      return ret;\n    },\n\n    // In:\n    // [{error: \"<message 1>\", ...}, {error: \"<message 2>\", ...}]\n    // Out:\n    // [\"<message 1>\", \"<message 2>\"]\n    flattenErrorsToArray: function(errors) {\n      return errors\n        .map(function(error) { return error.error; })\n        .filter(function(value, index, self) {\n          return self.indexOf(value) === index;\n        });\n    },\n\n    cleanAttributes: function(attributes, whitelist) {\n      function whitelistCreator(obj, key, last) {\n        if (v.isObject(obj[key])) {\n          return obj[key];\n        }\n        return (obj[key] = last ? true : {});\n      }\n\n      function buildObjectWhitelist(whitelist) {\n        var ow = {}\n          , lastObject\n          , attr;\n        for (attr in whitelist) {\n          if (!whitelist[attr]) {\n            continue;\n          }\n          v.forEachKeyInKeypath(ow, attr, whitelistCreator);\n        }\n        return ow;\n      }\n\n      function cleanRecursive(attributes, whitelist) {\n        if (!v.isObject(attributes)) {\n          return attributes;\n        }\n\n        var ret = v.extend({}, attributes)\n          , w\n          , attribute;\n\n        for (attribute in attributes) {\n          w = whitelist[attribute];\n\n          if (v.isObject(w)) {\n            ret[attribute] = cleanRecursive(ret[attribute], w);\n          } else if (!w) {\n            delete ret[attribute];\n          }\n        }\n        return ret;\n      }\n\n      if (!v.isObject(whitelist) || !v.isObject(attributes)) {\n        return {};\n      }\n\n      whitelist = buildObjectWhitelist(whitelist);\n      return cleanRecursive(attributes, whitelist);\n    },\n\n    exposeModule: function(validate, root, exports, module, define) {\n      if (exports) {\n        if (module && module.exports) {\n          exports = module.exports = validate;\n        }\n        exports.validate = validate;\n      } else {\n        root.validate = validate;\n        if (validate.isFunction(define) && define.amd) {\n          define([], function () { return validate; });\n        }\n      }\n    },\n\n    warn: function(msg) {\n      if (typeof console !== \"undefined\" && console.warn) {\n        console.warn(\"[validate.js] \" + msg);\n      }\n    },\n\n    error: function(msg) {\n      if (typeof console !== \"undefined\" && console.error) {\n        console.error(\"[validate.js] \" + msg);\n      }\n    }\n  });\n\n  validate.validators = {\n    // Presence validates that the value isn't empty\n    presence: function(value, options) {\n      options = v.extend({}, this.options, options);\n      if (options.allowEmpty ? !v.isDefined(value) : v.isEmpty(value)) {\n        return options.message || this.message || \"can't be blank\";\n      }\n    },\n    length: function(value, options, attribute) {\n      // Empty values are allowed\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var is = options.is\n        , maximum = options.maximum\n        , minimum = options.minimum\n        , tokenizer = options.tokenizer || function(val) { return val; }\n        , err\n        , errors = [];\n\n      value = tokenizer(value);\n      var length = value.length;\n      if(!v.isNumber(length)) {\n        v.error(v.format(\"Attribute %{attr} has a non numeric value for `length`\", {attr: attribute}));\n        return options.message || this.notValid || \"has an incorrect length\";\n      }\n\n      // Is checks\n      if (v.isNumber(is) && length !== is) {\n        err = options.wrongLength ||\n          this.wrongLength ||\n          \"is the wrong length (should be %{count} characters)\";\n        errors.push(v.format(err, {count: is}));\n      }\n\n      if (v.isNumber(minimum) && length < minimum) {\n        err = options.tooShort ||\n          this.tooShort ||\n          \"is too short (minimum is %{count} characters)\";\n        errors.push(v.format(err, {count: minimum}));\n      }\n\n      if (v.isNumber(maximum) && length > maximum) {\n        err = options.tooLong ||\n          this.tooLong ||\n          \"is too long (maximum is %{count} characters)\";\n        errors.push(v.format(err, {count: maximum}));\n      }\n\n      if (errors.length > 0) {\n        return options.message || errors;\n      }\n    },\n    numericality: function(value, options) {\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var errors = []\n        , name\n        , count\n        , checks = {\n            greaterThan:          function(v, c) { return v > c; },\n            greaterThanOrEqualTo: function(v, c) { return v >= c; },\n            equalTo:              function(v, c) { return v === c; },\n            lessThan:             function(v, c) { return v < c; },\n            lessThanOrEqualTo:    function(v, c) { return v <= c; },\n            divisibleBy:          function(v, c) { return v % c === 0; }\n          };\n\n      // Strict will check that it is a valid looking number\n      if (v.isString(value) && options.strict) {\n        var pattern = \"^(0|[1-9]\\\\d*)\";\n        if (!options.onlyInteger) {\n          pattern += \"(\\\\.\\\\d+)?\";\n        }\n        pattern += \"$\";\n\n        if (!(new RegExp(pattern).test(value))) {\n          return options.message ||\n            options.notValid ||\n            this.notValid ||\n            this.message ||\n            \"must be a valid number\";\n        }\n      }\n\n      // Coerce the value to a number unless we're being strict.\n      if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {\n        value = +value;\n      }\n\n      // If it's not a number we shouldn't continue since it will compare it.\n      if (!v.isNumber(value)) {\n        return options.message ||\n          options.notValid ||\n          this.notValid ||\n          this.message ||\n          \"is not a number\";\n      }\n\n      // Same logic as above, sort of. Don't bother with comparisons if this\n      // doesn't pass.\n      if (options.onlyInteger && !v.isInteger(value)) {\n        return options.message ||\n          options.notInteger ||\n          this.notInteger ||\n          this.message ||\n          \"must be an integer\";\n      }\n\n      for (name in checks) {\n        count = options[name];\n        if (v.isNumber(count) && !checks[name](value, count)) {\n          // This picks the default message if specified\n          // For example the greaterThan check uses the message from\n          // this.notGreaterThan so we capitalize the name and prepend \"not\"\n          var key = \"not\" + v.capitalize(name);\n          var msg = options[key] ||\n            this[key] ||\n            this.message ||\n            \"must be %{type} %{count}\";\n\n          errors.push(v.format(msg, {\n            count: count,\n            type: v.prettify(name)\n          }));\n        }\n      }\n\n      if (options.odd && value % 2 !== 1) {\n        errors.push(options.notOdd ||\n            this.notOdd ||\n            this.message ||\n            \"must be odd\");\n      }\n      if (options.even && value % 2 !== 0) {\n        errors.push(options.notEven ||\n            this.notEven ||\n            this.message ||\n            \"must be even\");\n      }\n\n      if (errors.length) {\n        return options.message || errors;\n      }\n    },\n    datetime: v.extend(function(value, options) {\n      if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {\n        throw new Error(\"Both the parse and format functions needs to be set to use the datetime/date validator\");\n      }\n\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var err\n        , errors = []\n        , earliest = options.earliest ? this.parse(options.earliest, options) : NaN\n        , latest = options.latest ? this.parse(options.latest, options) : NaN;\n\n      value = this.parse(value, options);\n\n      // 86400000 is the number of seconds in a day, this is used to remove\n      // the time from the date\n      if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {\n        err = options.notValid ||\n          options.message ||\n          this.notValid ||\n          \"must be a valid date\";\n        return v.format(err, {value: arguments[0]});\n      }\n\n      if (!isNaN(earliest) && value < earliest) {\n        err = options.tooEarly ||\n          options.message ||\n          this.tooEarly ||\n          \"must be no earlier than %{date}\";\n        err = v.format(err, {\n          value: this.format(value, options),\n          date: this.format(earliest, options)\n        });\n        errors.push(err);\n      }\n\n      if (!isNaN(latest) && value > latest) {\n        err = options.tooLate ||\n          options.message ||\n          this.tooLate ||\n          \"must be no later than %{date}\";\n        err = v.format(err, {\n          date: this.format(latest, options),\n          value: this.format(value, options)\n        });\n        errors.push(err);\n      }\n\n      if (errors.length) {\n        return v.unique(errors);\n      }\n    }, {\n      parse: null,\n      format: null\n    }),\n    date: function(value, options) {\n      options = v.extend({}, options, {dateOnly: true});\n      return v.validators.datetime.call(v.validators.datetime, value, options);\n    },\n    format: function(value, options) {\n      if (v.isString(options) || (options instanceof RegExp)) {\n        options = {pattern: options};\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var message = options.message || this.message || \"is invalid\"\n        , pattern = options.pattern\n        , match;\n\n      // Empty values are allowed\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (!v.isString(value)) {\n        return message;\n      }\n\n      if (v.isString(pattern)) {\n        pattern = new RegExp(options.pattern, options.flags);\n      }\n      match = pattern.exec(value);\n      if (!match || match[0].length != value.length) {\n        return message;\n      }\n    },\n    inclusion: function(value, options) {\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (v.isArray(options)) {\n        options = {within: options};\n      }\n      options = v.extend({}, this.options, options);\n      if (v.contains(options.within, value)) {\n        return;\n      }\n      var message = options.message ||\n        this.message ||\n        \"^%{value} is not included in the list\";\n      return v.format(message, {value: value});\n    },\n    exclusion: function(value, options) {\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (v.isArray(options)) {\n        options = {within: options};\n      }\n      options = v.extend({}, this.options, options);\n      if (!v.contains(options.within, value)) {\n        return;\n      }\n      var message = options.message || this.message || \"^%{value} is restricted\";\n      return v.format(message, {value: value});\n    },\n    email: v.extend(function(value, options) {\n      options = v.extend({}, this.options, options);\n      var message = options.message || this.message || \"is not a valid email\";\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (!v.isString(value)) {\n        return message;\n      }\n      if (!this.PATTERN.exec(value)) {\n        return message;\n      }\n    }, {\n      PATTERN: /^[a-z0-9\\u007F-\\uffff!#$%&'*+\\/=?^_`{|}~-]+(?:\\.[a-z0-9\\u007F-\\uffff!#$%&'*+\\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z]{2,}$/i\n    }),\n    equality: function(value, options, attribute, attributes) {\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      if (v.isString(options)) {\n        options = {attribute: options};\n      }\n      options = v.extend({}, this.options, options);\n      var message = options.message ||\n        this.message ||\n        \"is not equal to %{attribute}\";\n\n      if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {\n        throw new Error(\"The attribute must be a non empty string\");\n      }\n\n      var otherValue = v.getDeepObjectValue(attributes, options.attribute)\n        , comparator = options.comparator || function(v1, v2) {\n          return v1 === v2;\n        };\n\n      if (!comparator(value, otherValue, options, attribute, attributes)) {\n        return v.format(message, {attribute: v.prettify(options.attribute)});\n      }\n    },\n\n    // A URL validator that is used to validate URLs with the ability to\n    // restrict schemes and some domains.\n    url: function(value, options) {\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var message = options.message || this.message || \"is not a valid url\"\n        , schemes = options.schemes || this.schemes || ['http', 'https']\n        , allowLocal = options.allowLocal || this.allowLocal || false;\n\n      if (!v.isString(value)) {\n        return message;\n      }\n\n      // https://gist.github.com/dperini/729294\n      var regex =\n        \"^\" +\n        // protocol identifier\n        \"(?:(?:\" + schemes.join(\"|\") + \")://)\" +\n        // user:pass authentication\n        \"(?:\\\\S+(?::\\\\S*)?@)?\" +\n        \"(?:\";\n\n      var tld = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\";\n\n      if (allowLocal) {\n        tld += \"?\";\n      } else {\n        regex +=\n          // IP address exclusion\n          // private & local networks\n          \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +\n          \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +\n          \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\";\n      }\n\n      regex +=\n          // IP address dotted notation octets\n          // excludes loopback network 0.0.0.0\n          // excludes reserved space >= 224.0.0.0\n          // excludes network & broacast addresses\n          // (first & last IP address of each class)\n          \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" +\n          \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" +\n          \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" +\n        \"|\" +\n          // host name\n          \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\" +\n          // domain name\n          \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\" +\n          tld +\n        \")\" +\n        // port number\n        \"(?::\\\\d{2,5})?\" +\n        // resource path\n        \"(?:[/?#]\\\\S*)?\" +\n      \"$\";\n\n      var PATTERN = new RegExp(regex, 'i');\n      if (!PATTERN.exec(value)) {\n        return message;\n      }\n    }\n  };\n\n  validate.formatters = {\n    detailed: function(errors) {return errors;},\n    flat: v.flattenErrorsToArray,\n    grouped: function(errors) {\n      var attr;\n\n      errors = v.groupErrorsByAttribute(errors);\n      for (attr in errors) {\n        errors[attr] = v.flattenErrorsToArray(errors[attr]);\n      }\n      return errors;\n    },\n    constraint: function(errors) {\n      var attr;\n      errors = v.groupErrorsByAttribute(errors);\n      for (attr in errors) {\n        errors[attr] = errors[attr].map(function(result) {\n          return result.validator;\n        }).sort();\n      }\n      return errors;\n    }\n  };\n\n  validate.exposeModule(validate, this, exports, module, __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\"));\n}).call(this,\n         true ? /* istanbul ignore next */ exports : undefined,\n         true ? /* istanbul ignore next */ module : undefined,\n        __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\"));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/validate.js/validate.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\n\tthrow new Error(\"define cannot be used indirect\");\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/harmony-module.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/system.js":
/*!***********************************!*\
  !*** (webpack)/buildin/system.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Provide a \"System\" global.\nmodule.exports = {\n\t// Make sure import is only used as \"System.import\"\n\timport: function() {\n\t\tthrow new Error(\"System.import cannot be used indirectly\");\n\t}\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/system.js?");

/***/ }),

/***/ "./tests/apps/app.js":
/*!***************************!*\
  !*** ./tests/apps/app.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var renderer = __webpack_require__(/*! ./app.stache */ \"./tests/apps/app.stache\");\nvar importsRenderer = __webpack_require__(/*! ./imports.stache */ \"./tests/apps/imports.stache\");\nvar dynamicImportsRenderer = __webpack_require__(/*! ./dynamic-imports.stache */ \"./tests/apps/dynamic-imports.stache\");\nvar partialsRenderer = __webpack_require__(/*! ./partials.stache */ \"./tests/apps/partials.stache\");\nvar {stache, StacheElement} = __webpack_require__(/*! can */ \"./node_modules/can/can.js\");\nvar aPartial = __webpack_require__(/*! ./partials/partial.stache */ \"./tests/apps/partials/partial.stache\");\n\n// basic test\nclass MyApp extends StacheElement {\n\n\tstatic get view() {\n\t\treturn renderer\n\t}\n\n\tstatic get props() {\n\t\treturn {\n\t\t\tmessage: { \n\t\t\t\ttype: String, \n\t\t\t\tdefault: 'Greetings from stache loader'\n\t\t\t}\n\t\t};\n\t}\n}\n\ncustomElements.define('my-app', MyApp);\n\n// import test\nclass Imports extends StacheElement{\n\tstatic get view() { return importsRenderer; }\n};\n\ncustomElements.define('imports-app', Imports);\n\n// dynamic import test\nclass DynamicImports extends StacheElement {\n\tstatic get view() {\n\t\treturn dynamicImportsRenderer;\n\t}\n};\n\ncustomElements.define('dynamic-imports-app', DynamicImports);\n\n// partial test\nstache.registerPartial('aPartial.stache', aPartial);\n\nclass Partials extends StacheElement {\n\tstatic get view() { return partialsRenderer; }\n};\n\ncustomElements.define('for-partials', Partials);\n\nclass Bindings extends StacheElement {\n\tstatic get view() {\n\t\t\n\t\treturn `\n\t\t\t<my-app message:raw=\"Foo\"></my-app>\n\t\t`;\n\t}\n}\n\ncustomElements.define('bindings-app', Bindings);\n\n\n//# sourceURL=webpack:///./tests/apps/app.js?");

/***/ }),

/***/ "./tests/apps/app.stache":
/*!*******************************!*\
  !*** ./tests/apps/app.stache ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {\n\t\tvar stache = __webpack_require__(/*! can-stache */ \"./node_modules/can-stache/can-stache.js\");\n\t\tvar mustacheCore = __webpack_require__( /*! can-stache/src/mustache_core */ \"./node_modules/can-stache/src/mustache_core.js\" );\n\t\tvar parse = __webpack_require__(/*! can-stache-ast */ \"./node_modules/can-stache-ast/can-stache-ast.js\").parse;\n\t\t//common deps\n\t\t__webpack_require__(/*! can-view-import */ \"./node_modules/can-view-import/can-view-import.js\");\n\t\t__webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\n\t\n\t\t\n\t\t\n\t\tvar renderer = stache(\"/Users/cherif_b/public_html/projects/canjs/can-stache-loader/tests/apps/app.stache\", [{\"tokenType\":\"start\",\"args\":[\"div\",false,1]},{\"tokenType\":\"attrStart\",\"args\":[\"id\",1]},{\"tokenType\":\"attrValue\",\"args\":[\"msg\",1]},{\"tokenType\":\"attrEnd\",\"args\":[\"id\",1]},{\"tokenType\":\"end\",\"args\":[\"div\",false,1]},{\"tokenType\":\"special\",\"args\":[\"this.message\",1]},{\"tokenType\":\"close\",\"args\":[\"div\",1]},{\"tokenType\":\"chars\",\"args\":[\"\\n\",1]},{\"tokenType\":\"done\",\"args\":[2]}])\n\n        module.exports = function(scope, options, nodeList) {\n\t\t\tvar moduleOptions = Object.assign({}, options);\n\t\t\t\n            if(moduleOptions.helpers) {\n                moduleOptions.helpers = Object.assign({ module: module }, moduleOptions.helpers);\n            } else {\n                moduleOptions.module = module;\n\t\t\t}\n            return renderer( scope, moduleOptions, nodeList );\n        };\n    \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./tests/apps/app.stache?");

/***/ }),

/***/ "./tests/apps/dynamic-imports.stache":
/*!*******************************************!*\
  !*** ./tests/apps/dynamic-imports.stache ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {\n\t\tvar stache = __webpack_require__(/*! can-stache */ \"./node_modules/can-stache/can-stache.js\");\n\t\tvar mustacheCore = __webpack_require__( /*! can-stache/src/mustache_core */ \"./node_modules/can-stache/src/mustache_core.js\" );\n\t\tvar parse = __webpack_require__(/*! can-stache-ast */ \"./node_modules/can-stache-ast/can-stache-ast.js\").parse;\n\t\t//common deps\n\t\t__webpack_require__(/*! can-view-import */ \"./node_modules/can-view-import/can-view-import.js\");\n\t\t__webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\n\t\n\t\t__webpack_require__(/*! ./imports/imported */ \"./tests/apps/imports/imported.js\");\n\t\t\n\t\tvar renderer = stache(\"/Users/cherif_b/public_html/projects/canjs/can-stache-loader/tests/apps/dynamic-imports.stache\", [{\"tokenType\":\"start\",\"args\":[\"can-dynamic-import\",true,1]},{\"tokenType\":\"attrStart\",\"args\":[\"from\",1]},{\"tokenType\":\"attrValue\",\"args\":[\"./imports/imported\",1]},{\"tokenType\":\"attrEnd\",\"args\":[\"from\",1]},{\"tokenType\":\"end\",\"args\":[\"can-dynamic-import\",true,1]},{\"tokenType\":\"chars\",\"args\":[\"\\n\\n\",1]},{\"tokenType\":\"start\",\"args\":[\"imported-com\",false,3]},{\"tokenType\":\"end\",\"args\":[\"imported-com\",false,3]},{\"tokenType\":\"close\",\"args\":[\"imported-com\",3]},{\"tokenType\":\"chars\",\"args\":[\"\\n\",3]},{\"tokenType\":\"done\",\"args\":[4]}])\n\n        module.exports = function(scope, options, nodeList) {\n\t\t\tvar moduleOptions = Object.assign({}, options);\n\t\t\t\n            if(moduleOptions.helpers) {\n                moduleOptions.helpers = Object.assign({ module: module }, moduleOptions.helpers);\n            } else {\n                moduleOptions.module = module;\n\t\t\t}\n            return renderer( scope, moduleOptions, nodeList );\n        };\n    \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./tests/apps/dynamic-imports.stache?");

/***/ }),

/***/ "./tests/apps/imports.stache":
/*!***********************************!*\
  !*** ./tests/apps/imports.stache ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {\n\t\tvar stache = __webpack_require__(/*! can-stache */ \"./node_modules/can-stache/can-stache.js\");\n\t\tvar mustacheCore = __webpack_require__( /*! can-stache/src/mustache_core */ \"./node_modules/can-stache/src/mustache_core.js\" );\n\t\tvar parse = __webpack_require__(/*! can-stache-ast */ \"./node_modules/can-stache-ast/can-stache-ast.js\").parse;\n\t\t//common deps\n\t\t__webpack_require__(/*! can-view-import */ \"./node_modules/can-view-import/can-view-import.js\");\n\t\t__webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\n\t\n\t\t__webpack_require__(/*! ./imports/imported */ \"./tests/apps/imports/imported.js\");\n\t\t\n\t\tvar renderer = stache(\"/Users/cherif_b/public_html/projects/canjs/can-stache-loader/tests/apps/imports.stache\", [{\"tokenType\":\"start\",\"args\":[\"can-import\",true,1]},{\"tokenType\":\"attrStart\",\"args\":[\"from\",1]},{\"tokenType\":\"attrValue\",\"args\":[\"./imports/imported\",1]},{\"tokenType\":\"attrEnd\",\"args\":[\"from\",1]},{\"tokenType\":\"end\",\"args\":[\"can-import\",true,1]},{\"tokenType\":\"chars\",\"args\":[\"\\n\\n\",1]},{\"tokenType\":\"start\",\"args\":[\"imported-com\",false,3]},{\"tokenType\":\"end\",\"args\":[\"imported-com\",false,3]},{\"tokenType\":\"close\",\"args\":[\"imported-com\",3]},{\"tokenType\":\"chars\",\"args\":[\"\\n\",3]},{\"tokenType\":\"done\",\"args\":[4]}])\n\n        module.exports = function(scope, options, nodeList) {\n\t\t\tvar moduleOptions = Object.assign({}, options);\n\t\t\t\n            if(moduleOptions.helpers) {\n                moduleOptions.helpers = Object.assign({ module: module }, moduleOptions.helpers);\n            } else {\n                moduleOptions.module = module;\n\t\t\t}\n            return renderer( scope, moduleOptions, nodeList );\n        };\n    \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./tests/apps/imports.stache?");

/***/ }),

/***/ "./tests/apps/imports/imported.js":
/*!****************************************!*\
  !*** ./tests/apps/imports/imported.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var renderer = __webpack_require__(/*! ./imported.stache */ \"./tests/apps/imports/imported.stache\");\nvar { StacheElement } = __webpack_require__(/*! can */ \"./node_modules/can/can.js\");\n\nclass Imported extends StacheElement {\n\tstatic get view() { return renderer; }\n};\n\ncustomElements.define('imported-com', Imported);\n\n\n//# sourceURL=webpack:///./tests/apps/imports/imported.js?");

/***/ }),

/***/ "./tests/apps/imports/imported.stache":
/*!********************************************!*\
  !*** ./tests/apps/imports/imported.stache ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {\n\t\tvar stache = __webpack_require__(/*! can-stache */ \"./node_modules/can-stache/can-stache.js\");\n\t\tvar mustacheCore = __webpack_require__( /*! can-stache/src/mustache_core */ \"./node_modules/can-stache/src/mustache_core.js\" );\n\t\tvar parse = __webpack_require__(/*! can-stache-ast */ \"./node_modules/can-stache-ast/can-stache-ast.js\").parse;\n\t\t//common deps\n\t\t__webpack_require__(/*! can-view-import */ \"./node_modules/can-view-import/can-view-import.js\");\n\t\t__webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\n\t\n\t\t\n\t\t\n\t\tvar renderer = stache(\"/Users/cherif_b/public_html/projects/canjs/can-stache-loader/tests/apps/imports/imported.stache\", [{\"tokenType\":\"start\",\"args\":[\"div\",false,1]},{\"tokenType\":\"attrStart\",\"args\":[\"id\",1]},{\"tokenType\":\"attrValue\",\"args\":[\"imported-com-content\",1]},{\"tokenType\":\"attrEnd\",\"args\":[\"id\",1]},{\"tokenType\":\"end\",\"args\":[\"div\",false,1]},{\"tokenType\":\"chars\",\"args\":[\"I'm in the imported component\",1]},{\"tokenType\":\"close\",\"args\":[\"div\",1]},{\"tokenType\":\"chars\",\"args\":[\"\\n\",1]},{\"tokenType\":\"done\",\"args\":[2]}])\n\n        module.exports = function(scope, options, nodeList) {\n\t\t\tvar moduleOptions = Object.assign({}, options);\n\t\t\t\n            if(moduleOptions.helpers) {\n                moduleOptions.helpers = Object.assign({ module: module }, moduleOptions.helpers);\n            } else {\n                moduleOptions.module = module;\n\t\t\t}\n            return renderer( scope, moduleOptions, nodeList );\n        };\n    \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./tests/apps/imports/imported.stache?");

/***/ }),

/***/ "./tests/apps/partials.stache":
/*!************************************!*\
  !*** ./tests/apps/partials.stache ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {\n\t\tvar stache = __webpack_require__(/*! can-stache */ \"./node_modules/can-stache/can-stache.js\");\n\t\tvar mustacheCore = __webpack_require__( /*! can-stache/src/mustache_core */ \"./node_modules/can-stache/src/mustache_core.js\" );\n\t\tvar parse = __webpack_require__(/*! can-stache-ast */ \"./node_modules/can-stache-ast/can-stache-ast.js\").parse;\n\t\t//common deps\n\t\t__webpack_require__(/*! can-view-import */ \"./node_modules/can-view-import/can-view-import.js\");\n\t\t__webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\n\t\n\t\t\n\t\t\n\t\tvar renderer = stache(\"/Users/cherif_b/public_html/projects/canjs/can-stache-loader/tests/apps/partials.stache\", [{\"tokenType\":\"chars\",\"args\":[\"Partial\\n\",1]},{\"tokenType\":\"start\",\"args\":[\"div\",false,2]},{\"tokenType\":\"attrStart\",\"args\":[\"id\",2]},{\"tokenType\":\"attrValue\",\"args\":[\"partial\",2]},{\"tokenType\":\"attrEnd\",\"args\":[\"id\",2]},{\"tokenType\":\"end\",\"args\":[\"div\",false,2]},{\"tokenType\":\"special\",\"args\":[\"> aPartial.stache\",2]},{\"tokenType\":\"close\",\"args\":[\"div\",2]},{\"tokenType\":\"chars\",\"args\":[\"\\n\",2]},{\"tokenType\":\"done\",\"args\":[3]}])\n\n        module.exports = function(scope, options, nodeList) {\n\t\t\tvar moduleOptions = Object.assign({}, options);\n\t\t\t\n            if(moduleOptions.helpers) {\n                moduleOptions.helpers = Object.assign({ module: module }, moduleOptions.helpers);\n            } else {\n                moduleOptions.module = module;\n\t\t\t}\n            return renderer( scope, moduleOptions, nodeList );\n        };\n    \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./tests/apps/partials.stache?");

/***/ }),

/***/ "./tests/apps/partials/partial.stache":
/*!********************************************!*\
  !*** ./tests/apps/partials/partial.stache ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {\n\t\tvar stache = __webpack_require__(/*! can-stache */ \"./node_modules/can-stache/can-stache.js\");\n\t\tvar mustacheCore = __webpack_require__( /*! can-stache/src/mustache_core */ \"./node_modules/can-stache/src/mustache_core.js\" );\n\t\tvar parse = __webpack_require__(/*! can-stache-ast */ \"./node_modules/can-stache-ast/can-stache-ast.js\").parse;\n\t\t//common deps\n\t\t__webpack_require__(/*! can-view-import */ \"./node_modules/can-view-import/can-view-import.js\");\n\t\t__webpack_require__(/*! can-stache-bindings */ \"./node_modules/can-stache-bindings/can-stache-bindings.js\");\n\t\n\t\t\n\t\t\n\t\tvar renderer = stache(\"/Users/cherif_b/public_html/projects/canjs/can-stache-loader/tests/apps/partials/partial.stache\", [{\"tokenType\":\"start\",\"args\":[\"div\",false,1]},{\"tokenType\":\"attrStart\",\"args\":[\"id\",1]},{\"tokenType\":\"attrValue\",\"args\":[\"thePartial\",1]},{\"tokenType\":\"attrEnd\",\"args\":[\"id\",1]},{\"tokenType\":\"end\",\"args\":[\"div\",false,1]},{\"tokenType\":\"chars\",\"args\":[\"I'm partial\",1]},{\"tokenType\":\"close\",\"args\":[\"div\",1]},{\"tokenType\":\"chars\",\"args\":[\"\\n\",1]},{\"tokenType\":\"done\",\"args\":[2]}])\n\n        module.exports = function(scope, options, nodeList) {\n\t\t\tvar moduleOptions = Object.assign({}, options);\n\t\t\t\n            if(moduleOptions.helpers) {\n                moduleOptions.helpers = Object.assign({ module: module }, moduleOptions.helpers);\n            } else {\n                moduleOptions.module = module;\n\t\t\t}\n            return renderer( scope, moduleOptions, nodeList );\n        };\n    \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./tests/apps/partials/partial.stache?");

/***/ })

/******/ });