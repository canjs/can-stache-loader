/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/can-assign/dist/cjs/can-assign.js":
/*!***************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-assign/dist/cjs/can-assign.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*can-assign@1.2.0#can-assign*/\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nmodule.exports = namespace.assign = function (d, s) {\n    for (var prop in s) {\n        d[prop] = s[prop];\n    }\n    return d;\n};\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-assign/dist/cjs/can-assign.js?");

/***/ }),

/***/ "../../node_modules/can-attribute-encoder/can-attribute-encoder.js":
/*!****************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-attribute-encoder/can-attribute-encoder.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\n\n/**\n * @module {{}} can-attribute-encoder can-attribute-encoder\n * @parent can-dom-utilities\n * @collection can-infrastructure\n * @package ./package.json\n *\n * Encode and decode attribute names.\n *\n * @option {Object} An object with the methods:\n * [can-attribute-encoder.encode] and [can-attribute-encoder.decode].\n *\n */\n\n\nfunction each(items, callback){\n\tfor ( var i = 0; i < items.length; i++ ) {\n\t\tcallback(items[i], i);\n\t}\n}\n\nfunction makeMap(str){\n\tvar obj = {}, items = str.split(\",\");\n\teach(items, function(name){\n\t\tobj[name] = true;\n\t});\n\treturn obj;\n}\n\n// Attributes for which the case matters - shouldn’t be lowercased.\nvar caseMattersAttributes = makeMap(\"allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector\");\n\nfunction camelCaseToSpinalCase(match, lowerCaseChar, upperCaseChar) {\n\treturn lowerCaseChar + \"-\" + upperCaseChar.toLowerCase();\n}\n\nfunction startsWith(allOfIt, startsWith) {\n\treturn allOfIt.indexOf(startsWith) === 0;\n}\n\nfunction endsWith(allOfIt, endsWith) {\n\treturn (allOfIt.length - allOfIt.indexOf(endsWith)) === endsWith.length;\n}\n\nvar regexes = {\n\tleftParens: /\\(/g,\n\trightParens: /\\)/g,\n\tleftBrace: /\\{/g,\n\trightBrace: /\\}/g,\n\tcamelCase: /([a-z]|^)([A-Z])/g,\n\tforwardSlash: /\\//g,\n\tspace: /\\s/g,\n\tuppercase: /[A-Z]/g,\n\tuppercaseDelimiterThenChar: /:u:([a-z])/g,\n\tcaret: /\\^/g,\n\tdollar: /\\$/g,\n\tat: /@/g\n};\n\nvar delimiters = {\n\tprependUppercase: ':u:',\n\treplaceSpace: ':s:',\n\treplaceForwardSlash: ':f:',\n\treplaceLeftParens: ':lp:',\n\treplaceRightParens: ':rp:',\n\treplaceLeftBrace: ':lb:',\n\treplaceRightBrace: ':rb:',\n\treplaceCaret: ':c:',\n\treplaceDollar: ':d:',\n\treplaceAt: ':at:'\n};\n\nvar encoder = {};\n\n/**\n * @function can-attribute-encoder.encode encode\n * @parent can-attribute-encoder\n * @description Encode an attribute name\n *\n * @signature `encoder.encode(attributeName)`\n *\n * Note: specific encoding may change, but encoded attributes\n * can always be decoded using [can-attribute-encoder.decode].\n *\n * @body\n *\n * ```js\n * var encodedAttributeName = encoder.encode(\"{(^$foo/bar baz)}\");\n * div.setAttribute(encodedAttributeName, \"attribute value\");\n * ```\n *\n * @param {String} attributeName The attribute name.\n * @return {String} The encoded attribute name.\n *\n */\nencoder.encode = function(name) {\n\tvar encoded = name;\n\n\t// encode or convert camelCase attributes unless in list of attributes\n\t// where case matters\n\tif (!caseMattersAttributes[encoded] && encoded.match(regexes.camelCase)) {\n\t\t// encode uppercase characters in new bindings\n\t\t// - on:fooBar, fooBar:to, fooBar:from, fooBar:bind\n\t\tif (\n\t\t\tstartsWith(encoded, 'on:') ||\n\t\t\tendsWith(encoded, ':to') ||\n\t\t\tendsWith(encoded, ':from') ||\n\t\t\tendsWith(encoded, ':bind') ||\n\t\t\tendsWith(encoded, ':raw')\n\t\t) {\n\t\t\tencoded = encoded\n\t\t\t\t.replace(regexes.uppercase, function(char) {\n\t\t\t\t\treturn delimiters.prependUppercase + char.toLowerCase();\n\t\t\t\t});\n\t\t} else if(startsWith(encoded, '(') || startsWith(encoded, '{')) {\n\t\t\t// convert uppercase characters in older bindings to kebab-case\n\t\t\t// - {fooBar}, (fooBar), {(fooBar)}\n\t\t\tencoded = encoded.replace(regexes.camelCase, camelCaseToSpinalCase);\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tdev.warn(\"can-attribute-encoder: Found attribute with name: \" + name + \". Converting to: \" + encoded + '.');\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\t}\n\n\t//encode spaces\n\tencoded = encoded.replace(regexes.space, delimiters.replaceSpace)\n\t\t//encode forward slashes\n\t\t.replace(regexes.forwardSlash, delimiters.replaceForwardSlash)\n\t\t// encode left parentheses\n\t\t.replace(regexes.leftParens, delimiters.replaceLeftParens)\n\t\t// encode right parentheses\n\t\t.replace(regexes.rightParens, delimiters.replaceRightParens)\n\t\t// encode left braces\n\t\t.replace(regexes.leftBrace, delimiters.replaceLeftBrace)\n\t\t// encode left braces\n\t\t.replace(regexes.rightBrace, delimiters.replaceRightBrace)\n\t\t// encode ^\n\t\t.replace(regexes.caret, delimiters.replaceCaret)\n\t\t// encode $\n\t\t.replace(regexes.dollar, delimiters.replaceDollar)\n\t\t// encode @\n\t\t.replace(regexes.at, delimiters.replaceAt);\n\n\treturn encoded;\n};\n\n/**\n * @function can-attribute-encoder.decode decode\n * @parent can-attribute-encoder\n * @description Decode an attribute name encoded by [can-attribute-encoder.encode]\n * @signature `encoder.decode(attributeName)`\n *\n * @body\n *\n * ```js\n * encoder.decode(attributeName); // -> \"{(^$foo/bar baz)}\"\n *\n * ```\n *\n * @param {String} attributeName The encoded attribute name.\n * @return {String} The decoded attribute name.\n *\n */\nencoder.decode = function(name) {\n\tvar decoded = name;\n\n\t// decode uppercase characters in new bindings\n\tif (!caseMattersAttributes[decoded] && decoded.match(regexes.uppercaseDelimiterThenChar)) {\n\t\tif (\n\t\t\tstartsWith(decoded, 'on:') ||\n\t\t\tendsWith(decoded, ':to') ||\n\t\t\tendsWith(decoded, ':from') ||\n\t\t\tendsWith(decoded, ':bind') ||\n\t\t\tendsWith(decoded, ':raw')\n\t\t) {\n\t\t\tdecoded = decoded\n\t\t\t\t.replace(regexes.uppercaseDelimiterThenChar, function(match, char) {\n\t\t\t\t\treturn char.toUpperCase();\n\t\t\t\t});\n\t\t}\n\t}\n\n\t// decode left parentheses\n\tdecoded = decoded.replace(delimiters.replaceLeftParens, '(')\n\t\t// decode right parentheses\n\t\t.replace(delimiters.replaceRightParens, ')')\n\t\t// decode left braces\n\t\t.replace(delimiters.replaceLeftBrace, '{')\n\t\t// decode left braces\n\t\t.replace(delimiters.replaceRightBrace, '}')\n\t\t// decode forward slashes\n\t\t.replace(delimiters.replaceForwardSlash, '/')\n\t\t// decode spaces\n\t\t.replace(delimiters.replaceSpace, ' ')\n\t\t// decode ^\n\t\t.replace(delimiters.replaceCaret, '^')\n\t\t//decode $\n\t\t.replace(delimiters.replaceDollar, '$')\n\t\t//decode @\n\t\t.replace(delimiters.replaceAt, '@');\n\n\treturn decoded;\n};\n\nif (namespace.encoder) {\n\tthrow new Error(\"You can't have two versions of can-attribute-encoder, check your dependencies\");\n} else {\n\tmodule.exports = namespace.encoder = encoder;\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-attribute-encoder/can-attribute-encoder.js?");

/***/ }),

/***/ "../../node_modules/can-attribute-observable/behaviors.js":
/*!*******************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-attribute-observable/behaviors.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\nvar global = __webpack_require__(/*! can-globals/global/global */ \"../../node_modules/can-globals/global/global.js\")();\nvar setData = __webpack_require__(/*! can-dom-data-state */ \"../../node_modules/can-dom-data-state/can-dom-data-state.js\");\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"../../node_modules/can-dom-events/can-dom-events.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"../../node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"../../node_modules/can-dom-mutate/node.js\");\nvar getMutationObserver = __webpack_require__(/*! can-globals/mutation-observer/mutation-observer */ \"../../node_modules/can-globals/mutation-observer/mutation-observer.js\");\nvar diff = __webpack_require__(/*! can-diff/list/list */ \"../../node_modules/can-diff/list/list.js\");\n\nvar formElements = {\"INPUT\": true, \"TEXTAREA\": true, \"SELECT\": true},\n\t// Used to convert values to strings.\n\ttoString = function(value){\n\t\tif(value == null) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn \"\"+value;\n\t\t}\n\t},\n\tisSVG = function(el){\n\t\treturn el.namespaceURI === \"http://www.w3.org/2000/svg\";\n\t},\n\ttruthy = function() { return true; },\n\tgetSpecialTest = function(special){\n\t\treturn (special && special.test) || truthy;\n\t},\n\tpropProp = function(prop, obj){\n\t\tobj = obj || {};\n\t\tobj.get = function(){\n\t\t\treturn this[prop];\n\t\t};\n\t\tobj.set = function(value){\n\t\t\tif(this[prop] !== value) {\n\t\t\t\tthis[prop] = value;\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\t\treturn obj;\n\t},\n\tbooleanProp = function(prop){\n\t\treturn {\n\t\t\tisBoolean: true,\n\t\t\tset: function(value){\n\t\t\t\tif(prop in this) {\n\t\t\t\t\tthis[prop] = value !== false;\n\t\t\t\t} else {\n\t\t\t\t\tdomMutateNode.setAttribute.call(this, prop, \"\");\n\t\t\t\t}\n\t\t\t},\n\t\t\tremove: function(){\n\t\t\t\tthis[prop] = false;\n\t\t\t}\n\t\t};\n\t},\n\tsetupMO = function(el, callback){\n\t\tvar attrMO = setData.get.call(el, \"attrMO\");\n\t\tif(!attrMO) {\n\t\t\tvar onMutation = function(){\n\t\t\t\tcallback.call(el);\n\t\t\t};\n\t\t\tvar MO = getMutationObserver();\n\t\t\tif(MO) {\n\t\t\t\tvar observer = new MO(onMutation);\n\t\t\t\tobserver.observe(el, {\n\t\t\t\t\tchildList: true,\n\t\t\t\t\tsubtree: true\n\t\t\t\t});\n\t\t\t\tsetData.set.call(el, \"attrMO\", observer);\n\t\t\t} else {\n\t\t\t\tsetData.set.call(el, \"attrMO\", true);\n\t\t\t\tsetData.set.call(el, \"canBindingCallback\", {onMutation: onMutation});\n\t\t\t}\n\t\t}\n\t},\n\t_findOptionToSelect = function (parent, value) {\n\t\tvar child = parent.firstChild;\n\t\twhile (child) {\n\t\t\tif (child.nodeName === \"OPTION\" && value === child.value) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t\tif (child.nodeName === \"OPTGROUP\") {\n\t\t\t\tvar groupChild = _findOptionToSelect(child, value);\n\t\t\t\tif (groupChild) {\n\t\t\t\t\treturn groupChild;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t},\n\tsetChildOptions = function(el, value){\n\t\tvar option;\n\t\tif (value != null) {\n\t\t\toption = _findOptionToSelect(el, value);\n\t\t}\n\t\tif (option) {\n\t\t\toption.selected = true;\n\t\t} else {\n\t\t\tel.selectedIndex = -1;\n\t\t}\n\t},\n\tforEachOption = function (parent, fn) {\n\t\tvar child = parent.firstChild;\n\t\twhile (child) {\n\t\t\tif (child.nodeName === \"OPTION\") {\n\t\t\t\tfn(child);\n\t\t\t}\n\t\t\tif (child.nodeName === \"OPTGROUP\") {\n\t\t\t\tforEachOption(child, fn);\n\t\t\t}\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t},\n\tcollectSelectedOptions = function (parent) {\n\t\tvar selectedValues = [];\n\t\tforEachOption(parent, function (option) {\n\t\t\tif (option.selected) {\n\t\t\t\tselectedValues.push(option.value);\n\t\t\t}\n\t\t});\n\t\treturn selectedValues;\n\t},\n\tmarkSelectedOptions = function (parent, values) {\n\t\tforEachOption(parent, function (option) {\n\t\t\toption.selected = values.indexOf(option.value) !== -1;\n\t\t});\n\t},\n\t// Create a handler, only once, that will set the child options any time\n\t// the select's value changes.\n\tsetChildOptionsOnChange = function(select, aEL){\n\t\tvar handler = setData.get.call(select, \"attrSetChildOptions\");\n\t\tif(handler) {\n\t\t\treturn Function.prototype;\n\t\t}\n\t\thandler = function(){\n\t\t\tsetChildOptions(select, select.value);\n\t\t};\n\t\tsetData.set.call(select, \"attrSetChildOptions\", handler);\n\t\taEL.call(select, \"change\", handler);\n\t\treturn function(rEL){\n\t\t\tsetData.clean.call(select, \"attrSetChildOptions\");\n\t\t\trEL.call(select, \"change\", handler);\n\t\t};\n\t},\n\t// cache of rules already calculated by `attr.getRule`\n\tbehaviorRules = new Map([]),\n\t// # isPropWritable\n\t// check if a property is writable on an element by finding its property descriptor\n\t// on the element or its prototype chain\n\tisPropWritable = function(el, prop) {\n\t\t   var desc = Object.getOwnPropertyDescriptor(el.constructor.prototype, prop);\n\n\t\t   if (desc) {\n\t\t\t\t   return desc.writable || desc.set;\n\t\t   } else {\n\t\t\t\t   var proto = Object.getPrototypeOf(el);\n\t\t\t\t   if (proto) {\n\t\t\t\t\t\t   return isPropWritable(proto, prop);\n\t\t\t\t   }\n\t\t   }\n\n\t\t   return false;\n\t},\n\t// # cacheRule\n\t// add a rule to the rules Map so it does not need to be calculated more than once\n\tcacheRule = function(el, attrOrPropName, rule) {\n\t\t   var rulesForElementType;\n\n\t\t   rulesForElementType = behaviorRules.get(el.prototype);\n\n\t\t   if (!rulesForElementType) {\n\t\t\t\t   rulesForElementType = {};\n\t\t\t\t   behaviorRules.set(el.constructor, rulesForElementType);\n\t\t   }\n\n\t\t   rulesForElementType[attrOrPropName] = rule;\n\n\t\t   return rule;\n\t};\n\nvar specialAttributes = {\n\tchecked: {\n\t\tget: function(){\n\t\t\treturn this.checked;\n\t\t},\n\t\tset: function(val){\n\t\t\t// - `set( truthy )` => TRUE\n\t\t\t// - `set( \"\" )`     => TRUE\n\t\t\t// - `set()`         => TRUE\n\t\t\t// - `set(undefined)` => false.\n\t\t\tvar notFalse = !!val || val === \"\" || arguments.length === 0;\n\t\t\tthis.checked = notFalse;\n\t\t\tif(notFalse && this.type === \"radio\") {\n\t\t\t\tthis.defaultChecked = true;\n\t\t\t}\n\n\t\t\treturn val;\n\t\t},\n\t\tremove: function(){\n\t\t\tthis.checked = false;\n\t\t},\n\t\ttest: function(){\n\t\t\treturn this.nodeName === \"INPUT\";\n\t\t}\n\t},\n\t\"class\": {\n\t\tget: function(){\n\t\t\tif(isSVG(this)) {\n\t\t\t\treturn this.getAttribute(\"class\");\n\t\t\t}\n\t\t\treturn this.className;\n\t\t},\n\t\tset: function(val){\n\t\t\tval = val || \"\";\n\n\t\t\tif(isSVG(this)) {\n\t\t\t\tdomMutateNode.setAttribute.call(this, \"class\", \"\" + val);\n\t\t\t} else {\n\t\t\t\tthis.className = val;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t},\n\tdisabled: booleanProp(\"disabled\"),\n\tfocused: {\n\t\tget: function(){\n\t\t\treturn this === document.activeElement;\n\t\t},\n\t\tset: function(val){\n\t\t\tvar cur = attr.get(this, \"focused\");\n\t\t\tvar docEl = this.ownerDocument.documentElement;\n\t\t\tvar element = this;\n\t\t\tfunction focusTask() {\n\t\t\t\tif (val) {\n\t\t\t\t\telement.focus();\n\t\t\t\t} else {\n\t\t\t\t\telement.blur();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cur !== val) {\n\t\t\t\tif (!docEl.contains(element)) {\n\t\t\t\t\tvar insertionDisposal = domMutate.onNodeInsertion(element, function () {\n\t\t\t\t\t\tinsertionDisposal();\n\t\t\t\t\t\tfocusTask();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// THIS MIGHT NEED TO BE PUT IN THE MUTATE QUEUE\n\t\t\t\t\tfocusTask();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !!val;\n\t\t},\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\taEL.call(this, \"focus\", handler);\n\t\t\taEL.call(this, \"blur\", handler);\n\t\t\treturn function(rEL){\n\t\t\t\trEL.call(this, \"focus\", handler);\n\t\t\t\trEL.call(this, \"blur\", handler);\n\t\t\t};\n\t\t},\n\t\ttest: function(){\n\t\t\treturn this.nodeName === \"INPUT\";\n\t\t}\n\t},\n\t\"for\": propProp(\"htmlFor\"),\n\tinnertext: propProp(\"innerText\"),\n\tinnerhtml: propProp(\"innerHTML\"),\n\tinnerHTML: propProp(\"innerHTML\", {\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\tvar handlers = [];\n\t\t\tvar el = this;\n\t\t\t[\"change\", \"blur\"].forEach(function(eventName){\n\t\t\t\tvar localHandler = function(){\n\t\t\t\t\thandler.apply(this, arguments);\n\t\t\t\t};\n\t\t\t\tdomEvents.addEventListener(el, eventName, localHandler);\n\t\t\t\thandlers.push([eventName, localHandler]);\n\t\t\t});\n\n\t\t\treturn function(rEL){\n\t\t\t\thandlers.forEach( function(info){\n\t\t\t\t\trEL.call(el, info[0], info[1]);\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t}),\n\trequired: booleanProp(\"required\"),\n\treadonly: booleanProp(\"readOnly\"),\n\tselected: {\n\t\tget: function(){\n\t\t\treturn this.selected;\n\t\t},\n\t\tset: function(val){\n\t\t\tval = !!val;\n\t\t\tsetData.set.call(this, \"lastSetValue\", val);\n\t\t\treturn this.selected = val;\n\t\t},\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\tvar option = this;\n\t\t\tvar select = this.parentNode;\n\t\t\tvar lastVal = option.selected;\n\t\t\tvar localHandler = function(changeEvent){\n\t\t\t\tvar curVal = option.selected;\n\t\t\t\tlastVal = setData.get.call(option, \"lastSetValue\") || lastVal;\n\t\t\t\tif(curVal !== lastVal) {\n\t\t\t\t\tlastVal = curVal;\n\n\t\t\t\t\tdomEvents.dispatch(option, eventName);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar removeChangeHandler = setChildOptionsOnChange(select, aEL);\n\t\t\tdomEvents.addEventListener(select, \"change\", localHandler);\n\t\t\taEL.call(option, eventName, handler);\n\n\t\t\treturn function(rEL){\n\t\t\t\tremoveChangeHandler(rEL);\n\t\t\t\tdomEvents.removeEventListener(select, \"change\", localHandler);\n\t\t\t\trEL.call(option, eventName, handler);\n\t\t\t};\n\t\t},\n\t\ttest: function(){\n\t\t\treturn this.nodeName === \"OPTION\" && this.parentNode &&\n\t\t\t\tthis.parentNode.nodeName === \"SELECT\";\n\t\t}\n\t},\n\tstyle: {\n\t\tset: (function () {\n\t\t\tvar el = global.document && getDocument().createElement(\"div\");\n\t\t\tif ( el && el.style && (\"cssText\" in el.style) ) {\n\t\t\t\treturn function (val) {\n\t\t\t\t\treturn this.style.cssText = (val || \"\");\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn function (val) {\n\t\t\t\t\treturn domMutateNode.setAttribute.call(this, \"style\", val);\n\t\t\t\t};\n\t\t\t}\n\t\t})()\n\t},\n\ttextcontent: propProp(\"textContent\"),\n\tvalue: {\n\t\tget: function(){\n\t\t\tvar value = this.value;\n\t\t\tif(this.nodeName === \"SELECT\") {\n\t\t\t\tif((\"selectedIndex\" in this) && this.selectedIndex === -1) {\n\t\t\t\t\tvalue = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tset: function(value){\n\t\t\tvar nodeName = this.nodeName.toLowerCase();\n\t\t\tif(nodeName === \"input\") {\n\t\t\t\t// Do some input types support non string values?\n\t\t\t\tvalue = toString(value);\n\t\t\t}\n\t\t\tif(this.value !== value || nodeName === \"option\") {\n\t\t\t\tthis.value = value;\n\t\t\t}\n\t\t\tif (nodeName === \"input\" || nodeName === \"textarea\") {\n\t\t\t\tthis.defaultValue = value;\n\t\t\t}\n\t\t\tif(nodeName === \"select\") {\n\t\t\t\tsetData.set.call(this, \"attrValueLastVal\", value);\n\t\t\t\t//If it's null then special case\n\t\t\t\tsetChildOptions(this, value === null ? value : this.value);\n\n\t\t\t\t// If not in the document reset the value when inserted.\n\t\t\t\tvar docEl = this.ownerDocument.documentElement;\n\t\t\t\tif(!docEl.contains(this)) {\n\t\t\t\t\tvar select = this;\n\t\t\t\t\tvar insertionDisposal = domMutate.onNodeInsertion(select, function () {\n\t\t\t\t\t\tinsertionDisposal();\n\t\t\t\t\t\tsetChildOptions(select, value === null ? value : select.value);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// MO handler is only set up **ONCE**\n\t\t\t\tsetupMO(this, function(){\n\t\t\t\t\tvar value = setData.get.call(this, \"attrValueLastVal\");\n\t\t\t\t\tattr.set(this, \"value\", value);\n\t\t\t\t\tdomEvents.dispatch(this, \"change\");\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\ttest: function(){\n\t\t\treturn formElements[this.nodeName];\n\t\t}\n\t},\n\tvalues: {\n\t\tget: function(){\n\t\t\treturn collectSelectedOptions(this);\n\t\t},\n\t\tset: function(values){\n\t\t\tvalues = values || [];\n\n\t\t\t// set new DOM state\n\t\t\tmarkSelectedOptions(this, values);\n\n\t\t\t// store new DOM state\n\t\t\tsetData.set.call(this, \"stickyValues\", attr.get(this,\"values\") );\n\n\t\t\t// MO handler is only set up **ONCE**\n\t\t\t// TODO: should this be moved into addEventListener?\n\t\t\tsetupMO(this, function(){\n\n\t\t\t\t// Get the previous sticky state\n\t\t\t\tvar previousValues = setData.get.call(this,\n\t\t\t\t\t\"stickyValues\");\n\n\t\t\t\t// Set DOM to previous sticky state\n\t\t\t\tattr.set(this, \"values\", previousValues);\n\n\t\t\t\t// Get the new result after trying to maintain the sticky state\n\t\t\t\tvar currentValues = setData.get.call(this,\n\t\t\t\t\t\"stickyValues\");\n\n\t\t\t\t// If there are changes, trigger a `values` event.\n\t\t\t\tvar changes = diff(previousValues.slice().sort(),\n\t\t\t\t\tcurrentValues.slice().sort());\n\n\t\t\t\tif (changes.length) {\n\t\t\t\t\tdomEvents.dispatch(this, \"values\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn values;\n\t\t},\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\tvar localHandler = function(){\n\t\t\t\tdomEvents.dispatch(this, \"values\");\n\t\t\t};\n\n\t\t\tdomEvents.addEventListener(this, \"change\", localHandler);\n\t\t\taEL.call(this, eventName, handler);\n\n\t\t\treturn function(rEL){\n\t\t\t\tdomEvents.removeEventListener(this, \"change\", localHandler);\n\t\t\t\trEL.call(this, eventName, handler);\n\t\t\t};\n\t\t}\n\t}\n};\n\nvar attr = {\n\t// cached rules (stored on `attr` for testing purposes)\n\trules: behaviorRules,\n\n\t// special attribute behaviors (stored on `attr` for testing purposes)\n\tspecialAttributes: specialAttributes,\n\n\t// # attr.getRule\n\t//\n\t// get the behavior rule for an attribute or property on an element\n\t//\n\t// Rule precendence:\n\t//   1. \"special\" behaviors - use the special behavior getter/setter\n\t//   2. writable properties - read and write as a property\n\t//   3. all others - read and write as an attribute\n\t//\n\t// Once rule is determined it will be cached for all elements of the same type\n\t// so that it does not need to be calculated again\n\tgetRule: function(el, attrOrPropName) {\n\t\tvar special = specialAttributes[attrOrPropName];\n\t\t// always use \"special\" if available\n\t\t// these are not cached since they would have to be cached separately\n\t\t// for each element type and it is faster to just look up in the\n\t\t// specialAttributes object\n\t\tif (special) {\n\t\t\treturn special;\n\t\t}\n\n\t\t// next use rules cached in a previous call to getRule\n\t\tvar rulesForElementType = behaviorRules.get(el.constructor);\n\t\tvar cached = rulesForElementType && rulesForElementType[attrOrPropName];\n\n\t\tif (cached) {\n\t\t\treturn cached;\n\t\t}\n\n\t\t// if the element doesn't have a property of this name, it must be an attribute\n\t\tif (!(attrOrPropName in el)) {\n\t\t\treturn this.attribute(attrOrPropName);\n\t\t}\n\n\t\t// if there is a property, check if it is writable\n\t\tvar newRule = isPropWritable(el, attrOrPropName) ?\n\t\t\tthis.property(attrOrPropName) :\n\t\t\tthis.attribute(attrOrPropName);\n\n\t\t// cache the new rule and return it\n\t\treturn cacheRule(el, attrOrPropName, newRule);\n\t},\n\n\tattribute: function(attrName) {\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\treturn this.getAttribute(attrName);\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\tdomMutateNode.setAttribute.call(this, attrName, val);\n\t\t\t}\n\t\t};\n\t},\n\n\tproperty: function(propName) {\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\treturn this[propName];\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\tthis[propName] = val;\n\t\t\t}\n\t\t};\n\t},\n\n\tfindSpecialListener: function(attributeName) {\n\t\treturn specialAttributes[attributeName] && specialAttributes[attributeName].addEventListener;\n\t},\n\n\tsetAttrOrProp: function(el, attrName, val){\n\t\treturn this.set(el, attrName, val);\n\t},\n\t// ## attr.set\n\t// Set the value an attribute on an element.\n\tset: function (el, attrName, val) {\n\t\tvar rule = this.getRule(el, attrName);\n\t\tvar setter = rule && rule.set;\n\n\t\tif (setter) {\n\t\t\treturn setter.call(el, val);\n\t\t}\n\t},\n\t// ## attr.get\n\t// Gets the value of an attribute or property.\n\t// First checks if the property is an `specialAttributes` and if so calls the special getter.\n\t// Then checks if the attribute or property is a property on the element.\n\t// Otherwise uses `getAttribute` to retrieve the value.\n\tget: function (el, attrName) {\n\t\tvar rule = this.getRule(el, attrName);\n\t\tvar getter = rule && rule.get;\n\n\t\tif (getter) {\n\t\t\treturn rule.test ?\n\t\t\t\trule.test.call(el) && getter.call(el) :\n\t\t\t\tgetter.call(el);\n\t\t}\n\t},\n\t// ## attr.remove\n\t// Removes an attribute from an element. First checks specialAttributes to see if the attribute is special and has a setter. If so calls the setter with `undefined`. Otherwise `removeAttribute` is used.\n\t// If the attribute previously had a value and the browser doesn't support MutationObservers we then trigger an \"attributes\" event.\n\tremove: function (el, attrName) {\n\t\tattrName = attrName.toLowerCase();\n\t\tvar special = specialAttributes[attrName];\n\t\tvar setter = special && special.set;\n\t\tvar remover = special && special.remove;\n\t\tvar test = getSpecialTest(special);\n\n\t\tif(typeof remover === \"function\" && test.call(el)) {\n\t\t\tremover.call(el);\n\t\t} else if(typeof setter === \"function\" && test.call(el)) {\n\t\t\tsetter.call(el, undefined);\n\t\t} else {\n\t\t\tdomMutateNode.removeAttribute.call(el, attrName);\n\t\t}\n\t}\n};\n\nmodule.exports = attr;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-attribute-observable/behaviors.js?");

/***/ }),

/***/ "../../node_modules/can-attribute-observable/can-attribute-observable.js":
/*!**********************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-attribute-observable/can-attribute-observable.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar canEvent = __webpack_require__(/*! ./event */ \"../../node_modules/can-attribute-observable/event.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar attr = __webpack_require__(/*! ./behaviors */ \"../../node_modules/can-attribute-observable/behaviors.js\");\nvar getEventName = __webpack_require__(/*! ./get-event-name */ \"../../node_modules/can-attribute-observable/get-event-name.js\");\nvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"../../node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ \"../../node_modules/can-simple-observable/settable/settable.js\");\n\n// We register a namespaced radiochange event with the global\n// event registry so it does not interfere with user-defined events.\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"../../node_modules/can-dom-events/can-dom-events.js\");\nvar radioChangeEvent = __webpack_require__(/*! can-event-dom-radiochange */ \"../../node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js\");\nvar internalRadioChangeEventType = \"can-attribute-observable-radiochange\";\ndomEvents.addEvent(radioChangeEvent, internalRadioChangeEventType);\n\nvar isSelect = function isSelect(el) {\n\treturn el.nodeName.toLowerCase() === \"select\";\n};\n\nvar isMultipleSelect = function isMultipleSelect(el, prop) {\n\treturn isSelect(el) && prop === \"value\" && el.multiple;\n};\n\nvar slice = Array.prototype.slice;\n\nfunction canUtilAEL () {\n\tvar args = slice.call(arguments, 0);\n\targs.unshift(this);\n\treturn domEvents.addEventListener.apply(null, args);\n}\n\nfunction canUtilREL () {\n\tvar args = slice.call(arguments, 0);\n\targs.unshift(this);\n\treturn domEvents.removeEventListener.apply(null, args);\n}\n\nfunction AttributeObservable(el, prop, bindingData, event) {\n\tthis.el = el;\n\tthis.bound = false;\n\tthis.bindingData = bindingData;\n\tthis.prop = isMultipleSelect(el, prop) ? \"values\" : prop;\n\tthis.event = event || getEventName(el, prop, bindingData);\n\tthis.handler = this.handler.bind(this);\n\n\t//!steal-remove-start\n\tif(true) {\n\t\t// register what changes the element's attribute\n\t\tcanReflectDeps.addMutatedBy(this.el, this.prop, this);\n\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function getName() {\n\t\t\t\treturn (\n\t\t\t\t\t\"AttributeObservable<\" +\n\t\t\t\t\tel.nodeName.toLowerCase() +\n\t\t\t\t\t\".\" +\n\t\t\t\t\tthis.prop +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\t//!steal-remove-end\n}\n\nAttributeObservable.prototype = Object.create(SettableObservable.prototype);\n\nObject.assign(AttributeObservable.prototype, {\n\tconstructor: AttributeObservable,\n\n\tget: function get() {\n\t\tif (ObservationRecorder.isRecording()) {\n\t\t\tObservationRecorder.add(this);\n\t\t\tif (!this.bound) {\n\t\t\t\tObservation.temporarilyBind(this);\n\t\t\t}\n\t\t}\n\t\treturn attr.get(this.el, this.prop);\n\t},\n\n\tset: function set(newVal) {\n\t\tattr.setAttrOrProp(this.el, this.prop, newVal);\n\n\t\t// update the observation internal value\n\t\tthis.value = newVal;\n\n\t\treturn newVal;\n\t},\n\n\thandler: function handler(newVal, event) {\n\t\tvar old = this.value;\n\t\tvar queuesArgs = [];\n\t\tthis.value = attr.get(this.el, this.prop);\n\n\t\tif (this.value !== old) {\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\t\tthis._log(old, newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t\n\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.handlers.getNode([]),\n  \t\t\tthis,\n  \t\t\t[newVal, old]\n  \t\t];\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tqueuesArgs = [\n\t\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\t\tthis,\n\t\t\t\t\t[newVal, old]\n\t\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t\t,null\n\t\t\t\t\t,[this.el,this.prop,\"changed to\", newVal, \"from\", old, \"by\", event]\n\t\t\t\t\t/* jshint laxcomma: false */\n\t\t\t\t];\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t// adds callback handlers to be called w/i their respective queue.\n\t\t\tqueues.enqueueByQueue.apply(queues, queuesArgs);\n\t\t}\n\t},\n\n\tonBound: function onBound() {\n\t\tvar observable = this;\n\n\t\tobservable.bound = true;\n\n\t\t// make sure `this.handler` gets the new value instead of\n\t\t// the event object passed to the event handler\n\t\tobservable._handler = function(event) {\n\t\t\tobservable.handler(attr.get(observable.el, observable.prop), event);\n\t\t};\n\n\t\tif (observable.event === internalRadioChangeEventType) {\n\t\t\tcanEvent.on.call(observable.el, \"change\", observable._handler);\n\t\t}\n\n\t\tvar specialBinding = attr.findSpecialListener(observable.prop);\n\t\tif (specialBinding) {\n\t\t\tobservable._specialDisposal = specialBinding.call(observable.el, observable.prop, observable._handler, canUtilAEL);\n\t\t}\n\n\t\tcanEvent.on.call(observable.el, observable.event, observable._handler);\n\n\t\t// initial value\n\t\tthis.value = attr.get(this.el, this.prop);\n\t},\n\n\tonUnbound: function onUnbound() {\n\t\tvar observable = this;\n\n\t\tobservable.bound = false;\n\n\t\tif (observable.event === internalRadioChangeEventType) {\n\t\t\tcanEvent.off.call(observable.el, \"change\", observable._handler);\n\t\t}\n\n\t\tif (observable._specialDisposal) {\n\t\t\tobservable._specialDisposal.call(observable.el, canUtilREL);\n\t\t\tobservable._specialDisposal = null;\n\t\t}\n\n\t\tcanEvent.off.call(observable.el, observable.event, observable._handler);\n\t},\n\n\tvalueHasDependencies: function valueHasDependencies() {\n\t\treturn true;\n\t},\n\n\tgetValueDependencies: function getValueDependencies() {\n\t\treturn {\n\t\t\tkeyDependencies: new Map([[this.el, new Set([this.prop])]])\n\t\t};\n\t}\n});\n\ncanReflect.assignSymbols(AttributeObservable.prototype, {\n\t\"can.isMapLike\": false,\n\t\"can.getValue\": AttributeObservable.prototype.get,\n\t\"can.setValue\": AttributeObservable.prototype.set,\n\t\"can.onValue\": AttributeObservable.prototype.on,\n\t\"can.offValue\": AttributeObservable.prototype.off,\n\t\"can.valueHasDependencies\": AttributeObservable.prototype.hasDependencies,\n\t\"can.getValueDependencies\": AttributeObservable.prototype.getValueDependencies\n});\n\nmodule.exports = AttributeObservable;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-attribute-observable/can-attribute-observable.js?");

/***/ }),

/***/ "../../node_modules/can-attribute-observable/event.js":
/*!***************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-attribute-observable/event.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"../../node_modules/can-dom-events/can-dom-events.js\");\nvar isDomEventTarget = __webpack_require__(/*! can-dom-events/helpers/util */ \"../../node_modules/can-dom-events/helpers/util.js\").isDomEventTarget;\n\nvar canEvent = {\n\ton: function on(eventName, handler, queue) {\n\t\tif (isDomEventTarget(this)) {\n\t\t\tdomEvents.addEventListener(this, eventName, handler, queue);\n\t\t} else {\n\t\t\tcanReflect.onKeyValue(this, eventName, handler, queue);\n\t\t}\n\t},\n\toff: function off(eventName, handler, queue) {\n\t\tif (isDomEventTarget(this)) {\n\t\t\tdomEvents.removeEventListener(this, eventName, handler, queue);\n\t\t} else {\n\t\t\tcanReflect.offKeyValue(this, eventName, handler, queue);\n\t\t}\n\t},\n\tone: function one(event, handler, queue) {\n\t\t// Unbind the listener after it has been executed\n\t\tvar one = function() {\n\t\t\tcanEvent.off.call(this, event, one, queue);\n\t\t\treturn handler.apply(this, arguments);\n\t\t};\n\n\t\t// Bind the altered listener\n\t\tcanEvent.on.call(this, event, one, queue);\n\t\treturn this;\n\t}\n};\n\nmodule.exports = canEvent;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-attribute-observable/event.js?");

/***/ }),

/***/ "../../node_modules/can-attribute-observable/get-event-name.js":
/*!************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-attribute-observable/get-event-name.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar attr = __webpack_require__(/*! ./behaviors */ \"../../node_modules/can-attribute-observable/behaviors.js\");\n\nvar isRadioInput = function isRadioInput(el) {\n\treturn el.nodeName.toLowerCase() === \"input\" && el.type === \"radio\";\n};\n\nvar isValidProp = function isValidProp(prop, bindingData) {\n\treturn prop === \"checked\" && !bindingData.legacyBindings;\n};\n\n// Determine the event or events we need to listen to when this value changes.\nmodule.exports = function getEventName(el, prop, bindingData) {\n\tvar event = \"change\";\n\n\tif (isRadioInput(el) && isValidProp(prop, bindingData)) {\n\t\tevent = \"can-attribute-observable-radiochange\";\n\t}\n\n\tif (attr.findSpecialListener(prop)) {\n\t\tevent = prop;\n\t}\n\n\treturn event;\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-attribute-observable/get-event-name.js?");

/***/ }),

/***/ "../../node_modules/can-bind/can-bind.js":
/*!**************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-bind/can-bind.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\n\n//!steal-remove-start\nif(true) {\n\tvar canLog = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\n\tvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"../../node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\n}\n//!steal-remove-end\n\n// Symbols\nvar getChangesSymbol = canSymbol.for(\"can.getChangesDependencyRecord\");\nvar getValueSymbol = canSymbol.for(\"can.getValue\");\nvar onValueSymbol = canSymbol.for(\"can.onValue\");\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\n\n// Default implementations for setting the child and parent values\nfunction defaultSetValue(newValue, observable) {\n\tcanReflect.setValue(observable, newValue);\n}\n\n// Given an observable, stop listening to it and tear down the mutation dependencies\nfunction turnOffListeningAndUpdate(listenToObservable, updateObservable, updateFunction, queue) {\n\tif (listenToObservable[onValueSymbol]) {\n\t\tcanReflect.offValue(listenToObservable, updateFunction, queue);\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\n\t\t\t// The updateObservable is no longer mutated by listenToObservable\n\t\t\tcanReflectDeps.deleteMutatedBy(updateObservable, listenToObservable);\n\n\t\t\t// The updateFunction no longer mutates anything\n\t\t\tupdateFunction[getChangesSymbol] = function getChangesDependencyRecord() {\n\t\t\t};\n\n\t\t}\n\t\t//!steal-remove-end\n\t}\n}\n\n// Given an observable, start listening to it and set up the mutation dependencies\nfunction turnOnListeningAndUpdate(listenToObservable, updateObservable, updateFunction, queue) {\n\tif (listenToObservable[onValueSymbol]) {\n\t\tcanReflect.onValue(listenToObservable, updateFunction, queue);\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\n\t\t\t// The updateObservable is mutated by listenToObservable\n\t\t\tcanReflectDeps.addMutatedBy(updateObservable, listenToObservable);\n\n\t\t\t// The updateFunction mutates updateObservable\n\t\t\tupdateFunction[getChangesSymbol] = function getChangesDependencyRecord() {\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: new Set([updateObservable])\n\t\t\t\t};\n\t\t\t};\n\n\t\t}\n\n\t\t//!steal-remove-end\n\t}\n}\n\n// Semaphores are used to keep track of updates to the child & parent\nfunction Semaphore() {\n\tthis.value = 0;\n}\nObject.assign(Semaphore.prototype, {\n\tdecrement: function() {\n\t\tthis.value -= 1;\n\t},\n\tincrement: function() {\n\t\tthis.value += 1;\n\t}\n});\n\nfunction Bind(options) {\n\tthis._options = options;\n\n\t// These parameters must be supplied\n\t//!steal-remove-start\n\tif(true) {\n\t\tif (options.child === undefined) {\n\t\t\tthrow new TypeError(\"You must supply a child\");\n\t\t}\n\t\tif (options.parent === undefined) {\n\t\t\tthrow new TypeError(\"You must supply a parent\");\n\t\t}\n\t\tif (options.queue && [\"notify\", \"derive\", \"domUI\"].indexOf(options.queue) === -1) {\n\t\t\tthrow new RangeError(\"Invalid queue; must be one of notify, derive, or domUI\");\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// queue; by default, domUI\n\tif (options.queue === undefined) {\n\t\toptions.queue = \"domUI\";\n\t}\n\n\t// cycles: when an observable is set in a two-way binding, it can update the\n\t// other bound observable, which can then update the original observable the\n\t// “cycles” number of times. For example, a child is set and updates the parent;\n\t// with cycles: 0, the parent could not update the child;\n\t// with cycles: 1, the parent could update the child, which can update the parent\n\t// with cycles: 2, the parent can update the child again, and so on and so forth…\n\tif (options.cycles > 0 === false) {\n\t\toptions.cycles = 0;\n\t}\n\n\t// onInitDoNotUpdateChild is false by default\n\toptions.onInitDoNotUpdateChild =\n\t\ttypeof options.onInitDoNotUpdateChild === \"boolean\" ?\n\t\t\toptions.onInitDoNotUpdateChild\n\t\t\t: false;\n\n\t// onInitSetUndefinedParentIfChildIsDefined is true by default\n\toptions.onInitSetUndefinedParentIfChildIsDefined =\n\t\ttypeof options.onInitSetUndefinedParentIfChildIsDefined === \"boolean\" ?\n\t\t\toptions.onInitSetUndefinedParentIfChildIsDefined\n\t\t\t: true;\n\n\t// The way the cycles are tracked is through semaphores; currently, when\n\t// either the child or parent is updated, we increase their respective\n\t// semaphore so that if it’s two-way binding, then the “other” observable\n\t// will only update if the total count for both semaphores is less than or\n\t// equal to twice the number of cycles (because a cycle means two updates).\n\tvar childSemaphore = new Semaphore();\n\tvar parentSemaphore = new Semaphore();\n\n\t// Determine if this is a one-way or two-way binding; by default, accept\n\t// whatever options are passed in, but if they’re not defined, then check for\n\t// the getValue and setValue symbols on the child and parent values.\n\tvar childToParent = true;\n\tif (typeof options.childToParent === \"boolean\") {\n\t\t// Always let the option override any checks\n\t\tchildToParent = options.childToParent;\n\t} else if (options.child[getValueSymbol] == null) {\n\t\t// Child to parent won’t work if we can’t get the child’s value\n\t\tchildToParent = false;\n\t} else if (options.setParent === undefined && options.parent[setValueSymbol] == null) {\n\t\t// Child to parent won’t work if we can’t set the parent’s value\n\t\tchildToParent = false;\n\t}\n\tvar parentToChild = true;\n\tif (typeof options.parentToChild === \"boolean\") {\n\t\t// Always let the option override any checks\n\t\tparentToChild = options.parentToChild;\n\t} else if (options.parent[getValueSymbol] == null) {\n\t\t// Parent to child won’t work if we can’t get the parent’s value\n\t\tparentToChild = false;\n\t} else if (options.setChild === undefined && options.child[setValueSymbol] == null) {\n\t\t// Parent to child won’t work if we can’t set the child’s value\n\t\tparentToChild = false;\n\t}\n\tif (childToParent === false && parentToChild === false) {\n\t\tthrow new Error(\"Neither the child nor parent will be updated; this is a no-way binding\");\n\t}\n\tthis._childToParent = childToParent;\n\tthis._parentToChild = parentToChild;\n\n\t// Custom child & parent setters can be supplied; if they aren’t provided,\n\t// then create our own.\n\tif (options.setChild === undefined) {\n\t\toptions.setChild = defaultSetValue;\n\t}\n\tif (options.setParent === undefined) {\n\t\toptions.setParent = defaultSetValue;\n\t}\n\n\t// Set the observables’ priority\n\tif (options.priority !== undefined) {\n\t\tcanReflect.setPriority(options.child, options.priority);\n\t\tcanReflect.setPriority(options.parent, options.priority);\n\t}\n\n\t// These variables keep track of how many updates are allowed in a cycle.\n\t// cycles is multipled by two because one update is allowed for each side of\n\t// the binding, child and parent. One more update is allowed depending on the\n\t// sticky option; if it’s sticky, then one more update needs to be allowed.\n\tvar allowedUpdates = options.cycles * 2;\n\tvar allowedChildUpdates = allowedUpdates + (options.sticky === \"childSticksToParent\" ? 1 : 0);\n\tvar allowedParentUpdates = allowedUpdates + (options.sticky === \"parentSticksToChild\" ? 1 : 0);\n\n\t// This keeps track of whether we’re bound to the child and/or parent; this\n\t// allows startParent() to be called first and on() can be called later to\n\t// finish setting up the child binding. This is also checked when updating\n\t// values; if stop() has been called but updateValue() is called, then we\n\t// ignore the update.\n\tvar bindingState = this._bindingState = {\n\t\tchild: false,\n\t\tparent: false\n\t};\n\n\t// This is the listener that’s called when the parent changes\n\tthis._updateChild = function(newValue) {\n\t\tupdateValue({\n\t\t\tbindingState: bindingState,\n\t\t\tnewValue: newValue,\n\n\t\t\t// Some options used for debugging\n\t\t\tdebugObservableName: \"child\",\n\t\t\tdebugPartnerName: \"parent\",\n\n\t\t\t// Main observable values\n\t\t\tobservable: options.child,\n\t\t\tsetValue: options.setChild,\n\t\t\tsemaphore: childSemaphore,\n\n\t\t\t// If the sum of the semaphores is less than or equal to this number, then\n\t\t\t// it’s ok to update the child with the new value.\n\t\t\tallowedUpdates: allowedChildUpdates,\n\n\t\t\t// If options.sticky === \"parentSticksToChild\", then after the parent sets\n\t\t\t// the child, check to see if the child matches the parent; if not, then\n\t\t\t// set the parent to the child’s value. This is used in cases where the\n\t\t\t// child modifies its own value and the parent should be kept in sync with\n\t\t\t// the child.\n\t\t\tsticky: options.sticky === \"parentSticksToChild\",\n\n\t\t\t// Partner observable values\n\t\t\tpartner: options.parent,\n\t\t\tsetPartner: options.setParent,\n\t\t\tpartnerSemaphore: parentSemaphore\n\t\t});\n\t};\n\n\t// This is the listener that’s called when the child changes\n\tthis._updateParent = function(newValue) {\n\t\tupdateValue({\n\t\t\tbindingState: bindingState,\n\t\t\tnewValue: newValue,\n\n\t\t\t// Some options used for debugging\n\t\t\tdebugObservableName: \"parent\",\n\t\t\tdebugPartnerName: \"child\",\n\n\t\t\t// Main observable values\n\t\t\tobservable: options.parent,\n\t\t\tsetValue: options.setParent,\n\t\t\tsemaphore: parentSemaphore,\n\n\t\t\t// If the sum of the semaphores is less than or equal to this number, then\n\t\t\t// it’s ok to update the parent with the new value.\n\t\t\tallowedUpdates: allowedParentUpdates,\n\n\t\t\t// If options.sticky === \"childSticksToParent\", then after the child sets\n\t\t\t// the parent, check to see if the parent matches the child; if not, then\n\t\t\t// set the child to the parent’s value. This is used in cases where the\n\t\t\t// parent modifies its own value and the child should be kept in sync with\n\t\t\t// the parent.\n\t\t\tsticky: options.sticky === \"childSticksToParent\",\n\n\t\t\t// Partner observable values\n\t\t\tpartner: options.child,\n\t\t\tsetPartner: options.setChild,\n\t\t\tpartnerSemaphore: childSemaphore\n\t\t});\n\t};\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tif (options.updateChildName) {\n\t\t\tObject.defineProperty(this._updateChild, \"name\", {\n\t\t\t\tvalue: options.updateChildName\n\t\t\t});\n\t\t}\n\t\tif (options.updateParentName) {\n\t\t\tObject.defineProperty(this._updateParent, \"name\", {\n\t\t\t\tvalue: options.updateParentName\n\t\t\t});\n\t\t}\n\t}\n\t//!steal-remove-end\n\n}\n\nObject.defineProperty(Bind.prototype, \"parentValue\", {\n\tget: function() {\n\t\treturn canReflect.getValue(this._options.parent);\n\t}\n});\n\nObject.assign(Bind.prototype, {\n\n\t// Turn on any bindings that haven’t already been enabled;\n\t// also update the child or parent if need be.\n\tstart: function() {\n\t\tvar childValue;\n\t\tvar options = this._options;\n\t\tvar parentValue;\n\n\t\t// The tests don’t show that it matters which is bound first, but we’ll\n\t\t// bind to the parent first to stay consistent with how\n\t\t// can-stache-bindings did things.\n\t\tthis.startParent();\n\t\tthis.startChild();\n\n\t\t// Initialize the child & parent values\n\t\tif (this._childToParent === true && this._parentToChild === true) {\n\t\t\t// Two-way binding\n\t\t\tparentValue = canReflect.getValue(options.parent);\n\t\t\tif (parentValue === undefined) {\n\t\t\t\tchildValue = canReflect.getValue(options.child);\n\t\t\t\tif (childValue === undefined) {\n\t\t\t\t\t// Check if updating the child is allowed\n\t\t\t\t\tif (options.onInitDoNotUpdateChild === false) {\n\t\t\t\t\t\tthis._updateChild(parentValue);\n\t\t\t\t\t}\n\t\t\t\t} else if (options.onInitSetUndefinedParentIfChildIsDefined === true) {\n\t\t\t\t\tthis._updateParent(childValue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Check if updating the child is allowed\n\t\t\t\tif (options.onInitDoNotUpdateChild === false) {\n\t\t\t\t\tthis._updateChild(parentValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else if (this._childToParent === true) {\n\t\t\t// One-way child -> parent, so update the parent\n\t\t\tchildValue = canReflect.getValue(options.child);\n\t\t\tthis._updateParent(childValue);\n\n\t\t} else if (this._parentToChild === true) {\n\t\t\t// One-way parent -> child, so update the child\n\t\t\t// Check if updating the child is allowed\n\t\t\tif (options.onInitDoNotUpdateChild === false) {\n\t\t\t\tparentValue = canReflect.getValue(options.parent);\n\t\t\t\tthis._updateChild(parentValue);\n\t\t\t}\n\t\t}\n\t},\n\n\t// Listen for changes to the child observable and update the parent\n\tstartChild: function() {\n\t\tif (this._bindingState.child === false && this._childToParent === true) {\n\t\t\tvar options = this._options;\n\t\t\tthis._bindingState.child = true;\n\t\t\tturnOnListeningAndUpdate(options.child, options.parent, this._updateParent, options.queue);\n\t\t}\n\t},\n\n\t// Listen for changes to the parent observable and update the child\n\tstartParent: function() {\n\t\tif (this._bindingState.parent === false && this._parentToChild === true) {\n\t\t\tvar options = this._options;\n\t\t\tthis._bindingState.parent = true;\n\t\t\tturnOnListeningAndUpdate(options.parent, options.child, this._updateChild, options.queue);\n\t\t}\n\t},\n\n\t// Turn off all the bindings\n\tstop: function() {\n\t\tvar bindingState = this._bindingState;\n\t\tvar options = this._options;\n\n\t\t// Turn off the parent listener\n\t\tif (bindingState.parent === true && this._parentToChild === true) {\n\t\t\tbindingState.parent = false;\n\t\t\tturnOffListeningAndUpdate(options.parent, options.child, this._updateChild, options.queue);\n\t\t}\n\n\t\t// Turn off the child listener\n\t\tif (bindingState.child === true && this._childToParent === true) {\n\t\t\tbindingState.child = false;\n\t\t\tturnOffListeningAndUpdate(options.child, options.parent, this._updateParent, options.queue);\n\t\t}\n\t}\n\n});\n\n// updateValue is a helper function that’s used by updateChild and updateParent\nfunction updateValue(args) {\n\n\t// Check to see whether the binding is active; ignore updates if it isn’t active\n\tvar bindingState = args.bindingState;\n\tif (bindingState.child === false && bindingState.parent === false) {\n\t\t// We don’t warn the user about this because it’s a common occurrence in\n\t\t// can-stache-bindings, e.g. {{#if value}}<input value:bind=\"value\"/>{{/if}}\n\t\treturn;\n\t}\n\n\t// Now check the semaphore; if this change is happening because the partner\n\t// observable was just updated, we only want to update this observable again\n\t// if the total count for both semaphores is less than or equal to the number\n\t// of allowed updates.\n\tvar semaphore = args.semaphore;\n\tif ((semaphore.value + args.partnerSemaphore.value) <= args.allowedUpdates) {\n\t\tqueues.batch.start();\n\n\t\t// Update the observable’s value; this uses either a custom function passed\n\t\t// in when the binding was initialized or canReflect.setValue.\n\t\targs.setValue(args.newValue, args.observable);\n\n\t\t// Increase the semaphore so that when the batch ends, if an update to the\n\t\t// partner observable’s value is made, then it won’t update this observable\n\t\t// again unless cycles are allowed.\n\t\tsemaphore.increment();\n\n\t\t// Decrease the semaphore after all other updates have occurred\n\t\tqueues.mutateQueue.enqueue(semaphore.decrement, semaphore, []);\n\n\t\tqueues.batch.stop();\n\n\t\t// Stickiness is used in cases where the call to args.setValue above might\n\t\t// have resulted in the observable being set to a different value than what\n\t\t// was passed into this function (args.newValue). If sticky:true, then set\n\t\t// the partner observable’s value so they’re kept in sync.\n\t\tif (args.sticky) {\n\t\t\tvar observableValue = canReflect.getValue(args.observable);\n\t\t\tif (observableValue !== canReflect.getValue(args.partner)) {\n\t\t\t\targs.setPartner(observableValue, args.partner);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t// It’s natural for this “else” block to be hit in two-way bindings; as an\n\t\t// example, if a parent gets set and the child gets updated, the child’s\n\t\t// listener to update the parent will be called, but it’ll be ignored if we\n\t\t// don’t want cycles. HOWEVER, if this gets called and the parent is not the\n\t\t// same value as the child, then their values are going to be out of sync,\n\t\t// probably unintentionally. This is worth pointing out to developers\n\t\t// because it can cause unexpected behavior… some people call those bugs. :)\n\n\t\t//!steal-remove-start\n\t\tif(true){\n\t\t\tvar currentValue = canReflect.getValue(args.observable);\n\t\t\tif (currentValue !== args.newValue) {\n\t\t\t\tvar warningParts = [\n\t\t\t\t\t\"can-bind updateValue: attempting to update \" + args.debugObservableName + \" \" + canReflect.getName(args.observable) + \" to new value: %o\",\n\t\t\t\t\t\"…but the \" + args.debugObservableName + \" semaphore is at \" + semaphore.value + \" and the \" + args.debugPartnerName + \" semaphore is at \" + args.partnerSemaphore.value + \". The number of allowed updates is \" + args.allowedUpdates + \".\",\n\t\t\t\t\t\"The \" + args.debugObservableName + \" value will remain unchanged; it’s currently: %o\"\n\t\t\t\t];\n\t\t\t\tcanLog.warn(warningParts.join(\"\\n\"), args.newValue, currentValue);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t}\n}\n\nmodule.exports = namespace.Bind = Bind;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-bind/can-bind.js?");

/***/ }),

/***/ "../../node_modules/can-child-nodes/can-child-nodes.js":
/*!****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-child-nodes/can-child-nodes.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\n\n/**\n * @module {function} can-child-nodes\n * @parent can-dom-utilities\n * @collection can-infrastructure\n * \n * @signature `childNodes(node)`\n *\n * Get all of the childNodes of a given node.\n *\n * ```js\n * var stache = require(\"can-stache\");\n * var childNodes = require(\"can-util/child-nodes/child-nodes\");\n *\n * var html = \"<div><h1><span></span></h1></div>\";\n * var frag = stache(html)();\n *\n * console.log(childNodes(frag)[0].nodeName); // -> DIV\n * ```\n *\n * @param {Object} node The Node that you want child nodes for.\n */\n\nfunction childNodes(node) {\n\tvar childNodes = node.childNodes;\n\tif (\"length\" in childNodes) {\n\t\treturn childNodes;\n\t} else {\n\t\tvar cur = node.firstChild;\n\t\tvar nodes = [];\n\t\twhile (cur) {\n\t\t\tnodes.push(cur);\n\t\t\tcur = cur.nextSibling;\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\nmodule.exports = namespace.childNodes = childNodes;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-child-nodes/can-child-nodes.js?");

/***/ }),

/***/ "../../node_modules/can-cid/can-cid.js":
/*!************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-cid/can-cid.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\n/**\n * @module {function} can-cid\n * @parent can-typed-data\n * @collection can-infrastructure\n * @package ./package.json\n * @description Utility for getting a unique identifier for an object.\n * @signature `cid(object, optionalObjectType)`\n *\n * Get a unique identifier for the object, optionally prefixed by a type name.\n *\n * Once set, the unique identifier does not change, even if the type name\n * changes on subsequent calls.\n *\n * ```js\n * var cid = require(\"can-cid\");\n * var x = {};\n * var y = {};\n *\n * console.log(cid(x, \"demo\")); // -> \"demo1\"\n * console.log(cid(x, \"prod\")); // -> \"demo1\"\n * console.log(cid(y));         // -> \"2\"\n * ```\n *\n * @param {Object} object The object to uniquely identify.\n * @param {String} name   An optional type name with which to prefix the identifier\n *\n * @return {String} Returns the unique identifier\n */\nvar _cid = 0;\n// DOM nodes shouldn't all use the same property\nvar domExpando = \"can\" + new Date();\nvar cid = function (object, name) {\n\tvar propertyName = object.nodeName ? domExpando : \"_cid\";\n\n\tif (!object[propertyName]) {\n\t\t_cid++;\n\t\tobject[propertyName] = (name || '') + _cid;\n\t}\n\treturn object[propertyName];\n};\ncid.domExpando = domExpando;\ncid.get = function(object){\n\tvar type = typeof object;\n\tvar isObject = type !== null && (type === \"object\" || type === \"function\");\n\treturn isObject ? cid(object) : (type + \":\" + object);\n};\n\nif (namespace.cid) {\n\tthrow new Error(\"You can't have two versions of can-cid, check your dependencies\");\n} else {\n\tmodule.exports = namespace.cid = cid;\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-cid/can-cid.js?");

/***/ }),

/***/ "../../node_modules/can-component/can-component.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-component/can-component.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint -W079 */\n// # can/component/component.js\n//\n// This implements the `Component` which allows you to create widgets\n// that use a view, a view-model, and custom tags.\n//\n// `Component` implements most of it's functionality in the `Component.setup`\n// and the `Component.prototype.setup` functions.\n//\n// `Component.setup` prepares everything needed by the `Component.prototype.setup`\n// to hookup the component.\nvar ComponentControl = __webpack_require__(/*! ./control/control */ \"../../node_modules/can-component/control/control.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\n\nvar Bind = __webpack_require__(/*! can-bind */ \"../../node_modules/can-bind/can-bind.js\");\nvar Construct = __webpack_require__(/*! can-construct */ \"../../node_modules/can-construct/can-construct.js\");\nvar stache = __webpack_require__(/*! can-stache */ \"../../node_modules/can-stache/can-stache.js\");\nvar stacheBindings = __webpack_require__(/*! can-stache-bindings */ \"../../node_modules/can-stache-bindings/can-stache-bindings.js\");\nvar Scope = __webpack_require__(/*! can-view-scope */ \"../../node_modules/can-view-scope/can-view-scope.js\");\nvar viewCallbacks = __webpack_require__(/*! can-view-callbacks */ \"../../node_modules/can-view-callbacks/can-view-callbacks.js\");\nvar nodeLists = __webpack_require__(/*! can-view-nodelist */ \"../../node_modules/can-view-nodelist/can-view-nodelist.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar observeReader = __webpack_require__(/*! can-stache-key */ \"../../node_modules/can-stache-key/can-stache-key.js\");\nvar SettableObservable = __webpack_require__(/*! can-simple-observable/setter/setter */ \"../../node_modules/can-simple-observable/setter/setter.js\");\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"../../node_modules/can-simple-observable/can-simple-observable.js\");\nvar SimpleMap = __webpack_require__(/*! can-simple-map */ \"../../node_modules/can-simple-map/can-simple-map.js\");\nvar DefineMap = __webpack_require__(/*! can-define/map/map */ \"../../node_modules/can-define/map/map.js\");\nvar canLog = __webpack_require__(/*! can-log */ \"../../node_modules/can-log/dist/cjs/can-log.js\");\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\n__webpack_require__(/*! can-view-model */ \"../../node_modules/can-view-model/can-view-model.js\");\n\n// DefineList must be imported so Arrays on the ViewModel\n// will be converted to DefineLists automatically\n__webpack_require__(/*! can-define/list/list */ \"../../node_modules/can-define/list/list.js\");\n\nvar domData = __webpack_require__(/*! can-dom-data-state */ \"../../node_modules/can-dom-data-state/can-dom-data-state.js\");\nvar getChildNodes = __webpack_require__(/*! can-child-nodes */ \"../../node_modules/can-child-nodes/can-child-nodes.js\");\nvar string = __webpack_require__(/*! can-string */ \"../../node_modules/can-string/can-string.js\");\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"../../node_modules/can-dom-events/can-dom-events.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"../../node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"../../node_modules/can-dom-mutate/node.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar DOCUMENT = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\n\n// Symbols\nvar createdByCanComponentSymbol = canSymbol(\"can.createdByCanComponent\");\nvar getValueSymbol = canSymbol.for(\"can.getValue\");\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\nvar viewInsertSymbol = canSymbol.for(\"can.viewInsert\");\nvar viewModelSymbol = canSymbol.for('can.viewModel');\n\nstache.addBindings(stacheBindings);\n\n// For insertion elements like <can-slot> and <context>, this will add\n// a compute viewModel to the top of the context if\n// a binding like {this}=\"value\" is present.\n// - el - the insertion element\n// - tagData - the tagData the insertion element will be rendered with\n// - insertionElementTagData - the tagData found at the insertion element\n// `returns` - the tagData the template should be rendered with.\nfunction addContext(el, tagData, insertionElementTagData) {\n\tvar vm;\n\n\tdomData.set.call(el, \"preventDataBindings\", true);\n\n\t// insertionElementTagData is where the <content> element is in the shadow dom\n\t// it should be used for bindings\n\tvar teardown = stacheBindings.behaviors.viewModel(el, insertionElementTagData, function(initialData) {\n\t\t// Create a compute responsible for keeping the vm up-to-date\n\t\treturn vm = new SimpleObservable(initialData);\n\t}, undefined, true);\n\n\n\tif(!teardown) {\n\t\t// if no teardown, there's no bindings, no need to change the scope\n\t\treturn tagData;\n\t} else {\n\t\treturn assign( assign({}, tagData), {\n\t\t\tteardown: teardown,\n\t\t\tscope: tagData.scope.add(vm)\n\t\t});\n\t}\n\n}\n\n// Returns a hookupFuction that gets the proper tagData in a template, renders it, and adds it to nodeLists\nfunction makeInsertionTagCallback(tagName, componentTagData, shadowTagData, leakScope, getPrimaryTemplate) {\n\tvar options = shadowTagData.options;\n\n\treturn function hookupFunction(el, insertionElementTagData) {\n\t\tvar template = getPrimaryTemplate(el) || insertionElementTagData.subtemplate,\n\t\t\trenderingLightContent = template !== insertionElementTagData.subtemplate;\n\n\t\tif (template) {\n\t\t\t// However, `_tags.[tagName]` is going to point to this current content callback.  We need to\n\t\t\t// remove that so it will walk up the chain\n\t\t\tdelete options.tags[tagName];\n\n\t\t\t// By default, light dom scoping is\n\t\t\t// dynamic. This means that any `{{foo}}`\n\t\t\t// bindings inside the \"light dom\" content of\n\t\t\t// the component will have access to the\n\t\t\t// internal viewModel. This can be overridden to be\n\t\t\t// lexical with the leakScope option.\n\t\t\tvar tagData;\n\n\t\t\tif( renderingLightContent ) {\n\n\t\t\t\tif(leakScope.toLightContent) {\n\t\t\t\t\t// render with the component's viewModel mixed in, however\n\t\t\t\t\t// we still want the outer refs to be used, NOT the component's refs\n\t\t\t\t\t// <component> {{some value }} </component>\n\t\t\t\t\t// To fix this, we\n\t\t\t\t\t// walk down the scope to the component's ref, clone scopes from that point up\n\t\t\t\t\t// use that as the new scope.\n\t\t\t\t\ttagData = addContext(el, {\n\t\t\t\t\t\tscope: insertionElementTagData.scope.cloneFromRef(),\n\t\t\t\t\t\toptions: insertionElementTagData.options\n\t\t\t\t\t}, insertionElementTagData);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// render with the same scope the component was found within.\n\t\t\t\t\ttagData = addContext(el, componentTagData, insertionElementTagData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we are rendering default content so this content should\n\t\t\t\t// use the same scope as the <content> tag was found within.\n\t\t\t\ttagData = addContext(el, insertionElementTagData, insertionElementTagData);\n\t\t\t}\n\n\n\t\t\t// the `el` is part of some parent node list\n\n\t\t\tvar nodeList = nodeLists.register([el], function() {\n\t\t\t\tif(tagData.teardown) {\n\t\t\t\t\ttagData.teardown();\n\t\t\t\t}\n\t\t\t}, insertionElementTagData.parentNodeList || true, insertionElementTagData.directlyNested);\n\t\t\tnodeList.expression = \"<can-slot name='\"+el.getAttribute('name')+\"'/>\";\n\n\t\t\tvar frag = template(tagData.scope, tagData.options, nodeList);\n\t\t\tvar newNodes = canReflect.toArray( getChildNodes(frag) );\n\t\t\tvar oldNodes = nodeLists.update(nodeList, newNodes);\n\t\t\tnodeLists.replace(oldNodes, frag);\n\n\n\t\t\t// Restore the proper tag function so it could potentially be used again (as in lists)\n\t\t\toptions.tags[tagName] = hookupFunction;\n\t\t}\n\t};\n}\n\n// Helper function for taking a viewModel passed into a component’s constructor\n// function and returning a function that can be used to set up the bindings\nfunction getSetupFunctionForComponentVM(componentInitVM) {\n\t// componentInitVM is the viewModel in `new ComponentConstructor({ viewModel: {...} })`\n\treturn function(el, makeViewModel, initialVMData) {\n\t\tvar onCompleteBindings = [];\n\t\tvar onTeardowns = [];\n\t\tvar viewModel;// This will be created after getting all the initial values\n\n\t\t// Loop through all the props to create the new binding and get the initial\n\t\t// values (so the viewModel can be created with the initial values)\n\t\tcanReflect.eachKey(componentInitVM, function(parent, propName) {\n\t\t\tvar canGetParentValue = !!parent[getValueSymbol];\n\n\t\t\t// If we can get or set the value, then we’ll create a binding\n\t\t\tif (canGetParentValue === true || parent[setValueSymbol]) {\n\n\t\t\t\t// Create an observable for reading/writing the viewModel\n\t\t\t\tvar keysToRead = observeReader.reads(propName);\n\t\t\t\tvar child = new SettableObservable(\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\treturn observeReader.read(viewModel, keysToRead).value;\n\t\t\t\t\t},\n\t\t\t\t\tfunction(newValue) {\n\t\t\t\t\t\tcanReflect.setKeyValue(viewModel, propName, newValue);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Create the binding similar to what’s in can-stache-bindings\n\t\t\t\tvar canBinding = new Bind({\n\t\t\t\t\tchild: child,\n\t\t\t\t\tparent: parent,\n\t\t\t\t\tqueue: \"domUI\",\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t// For debugging: the names that will be assigned to the updateChild\n\t\t\t\t\t// and updateParent functions within can-bind\n\t\t\t\t\tupdateChildName: \"update viewModel.\" + propName + \" of <\" + el.nodeName.toLowerCase() + \">\",\n\t\t\t\t\tupdateParentName: \"update \" + canReflect.getName(parent) + \" of <\" + el.nodeName.toLowerCase() + \">\"\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t});\n\n\t\t\t\t// Immediately bind to the parent\n\t\t\t\tcanBinding.startParent();\n\n\t\t\t\t// If we can get the value, we want to instantiate the viewModel with it\n\t\t\t\tif (canGetParentValue === true) {\n\t\t\t\t\tinitialVMData[propName] = canBinding.parentValue;\n\t\t\t\t}\n\n\t\t\t\t// Like can-stache-bindings, delay starting the rest of the binding\n\t\t\t\tonCompleteBindings.push(canBinding.start.bind(canBinding));\n\n\t\t\t\t// We’ll want to turn off the bindings when the component is destroyed\n\t\t\t\tonTeardowns.push(canBinding.stop);\n\n\t\t\t} else {\n\t\t\t\t// Can’t get or set the value, so assume it’s not an observable\n\t\t\t\tinitialVMData[propName] = parent;\n\t\t\t}\n\t\t});\n\n\t\t// Now that we have all the initial values, create the component’s viewModel\n\t\tviewModel = makeViewModel(initialVMData);\n\n\t\t// Call start() on all the bindings\n\t\tfor (var i = 0, len = onCompleteBindings.length; i < len; i++) {\n\t\t\tonCompleteBindings[i]();\n\t\t}\n\n\t\t// Return a teardown function\n\t\treturn function() {\n\t\t\tonTeardowns.forEach(function(onTeardown) {\n\t\t\t\tonTeardown();\n\t\t\t});\n\t\t};\n\t};\n}\n\nvar Component = Construct.extend(\n\n\t// ## Static\n\t{\n\t\t// ### setup\n\t\t//\n\t\t// When a component is extended, this sets up the component's internal constructor\n\t\t// functions and views for later fast initialization.\n\t\t// jshint maxdepth:6\n\t\tsetup: function() {\n\t\t\tConstruct.setup.apply(this, arguments);\n\n\t\t\t// When `Component.setup` function is ran for the first time, `Component` doesn't exist yet\n\t\t\t// which ensures that the following code is ran only in constructors that extend `Component`.\n\t\t\tif (Component) {\n\t\t\t\tvar self = this;\n\n\t\t\t\t// Define a control using the `events` prototype property.\n\t\t\t\tif(this.prototype.events !== undefined && canReflect.size(this.prototype.events) !== 0) {\n\t\t\t\t\tthis.Control = ComponentControl.extend(this.prototype.events);\n\t\t\t\t}\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\t// If a constructor is assigned to the viewModel, give a warning\n\t\t\t\t\tif (this.prototype.viewModel && canReflect.isConstructorLike(this.prototype.viewModel)) {\n\t\t\t\t\t\tcanDev.warn(\"can-component: Assigning a DefineMap or constructor type to the viewModel property may not be what you intended. Did you mean ViewModel instead? More info: https://canjs.com/doc/can-component.prototype.ViewModel.html\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\t// Look at viewModel, scope, and ViewModel properties and set one of:\n\t\t\t\t//  - this.viewModelHandler\n\t\t\t\t//  - this.ViewModel\n\t\t\t\t//  - this.viewModelInstance\n\t\t\t\tvar protoViewModel = this.prototype.viewModel || this.prototype.scope;\n\n\t\t\t\tif(protoViewModel && this.prototype.ViewModel) {\n\t\t\t\t\tthrow new Error(\"Cannot provide both a ViewModel and a viewModel property\");\n\t\t\t\t}\n\t\t\t\tvar vmName = string.capitalize( string.camelize(this.prototype.tag) )+\"VM\";\n\t\t\t\tif(this.prototype.ViewModel) {\n\t\t\t\t\tif(typeof this.prototype.ViewModel === \"function\") {\n\t\t\t\t\t\tthis.ViewModel = this.prototype.ViewModel;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.ViewModel = DefineMap.extend(vmName, {}, this.prototype.ViewModel);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif(protoViewModel) {\n\t\t\t\t\t\tif(typeof protoViewModel === \"function\") {\n\t\t\t\t\t\t\tif(canReflect.isObservableLike(protoViewModel.prototype) && canReflect.isMapLike(protoViewModel.prototype)) {\n\t\t\t\t\t\t\t\tthis.ViewModel = protoViewModel;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.viewModelHandler = protoViewModel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(canReflect.isObservableLike(protoViewModel) && canReflect.isMapLike(protoViewModel)) {\n\t\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\t\t\tcanLog.warn(\"can-component: \"+this.prototype.tag+\" is sharing a single map across all component instances\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\t\tthis.viewModelInstance = protoViewModel;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcanLog.warn(\"can-component: \"+this.prototype.tag+\" is extending the viewModel into a can-simple-map\");\n\t\t\t\t\t\t\t\tthis.ViewModel = SimpleMap.extend(vmName,{},protoViewModel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.ViewModel = SimpleMap.extend(vmName,{},{});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Convert the template into a renderer function.\n\t\t\t\tif (this.prototype.template) {\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tcanLog.warn('can-component.prototype.template: is deprecated and will be removed in a future release. Use can-component.prototype.view');\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tthis.renderer = this.prototype.template;\n\t\t\t\t}\n\t\t\t\tif (this.prototype.view) {\n\t\t\t\t\tthis.renderer = this.prototype.view;\n\t\t\t\t}\n\n\t\t\t\t// default to stache if renderer is a string\n\t\t\t\tif (typeof this.renderer === \"string\") {\n\t\t\t\t\tvar viewName = string.capitalize( string.camelize(this.prototype.tag) )+\"View\";\n\t\t\t\t\tthis.renderer = stache(viewName, this.renderer);\n\t\t\t\t}\n\n\t\t\t\t// Register this component to be created when its `tag` is found.\n\t\t\t\tviewCallbacks.tag(this.prototype.tag, function(el, tagData) {\n\t\t\t\t\t// Check if a symbol already exists on the element; if it does, then\n\t\t\t\t\t// a new instance of the component has already been created\n\t\t\t\t\tif (el[createdByCanComponentSymbol] === undefined) {\n\t\t\t\t\t\tnew self(el, tagData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}, {\n\t\t// ## Prototype\n\t\t// ### setup\n\t\t// When a new component instance is created, setup bindings, render the view, etc.\n\t\tsetup: function(el, componentTagData) {\n\t\t\tvar component = this;\n\t\t\tvar options = {\n\t\t\t\thelpers: {},\n\t\t\t\ttags: {}\n\t\t\t};\n\t\t\t// If a view is not provided, we fall back to\n\t\t\t// dynamic scoping regardless of settings.\n\n\t\t\t// If componentTagData isn’t defined, check for el and use it if it’s defined;\n\t\t\t// otherwise, an empty object is needed for componentTagData.\n\t\t\tif (componentTagData === undefined) {\n\t\t\t\tif (el === undefined) {\n\t\t\t\t\tcomponentTagData = {};\n\t\t\t\t} else {\n\t\t\t\t\tcomponentTagData = el;\n\t\t\t\t\tel = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create an element if it doesn’t exist and make it available outside of this\n\t\t\tif (el === undefined) {\n\t\t\t\tel = DOCUMENT().createElement(this.tag);\n\t\t\t\tel[createdByCanComponentSymbol] = true;\n\t\t\t}\n\t\t\tthis.element = el;\n\n\t\t\t// Hook up any <content> with which the component was instantiated\n\t\t\tvar componentContent = componentTagData.content;\n\t\t\tif (componentContent !== undefined) {\n\t\t\t\t// Check if it’s already a renderer function or\n\t\t\t\t// a string that needs to be parsed by stache\n\t\t\t\tif (typeof componentContent === \"function\") {\n\t\t\t\t\tcomponentTagData.subtemplate = componentContent;\n\t\t\t\t} else if (typeof componentContent === \"string\") {\n\t\t\t\t\tcomponentTagData.subtemplate = stache(componentContent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for the component being instantiated with a scope\n\t\t\tvar componentScope = componentTagData.scope;\n\t\t\tif (componentScope !== undefined && componentScope instanceof Scope === false) {\n\t\t\t\tcomponentTagData.scope = new Scope(componentScope);\n\t\t\t}\n\n\t\t\t// Hook up any templates with which the component was instantiated\n\t\t\tvar componentTemplates = componentTagData.templates;\n\t\t\tif (componentTemplates !== undefined) {\n\t\t\t\tcanReflect.eachKey(componentTemplates, function(template, name) {\n\t\t\t\t\t// Check if it’s a string that needs to be parsed by stache\n\t\t\t\t\tif (typeof template === \"string\") {\n\t\t\t\t\t\tvar debugName = name + \" template\";\n\t\t\t\t\t\tcomponentTemplates[name] = stache(debugName, template);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// an array of teardown stuff that should happen when the element is removed\n\t\t\tvar teardownFunctions = [];\n\t\t\tvar initialViewModelData = {};\n\t\t\tvar callTeardownFunctions = function() {\n\t\t\t\t\tfor (var i = 0, len = teardownFunctions.length; i < len; i++) {\n\t\t\t\t\t\tteardownFunctions[i]();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\tvar preventDataBindings = domData.get.call(el, \"preventDataBindings\");\n\t\t\tvar viewModel, frag;\n\n\t\t\t// ## Scope\n\t\t\tvar teardownBindings;\n\t\t\tif (preventDataBindings) {\n\t\t\t\tviewModel = el[viewModelSymbol];\n\t\t\t} else {// Set up the bindings\n\t\t\t\tvar setupFn;\n\t\t\t\tif (componentTagData.setupBindings) {\n\t\t\t\t\tsetupFn = componentTagData.setupBindings;\n\t\t\t\t} else if (componentTagData.viewModel) {\n\t\t\t\t\t// Component is being instantiated with a viewModel\n\t\t\t\t\tsetupFn = getSetupFunctionForComponentVM(componentTagData.viewModel);\n\t\t\t\t} else {\n\t\t\t\t\tsetupFn = function(el, callback, data) {\n\t\t\t\t\t\treturn stacheBindings.behaviors.viewModel(el, componentTagData, callback, data);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tteardownBindings = setupFn(el, function(initialViewModelData) {\n\n\t\t\t\t\tvar ViewModel = component.constructor.ViewModel,\n\t\t\t\t\t\tviewModelHandler = component.constructor.viewModelHandler,\n\t\t\t\t\t\tviewModelInstance = component.constructor.viewModelInstance;\n\n\t\t\t\t\tif(viewModelHandler) {\n\t\t\t\t\t\tvar scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);\n\t\t\t\t\t\tif (canReflect.isObservableLike(scopeResult) && canReflect.isMapLike(scopeResult) ) {\n\t\t\t\t\t\t\t// If the function returns a can.Map, use that as the viewModel\n\t\t\t\t\t\t\tviewModelInstance = scopeResult;\n\t\t\t\t\t\t} else if (canReflect.isObservableLike(scopeResult.prototype) && canReflect.isMapLike(scopeResult.prototype)) {\n\t\t\t\t\t\t\t// If `scopeResult` is of a `can.Map` type, use it to wrap the `initialViewModelData`\n\t\t\t\t\t\t\tViewModel = scopeResult;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise extend `SimpleMap` with the `scopeResult` and initialize it with the `initialViewModelData`\n\t\t\t\t\t\t\tViewModel = SimpleMap.extend(scopeResult);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(ViewModel) {\n\t\t\t\t\t\tviewModelInstance = new component.constructor.ViewModel(initialViewModelData);\n\t\t\t\t\t}\n\t\t\t\t\tviewModel = viewModelInstance;\n\t\t\t\t\treturn viewModelInstance;\n\t\t\t\t}, initialViewModelData);\n\t\t\t}\n\n\t\t\t// Set `viewModel` to `this.viewModel` and set it to the element's `data` object as a `viewModel` property\n\t\t\tthis.viewModel = viewModel;\n\n\t\t\tel[viewModelSymbol] = viewModel;\n\t\t\tdomData.set.call(el, \"preventDataBindings\", true);\n\n\t\t\t// ## Helpers\n\n\t\t\t// Setup helpers to callback with `this` as the component\n\t\t\tif(this.helpers !== undefined) {\n\t\t\t\tcanReflect.eachKey(this.helpers, function(val, prop) {\n\t\t\t\t\tif (typeof val === \"function\") {\n\t\t\t\t\t\toptions.helpers[prop] = val.bind(viewModel);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\n\t\t\t// ## `events` control\n\n\t\t\t// Create a control to listen to events\n\t\t\tif(this.constructor.Control) {\n\t\t\t\tthis._control = new this.constructor.Control(el, {\n\t\t\t\t\t// Pass the viewModel to the control so we can listen to it's changes from the controller.\n\t\t\t\t\tscope: this.viewModel,\n\t\t\t\t\tviewModel: this.viewModel,\n\t\t\t\t\tdestroy: callTeardownFunctions\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvar removalDisposal = domMutate.onNodeRemoval(el, function () {\n\t\t\t\t\tif (!el.ownerDocument.contains(el)) {\n\t\t\t\t\t\tremovalDisposal();\n\t\t\t\t\t\tcallTeardownFunctions();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// ## Rendering\n\n\t\t\tvar leakScope = {\n\t\t\t\ttoLightContent: this.leakScope === true,\n\t\t\t\tintoShadowContent: this.leakScope === true\n\t\t\t};\n\n\t\t\tvar hasShadowTemplate = !!(this.constructor.renderer);\n\n\t\t\t// Get what we should render between the component tags\n\t\t\t// and the data for it.\n\t\t\tvar betweenTagsRenderer;\n\t\t\tvar betweenTagsTagData;\n\t\t\tif( hasShadowTemplate ) {\n\t\t\t\tvar shadowTagData;\n\t\t\t\tif (leakScope.intoShadowContent) {\n\t\t\t\t\t// Give access to the component's data and the VM\n\t\t\t\t\tshadowTagData = {\n\t\t\t\t\t\tscope: componentTagData.scope.add(this.viewModel, { viewModel: true }),\n\t\t\t\t\t\toptions: options\n\t\t\t\t\t};\n\n\t\t\t\t} else { // lexical\n\t\t\t\t\t// only give access to the VM\n\t\t\t\t\tshadowTagData = {\n\t\t\t\t\t\tscope: new Scope(this.viewModel, null, { viewModel: true }),\n\t\t\t\t\t\toptions: options\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Add a hookup for each <can-slot>\n\t\t\t\toptions.tags['can-slot'] = makeInsertionTagCallback('can-slot', componentTagData, shadowTagData, leakScope, function(el) {\n\t\t\t\t\tvar templates = componentTagData.templates;\n\t\t\t\t\tif (templates) {// This is undefined if the component is <self-closing/>\n\t\t\t\t\t\treturn templates[el.getAttribute(\"name\")];\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Add a hookup for <content>\n\t\t\t\toptions.tags.content = makeInsertionTagCallback('content',  componentTagData, shadowTagData, leakScope, function() {\n\t\t\t\t\treturn componentTagData.subtemplate;\n\t\t\t\t});\n\n\t\t\t\tbetweenTagsRenderer = this.constructor.renderer;\n\t\t\t\tbetweenTagsTagData = shadowTagData;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No shadow template.\n\t\t\t\t// Render light template with viewModel on top\n\t\t\t\tvar lightTemplateTagData = {\n\t\t\t\t\tscope: componentTagData.scope.add(this.viewModel, {\n\t\t\t\t\t\tviewModel: true\n\t\t\t\t\t}),\n\t\t\t\t\toptions: options\n\t\t\t\t};\n\t\t\t\tbetweenTagsTagData = lightTemplateTagData;\n\t\t\t\tbetweenTagsRenderer = componentTagData.subtemplate || el.ownerDocument.createDocumentFragment.bind(el.ownerDocument);\n\t\t\t}\n\t\t\tvar disconnectedCallback,\n\t\t\t\tcomponentInPage;\n\n\t\t\t// Keep a nodeList so we can kill any directly nested nodeLists within this component\n\t\t\tvar nodeList = nodeLists.register([], function() {\n\t\t\t\tdomEvents.dispatch(el, \"beforeremove\", false);\n\t\t\t\tif(teardownBindings) {\n\t\t\t\t\tteardownBindings();\n\t\t\t\t}\n\t\t\t\tif(disconnectedCallback) {\n\t\t\t\t\tdisconnectedCallback(el);\n\t\t\t\t}\n\t\t\t}, componentTagData.parentNodeList || true, false);\n\t\t\tnodeList.expression = \"<\" + this.tag + \">\";\n\t\t\tteardownFunctions.push(function() {\n\t\t\t\tnodeLists.unregister(nodeList);\n\t\t\t});\n\t\t\tthis.nodeList = nodeList;\n\n\t\t\tfrag = betweenTagsRenderer(betweenTagsTagData.scope, betweenTagsTagData.options, nodeList);\n\n\t\t\t// Append the resulting document fragment to the element\n\t\t\tdomMutateNode.appendChild.call(el, frag);\n\n\t\t\t// update the nodeList with the new children so the mapping gets applied\n\t\t\tnodeLists.update(nodeList, getChildNodes(el));\n\n\t\t\tif(viewModel && viewModel.connectedCallback) {\n\t\t\t\tcomponentInPage = DOCUMENT().body.contains(el);\n\n\t\t\t\tif(componentInPage) {\n\t\t\t\t\tdisconnectedCallback = viewModel.connectedCallback(el);\n\t\t\t\t} else {\n\t\t\t\t\tvar insertionDisposal = domMutate.onNodeInsertion(el, function () {\n\t\t\t\t\t\tinsertionDisposal();\n\t\t\t\t\t\tdisconnectedCallback = viewModel.connectedCallback(el);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t});\n\n// This adds support for components being rendered as values in stache templates\nComponent.prototype[viewInsertSymbol] = function(viewData) {\n\tviewData.nodeList.newDeepChildren.push(this.nodeList);\n\treturn this.element;\n};\n\nmodule.exports = namespace.Component = Component;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-component/can-component.js?");

/***/ }),

/***/ "../../node_modules/can-component/control/control.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-component/control/control.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Control = __webpack_require__(/*! can-control */ \"../../node_modules/can-control/can-control.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\n// ## Helpers\n// Attribute names to ignore for setting viewModel values.\nvar paramReplacer = /\\{([^\\}]+)\\}/g;\n\nvar ComponentControl = Control.extend({\n\t\t// the lookup path - where templated keys will be looked up\n\t\t// change lookup to first look in the viewModel\n\t\t_lookup: function(options) {\n\t\t\treturn [options.scope, options, window];\n\t\t},\n\t\t// strip strings that represent delegates from the key\n\t\t// viewModel.foo -> foo\n\t\t_removeDelegateFromKey: function (key) {\n\t\t\treturn key.replace(/^(scope|^viewModel)\\./, \"\");\n\t\t},\n\t\t// return whether the key is a delegate\n\t\t_isDelegate: function(options, key) {\n\t\t\treturn key === 'scope' || key === 'viewModel';\n\t\t},\n\t\t// return the delegate object for a given key\n\t\t_getDelegate: function(options, key) {\n\t\t\treturn options[key];\n\t\t},\n\t\t_action: function(methodName, options, controlInstance) {\n\t\t\tvar hasObjectLookup;\n\n\t\t\tparamReplacer.lastIndex = 0;\n\n\t\t\thasObjectLookup = paramReplacer.test(methodName);\n\n\t\t\t// If we don't have options (a `control` instance), we'll run this later.\n\t\t\tif (!controlInstance && hasObjectLookup) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\treturn Control._action.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t},\n\t// Extend `events` with a setup method that listens to changes in `viewModel` and\n\t// rebinds all templated event handlers.\n\t{\n\t\tsetup: function(el, options) {\n\t\t\tthis.scope = options.scope;\n\t\t\tthis.viewModel = options.viewModel;\n\t\t\treturn Control.prototype.setup.call(this, el, options);\n\t\t},\n\t\toff: function() {\n\t\t\t// If `this._bindings` exists we need to go through it's `readyComputes` and manually\n\t\t\t// unbind `change` event listeners set by the controller.\n\t\t\tif (this._bindings) {\n\t\t\t\tcanReflect.eachKey(this._bindings.readyComputes || {}, function(value) {\n\t\t\t\t\tcanReflect.offValue(value.compute, value.handler);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Call `Control.prototype.off` function on this instance to cleanup the bindings.\n\t\t\tControl.prototype.off.apply(this, arguments);\n\t\t\tthis._bindings.readyComputes = {};\n\t\t},\n\t\tdestroy: function() {\n\t\t\tControl.prototype.destroy.apply(this, arguments);\n\t\t\tif (typeof this.options.destroy === 'function') {\n\t\t\t\tthis.options.destroy.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t});\n\nmodule.exports = ComponentControl;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-component/control/control.js?");

/***/ }),

/***/ "../../node_modules/can-construct/can-construct.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-construct/can-construct.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\n//!steal-remove-start\nif(true) {\n\tvar CanString = __webpack_require__(/*! can-string */ \"../../node_modules/can-string/can-string.js\");\n\tvar reservedWords = {\n\t\t\"abstract\": true,\n\t\t\"boolean\": true,\n\t\t\"break\": true,\n\t\t\"byte\": true,\n\t\t\"case\": true,\n\t\t\"catch\": true,\n\t\t\"char\": true,\n\t\t\"class\": true,\n\t\t\"const\": true,\n\t\t\"continue\": true,\n\t\t\"debugger\": true,\n\t\t\"default\": true,\n\t\t\"delete\": true,\n\t\t\"do\": true,\n\t\t\"double\": true,\n\t\t\"else\": true,\n\t\t\"enum\": true,\n\t\t\"export\": true,\n\t\t\"extends\": true,\n\t\t\"false\": true,\n\t\t\"final\": true,\n\t\t\"finally\": true,\n\t\t\"float\": true,\n\t\t\"for\": true,\n\t\t\"function\": true,\n\t\t\"goto\": true,\n\t\t\"if\": true,\n\t\t\"implements\": true,\n\t\t\"import\": true,\n\t\t\"in\": true,\n\t\t\"instanceof\": true,\n\t\t\"int\": true,\n\t\t\"interface\": true,\n\t\t\"let\": true,\n\t\t\"long\": true,\n\t\t\"native\": true,\n\t\t\"new\": true,\n\t\t\"null\": true,\n\t\t\"package\": true,\n\t\t\"private\": true,\n\t\t\"protected\": true,\n\t\t\"public\": true,\n\t\t\"return\": true,\n\t\t\"short\": true,\n\t\t\"static\": true,\n\t\t\"super\": true,\n\t\t\"switch\": true,\n\t\t\"synchronized\": true,\n\t\t\"this\": true,\n\t\t\"throw\": true,\n\t\t\"throws\": true,\n\t\t\"transient\": true,\n\t\t\"true\": true,\n\t\t\"try\": true,\n\t\t\"typeof\": true,\n\t\t\"var\": true,\n\t\t\"void\": true,\n\t\t\"volatile\": true,\n\t\t\"while\": true,\n\t\t\"with\": true\n\t};\n\tvar constructorNameRegex = /[^A-Z0-9_]/gi;\n}\n//!steal-remove-end\n\n// ## construct.js\n// `Construct`\n// _This is a modified version of\n// [John Resig's class](http://ejohn.org/blog/simple-javascript-inheritance/).\n// It provides class level inheritance and callbacks._\n// A private flag used to initialize a new class instance without\n// initializing it's bindings.\nvar initializing = 0;\n\n//!steal-remove-start\nif(true) {\n\tvar namedCtor = (function(cache){\n\t\treturn function(name, fn) {\n\t\t\treturn ((name in cache) ? cache[name] : cache[name] = new Function(\n\t\t\t\t\"__\", \"function \"+name+\"(){return __.apply(this,arguments)};return \"+name\n\t\t\t))( fn );\n\t\t};\n\t}({}));\n}\n//!steal-remove-end\n\n/**\n * @add can-construct\n */\nvar Construct = function () {\n\tif (arguments.length) {\n\t\treturn Construct.extend.apply(Construct, arguments);\n\t}\n};\n\nvar canGetDescriptor;\ntry {\n\tObject.getOwnPropertyDescriptor({});\n\tcanGetDescriptor = true;\n} catch(e) {\n\tcanGetDescriptor = false;\n}\n\nvar getDescriptor = function(newProps, name) {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(newProps, name);\n\t\tif(descriptor && (descriptor.get || descriptor.set)) {\n\t\t\treturn descriptor;\n\t\t}\n\t\treturn null;\n\t},\n\tinheritGetterSetter = function(newProps, oldProps, addTo) {\n\t\taddTo = addTo || newProps;\n\t\tvar descriptor;\n\n\t\tfor (var name in newProps) {\n\t\t\tif( (descriptor = getDescriptor(newProps, name)) ) {\n\t\t\t\tthis._defineProperty(addTo, oldProps, name, descriptor);\n\t\t\t} else {\n\t\t\t\tConstruct._overwrite(addTo, oldProps, name, newProps[name]);\n\t\t\t}\n\t\t}\n\t},\n\tsimpleInherit = function (newProps, oldProps, addTo) {\n\t\taddTo = addTo || newProps;\n\n\t\tfor (var name in newProps) {\n\t\t\tConstruct._overwrite(addTo, oldProps, name, newProps[name]);\n\t\t}\n\t};\n/**\n * @static\n */\ncanReflect.assignMap(Construct, {\n\t/**\n\t * @property {Boolean} can-construct.constructorExtends constructorExtends\n\t * @parent can-construct.static\n\t *\n\t * @description\n\t * Toggles the behavior of a constructor function called\n\t * without the `new` keyword to extend the constructor function or\n\t * create a new instance.\n\t *\n\t * ```js\n\t * var animal = Animal();\n\t * // vs\n\t * var animal = new Animal();\n\t * ```\n\t *\n\t * @body\n\t *\n\t * If `constructorExtends` is:\n\t *\n\t *  - `true` - the constructor extends\n\t *  - `false` - a new instance of the constructor is created\n\t *\n\t * This property defaults to false.\n\t *\n\t * Example of constructExtends as `true`:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   constructorExtends: true // the constructor extends\n\t * },{\n\t *   sayHi: function() {\n\t *     console.log(\"hai!\");\n\t *   }\n\t * });\n\t *\n\t * var Pony = Animal({\n\t *   gallop: function () {\n\t *      console.log(\"Galloping!!\");\n\t *   }\n\t * }); // Pony is now a constructor function extended from Animal\n\t *\n\t * var frank = new Animal(); // frank is a new instance of Animal\n\t *\n\t * var gertrude = new Pony(); // gertrude is a new instance of Pony\n\t * gertrude.sayHi(); // \"hai!\" - sayHi is \"inherited\" from Animal\n\t * gertrude.gallop(); // \"Galloping!!\" - gallop is unique to instances of Pony\n\t *```\n\t *\n\t * The default behavior is shown in the example below:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   constructorExtends: false // the constructor does NOT extend\n\t * },{\n\t *   sayHi: function() {\n\t *     console.log(\"hai!\");\n\t *   }\n\t * });\n\t *\n\t * var pony = Animal(); // pony is a new instance of Animal\n\t * var frank = new Animal(); // frank is a new instance of Animal\n\t *\n\t * pony.sayHi() // \"hai!\"\n\t * frank.sayHi() // \"hai!\"\n\t *```\n\t * By default to extend a constructor, you must use [can-construct.extend extend].\n\t */\n\tconstructorExtends: true,\n\t/**\n\t * @function can-construct.newInstance newInstance\n\t * @parent can-construct.static\n\t *\n\t * @description Returns an instance of `Construct`. This method\n\t * can be overridden to return a cached instance.\n\t *\n\t * @signature `Construct.newInstance([...args])`\n\t *\n\t * @param {*} [args] arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\n\t * that if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\n\t * instead.\n\t * @return {class} instance of the class\n\t *\n\t * @body\n\t * Creates a new instance of the constructor function. This method is useful for creating new instances\n\t * with arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n\t * __new__ operator.\n\t *\n\t * ## Example\n\t *\n\t * The following creates a `Person` Construct and overrides `newInstance` to cache all\n\t * instances of Person to prevent duplication. If the properties of a new Person match an existing one it\n\t * will return a reference to the previously created object, otherwise it returns a new object entirely.\n\t *\n\t * ```js\n\t * // define and create the Person constructor\n\t * var Person = Construct.extend({\n\t *   init : function(first, middle, last) {\n\t *     this.first = first;\n\t *     this.middle = middle;\n\t *     this.last = last;\n\t *   }\n\t * });\n\t *\n\t * // store a reference to the original newInstance function\n\t * var _newInstance = Person.newInstance;\n\t *\n\t * // override Person's newInstance function\n\t * Person.newInstance = function() {\n\t *   // if cache does not exist make it an new object\n\t *   this.__cache = this.__cache || {};\n\t *   // id is a stingified version of the passed arguments\n\t *   var id = JSON.stringify(arguments);\n\t *\n\t *   // look in the cache to see if the object already exists\n\t *   var cachedInst = this.__cache[id];\n\t *   if(cachedInst) {\n\t *     return cachedInst;\n\t *   }\n\t *\n\t *   //otherwise call the original newInstance function and return a new instance of Person.\n\t *   var newInst = _newInstance.apply(this, arguments);\n\t *   this.__cache[id] = newInst;\n\t *   return newInst;\n\t * };\n\t *\n\t * // create two instances with the same arguments\n\t * var justin = new Person('Justin', 'Barry', 'Meyer'),\n\t *\t\tbrian = new Person('Justin', 'Barry', 'Meyer');\n\t *\n\t * console.log(justin === brian); // true - both are references to the same instance\n\t * ```\n\t *\n\t */\n\tnewInstance: function () {\n\t\t// Get a raw instance object (`init` is not called).\n\t\tvar inst = this.instance(),\n\t\t\targs;\n\t\t// Call `setup` if there is a `setup`\n\t\tif (inst.setup) {\n\t\t\tObject.defineProperty(inst,\"__inSetup\",{\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t\targs = inst.setup.apply(inst, arguments);\n\t\t\tif (args instanceof Construct.ReturnValue){\n\t\t\t\treturn args.value;\n\t\t\t}\n\t\t\tinst.__inSetup = false;\n\t\t}\n\t\t// Call `init` if there is an `init`\n\t\t// If `setup` returned `args`, use those as the arguments\n\t\tif (inst.init) {\n\t\t\tinst.init.apply(inst, args || arguments);\n\t\t}\n\t\treturn inst;\n\t},\n\t// Overwrites an object with methods. Used in the `super` plugin.\n\t// `newProps` - New properties to add.\n\t// `oldProps` - Where the old properties might be (used with `super`).\n\t// `addTo` - What we are adding to.\n\t_inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,\n\n\t// Adds a `defineProperty` with the given name and descriptor\n\t// Will only ever be called if ES5 is supported\n\t_defineProperty: function(what, oldProps, propName, descriptor) {\n\t\tObject.defineProperty(what, propName, descriptor);\n\t},\n\n\t// used for overwriting a single property.\n\t// this should be used for patching other objects\n\t// the super plugin overwrites this\n\t_overwrite: function (what, oldProps, propName, val) {\n\t\tObject.defineProperty(what, propName, {value: val, configurable: true, enumerable: true, writable: true});\n\t},\n\t// Set `defaults` as the merger of the parent `defaults` and this\n\t// object's `defaults`. If you overwrite this method, make sure to\n\t// include option merging logic.\n\t/**\n\t * @function can-construct.setup setup\n\t * @parent can-construct.static\n\t *\n\t * @description Perform initialization logic for a constructor function.\n\t *\n\t * @signature `Construct.setup(base, fullName, staticProps, protoProps)`\n\t *\n\t * A static `setup` method provides inheritable setup functionality\n\t * for a Constructor function. The following example\n\t * creates a Group constructor function.  Any constructor\n\t * functions that inherit from Group will be added to\n\t * `Group.childGroups`.\n\t *\n\t *\n\t *     Group = Construct.extend({\n\t *       setup: function(Construct, fullName, staticProps, protoProps){\n\t *         this.childGroups = [];\n\t *         if(Construct !== Construct){\n\t *           this.childGroups.push(Construct)\n\t *         }\n\t *         Construct.setup.apply(this, arguments)\n\t *       }\n\t *     },{})\n\t *     var Flock = Group.extend(...)\n\t *     Group.childGroups[0] //-> Flock\n\t *\n\t * @param {constructor} base The base constructor that is being inherited from.\n\t * @param {String} fullName The name of the new constructor.\n\t * @param {Object} staticProps The static properties of the new constructor.\n\t * @param {Object} protoProps The prototype properties of the new constructor.\n\t *\n\t * @body\n\t * The static `setup` method is called immediately after a constructor\n\t * function is created and\n\t * set to inherit from its base constructor. It is useful for setting up\n\t * additional inheritance work.\n\t * Do not confuse this with the prototype `[can-construct::setup]` method.\n\t *\n\t * ## Example\n\t *\n\t * This `Parent` class adds a reference to its base class to itself, and\n\t * so do all the classes that inherit from it.\n\t *\n\t * ```js\n\t * Parent = Construct.extend({\n\t *   setup : function(base, fullName, staticProps, protoProps){\n\t *     this.base = base;\n\t *\n\t *     // call base functionality\n\t *     Construct.setup.apply(this, arguments)\n\t *   }\n\t * },{});\n\t *\n\t * Parent.base; // Construct\n\t *\n\t * Child = Parent({});\n\t *\n\t * Child.base; // Parent\n\t * ```\n\t */\n\tsetup: function (base) {\n\t\tvar defaults = canReflect.assignDeepMap({},base.defaults);\n\t\tthis.defaults = canReflect.assignDeepMap(defaults,this.defaults);\n\t},\n\t// Create's a new `class` instance without initializing by setting the\n\t// `initializing` flag.\n\tinstance: function () {\n\t\t// Prevents running `init`.\n\t\tinitializing = 1;\n\t\tvar inst = new this();\n\t\t// Allow running `init`.\n\t\tinitializing = 0;\n\t\treturn inst;\n\t},\n\t// Extends classes.\n\t/**\n\t * @function can-construct.extend extend\n\t * @parent can-construct.static\n\t *\n\t * @signature `Construct.extend([name,] [staticProperties,] instanceProperties)`\n\t *\n\t * Extends `Construct`, or constructor functions derived from `Construct`,\n\t * to create a new constructor function. Example:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   sayHi: function(){\n\t *     console.log(\"hi\")\n\t *   }\n\t * });\n\t *\n\t * var animal = new Animal()\n\t * animal.sayHi();\n\t * ```\n\t *\n\t * @param {String} [name] Adds a name to the constructor function so\n\t * it is nicely labeled in the developer tools. The following:\n\t *\n\t *     Construct.extend(\"ConstructorName\",{})\n\t *\n\t * returns a constructur function that will show up as `ConstructorName`\n\t * in the developer tools.\n\t * It also sets \"ConstructorName\" as [can-construct.shortName shortName].\n\t *\n\t * @param {Object} [staticProperties] Properties that are added the constructor\n\t * function directly. For example:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   findAll: function(){\n\t *     return can.ajax({url: \"/animals\"})\n\t *   }\n\t * },{}); // need to pass an empty instanceProperties object\n\t *\n\t * Animal.findAll().then(function(json){ ... })\n\t * ```\n\t *\n\t * The [can-construct.setup static setup] method can be used to\n\t * specify inheritable behavior when a Constructor function is created.\n\t *\n\t * @param {Object} instanceProperties Properties that belong to\n\t * instances made with the constructor. These properties are added to the\n\t * constructor's `prototype` object. Example:\n\t *\n\t *     var Animal = Construct.extend({\n\t *\t\t  findAll: function() {\n\t *\t\t\treturn can.ajax({url: \"/animals\"});\n\t *\t\t  }\n\t *     },{\n\t *       init: function(name) {\n\t *         this.name = name;\n\t *       },\n\t *       sayHi: function() {\n\t *         console.log(this.name,\" says hai!\");\n\t *       }\n\t *     })\n\t *     var pony = new Animal(\"Gertrude\");\n\t *     pony.sayHi(); // \"Gertrude says hai!\"\n\t *\n\t * The [can-construct::init init] and [can-construct::setup setup] properties\n\t * are used for initialization.\n\t *\n\t * @return {function} The constructor function.\n\t *\n\t * ```js\n\t *\tvar Animal = Construct.extend(...);\n\t *\tvar pony = new Animal(); // Animal is a constructor function\n\t * ```\n\t * @body\n\t * ## Inheritance\n\t * Creating \"subclasses\" with `Construct` is simple. All you need to do is call the base constructor\n\t * with the new function's static and instance properties. For example, we want our `Snake` to\n\t * be an `Animal`, but there are some differences:\n\t *\n\t *\n\t *     var Snake = Animal.extend({\n\t *         legs: 0\n\t *     }, {\n\t *         init: function() {\n\t *             Animal.prototype.init.call(this, 'ssssss');\n\t *         },\n\t *         slither: function() {\n\t *             console.log('slithering...');\n\t *         }\n\t *     });\n\t *\n\t *     var baslisk = new Snake();\n\t *     baslisk.speak();   // \"ssssss\"\n\t *     baslisk.slither(); // \"slithering...\"\n\t *     baslisk instanceof Snake;  // true\n\t *     baslisk instanceof Animal; // true\n\t *\n\t *\n\t * ## Static properties and inheritance\n\t *\n\t * If you pass all three arguments to Construct, the second one will be attached directy to the\n\t * constructor, allowing you to imitate static properties and functions. You can access these\n\t * properties through the `[can-construct::constructor this.constructor]` property.\n\t *\n\t * Static properties can get overridden through inheritance just like instance properties. In the example below,\n\t * we override both the legs static property as well as the the init function for each instance:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *     legs: 4\n\t * }, {\n\t *     init: function(sound) {\n\t *         this.sound = sound;\n\t *     },\n\t *     speak: function() {\n\t *         console.log(this.sound);\n\t *     }\n\t * });\n\t *\n\t * var Snake = Animal.extend({\n\t *     legs: 0\n\t * }, {\n\t *     init: function() {\n\t *         this.sound = 'ssssss';\n\t *     },\n\t *     slither: function() {\n\t *         console.log('slithering...');\n\t *     }\n\t * });\n\t *\n\t * Animal.legs; // 4\n\t * Snake.legs; // 0\n\t * var dog = new Animal('woof');\n\t * var blackMamba = new Snake();\n\t * dog.speak(); // 'woof'\n\t * blackMamba.speak(); // 'ssssss'\n\t * ```\n\t *\n\t * ## Alternative value for a new instance\n\t *\n\t * Sometimes you may want to return some custom value instead of a new object when creating an instance of your class.\n\t * For example, you want your class to act as a singleton, or check whether an item with the given id was already\n\t * created and return an existing one from your cache store (e.g. using [can-connect/constructor/store/store]).\n\t *\n\t * To achieve this you can return [can-construct.ReturnValue] from `setup` method of your class.\n\t *\n\t * Lets say you have `myStore` to cache all newly created instances. And if an item already exists you want to merge\n\t * the new data into the existing instance and return the updated instance.\n\t *\n\t * ```\n\t * var myStore = {};\n\t *\n\t * var Item = Construct.extend({\n\t *     setup: function(params){\n\t *         if (myStore[params.id]){\n\t *             var item = myStore[params.id];\n\t *\n\t *             // Merge new data to the existing instance:\n\t *             Object.assign(item, params);\n\t *\n\t *             // Return the updated item:\n\t *             return new Construct.ReturnValue( item );\n\t *         } else {\n\t *             // Save to cache store:\n\t *             myStore[this.id] = this;\n\t *\n\t *             return [params];\n\t *         }\n\t *     },\n\t *     init: function(params){\n\t *         Object.assign(this, params);\n\t *     }\n\t * });\n\t *\n\t * var item_1  = new Item( {id: 1, name: \"One\"} );\n\t * var item_1a = new Item( {id: 1, name: \"OnePlus\"} )\n\t * ```\n\t */\n\textend: function (name, staticProperties, instanceProperties) {\n\t\tvar shortName = name,\n\t\t\tklass = staticProperties,\n\t\t\tproto = instanceProperties;\n\n\t\t// Figure out what was passed and normalize it.\n\t\tif (typeof shortName !== 'string') {\n\t\t\tproto = klass;\n\t\t\tklass = shortName;\n\t\t\tshortName = null;\n\t\t}\n\t\tif (!proto) {\n\t\t\tproto = klass;\n\t\t\tklass = null;\n\t\t}\n\t\tproto = proto || {};\n\t\tvar _super_class = this,\n\t\t\t_super = this.prototype,\n\t\t\tConstructor, prototype;\n\t\t// Instantiate a base class (but only create the instance,\n\t\t// don't run the init constructor).\n\t\tprototype = this.instance();\n\t\t// Copy the properties over onto the new prototype.\n\t\tConstruct._inherit(proto, _super, prototype);\n\n\t\tif(shortName) {\n\n\t\t} else if(klass && klass.shortName) {\n\t\t\tshortName = klass.shortName;\n\t\t} else if(this.shortName) {\n\t\t\tshortName = this.shortName;\n\t\t}\n\t\t// We want constructor.name to be the same as shortName, within\n\t\t// the bounds of what the JS VM will allow (meaning no non-word characters).\n\t\t// new Function() is significantly faster than eval() here.\n\n\t\t// Strip semicolons\n\t\t//!steal-remove-start\n\t\t// wrapping this var will cause \"used out of scope.\" when linting\n\t\tvar constructorName = shortName ? shortName.replace(constructorNameRegex, '_') : 'Constructor';\n\t\tif(true) {\n\t\t\tif(reservedWords[constructorName]) {\n\t\t\t\tconstructorName = CanString.capitalize(constructorName);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// The dummy class constructor.\n\t\tfunction init() {\n\t\t\t/* jshint validthis: true */\n\t\t\t// All construction is actually done in the init method.\n\t\t\tif (!initializing) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tif(!this || (this.constructor !== Constructor) &&\n\t\t\t\t\t// We are being called without `new` or we are extending.\n\t\t\t\t\targuments.length && Constructor.constructorExtends) {\n\t\t\t\t\t\tdev.warn('can/construct/construct.js: extending a Construct without calling extend');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\treturn (!this || this.constructor !== Constructor) &&\n\t\t\t\t// We are being called without `new` or we are extending.\n\t\t\t\targuments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) :\n\t\t\t\t// We are being called with `new`.\n\t\t\t\tConstructor.newInstance.apply(Constructor, arguments);\n\t\t\t}\n\t\t}\n\t\tConstructor = typeof namedCtor === \"function\" ?\n\t\t\tnamedCtor( constructorName, init ) :\n\t\t\tfunction() { return init.apply(this, arguments); };\n\n\t\t// Copy old stuff onto class (can probably be merged w/ inherit)\n\t\tfor (var propName in _super_class) {\n\t\t\tif (_super_class.hasOwnProperty(propName)) {\n\t\t\t\tConstructor[propName] = _super_class[propName];\n\t\t\t}\n\t\t}\n\t\t// Copy new static properties on class.\n\t\tConstruct._inherit(klass, _super_class, Constructor);\n\n\t\t// Set things that shouldn't be overwritten.\n\t\tcanReflect.assignMap(Constructor, {\n\t\t\tconstructor: Constructor,\n\t\t\tprototype: prototype\n\t\t\t/**\n\t\t\t * @property {String} can-construct.shortName shortName\n\t\t\t * @parent can-construct.static\n\t\t\t *\n\t\t\t * If you pass a name when creating a Construct, the `shortName` property will be set to the\n\t\t\t * name.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var MyConstructor = Construct.extend(\"MyConstructor\",{},{});\n\t\t\t * MyConstructor.shortName // \"MyConstructor\"\n\t\t\t * ```\n\t\t\t */\n\t\t});\n\n\t\tif (shortName !== undefined) {\n\t\t\tif (Object.getOwnPropertyDescriptor) {\n\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(Constructor, 'name');\n\t\t\t\tif (!desc || desc.configurable) {\n\t\t\t\t\tObject.defineProperty(\n\t\t\t\t\t\tConstructor,\n\t\t\t\t\t\t'name',\n\t\t\t\t\t\t{ writable: true, value: shortName, configurable: true }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tConstructor.shortName = shortName;\n\t\t}\n\t\t// Make sure our prototype looks nice.\n\t\tConstructor.prototype.constructor = Constructor;\n\t\t// Call the class `setup` and `init`\n\t\tvar t = [_super_class].concat(Array.prototype.slice.call(arguments)),\n\t\t\targs = Constructor.setup.apply(Constructor, t);\n\t\tif (Constructor.init) {\n\t\t\tConstructor.init.apply(Constructor, args || t);\n\t\t}\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\treturn Constructor; //\n\t\t/**\n\t\t * @property {Object} can-construct.prototype.constructor constructor\n\t\t * @parent can-construct.prototype\n\t\t *\n\t\t * A reference to the constructor function that created the instance. This allows you to access\n\t\t * the constructor's static properties from an instance.\n\t\t *\n\t\t * @body\n\t\t * ## Example\n\t\t *\n\t\t * This Construct has a static counter that counts how many instances have been created:\n\t\t *\n\t\t * ```js\n\t\t * var Counter = Construct.extend({\n\t\t *     count: 0\n\t\t * }, {\n\t\t *     init: function() {\n\t\t *         this.constructor.count++;\n\t\t *     }\n\t\t * });\n\t\t *\n\t\t * var childCounter = new Counter();\n\t\t * console.log(childCounter.constructor.count); // 1\n\t\t * console.log(Counter.count); // 1\n\t\t * ```\n\t\t */\n\t},\n\t/**\n\t * @function can-construct.ReturnValue ReturnValue\n\t * @parent can-construct.static\n\t *\n\t * Use to overwrite the return value of new Construct(...).\n\t *\n\t * @signature `new Construct.ReturnValue( value )`\n\t *\n\t *   This constructor function can be used for creating a return value of the `setup` method.\n\t *   [can-construct] will check if the return value is an instance of `Construct.ReturnValue`.\n\t *   If it is then its `value` will be used as the new instance.\n\t *\n\t *   @param {Object} value A value to be used for a new instance instead of a new object.\n\t *\n\t *   ```\n\t *   var Student = function( name, school ){\n\t *       this.name = name;\n\t *       this.school = school;\n\t *   }\n\t *\n\t *   var Person = Construct.extend({\n\t *       setup: function( options ){\n\t *           if (options.school){\n\t *               return new Constructor.ReturnValue( new Student( options.name, options.school ) );\n\t *           } else {\n\t *               return [options];\n\t *           }\n\t *       }\n\t *   });\n\t *\n\t *   var myPerson = new Person( {name: \"Ilya\", school: \"PetrSU\"} );\n\t *\n\t *   myPerson instanceof Student // => true\n\t *   ```\n   */\n\tReturnValue: function(value){\n\t\tthis.value = value;\n\t}\n});\n/**\n * @function can-construct.prototype.setup setup\n * @parent can-construct.prototype\n *\n * @signature `construct.setup(...args)`\n *\n * A setup function for the instantiation of a constructor function.\n *\n * @param {*} args The arguments passed to the constructor.\n *\n * @return {Array|undefined|can-construct.ReturnValue} If an array is returned, the array's items are passed as\n * arguments to [can-construct::init init]. If a [can-construct.ReturnValue] instance is returned, the ReturnValue\n * instance's value will be returned as the result of calling new Construct(). The following example always makes\n * sure that init is called with a jQuery wrapped element:\n *\n * ```js\n * \tWidgetFactory = Construct.extend({\n * \t\t\tsetup: function(element){\n * \t\t\t\t\treturn [$(element)]\n * \t\t\t}\n * \t});\n *\n * \tMyWidget = WidgetFactory.extend({\n * \t\t\tinit: function($el){\n * \t\t\t\t\t$el.html(\"My Widget!!\")\n * \t\t\t}\n * \t});\n *  ```\n *\n * Otherwise, the arguments to the\n * constructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n *\n * @body\n *\n * ## Deciding between `setup` and `init`\n *\n *\n * Usually, you should use [can-construct::init init] to do your constructor function's initialization.\n * You should, instead, use `setup` when:\n *\n *   - there is initialization code that you want to run before the inheriting constructor's\n *     `init` method is called.\n *   - there is initialization code that should run whether or not inheriting constructors\n *     call their base's `init` methods.\n *   - you want to modify the arguments that will get passed to `init`.\n *\n */\nConstruct.prototype.setup = function () {};\n/**\n * @function can-construct.prototype.init init\n * @parent can-construct.prototype\n *\n * @description Called when a new instance of a Construct is created.\n *\n * @signature `construct.init(...args)`\n * @param {*} args the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n *\n * @body\n * If a prototype `init` method is provided, `init` is called when a new Construct is created---\n * after [can-construct::setup]. The `init` method is where the bulk of your initialization code\n * should go. A common thing to do in `init` is save the arguments passed into the constructor.\n *\n * ## Examples\n *\n * First, we'll make a Person constructor that has a first and last name:\n *\n * ```js\n * var Person = Construct.extend({\n *     init: function(first, last) {\n *         this.first = first;\n *         this.last  = last;\n *     }\n * });\n *\n * var justin = new Person(\"Justin\", \"Meyer\");\n * justin.first; // \"Justin\"\n * justin.last; // \"Meyer\"\n * ```\n *\n * Then, we'll extend Person into Programmer, and add a favorite language:\n *\n * ```js\n * var Programmer = Person.extend({\n *     init: function(first, last, language) {\n *         // call base's init\n *         Person.prototype.init.apply(this, arguments);\n *\n *         // other initialization code\n *         this.language = language;\n *     },\n *     bio: function() {\n *         return \"Hi! I'm \" + this.first + \" \" + this.last +\n *             \" and I write \" + this.language + \".\";\n *     }\n * });\n *\n * var brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\n * brian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n * ```\n *\n * ## Modified Arguments\n *\n * [can-construct::setup] is able to modify the arguments passed to `init`.\n * If you aren't receiving the arguments you passed to `new Construct(args)`,\n * check that they aren't being changed by `setup` along\n * the inheritance chain.\n */\nConstruct.prototype.init = function () {};\n\nmodule.exports = namespace.Construct = Construct;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-construct/can-construct.js?");

/***/ }),

/***/ "../../node_modules/can-control/can-control.js":
/*!********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-control/can-control.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # can/control/control.js\n//\n// Create organized, memory-leak free, rapidly performing, stateful\n// controls with declarative eventing binding. Used when creating UI\n// controls with behaviors, bound to elements on the page.\n// ## helpers\n\nvar Construct = __webpack_require__(/*! can-construct */ \"../../node_modules/can-construct/can-construct.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\nvar observeReader = __webpack_require__(/*! can-stache-key */ \"../../node_modules/can-stache-key/can-stache-key.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar canEvent = __webpack_require__(/*! can-event-queue/map/map */ \"../../node_modules/can-event-queue/map/map.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\n\nvar string = __webpack_require__(/*! can-string */ \"../../node_modules/can-string/can-string.js\");\nvar get = __webpack_require__(/*! can-key/get/get */ \"../../node_modules/can-key/get/get.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"../../node_modules/can-dom-mutate/can-dom-mutate.js\");\n\nvar processors;\nvar controlData = new WeakMap();\n\n// ### bind\n// this helper binds to one element and returns a function that unbinds from that element.\nvar bind = function (el, ev, callback, queue) {\n\n    canEvent.on.call(el, ev, callback, queue);\n\n\treturn function () {\n        canEvent.off.call(el, ev, callback, queue);\n\t};\n},\n\tslice = [].slice,\n\tparamReplacer = /\\{([^\\}]+)\\}/g,\n\n\t// ### delegate\n\t//\n\t// this helper binds to elements based on a selector and returns a\n\t// function that unbinds.\n\tdelegate = function (el, selector, ev, callback) {\n        canEvent.on.call(el, ev, selector, callback);\n\n\t\treturn function () {\n            canEvent.off.call(el, ev, selector, callback);\n\t\t};\n\t},\n\n\t// ### binder\n\t//\n\t// Calls bind or unbind depending if there is a selector.\n\tbinder = function (el, ev, callback, selector) {\n\t\treturn selector ?\n\t\t\tdelegate(el, selector.trim(), ev, callback) :\n\t\t\tbind(el, ev, callback);\n\t},\n\n\tbasicProcessor;\n\nvar Control = Construct.extend(\"Control\",\n\t// ## *static functions*\n\t/**\n\t * @static\n\t */\n\t{\n\t\t// ## can.Control.setup\n\t\t//\n\t\t// This function pre-processes which methods are event listeners and which are methods of\n\t\t// the control. It has a mechanism to allow controllers to inherit default values from super\n\t\t// classes, like `can.Construct`, and will cache functions that are action functions (see `_isAction`)\n\t\t// or functions with an underscored name.\n\t\tsetup: function () {\n\t\t\tConstruct.setup.apply(this, arguments);\n\n\t\t\tif (Control) {\n\t\t\t\tvar control = this,\n\t\t\t\t\tfuncName;\n\n\t\t\t\tcontrol.actions = {};\n\t\t\t\tfor (funcName in control.prototype) {\n\t\t\t\t\tif (control._isAction(funcName)) {\n\t\t\t\t\t\tcontrol.actions[funcName] = control._action(funcName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// ## can.Control._shifter\n\t\t//\n\t\t// Moves `this` to the first argument, wraps it with `jQuery` if it's\n\t\t// an element.\n\t\t_shifter: function (context, name) {\n\t\t\tvar method = typeof name === \"string\" ? context[name] : name;\n\n\t\t\tif (typeof method !== \"function\") {\n\t\t\t\tmethod = context[method];\n\t\t\t}\n            var Control = this;\n\t\t\tfunction controlMethod() {\n\t\t\t\tvar wrapped = Control.wrapElement(this);\n\t\t\t\tcontext.called = name;\n\t\t\t\treturn method.apply(context, [wrapped].concat(slice.call(arguments, 0)));\n\t\t\t}\n      //!steal-remove-start\n      if(true) {\n\t      Object.defineProperty(controlMethod, \"name\", {\n\t      \tvalue: canReflect.getName(this) + \"[\"+name+\"]\",\n\t      });\n\t     }\n      //!steal-remove-end\n      return controlMethod;\n\t\t},\n\n\t\t// ## can.Control._isAction\n\t\t//\n\t\t// Return `true` if `methodName` refers to an action. An action is a `methodName` value that\n\t\t// is not the constructor, and is either a function or string that refers to a function, or is\n\t\t// defined in `special`, `processors`. Detects whether `methodName` is also a valid method name.\n\t\t_isAction: function (methodName) {\n\t\t\tvar val = this.prototype[methodName],\n\t\t\t\ttype = typeof val;\n\n\t\t\treturn (methodName !== 'constructor') &&\n\t\t\t(type === \"function\" || (type === \"string\" && (typeof this.prototype[val] === \"function\") )) &&\n\t\t\t!! (Control.isSpecial(methodName) || processors[methodName] || /[^\\w]/.test(methodName));\n\t\t},\n\t\t// ## can.Control._action\n\t\t//\n\t\t// Takes a method name and the options passed to a control and tries to return the data\n\t\t// necessary to pass to a processor (something that binds things).\n\t\t//\n\t\t// For performance reasons, `_action` is called twice:\n\t\t// * It's called when the Control class is created. for templated method names (e.g., `{window} foo`), it returns null. For non-templated method names it returns the event binding data. That data is added to `this.actions`.\n\t\t// * It is called wehn a control instance is created, but only for templated actions.\n\t\t_action: function(methodName, options, controlInstance) {\n\t\t\tvar readyCompute,\n                unableToBind;\n\n\t\t\t// If we don't have options (a `control` instance), we'll run this later. If we have\n\t\t\t// options, run `can.sub` to replace the action template `{}` with values from the `options`\n\t\t\t// or `window`. If a `{}` template resolves to an object, `convertedName` will be an array.\n\t\t\t// In that case, the event name we want will be the last item in that array.\n\t\t\tparamReplacer.lastIndex = 0;\n\t\t\tif (options || !paramReplacer.test(methodName)) {\n                var controlActionData = function() {\n\t\t\t\t\tvar delegate;\n\n\t\t\t\t\t// Set the delegate target and get the name of the event we're listening to.\n\t\t\t\t\tvar name = methodName.replace(paramReplacer, function(matched, key) {\n\t\t\t\t\t\tvar value, parent;\n\n\t\t\t\t\t\t// If listening directly to a delegate target, set it\n\t\t\t\t\t\tif (this._isDelegate(options, key)) {\n\t\t\t\t\t\t\tdelegate = this._getDelegate(options, key);\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If key contains part of the lookup path, remove it.\n\t\t\t\t\t\t// This is needed for bindings like {viewModel.foo} in can-component's Control.\n\t\t\t\t\t\tkey = this._removeDelegateFromKey(key);\n\n\t\t\t\t\t\t// set the parent (where the key will be read from)\n\t\t\t\t\t\tparent = this._lookup(options)[0];\n\n\t\t\t\t\t\tvalue = observeReader.read(parent, observeReader.reads(key), {\n\t\t\t\t\t\t\t// if we find a compute, we should bind on that and not read it\n\t\t\t\t\t\t\treadCompute: false\n\t\t\t\t\t\t}).value;\n\n\t\t\t\t\t\t// If `value` is undefined try to get the value from the window.\n\t\t\t\t\t\tif (value === undefined && typeof window !== 'undefined') {\n\t\t\t\t\t\t\tvalue = get(window, key);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if the parent is not an observable and we don't have a value, show a warning\n\t\t\t\t\t\t// in this situation, it is not possible for the event handler to be triggered\n\t\t\t\t\t\tif (!parent || !(canReflect.isObservableLike(parent) && canReflect.isMapLike(parent)) && !value) {\n                            unableToBind = true;\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If `value` is a string we just return it, otherwise we set it as a delegate target.\n\t\t\t\t\t\tif (typeof value === \"string\") {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelegate = value;\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\t// removing spaces that get added when converting\n\t\t\t\t\t// `{element} click` -> ` click`\n\t\t\t\t\tname = name.trim();\n\n\t\t\t\t\t// Get the name of the `event` we're listening to.\n\t\t\t\t\tvar parts = name.split(/\\s+/g),\n\t\t\t\t\t\tevent = parts.pop();\n\n\t\t\t\t\t// Return everything needed to handle the event we're listening to.\n\t\t\t\t\treturn {\n\t\t\t\t\t\tprocessor: this.processors[event] || basicProcessor,\n\t\t\t\t\t\tparts: [name, parts.join(\" \"), event],\n\t\t\t\t\t\tdelegate: delegate || undefined\n\t\t\t\t\t};\n\t\t\t\t};\n\n        //!steal-remove-start\n        if(true) {\n\t\t    \tObject.defineProperty(controlActionData, \"name\", {\n\t\t      \tvalue: canReflect.getName(controlInstance || this.prototype) + \"[\"+methodName+\"].actionData\",\n\t\t      });\n\t      }\n        //!steal-remove-end\n\n\t\t\t\treadyCompute = new Observation(controlActionData, this);\n\n\n\t\t\t\tif (controlInstance) {\n\t\t\t\t\t// Create a handler function that we'll use to handle the `change` event on the `readyCompute`.\n\t\t\t\t\tvar handler = function(actionData) {\n\t\t\t\t\t\t// unbinds the old binding\n\t\t\t\t\t\tcontrolInstance._bindings.control[methodName](controlInstance.element);\n\t\t\t\t\t\t// binds the new\n\t\t\t\t\t\tcontrolInstance._bindings.control[methodName] = actionData.processor(\n\t\t\t\t\t\t\tactionData.delegate || controlInstance.element,\n\t\t\t\t\t\t\tactionData.parts[2], actionData.parts[1], methodName, controlInstance);\n\t\t\t\t\t};\n\n          //!steal-remove-start\n          if(true) {\n          \tObject.defineProperty(handler, \"name\", {\n            \tvalue: canReflect.getName(controlInstance) + \"[\"+methodName+\"].handler\",\n            });\n          }\n\t\t\t\t\t//!steal-remove-end\n\n\n\t\t\t\t\tcanReflect.onValue(readyCompute, handler, \"mutate\");\n          //!steal-remove-start\n          if(true) {\n\t          if(unableToBind) {\n\t          \tdev.log('can-control: No property found for handling ' + methodName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tcontrolInstance._bindings.readyComputes[methodName] = {\n\t\t\t\t\t\tcompute: readyCompute,\n\t\t\t\t\t\thandler: handler\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn readyCompute.get();\n\t\t\t}\n\t\t},\n\t\t// the lookup path - where templated keys will be looked up\n\t\t_lookup: function (options) {\n\t\t\treturn [options, window];\n\t\t},\n\t\t// strip strings that represent delegates from the key\n\t\t_removeDelegateFromKey: function (key) {\n\t\t\treturn key;\n\t\t},\n\t\t// return whether the key is a delegate\n\t\t_isDelegate: function(options, key) {\n\t\t\treturn key === 'element';\n\t\t},\n\t\t// return the delegate object for a given key\n\t\t_getDelegate: function(options, key) {\n\t\t\treturn undefined;\n\t\t},\n\t\t// ## can.Control.processors\n\t\t//\n\t\t// An object of `{eventName : function}` pairs that Control uses to\n\t\t// hook up events automatically.\n\t\tprocessors: {},\n\t\t// ## can.Control.defaults\n\t\t// A object of name-value pairs that act as default values for a control instance\n\t\tdefaults: {},\n        // should be used to overwrite to make nodeLists on this\n        convertElement: function(element) {\n            element = typeof element === \"string\" ?\n\t\t\t\t\t\t\tdocument.querySelector(element) : element;\n\n\t\t\t\t\t\treturn this.wrapElement(element);\n        },\n        wrapElement: function(el){\n            return el;\n        },\n        unwrapElement: function(el){\n            return el;\n        },\n        // should be overwritten to look in jquery special events\n        isSpecial: function(eventName){\n            return eventName === \"inserted\" || eventName === \"removed\";\n        }\n\t}, {\n\t\t// ## *prototype functions*\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\t// ## setup\n\t\t//\n\t\t// Setup is where most of the Control's magic happens. It performs several pre-initialization steps:\n\t\t// - Sets `this.element`\n\t\t// - Adds the Control's name to the element's className\n\t\t// - Saves the Control in `$.data`\n\t\t// - Merges Options\n\t\t// - Binds event handlers using `delegate`\n\t\t// The final step is to return pass the element and prepareed options, to be used in `init`.\n\t\tsetup: function (element, options) {\n\n\t\t\tvar cls = this.constructor,\n\t\t\t\tpluginname = cls.pluginName || cls.shortName,\n\t\t\t\tarr;\n\n\t\t\tif (!element) {\n\t\t\t\tthrow new Error('Creating an instance of a named control without passing an element');\n\t\t\t}\n\t\t\t// Retrieve the raw element, then set the plugin name as a class there.\n            this.element = cls.convertElement(element);\n\n\t\t\tif (pluginname && pluginname !== 'Control' && this.element.classList) {\n                this.element.classList.add(pluginname);\n\t\t\t}\n\n\t\t\t// Set up the 'controls' data on the element. If it does not exist, initialize\n\t\t\t// it to an empty array.\n\t\t\tarr = controlData.get(this.element);\n\t\t\tif (!arr) {\n\t\t\t\tarr = [];\n\t\t\t\tcontrolData.set(this.element, arr);\n\t\t\t}\n\t\t\tarr.push(this);\n\n\t\t\t// The `this.options` property is an Object that contains configuration data\n\t\t\t// passed to a control when it is created (`new can.Control(element, options)`)\n\t\t\t//\n\t\t\t// The `options` argument passed when creating the control is merged with `can.Control.defaults`\n\t\t\t// in [can.Control.prototype.setup setup].\n\t\t\t//\n\t\t\t// If no `options` value is used during creation, the value in `defaults` is used instead\n\t\t\tif (canReflect.isObservableLike(options) && canReflect.isMapLike(options)) {\n\t\t\t\tfor (var prop in cls.defaults) {\n\t\t\t\t\tif (!options.hasOwnProperty(prop)) {\n\t\t\t\t\t\tobserveReader.set(options, prop, cls.defaults[prop]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.options = options;\n\t\t\t} else {\n\t\t\t\tthis.options = assign( assign({}, cls.defaults), options);\n\t\t\t}\n\n\t\t\tthis.on();\n\n\t\t\treturn [this.element, this.options];\n\t\t},\n\t\t// ## on\n\t\t//\n\t\t// This binds an event handler for an event to a selector under the scope of `this.element`\n\t\t// If no options are specified, all events are rebound to their respective elements. The actions,\n\t\t// which were cached in `setup`, are used and all elements are bound using `delegate` from `this.element`.\n\t\ton: function (el, selector, eventName, func) {\n\t\t\tif (!el) {\n\t\t\t\tthis.off();\n\n\t\t\t\tvar cls = this.constructor,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tactions = cls.actions,\n\t\t\t\t\telement = this.constructor.unwrapElement(this.element),\n\t\t\t\t\tdestroyCB = Control._shifter(this, \"destroy\"),\n\t\t\t\t\tfuncName, ready;\n\n\t\t\t\tfor (funcName in actions) {\n\t\t\t\t\t// Only push if we have the action and no option is `undefined`\n\t\t\t\t\tif ( actions.hasOwnProperty(funcName) ) {\n\t\t\t\t\t\tready = actions[funcName] || cls._action(funcName, this.options, this);\n\t\t\t\t\t\tif( ready ) {\n\t\t\t\t\t\t\tbindings.control[funcName]  = ready.processor(ready.delegate || element,\n\t\t\t\t\t\t\t\tready.parts[2], ready.parts[1], funcName, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set up the ability to `destroy` the control later.\n\t\t\t\tvar removalDisposal = domMutate.onNodeRemoval(element, function () {\n\t\t\t\t\tif (!element.ownerDocument.contains(element)) {\n\t\t\t\t\t\tdestroyCB();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbindings.user.push(function () {\n\t\t\t\t\tif (removalDisposal) {\n\t\t\t\t\t\tremovalDisposal();\n\t\t\t\t\t\tremovalDisposal = undefined;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn bindings.user.length;\n\t\t\t}\n\n\t\t\t// if `el` is a string, use that as `selector` and re-set it to this control's element...\n\t\t\tif (typeof el === 'string') {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = el;\n\t\t\t\tel = this.element;\n\t\t\t}\n\n\t\t\t// ...otherwise, set `selector` to null\n\t\t\tif (func === undefined) {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = null;\n\t\t\t}\n\n\t\t\tif (typeof func === 'string') {\n\t\t\t\tfunc = Control._shifter(this, func);\n\t\t\t}\n\n\t\t\tthis._bindings.user.push(binder(el, eventName, func, selector));\n\n\t\t\treturn this._bindings.user.length;\n\t\t},\n\t\t// ## off\n\t\t//\n\t\t// Unbinds all event handlers on the controller.\n\t\t// This should _only_ be called in combination with .on()\n\t\toff: function () {\n\t\t\tvar el = this.constructor.unwrapElement(this.element),\n\t\t\t\tbindings = this._bindings;\n\t\t\tif( bindings ) {\n\t\t\t\t(bindings.user || []).forEach(function (value) {\n\t\t\t\t\tvalue(el);\n\t\t\t\t});\n\t\t\t\tcanReflect.eachKey(bindings.control || {}, function (value) {\n\t\t\t\t\tvalue(el);\n\t\t\t\t});\n\t\t\t\tcanReflect.eachKey(bindings.readyComputes || {}, function(value) {\n\t\t\t\t\tcanReflect.offValue(value.compute, value.handler, \"mutate\");\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Adds bindings.\n\t\t\tthis._bindings = {user: [], control: {}, readyComputes: {}};\n\t\t},\n\t\t// ## destroy\n\t\t//\n\t\t// Prepares a `control` for garbage collection.\n\t\t// First checks if it has already been removed. Then, removes all the bindings, data, and\n\t\t// the element from the Control instance.\n\t\tdestroy: function () {\n\t\t\tif (this.element === null) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tdev.warn(\"can-control: Control already destroyed\");\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar Class = this.constructor,\n\t\t\t\tpluginName = Class.pluginName || (Class.shortName && string.underscore(Class.shortName)),\n\t\t\t\tcontrols;\n\n\t\t\tthis.off();\n\n\t\t\tif (pluginName && pluginName !== 'can_control' && this.element.classList) {\n                this.element.classList.remove(pluginName);\n\t\t\t}\n\n\t\t\tcontrols = controlData.get(this.element);\n\t\t\tif (controls) {\n\t\t\t\tcontrols.splice(controls.indexOf(this), 1);\n\t\t\t}\n\n\t\t\t//canEvent.dispatch.call(this, \"destroyed\");\n\n\t\t\tthis.element = null;\n\t\t}\n\t});\n\n// ## Processors\n//\n// Processors do the binding. This basic processor binds events. Each returns a function that unbinds\n// when called.\nprocessors = Control.processors;\nbasicProcessor = function (el, event, selector, methodName, control) {\n\treturn binder(el, event, Control._shifter(control, methodName), selector);\n};\n\n// Set common events to be processed as a `basicProcessor`\n[\"beforeremove\", \"change\", \"click\", \"contextmenu\", \"dblclick\", \"keydown\", \"keyup\",\n\t\"keypress\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\",\n\t\"mouseup\", \"reset\", \"resize\", \"scroll\", \"select\", \"submit\", \"focusin\",\n\t\"focusout\", \"mouseenter\", \"mouseleave\",\n\t\"touchstart\", \"touchmove\", \"touchcancel\", \"touchend\", \"touchleave\",\n\t\"inserted\",\"removed\",\n\t\"dragstart\", \"dragenter\", \"dragover\", \"dragleave\", \"drag\", \"drop\", \"dragend\"\n].forEach(function (v) {\n\tprocessors[v] = basicProcessor;\n});\n\nmodule.exports = namespace.Control = Control;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-control/can-control.js?");

/***/ }),

/***/ "../../node_modules/can-data-types/maybe-boolean/maybe-boolean.js":
/*!***************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-data-types/maybe-boolean/maybe-boolean.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nfunction toBoolean(val) {\n\tif(val == null) {\n\t\treturn val;\n\t}\n\tif (val === 'false' || val === '0' || !val) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nmodule.exports = canReflect.assignSymbols(toBoolean,{\n\t\"can.new\": toBoolean,\n\t\"can.getSchema\": function(){\n\t\treturn {\n\t\t\ttype: \"Or\",\n\t\t\tvalues: [true, false, undefined, null]\n\t\t};\n\t},\n    \"can.getName\": function(){\n        return \"MaybeBoolean\";\n    },\n\t\"can.isMember\": function(value) {\n\t\treturn value == null || typeof value === \"boolean\";\n\t}\n});\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-data-types/maybe-boolean/maybe-boolean.js?");

/***/ }),

/***/ "../../node_modules/can-data-types/maybe-date/maybe-date.js":
/*!*********************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-data-types/maybe-date/maybe-date.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nfunction toDate(str) {\n\tvar type = typeof str;\n\tif (type === 'string') {\n\t\tstr = Date.parse(str);\n\t\treturn isNaN(str) ? null : new Date(str);\n\t} else if (type === 'number') {\n\t\treturn new Date(str);\n\t} else {\n\t\treturn str;\n\t}\n}\n\nfunction DateStringSet(dateStr){\n\tthis.setValue = dateStr;\n\tvar date = toDate(dateStr);\n\tthis.value = date == null ? date : date.getTime();\n}\nDateStringSet.prototype.valueOf = function(){\n\treturn this.value;\n};\ncanReflect.assignSymbols(DateStringSet.prototype,{\n\t\"can.serialize\": function(){\n\t\treturn this.setValue;\n\t}\n});\n\nmodule.exports = canReflect.assignSymbols(toDate,{\n\t\"can.new\": toDate,\n\t\"can.getSchema\": function(){\n\t\treturn {\n\t\t\ttype: \"Or\",\n\t\t\tvalues: [Date, undefined, null]\n\t\t};\n\t},\n\t\"can.ComparisonSetType\": DateStringSet,\n    \"can.getName\": function(){\n        return \"MaybeDate\";\n    },\n\t\"can.isMember\": function(value) {\n\t\treturn value == null || (value instanceof Date);\n\t}\n});\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-data-types/maybe-date/maybe-date.js?");

/***/ }),

/***/ "../../node_modules/can-data-types/maybe-number/maybe-number.js":
/*!*************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-data-types/maybe-number/maybe-number.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nfunction toNumber(val) {\n\tif (val == null) {\n\t\treturn val;\n\t}\n\treturn +(val);\n}\n\nmodule.exports = canReflect.assignSymbols(toNumber,{\n\t\"can.new\": toNumber,\n\t\"can.getSchema\": function(){\n\t\treturn {\n\t\t\ttype: \"Or\",\n\t\t\tvalues: [Number, undefined, null]\n\t\t};\n\t},\n    \"can.getName\": function(){\n        return \"MaybeNumber\";\n    },\n\t\"can.isMember\": function(value) {\n\t\treturn value == null || typeof value === \"number\";\n\t}\n});\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-data-types/maybe-number/maybe-number.js?");

/***/ }),

/***/ "../../node_modules/can-data-types/maybe-string/maybe-string.js":
/*!*************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-data-types/maybe-string/maybe-string.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nfunction toString(val) {\n\tif (val == null) {\n\t\treturn val;\n\t}\n\treturn '' + val;\n}\n\nmodule.exports = canReflect.assignSymbols(toString,{\n\t\"can.new\": toString,\n\t\"can.getSchema\": function(){\n\t\treturn {\n\t\t\ttype: \"Or\",\n\t\t\tvalues: [String, undefined, null]\n\t\t};\n\t},\n    \"can.getName\": function(){\n        return \"MaybeString\";\n    },\n\t\"can.isMember\": function(value) {\n\t\treturn value == null || typeof value === \"string\";\n\t}\n});\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-data-types/maybe-string/maybe-string.js?");

/***/ }),

/***/ "../../node_modules/can-define-lazy-value/define-lazy-value.js":
/*!************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-define-lazy-value/define-lazy-value.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-define-lazy-value\n * @parent can-js-utilities\n * @collection can-infrastructure\n * @package ./package.json\n * @signature `defineLazyValue(obj, prop, fn, writable)`\n *\n * Use Object.defineProperty to define properties whose values will be created lazily when they are first read.\n *\n * ```js\n * var _id = 1;\n * function getId() {\n *     return _id++;\n * }\n *\n * function MyObj(name) {\n *     this.name = name;\n * }\n *\n * defineLazyValue(MyObj.prototype, 'id', getId);\n *\n * var obj1 = new MyObj('obj1');\n * var obj2 = new MyObj('obj2');\n *\n * console.log( obj2 ); // -> { name: \"obj2\" }\n * console.log( obj1 ); // -> { name: \"obj1\" }\n *\n * // the first `id` read will get id `1`\n * console( obj2.id ); // -> 1\n * console( obj1.id ); // -> 2\n *\n * console.log( obj2 ); // -> { name: \"obj2\", id: 1 }\n * console.log( obj1 ); // -> { name: \"obj1\", id: 2 }\n *\n * ```\n *\n * @param {Object} object The object to add the property to.\n * @param {String} prop   The name of the property.\n * @param {Function} fn   A function to get the value the property should be set to.\n * @param {boolean} writable   Whether the field should be writable (false by default).\n */\nmodule.exports = function defineLazyValue(obj, prop, initializer, writable) {\n\tObject.defineProperty(obj, prop, {\n\t\tconfigurable: true,\n\t\tget: function() {\n\t\t\t// make the property writable\n\t\t\tObject.defineProperty(this, prop, {\n\t\t\t\tvalue: undefined,\n\t\t\t\twritable: true\n\t\t\t});\n\n\t\t\t// get the value from the initializer function\n\t\t\tvar value = initializer.call(this, obj, prop);\n\n\t\t\t// redefine the property to the value property\n\t\t\t// and reset the writable flag\n\t\t\tObject.defineProperty(this, prop, {\n\t\t\t\tvalue: value,\n\t\t\t\twritable: !!writable\n\t\t\t});\n\n\t\t\t// return the value\n\t\t\treturn value;\n\t\t},\n\t\tset: function(value){\n\t\t\tObject.defineProperty(this, prop, {\n\t\t\t\tvalue: value,\n\t\t\t\twritable: !!writable\n\t\t\t});\n\n\t\t\treturn value;\n\t\t}\n\t});\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-define-lazy-value/define-lazy-value.js?");

/***/ }),

/***/ "../../node_modules/can-define/can-define.js":
/*!******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-define/can-define.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\"format cjs\";\n\nvar ns = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar AsyncObservable = __webpack_require__(/*! can-simple-observable/async/async */ \"../../node_modules/can-simple-observable/async/async.js\");\nvar SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ \"../../node_modules/can-simple-observable/settable/settable.js\");\nvar ResolverObservable = __webpack_require__(/*! can-simple-observable/resolver/resolver */ \"../../node_modules/can-simple-observable/resolver/resolver.js\");\n\nvar eventQueue = __webpack_require__(/*! can-event-queue/map/map */ \"../../node_modules/can-event-queue/map/map.js\");\nvar addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ \"../../node_modules/can-event-queue/type/type.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\nvar canLogDev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\n\nvar stringToAny = __webpack_require__(/*! can-string-to-any */ \"../../node_modules/can-string-to-any/can-string-to-any.js\");\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"../../node_modules/can-define-lazy-value/define-lazy-value.js\");\n\nvar MaybeBoolean = __webpack_require__(/*! can-data-types/maybe-boolean/maybe-boolean */ \"../../node_modules/can-data-types/maybe-boolean/maybe-boolean.js\"),\n    MaybeDate = __webpack_require__(/*! can-data-types/maybe-date/maybe-date */ \"../../node_modules/can-data-types/maybe-date/maybe-date.js\"),\n    MaybeNumber = __webpack_require__(/*! can-data-types/maybe-number/maybe-number */ \"../../node_modules/can-data-types/maybe-number/maybe-number.js\"),\n    MaybeString = __webpack_require__(/*! can-data-types/maybe-string/maybe-string */ \"../../node_modules/can-data-types/maybe-string/maybe-string.js\");\n\nvar newSymbol = canSymbol.for(\"can.new\"),\n\tserializeSymbol = canSymbol.for(\"can.serialize\");\n\nvar eventsProto, define,\n\tmake, makeDefinition, getDefinitionsAndMethods, getDefinitionOrMethod;\n\n// UTILITIES\nfunction isDefineType(func){\n\treturn func && (func.canDefineType === true || func[newSymbol] );\n}\n\nvar peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));\n\nvar Object_defineNamedPrototypeProperty = Object.defineProperty;\n//!steal-remove-start\nif(true) {\n\tObject_defineNamedPrototypeProperty = function(obj, prop, definition) {\n\t\tif (definition.get) {\n\t\t\tObject.defineProperty(definition.get, \"name\", {\n\t\t\t\tvalue: \"get \"+canReflect.getName(obj) + \".\"+prop,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t}\n\t\tif (definition.set) {\n\t\t\tObject.defineProperty(definition.set, \"name\", {\n\t\t\t\tvalue:  \"set \"+canReflect.getName(obj) + \".\"+prop\n\t\t\t});\n\t\t}\n\t\treturn Object.defineProperty(obj, prop, definition);\n\t};\n}\n//!steal-remove-end\n\n\nfunction defineConfigurableAndNotEnumerable(obj, prop, value) {\n\tObject.defineProperty(obj, prop, {\n\t\tconfigurable: true,\n\t\tenumerable: false,\n\t\twritable: true,\n\t\tvalue: value\n\t});\n}\n\nfunction eachPropertyDescriptor(map, cb){\n\tfor(var prop in map) {\n\t\tif(map.hasOwnProperty(prop)) {\n\t\t\tcb.call(map, prop, Object.getOwnPropertyDescriptor(map,prop));\n\t\t}\n\t}\n}\n\nfunction cleanUpDefinition(prop, definition, shouldWarn){\n\t// cleanup `value` -> `default`\n\tif(definition.value !== undefined && ( typeof definition.value !== \"function\" || definition.value.length === 0) ){\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif(shouldWarn) {\n\t\t\t\tcanLogDev.warn(\n\t\t\t\t\t\"can-define: Change the 'value' definition for \" + prop + \" to 'default'.\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tdefinition.default = definition.value;\n\t\tdelete definition.value;\n\t}\n\t// cleanup `Value` -> `DEFAULT`\n\tif(definition.Value !== undefined  ){\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif(shouldWarn) {\n\t\t\t\tcanLogDev.warn(\n\t\t\t\t\t\"can-define: Change the 'Value' definition for \" + prop + \" to 'Default'.\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t\tdefinition.Default = definition.Value;\n\t\tdelete definition.Value;\n\t}\n}\n\nfunction isValueResolver(definition) {\n\t// there's a function and it has one argument\n\treturn typeof definition.value === \"function\" && definition.value.length;\n}\n\nmodule.exports = define = ns.define = function(typePrototype, defines, baseDefine) {\n\t// default property definitions on _data\n\tvar prop,\n\t\tdataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null),\n\t\t// computed property definitions on _computed\n\t\tcomputedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);\n\n\tvar result = getDefinitionsAndMethods(defines, baseDefine);\n\tresult.dataInitializers = dataInitializers;\n\tresult.computedInitializers = computedInitializers;\n\n\n\t// Goes through each property definition and creates\n\t// a `getter` and `setter` function for `Object.defineProperty`.\n\tcanReflect.eachKey(result.definitions, function(definition, property){\n\t\tdefine.property(typePrototype, property, definition, dataInitializers, computedInitializers, result.defaultDefinition);\n\t});\n\n\t// Places a `_data` on the prototype that when first called replaces itself\n\t// with a `_data` object local to the instance.  It also defines getters\n\t// for any value that has a default value.\n\tif(typePrototype.hasOwnProperty(\"_data\")) {\n\t\tfor (prop in dataInitializers) {\n\t\t\tdefineLazyValue(typePrototype._data, prop, dataInitializers[prop].bind(typePrototype), true);\n\t\t}\n\t} else {\n\t\tdefineLazyValue(typePrototype, \"_data\", function() {\n\t\t\tvar map = this;\n\t\t\tvar data = {};\n\t\t\tfor (var prop in dataInitializers) {\n\t\t\t\tdefineLazyValue(data, prop, dataInitializers[prop].bind(map), true);\n\t\t\t}\n\t\t\treturn data;\n\t\t});\n\t}\n\n\t// Places a `_computed` on the prototype that when first called replaces itself\n\t// with a `_computed` object local to the instance.  It also defines getters\n\t// that will create the property's compute when read.\n\tif(typePrototype.hasOwnProperty(\"_computed\")) {\n\t\tfor (prop in computedInitializers) {\n\t\t\tdefineLazyValue(typePrototype._computed, prop, computedInitializers[prop].bind(typePrototype));\n\t\t}\n\t} else {\n\t\tdefineLazyValue(typePrototype, \"_computed\", function() {\n\t\t\tvar map = this;\n\t\t\tvar data = Object.create(null);\n\t\t\tfor (var prop in computedInitializers) {\n\t\t\t\tdefineLazyValue(data, prop, computedInitializers[prop].bind(map));\n\t\t\t}\n\t\t\treturn data;\n\t\t});\n\t}\n\n\t// Add necessary event methods to this object.\n\tfor (prop in eventsProto) {\n\t\tObject.defineProperty(typePrototype, prop, {\n\t\t\tenumerable: false,\n\t\t\tvalue: eventsProto[prop],\n\t\t\tconfigurable: true,\n\t\t\twritable: true\n\t\t});\n\t}\n\t// add so instance defs can be dynamically added\n\tObject.defineProperty(typePrototype,\"_define\",{\n\t\tenumerable: false,\n\t\tvalue: result,\n\t\tconfigurable: true,\n\t\twritable: true\n\t});\n\n\t// Places Symbol.iterator or @@iterator on the prototype\n\t// so that this can be iterated with for/of and canReflect.eachIndex\n\tvar iteratorSymbol = canSymbol.iterator || canSymbol.for(\"iterator\");\n\tif(!typePrototype[iteratorSymbol]) {\n\t\tdefineConfigurableAndNotEnumerable(typePrototype, iteratorSymbol, function(){\n\t\t\treturn new define.Iterator(this);\n\t\t});\n\t}\n\n\treturn result;\n};\n\nvar onlyType = function(obj){\n\tfor(var prop in obj) {\n\t\tif(prop !== \"type\") {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\ndefine.extensions = function () {};\n\n// typePrototype - the prototype of the type we are defining `prop` on.\n// `definition` - the user provided definition\ndefine.property = function(typePrototype, prop, definition, dataInitializers, computedInitializers, defaultDefinition) {\n\tvar propertyDefinition = define.extensions.apply(this, arguments);\n\n\tif (propertyDefinition) {\n\t\tdefinition = makeDefinition(prop, propertyDefinition, defaultDefinition || {});\n\t}\n\n\tvar type = definition.type;\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tif (type && canReflect.isConstructorLike(type) && !isDefineType(type)) {\n\t\t\tcanLogDev.warn(\n\t\t\t\t\"can-define: the definition for \" +\n\t\t\t\tprop +\n\t\t\t\t(typePrototype.constructor.shortName ? \" on \" + typePrototype.constructor.shortName : \"\") +\n\t\t\t\t\" uses a constructor for \\\"type\\\". Did you mean \\\"Type\\\"?\"\n\t\t\t);\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// Special case definitions that have only `type: \"*\"`.\n\tif (type && onlyType(definition) && type === define.types[\"*\"]) {\n\t\tObject_defineNamedPrototypeProperty(typePrototype, prop, {\n\t\t\tget: make.get.data(prop),\n\t\t\tset: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t\treturn;\n\t}\n\tdefinition.type = type;\n\n\t// Where the value is stored.  If there is a `get` the source of the value\n\t// will be a compute in `this._computed[prop]`.  If not, the source of the\n\t// value will be in `this._data[prop]`.\n\tvar dataProperty = definition.get || isValueResolver(definition) ? \"computed\" : \"data\",\n\n\t\t// simple functions that all read/get/set to the right place.\n\t\t// - reader - reads the value but does not observe.\n\t\t// - getter - reads the value and notifies observers.\n\t\t// - setter - sets the value.\n\t\treader = make.read[dataProperty](prop),\n\t\tgetter = make.get[dataProperty](prop),\n\t\tsetter = make.set[dataProperty](prop),\n\t\tgetInitialValue;\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tif (definition.get) {\n\t\t\tObject.defineProperty(definition.get, \"name\", {\n\t\t\t\tvalue: canReflect.getName(typePrototype) + \"'s \" + prop + \" getter\",\n\t\t\t});\n\t\t}\n\t\tif (definition.set) {\n\t\t\tObject.defineProperty(definition.set, \"name\", {\n\t\t\t\tvalue: canReflect.getName(typePrototype) + \"'s \" + prop + \" setter\",\n\t\t\t});\n\t\t}\n\t\tif(isValueResolver(definition)) {\n\t\t\tObject.defineProperty(definition.value, \"name\", {\n\t\t\t\tvalue: canReflect.getName(typePrototype) + \"'s \" + prop + \" value\",\n\t\t\t});\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// Determine the type converter\n\tvar typeConvert = function(val) {\n\t\treturn val;\n\t};\n\n\tif (definition.Type) {\n\t\ttypeConvert = make.set.Type(prop, definition.Type, typeConvert);\n\t}\n\tif (type) {\n\t\ttypeConvert = make.set.type(prop, type, typeConvert);\n\t}\n\n\t// make a setter that's going to fire of events\n\tvar eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));\n\tif(isValueResolver(definition)) {\n\t\tcomputedInitializers[prop] = make.valueResolver(prop, definition, typeConvert);\n\t}\n\t// Determine a function that will provide the initial property value.\n\telse if ((definition.default !== undefined || definition.Default !== undefined)) {\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\t// If value is an object or array, give a warning\n\t\t\tif (definition.default !== null && typeof definition.default === 'object') {\n\t\t\t\tcanLogDev.warn(\"can-define: The default value for \" + prop + \" is set to an object. This will be shared by all instances of the DefineMap. Use a function that returns the object instead.\");\n\t\t\t}\n\t\t\t// If value is a constructor, give a warning\n\t\t\tif (definition.default && canReflect.isConstructorLike(definition.default)) {\n\t\t\t\tcanLogDev.warn(\"can-define: The \\\"default\\\" for \" + prop + \" is set to a constructor. Did you mean \\\"Default\\\" instead?\");\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tgetInitialValue = ObservationRecorder.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));\n\t}\n\n\t// If property has a getter, create the compute that stores its data.\n\tif (definition.get) {\n\t\tcomputedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);\n\t}\n\t// If the property isn't a getter, but has an initial value, setup a\n\t// default value on `this._data[prop]`.\n\telse if (getInitialValue) {\n\t\tdataInitializers[prop] = getInitialValue;\n\t}\n\n\n\t// Define setter behavior.\n\n\t// If there's a `get` and `set`, make the setter get the `lastSetValue` on the\n\t// `get`'s compute.\n\tif (definition.get && definition.set) {\n\t\t// the compute will set off events, so we can use the basic setter\n\t\tsetter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);\n\t}\n\t// If there's a `set` and no `get`,\n\telse if (definition.set) {\n\t\t// Add `set` functionality to the eventSetter.\n\t\tsetter = make.set.setter(prop, definition.set, reader, eventsSetter, false);\n\t}\n\t// If there's neither `set` or `get` or `value` (resolver)\n\telse if (dataProperty === \"data\") {\n\t\t// make a set that produces events.\n\t\tsetter = eventsSetter;\n\t}\n\t// If there's zero-arg `get` but not `set`, warn on all sets in dev mode\n\telse if (definition.get && definition.get.length < 1) {\n\t\tsetter = function() {\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tcanLogDev.warn(\"can-define: Set value for property \" +\n\t\t\t\t\tprop +\n\t\t\t\t\t(typePrototype.constructor.shortName ? \" on \" + typePrototype.constructor.shortName : \"\") +\n\t\t\t\t\t\" ignored, as its definition has a zero-argument getter and no setter\");\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t};\n\t}\n\n\n\t// Add type behavior to the setter.\n\tif (type) {\n\t\tsetter = make.set.type(prop, type, setter);\n\t}\n\tif (definition.Type) {\n\t\tsetter = make.set.Type(prop, definition.Type, setter);\n\t}\n\n\t// Define the property.\n\tObject_defineNamedPrototypeProperty(typePrototype, prop, {\n\t\tget: getter,\n\t\tset: setter,\n\t\tenumerable: \"serialize\" in definition ? !!definition.serialize : !definition.get,\n\t\tconfigurable: true\n\t});\n};\ndefine.makeDefineInstanceKey = function(constructor) {\n\tconstructor[canSymbol.for(\"can.defineInstanceKey\")] = function(property, value) {\n\t\tvar defineResult = this.prototype._define;\n\t\tif(typeof value === \"object\") {\n\t\t\t// change `value` to default.\n\t\t\tcleanUpDefinition(property, value, false);\n\t\t}\n\t\tvar definition = getDefinitionOrMethod(property, value, defineResult.defaultDefinition);\n\t\tif(definition && typeof definition === \"object\") {\n\t\t\tdefine.property(constructor.prototype, property, definition, defineResult.dataInitializers, defineResult.computedInitializers, defineResult.defaultDefinition);\n\t\t\tdefineResult.definitions[property] = definition;\n\t\t} else {\n\t\t\tdefineResult.methods[property] = definition;\n\t\t}\n\t};\n};\n\n// Makes a simple constructor function.\ndefine.Constructor = function(defines, sealed) {\n\tvar constructor = function(props) {\n\t\tObject.defineProperty(this,\"__inSetup\",{\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: true,\n\t\t\twritable: true\n\t\t});\n\t\tdefine.setup.call(this, props, sealed);\n\t\tthis.__inSetup = false;\n\t};\n\tvar result = define(constructor.prototype, defines);\n\taddTypeEvents(constructor);\n\tdefine.makeDefineInstanceKey(constructor, result);\n\treturn constructor;\n};\n\n// A bunch of helper functions that are used to create various behaviors.\nmake = {\n\n\tcomputeObj: function(map, prop, observable) {\n\t\tvar computeObj = {\n\t\t\toldValue: undefined,\n\t\t\tcompute: observable,\n\t\t\tcount: 0,\n\t\t\thandler: function(newVal) {\n\t\t\t\tvar oldValue = computeObj.oldValue;\n\t\t\t\tcomputeObj.oldValue = newVal;\n\n\t\t\t\tmap.dispatch({\n\t\t\t\t\ttype: prop,\n\t\t\t\t\ttarget: map\n\t\t\t\t}, [newVal, oldValue]);\n\t\t\t}\n\t\t};\n\t\treturn computeObj;\n\t},\n\tvalueResolver: function(prop, definition, typeConvert) {\n\t\treturn function(){\n\t\t\tvar map = this;\n\t\t\tvar computeObj = make.computeObj(map, prop, new ResolverObservable(definition.value, map));\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tObject.defineProperty(computeObj.handler, \"name\", {\n\t\t\t\t\tvalue: canReflect.getName(definition.value).replace('value', 'event emitter')\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\treturn computeObj;\n\t\t};\n\t},\n\t// Returns a function that creates the `_computed` prop.\n\tcompute: function(prop, get, defaultValueFn) {\n\n\t\treturn function() {\n\t\t\tvar map = this,\n\t\t\t\tdefaultValue = defaultValueFn && defaultValueFn.call(this),\n\t\t\t\tobservable, computeObj;\n\n\t\t\tif(get.length === 0) {\n\t\t\t\tobservable = new Observation(get, map);\n\t\t\t} else if(get.length === 1) {\n\t\t\t\tobservable = new SettableObservable(get, map, defaultValue);\n\t\t\t} else {\n\t\t\t\tobservable = new AsyncObservable(get, map, defaultValue);\n\t\t\t}\n\n\t\t\tcomputeObj = make.computeObj(map, prop, observable);\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tObject.defineProperty(computeObj.handler, \"name\", {\n\t\t\t\t\tvalue: canReflect.getName(get).replace('getter', 'event emitter')\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn computeObj;\n\t\t};\n\t},\n\t// Set related helpers.\n\tset: {\n\t\tdata: function(prop) {\n\t\t\treturn function(newVal) {\n\t\t\t\tthis._data[prop] = newVal;\n\t\t\t};\n\t\t},\n\t\tcomputed: function(prop) {\n\t\t\treturn function(val) {\n\t\t\t\tcanReflect.setValue( this._computed[prop].compute, val );\n\t\t\t};\n\t\t},\n\t\tevents: function(prop, getCurrent, setData, eventType) {\n\t\t\treturn function(newVal) {\n\t\t\t\tif (this.__inSetup) {\n\t\t\t\t\tsetData.call(this, newVal);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar current = getCurrent.call(this);\n\t\t\t\t\tif (newVal !== current) {\n\t\t\t\t\t\tvar dispatched;\n\t\t\t\t\t\tsetData.call(this, newVal);\n\n\t\t\t\t\t\tdispatched = {\n\t\t\t\t\t\t\tpatches: [{type: \"set\", key: prop, value: newVal}],\n\t\t\t\t\t\t\ttype: prop,\n\t\t\t\t\t\t\ttarget: this\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif(true) {\n\t\t\t\t\t\t\tdispatched.reasonLog = [ canReflect.getName(this) + \"'s\", prop, \"changed to\", newVal, \"from\", current ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\t\tthis.dispatch(dispatched, [newVal, current]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\tsetter: function(prop, setter, getCurrent, setEvents, hasGetter) {\n\t\t\treturn function(value) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tvar asyncTimer;\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\tvar self = this;\n\n\t\t\t\t// call the setter, if returned value is undefined,\n\t\t\t\t// this means the setter is async so we\n\t\t\t\t// do not call update property and return right away\n\n\t\t\t\tqueues.batch.start();\n\t\t\t\tvar setterCalled = false,\n\t\t\t\t\tcurrent = getCurrent.call(this),\n\t\t\t\t\tsetValue = setter.call(this, value, function(value) {\n\t\t\t\t\t\tsetEvents.call(self, value);\n\n\t\t\t\t\t\tsetterCalled = true;\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif(true) {\n\t\t\t\t\t\t\tclearTimeout(asyncTimer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t}, current);\n\n\t\t\t\tif (setterCalled) {\n\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t} else {\n\t\t\t\t\tif (hasGetter) {\n\t\t\t\t\t\t// we got a return value\n\t\t\t\t\t\tif (setValue !== undefined) {\n\t\t\t\t\t\t\t// if the current `set` value is returned, don't set\n\t\t\t\t\t\t\t// because current might be the `lastSetVal` of the internal compute.\n\t\t\t\t\t\t\tif (current !== setValue) {\n\t\t\t\t\t\t\t\tsetEvents.call(this, setValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// this is a side effect, it didn't take a value\n\t\t\t\t\t\t// so use the original set value\n\t\t\t\t\t\telse if (setter.length === 0) {\n\t\t\t\t\t\t\tsetEvents.call(this, value);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// it took a value\n\t\t\t\t\t\telse if (setter.length === 1) {\n\t\t\t\t\t\t\t// if we have a getter, and undefined was returned,\n\t\t\t\t\t\t\t// we should assume this is setting the getters properties\n\t\t\t\t\t\t\t// and we shouldn't do anything.\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// we are expecting something\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\tif(true) {\n\t\t\t\t\t\t\t\tasyncTimer = setTimeout(function() {\n\t\t\t\t\t\t\t\t\tcanLogDev.warn('can/map/setter.js: Setter \"' + prop + '\" did not return a value or call the setter callback.');\n\t\t\t\t\t\t\t\t}, canLogDev.warnTimeout);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we got a return value\n\t\t\t\t\t\tif (setValue !== undefined) {\n\t\t\t\t\t\t\t// if the current `set` value is returned, don't set\n\t\t\t\t\t\t\t// because current might be the `lastSetVal` of the internal compute.\n\t\t\t\t\t\t\tsetEvents.call(this, setValue);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// this is a side effect, it didn't take a value\n\t\t\t\t\t\t// so use the original set value\n\t\t\t\t\t\telse if (setter.length === 0) {\n\t\t\t\t\t\t\tsetEvents.call(this, value);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// it took a value\n\t\t\t\t\t\telse if (setter.length === 1) {\n\t\t\t\t\t\t\t// if we don't have a getter, we should probably be setting the\n\t\t\t\t\t\t\t// value to undefined\n\t\t\t\t\t\t\tsetEvents.call(this, undefined);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// we are expecting something\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\tif(true) {\n\t\t\t\t\t\t\t\tasyncTimer = setTimeout(function() {\n\t\t\t\t\t\t\t\t\tcanLogDev.warn('can/map/setter.js: Setter \"' + prop + '\" did not return a value or call the setter callback.');\n\t\t\t\t\t\t\t\t}, canLogDev.warnTimeout);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\ttype: function(prop, type, set) {\n\t\t\tfunction setter(newValue) {\n\t\t\t\treturn set.call(this, type.call(this, newValue, prop));\n\t\t\t}\n\t\t\tif(isDefineType(type)) {\n\t\t\t\t// TODO: remove this `canDefineType` check in a future release.\n\t\t\t\tif(type.canDefineType) {\n\t\t\t\t\treturn setter;\n\t\t\t\t} else {\n\t\t\t\t\treturn function setter(newValue){\n\t\t\t\t\t\treturn set.call(this, canReflect.convert(newValue, type));\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If type is a nested object: `type: {foo: \"string\", bar: \"number\"}`\n\t\t\tif (typeof type === \"object\") {\n\t\t\t\treturn make.set.Type(prop, type, set);\n\t\t\t} else {\n\t\t\t\treturn setter;\n\t\t\t}\n\t\t},\n\t\tType: function(prop, Type, set) {\n\t\t\t// `type`: {foo: \"string\"}\n\t\t\tif(Array.isArray(Type) && define.DefineList) {\n\t\t\t\tType = define.DefineList.extend({\n\t\t\t\t\t\"#\": Type[0]\n\t\t\t\t});\n\t\t\t} else if (typeof Type === \"object\") {\n\t\t\t\tif(define.DefineMap) {\n\t\t\t\t\tType = define.DefineMap.extend(Type);\n\t\t\t\t} else {\n\t\t\t\t\tType = define.Constructor(Type);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function(newValue) {\n\t\t\t\tif (newValue instanceof Type || newValue == null) {\n\t\t\t\t\treturn set.call(this, newValue);\n\t\t\t\t} else {\n\t\t\t\t\treturn set.call(this, new Type(newValue));\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\t// Helpes that indicate what the event type should be.  These probably aren't needed.\n\teventType: {\n\t\tdata: function(prop) {\n\t\t\treturn function(newVal, oldVal) {\n\t\t\t\treturn oldVal !== undefined || this._data.hasOwnProperty(prop) ? \"set\" : \"add\";\n\t\t\t};\n\t\t},\n\t\tcomputed: function() {\n\t\t\treturn function() {\n\t\t\t\treturn \"set\";\n\t\t\t};\n\t\t}\n\t},\n\t// Helpers that read the data in a non-observable way.\n\tread: {\n\t\tdata: function(prop) {\n\t\t\treturn function() {\n\t\t\t\treturn this._data[prop];\n\t\t\t};\n\t\t},\n\t\tcomputed: function(prop) {\n\t\t\t// might want to protect this\n\t\t\treturn function() {\n\t\t\t\treturn canReflect.getValue( this._computed[prop].compute );\n\t\t\t};\n\t\t},\n\t\tlastSet: function(prop) {\n\t\t\treturn function() {\n\t\t\t\tvar observable = this._computed[prop].compute;\n\t\t\t\tif(observable.lastSetValue) {\n\t\t\t\t\treturn canReflect.getValue(observable.lastSetValue);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\t// Helpers that read the data in an observable way.\n\tget: {\n\t\t// uses the default value\n\t\tdefaultValue: function(prop, definition, typeConvert, callSetter) {\n\t\t\treturn function() {\n\t\t\t\tvar value = definition.default;\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tif (typeof value === \"function\") {\n\t\t\t\t\t\tvalue = value.call(this);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = typeConvert.call(this, value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar Default = definition.Default;\n\t\t\t\t\tif (Default) {\n\t\t\t\t\t\tvalue = typeConvert.call(this,new Default());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(definition.set) {\n\t\t\t\t\t// TODO: there's almost certainly a faster way of making this happen\n\t\t\t\t\t// But this is maintainable.\n\n\t\t\t\t\tvar VALUE;\n\t\t\t\t\tvar sync = true;\n\n\t\t\t\t\tvar setter = make.set.setter(prop, definition.set, function(){}, function(value){\n\t\t\t\t\t\tif(sync) {\n\t\t\t\t\t\t\tVALUE = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallSetter.call(this, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, definition.get);\n\n\t\t\t\t\tsetter.call(this,value);\n\t\t\t\t\tsync= false;\n\n\t\t\t\t\t// VALUE will be undefined if the callback is never called.\n\t\t\t\t\treturn VALUE;\n\n\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t};\n\t\t},\n\t\tdata: function(prop) {\n\t\t\treturn function() {\n\t\t\t\tif (!this.__inSetup) {\n\t\t\t\t\tObservationRecorder.add(this, prop);\n\t\t\t\t}\n\n\t\t\t\treturn this._data[prop];\n\t\t\t};\n\t\t},\n\t\tcomputed: function(prop) {\n\t\t\treturn function(val) {\n\t\t\t\tvar compute = this._computed[prop].compute;\n\t\t\t\tif (ObservationRecorder.isRecording()) {\n\t\t\t\t\tObservationRecorder.add(this, prop);\n\t\t\t\t\tif (!canReflect.isBound(compute)) {\n\t\t\t\t\t\tObservation.temporarilyBind(compute);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn peek(compute);\n\t\t\t};\n\t\t}\n\t}\n};\n\ndefine.behaviors = [\"get\", \"set\", \"value\", \"Value\", \"type\", \"Type\", \"serialize\"];\n\n// This cleans up a particular behavior and adds it to the definition\nvar addBehaviorToDefinition = function(definition, behavior, value) {\n\tif(behavior === \"enumerable\") {\n\t\t// treat enumerable like serialize\n\t\tdefinition.serialize = !!value;\n\t}\n\telse if(behavior === \"type\") {\n\t\tvar behaviorDef = value;\n\t\tif(typeof behaviorDef === \"string\") {\n\t\t\tbehaviorDef = define.types[behaviorDef];\n\t\t\tif(typeof behaviorDef === \"object\" && !isDefineType(behaviorDef)) {\n\t\t\t\tassign(definition, behaviorDef);\n\t\t\t\tbehaviorDef = behaviorDef[behavior];\n\t\t\t}\n\t\t}\n\t\tif (typeof behaviorDef !== 'undefined') {\n\t\t\tdefinition[behavior] = behaviorDef;\n\t\t}\n\t}\n\telse {\n\t\tdefinition[behavior] = value;\n\t}\n};\n\n// This is called by `define.property` AND `getDefinitionOrMethod` (which is called by `define`)\n// Currently, this is adding default behavior\n// copying `type` over, and even cleaning up the final definition object\nmakeDefinition = function(prop, def, defaultDefinition) {\n\tvar definition = {};\n\n\tcanReflect.eachKey(def, function(value, behavior) {\n\t\taddBehaviorToDefinition(definition, behavior, value);\n\t});\n\t// only add default if it doesn't exist\n\tcanReflect.eachKey(defaultDefinition, function(value, prop){\n\t\tif(definition[prop] === undefined) {\n\t\t\tif(prop !== \"type\" && prop !== \"Type\") {\n\t\t\t\tdefinition[prop] = value;\n\t\t\t}\n\t\t}\n\t});\n\n\t// normalize Type that implements can.new\n\tif(def.Type) {\n\t\tvar value = def.Type;\n\n\t\tvar serialize = value[serializeSymbol];\n\t\tif(serialize) {\n\t\t\tdefinition.serialize = function(val){\n\t\t\t\treturn serialize.call(val);\n\t\t\t};\n\t\t}\n\t\tif(value[newSymbol]) {\n\t\t\tdefinition.type = value[newSymbol];\n\t\t\tdelete definition.Type;\n\t\t}\n\t}\n\n\t// We only want to add a defaultDefinition if def.type is not a string\n\t// if def.type is a string it is handled in addDefinition\n\tif(typeof def.type !== 'string') {\n\t\t// if there's no type definition, take it from the defaultDefinition\n\t\tif(!definition.type && !definition.Type) {\n            var defaultsCopy = canReflect.assignMap({},defaultDefinition);\n            definition = canReflect.assignMap(defaultsCopy, definition);\n\t\t}\n\n\t\tif( canReflect.size(definition) === 0 ) {\n\t\t\tdefinition.type = define.types[\"*\"];\n\t\t}\n\t}\n\tcleanUpDefinition(prop, definition, true);\n\treturn definition;\n};\n\n// called by `can.defineInstanceKey` and `getDefinitionsAndMethods`\n// returns the value or the definition object.\n// calls makeDefinition\n// This is dealing with a string value\ngetDefinitionOrMethod = function(prop, value, defaultDefinition){\n\t// Clean up the value to make it a definition-like object\n\tvar definition;\n\tif(typeof value === \"string\") {\n\t\tdefinition = {type: value};\n\t}\n    // copies a `Type`'s methods over\n\telse if(value && (value[serializeSymbol] || value[newSymbol]) ) {\n\t\tdefinition = { Type: value };\n\t}\n\telse if(typeof value === \"function\") {\n\t\tif(canReflect.isConstructorLike(value)) {\n\t\t\tdefinition = {Type: value};\n\t\t}\n\t\t// or leaves as a function\n\t} else if( Array.isArray(value) ) {\n\t\tdefinition = {Type: value};\n\t} else if( canReflect.isPlainObject(value) ){\n\t\tdefinition = value;\n\t}\n\n\tif(definition) {\n\t\treturn makeDefinition(prop, definition, defaultDefinition);\n\t}\n\telse {\n\t\treturn value;\n\t}\n};\n// called by can.define\ngetDefinitionsAndMethods = function(defines, baseDefines) {\n\t// make it so the definitions include base definitions on the proto\n\tvar definitions = Object.create(baseDefines ? baseDefines.definitions : null);\n\tvar methods = {};\n\t// first lets get a default if it exists\n\tvar defaults = defines[\"*\"],\n\t\tdefaultDefinition;\n\tif(defaults) {\n\t\tdelete defines[\"*\"];\n\t\tdefaultDefinition = getDefinitionOrMethod(\"*\", defaults, {});\n\t} else {\n\t\tdefaultDefinition = Object.create(null);\n\t}\n\n\teachPropertyDescriptor(defines, function( prop, propertyDescriptor ) {\n\n\t\tvar value;\n\t\tif(propertyDescriptor.get || propertyDescriptor.set) {\n\t\t\tvalue = {get: propertyDescriptor.get, set: propertyDescriptor.set};\n\t\t} else {\n\t\t\tvalue = propertyDescriptor.value;\n\t\t}\n\n\t\tif(prop === \"constructor\") {\n\t\t\tmethods[prop] = value;\n\t\t\treturn;\n\t\t} else {\n\t\t\tvar result = getDefinitionOrMethod(prop, value, defaultDefinition);\n\t\t\tif(result && typeof result === \"object\" && canReflect.size(result) > 0) {\n\t\t\t\tdefinitions[prop] = result;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Removed adding raw values that are not functions\n\t\t\t\tif (typeof result === 'function') {\n\t\t\t\t\tmethods[prop] = result;\n\t\t\t\t}\n\t\t\t\t//!steal-remove-start\n\t\t\t\telse if (typeof result !== 'undefined') {\n\t\t\t\t\tif(true) {\n                    \t// Ex: {prop: 0}\n\t\t\t\t\t\tcanLogDev.error(prop + (this.constructor.shortName ? \" on \" + this.constructor.shortName : \"\") + \" does not match a supported propDefinition. See: https://canjs.com/doc/can-define.types.propDefinition.html\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t}\n\t\t}\n\t});\n\tif(defaults) {\n\t\tdefines[\"*\"] = defaults;\n\t}\n\treturn {definitions: definitions, methods: methods, defaultDefinition: defaultDefinition};\n};\n\neventsProto = eventQueue({});\n\nfunction setupComputed(instance, eventName) {\n\tvar computedBinding = instance._computed && instance._computed[eventName];\n\tif (computedBinding && computedBinding.compute) {\n\t\tif (!computedBinding.count) {\n\t\t\tcomputedBinding.count = 1;\n\t\t\tcanReflect.onValue(computedBinding.compute, computedBinding.handler, \"notify\");\n\t\t\tcomputedBinding.oldValue = canReflect.getValue(computedBinding.compute);\n\t\t} else {\n\t\t\tcomputedBinding.count++;\n\t\t}\n\n\t}\n}\nfunction teardownComputed(instance, eventName){\n\tvar computedBinding = instance._computed && instance._computed[eventName];\n\tif (computedBinding) {\n\t\tif (computedBinding.count === 1) {\n\t\t\tcomputedBinding.count = 0;\n\t\t\tcanReflect.offValue(computedBinding.compute, computedBinding.handler,\"notify\");\n\t\t} else {\n\t\t\tcomputedBinding.count--;\n\t\t}\n\t}\n}\n\nvar canMetaSymbol = canSymbol.for(\"can.meta\");\nassign(eventsProto, {\n\t_eventSetup: function() {},\n\t_eventTeardown: function() {},\n\taddEventListener: function(eventName, handler, queue) {\n\t\tsetupComputed(this, eventName);\n\t\treturn eventQueue.addEventListener.apply(this, arguments);\n\t},\n\n\t// ### unbind\n\t// Stops listening to an event.\n\t// If this is the last listener of a computed property,\n\t// stop forwarding events of the computed property to this map.\n\tremoveEventListener: function(eventName, handler) {\n\t\tteardownComputed(this, eventName);\n\t\treturn eventQueue.removeEventListener.apply(this, arguments);\n\n\t}\n});\neventsProto.on = eventsProto.bind = eventsProto.addEventListener;\neventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;\n\n\nvar onKeyValueSymbol = canSymbol.for(\"can.onKeyValue\");\nvar offKeyValueSymbol = canSymbol.for(\"can.offKeyValue\");\n\ncanReflect.assignSymbols(eventsProto,{\n\t\"can.onKeyValue\": function(key){\n\t\tsetupComputed(this, key);\n\t\treturn eventQueue[onKeyValueSymbol].apply(this, arguments);\n\t},\n\t\"can.offKeyValue\": function(key){\n\t\tteardownComputed(this, key);\n\t\treturn eventQueue[offKeyValueSymbol].apply(this, arguments);\n\t}\n});\n\ndelete eventsProto.one;\n\ndefine.setup = function(props, sealed) {\n\tObject.defineProperty(this,\"constructor\", {value: this.constructor, enumerable: false, writable: false});\n\tObject.defineProperty(this,canMetaSymbol, {value: Object.create(null), enumerable: false, writable: false});\n\n\t/* jshint -W030 */\n\n\tvar definitions = this._define.definitions;\n\tvar instanceDefinitions = Object.create(null);\n\tvar map = this;\n\tcanReflect.eachKey(props, function(value, prop){\n\t\tif(definitions[prop] !== undefined) {\n\t\t\tmap[prop] = value;\n\t\t} else {\n\t\t\tvar def = define.makeSimpleGetterSetter(prop);\n\t\t\tinstanceDefinitions[prop] = {};\n\t\t\tObject_defineNamedPrototypeProperty(map, prop, def);\n\t\t\t// possibly convert value to List or DefineMap\n\t\t\tmap[prop] = define.types.observable(value);\n\t\t}\n\t});\n\tif(canReflect.size(instanceDefinitions) > 0) {\n\t\tdefineConfigurableAndNotEnumerable(this, \"_instanceDefinitions\", instanceDefinitions);\n\t}\n\t// only seal in dev mode for performance reasons.\n\t//!steal-remove-start\n\tif(true) {\n\t\tthis._data;\n\t\tthis._computed;\n\t\tif(sealed !== false) {\n\t\t\tObject.seal(this);\n\t\t}\n\t}\n\t//!steal-remove-end\n};\ndefine.replaceWith = defineLazyValue;\ndefine.eventsProto = eventsProto;\ndefine.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;\ndefine.make = make;\ndefine.getDefinitionOrMethod = getDefinitionOrMethod;\nvar simpleGetterSetters = {};\ndefine.makeSimpleGetterSetter = function(prop){\n\tif(simpleGetterSetters[prop] === undefined) {\n\n\t\tvar setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop) );\n\n\t\tsimpleGetterSetters[prop] = {\n\t\t\tget: make.get.data(prop),\n\t\t\tset: function(newVal){\n\t\t\t\treturn setter.call(this, define.types.observable(newVal));\n\t\t\t},\n\t\t\tenumerable: true,\n            configurable: true\n\t\t};\n\t}\n\treturn simpleGetterSetters[prop];\n};\n\ndefine.Iterator = function(obj){\n\tthis.obj = obj;\n\tthis.definitions = Object.keys(obj._define.definitions);\n\tthis.instanceDefinitions = obj._instanceDefinitions ?\n\t\tObject.keys(obj._instanceDefinitions) :\n\t\tObject.keys(obj);\n\tthis.hasGet = typeof obj.get === \"function\";\n};\n\ndefine.Iterator.prototype.next = function(){\n\tvar key;\n\tif(this.definitions.length) {\n\t\tkey = this.definitions.shift();\n\n\t\t// Getters should not be enumerable\n\t\tvar def = this.obj._define.definitions[key];\n\t\tif(def.get) {\n\t\t\treturn this.next();\n\t\t}\n\t} else if(this.instanceDefinitions.length) {\n\t\tkey = this.instanceDefinitions.shift();\n\t} else {\n\t\treturn {\n\t\t\tvalue: undefined,\n\t\t\tdone: true\n\t\t};\n\t}\n\n\treturn {\n\t\tvalue: [\n\t\t\tkey,\n\t\t\tthis.hasGet ? this.obj.get(key) : this.obj[key]\n\t\t],\n\t\tdone: false\n\t};\n};\n\n\n\nfunction isObservableValue(obj){\n\treturn canReflect.isValueLike(obj) && canReflect.isObservableLike(obj);\n}\n\ndefine.types = {\n\t// To be made into a type ... this is both lazy {time: '123-456'}\n\t'date': MaybeDate,\n\t'number': MaybeNumber,\n\t'boolean': MaybeBoolean,\n\t'observable': function(newVal) {\n\t\t\tif(Array.isArray(newVal) && define.DefineList) {\n\t\t\t\t\tnewVal = new define.DefineList(newVal);\n\t\t\t}\n\t\t\telse if(canReflect.isPlainObject(newVal) &&  define.DefineMap) {\n\t\t\t\t\tnewVal = new define.DefineMap(newVal);\n\t\t\t}\n\t\t\treturn newVal;\n\t},\n\t'stringOrObservable': function(newVal) {\n\t\tif(Array.isArray(newVal)) {\n\t\t\treturn new define.DefaultList(newVal);\n\t\t}\n\t\telse if(canReflect.isPlainObject(newVal)) {\n\t\t\treturn new define.DefaultMap(newVal);\n\t\t}\n\t\telse {\n\t\t\treturn canReflect.convert( newVal, define.types.string);\n\t\t}\n\t},\n\t/**\n\t * Implements HTML-style boolean logic for attribute strings, where\n\t * any string, including \"\", is truthy.\n\t */\n\t'htmlbool': function(val) {\n\t\tif (val === '') {\n\t\t\treturn true;\n\t\t}\n\t\treturn !!stringToAny(val);\n\t},\n\t'*': function(val) {\n\t\treturn val;\n\t},\n\t'any': function(val) {\n\t\treturn val;\n\t},\n\t'string': MaybeString,\n\n\t'compute': {\n\t\tset: function(newValue, setVal, setErr, oldValue) {\n\t\t\tif (isObservableValue(newValue) ) {\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t\tif (isObservableValue(oldValue)) {\n\t\t\t\tcanReflect.setValue(oldValue,newValue);\n\t\t\t\treturn oldValue;\n\t\t\t}\n\t\t\treturn newValue;\n\t\t},\n\t\tget: function(value) {\n\t\t\treturn isObservableValue(value) ? canReflect.getValue(value) : value;\n\t\t}\n\t}\n};\n\ndefine.updateSchemaKeys = function(schema, definitions) {\n\tfor(var prop in definitions) {\n\t\tvar definition = definitions[prop];\n\t\tif(definition.serialize !== false ) {\n\t\t\tif(definition.type) {\n\t\t\t\tschema.keys[prop] = definition.type;\n\t\t\t} else {\n\t\t\t\tschema.keys[prop] = function(val){ return val; };\n\t\t\t}\n\t\t\t // some unknown type\n\t\t\tif(definitions[prop].identity === true) {\n\t\t\t\tschema.identity.push(prop);\n\t\t\t}\n\t\t}\n\t}\n\treturn schema;\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-define/can-define.js?");

/***/ }),

/***/ "../../node_modules/can-define/define-helpers/define-helpers.js":
/*!*************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-define/define-helpers/define-helpers.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar define = __webpack_require__(/*! can-define */ \"../../node_modules/can-define/can-define.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar ensureMeta = __webpack_require__(/*! ../ensure-meta */ \"../../node_modules/can-define/ensure-meta.js\");\n\nvar returnFirstArg = function(arg){\n\treturn arg;\n};\nvar defineHelpers = {\n\t// returns `true` if the value was defined and set\n\tdefineExpando: function(map, prop, value) {\n\t\t// first check if it's already a constructor define\n\t\tvar constructorDefines = map._define.definitions;\n\t\tif(constructorDefines && constructorDefines[prop]) {\n\t\t\treturn;\n\t\t}\n\t\t// next if it's already on this instances\n\t\tvar instanceDefines = map._instanceDefinitions;\n\t\tif(!instanceDefines) {\n\t\t\tif(Object.isSealed(map)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tObject.defineProperty(map, \"_instanceDefinitions\", {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t});\n\t\t\tinstanceDefines = map._instanceDefinitions;\n\t\t}\n\t\tif(!instanceDefines[prop]) {\n\t\t\tvar defaultDefinition = map._define.defaultDefinition || {type: define.types.observable};\n\t\t\tdefine.property(map, prop, defaultDefinition, {},{});\n\t\t\t// possibly convert value to List or DefineMap\n\t\t\tif(defaultDefinition.type) {\n\t\t\t\tmap._data[prop] = define.make.set.type(prop, defaultDefinition.type, returnFirstArg).call(map, value);\n\t\t\t} else {\n\t\t\t\tmap._data[prop] = define.types.observable(value);\n\t\t\t}\n\n\t\t\tinstanceDefines[prop] = defaultDefinition;\n\t\t\tqueues.batch.start();\n\t\t\tmap.dispatch({\n\t\t\t\ttype: \"can.keys\",\n\t\t\t\ttarget: map\n\t\t\t});\n\t\t\tif(map._data[prop] !== undefined) {\n\t\t\t\tmap.dispatch({\n\t\t\t\t\ttype: prop,\n\t\t\t\t\ttarget: map,\n\t\t\t\t\tpatches: [{type: \"set\", key: prop, value: map._data[prop]}],\n\t\t\t\t},[map._data[prop], undefined]);\n\t\t\t}\n\t\t\tqueues.batch.stop();\n\t\t\treturn true;\n\t\t}\n\t},\n\treflectSerialize: function(unwrapped){\n\t\tvar constructorDefinitions = this._define.definitions;\n\t\tvar defaultDefinition = this._define.defaultDefinition;\n\t\tthis.forEach(function(val, name){\n\t\t\tvar propDef = constructorDefinitions[name];\n\n\t\t\tif(propDef && typeof propDef.serialize === \"function\") {\n\t\t\t\tval = propDef.serialize.call(this, val, name);\n\t\t\t}\n\t\t\telse if(defaultDefinition && typeof defaultDefinition.serialize === \"function\") {\n\t\t\t\tval =  defaultDefinition.serialize.call(this, val, name);\n\t\t\t} else {\n\t\t\t\tval = canReflect.serialize(val);\n\t\t\t}\n\t\t\tif(val !== undefined) {\n\t\t\t\tunwrapped[name] = val;\n\t\t\t}\n\t\t}, this);\n\t\treturn unwrapped;\n\t},\n\treflectUnwrap: function(unwrapped){\n\t\tthis.forEach(function(value, key){\n\t\t\tif(value !== undefined) {\n\t\t\t\tunwrapped[key] = canReflect.unwrap(value);\n\t\t\t}\n\t\t});\n\t\treturn unwrapped;\n\t},\n\tlog: function(key) {\n\t\tvar instance = this;\n\n\t\tvar quoteString = function quoteString(x) {\n\t\t\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n\t\t};\n\n\t\tvar meta = ensureMeta(instance);\n\t\tvar allowed = meta.allowedLogKeysSet || new Set();\n\t\tmeta.allowedLogKeysSet = allowed;\n\n\t\tif (key) {\n\t\t\tallowed.add(key);\n\t\t}\n\n\t\tmeta._log = function(event, data) {\n\t\t\tvar type = event.type;\n\n\t\t\tif (\n\t\t\t\ttype === \"can.onPatches\" || (key && !allowed.has(type)) ||\n\t\t\t\ttype === \"can.keys\" || (key && !allowed.has(type))\n\t\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (type === \"add\" || type === \"remove\") {\n\t\t\t\tdev.log(\n\t\t\t\t\tcanReflect.getName(instance),\n\t\t\t\t\t\"\\n how   \", quoteString(type),\n\t\t\t\t\t\"\\n what  \", quoteString(data[0]),\n\t\t\t\t\t\"\\n index \", quoteString(data[1])\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// log `length` and `propertyName` events\n\t\t\t\tdev.log(\n\t\t\t\t\tcanReflect.getName(instance),\n\t\t\t\t\t\"\\n key \", quoteString(type),\n\t\t\t\t\t\"\\n is  \", quoteString(data[0]),\n\t\t\t\t\t\"\\n was \", quoteString(data[1])\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t},\n\tdeleteKey: function(prop){\n\t\tvar instanceDefines = this._instanceDefinitions;\n\t\tif(instanceDefines && Object.prototype.hasOwnProperty.call(instanceDefines, prop) && !Object.isSealed(this)) {\n\t\t\tdelete instanceDefines[prop];\n\t\t\tqueues.batch.start();\n\t\t\tthis.dispatch({\n\t\t\t\ttype: \"can.keys\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t\tvar oldValue = this._data[prop];\n\t\t\tif(oldValue !== undefined) {\n\t\t\t\tdelete this._data[prop];\n\t\t\t\tdelete this[prop];\n\t\t\t\tthis.dispatch({\n\t\t\t\t\ttype: prop,\n\t\t\t\t\ttarget: this,\n\t\t\t\t\tpatches: [{type: \"delete\", key: prop}],\n\t\t\t\t},[undefined,oldValue]);\n\t\t\t}\n\t\t\tqueues.batch.stop();\n\t\t} else {\n\t\t\tthis.set(prop, undefined);\n\t\t}\n\t\treturn this;\n\t}\n};\nmodule.exports = defineHelpers;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-define/define-helpers/define-helpers.js?");

/***/ }),

/***/ "../../node_modules/can-define/ensure-meta.js":
/*!*******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-define/ensure-meta.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\n// Ensure the \"obj\" passed as an argument has an object on @@can.meta\nmodule.exports = function ensureMeta(obj) {\n\tvar metaSymbol = canSymbol.for(\"can.meta\");\n\tvar meta = obj[metaSymbol];\n\n\tif (!meta) {\n\t\tmeta = {};\n\t\tcanReflect.setKeyValue(obj, metaSymbol, meta);\n\t}\n\n\treturn meta;\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-define/ensure-meta.js?");

/***/ }),

/***/ "../../node_modules/can-define/list/list.js":
/*!*****************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-define/list/list.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Construct = __webpack_require__(/*! can-construct */ \"../../node_modules/can-construct/can-construct.js\");\nvar define = __webpack_require__(/*! can-define */ \"../../node_modules/can-define/can-define.js\");\nvar make = define.make;\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ \"../../node_modules/can-event-queue/type/type.js\");\n\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar canLog = __webpack_require__(/*! can-log */ \"../../node_modules/can-log/dist/cjs/can-log.js\");\nvar canLogDev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar defineHelpers = __webpack_require__(/*! ../define-helpers/define-helpers */ \"../../node_modules/can-define/define-helpers/define-helpers.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\nvar diff = __webpack_require__(/*! can-diff/list/list */ \"../../node_modules/can-diff/list/list.js\");\nvar ns = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar singleReference = __webpack_require__(/*! can-single-reference */ \"../../node_modules/can-single-reference/can-single-reference.js\");\n\nvar splice = [].splice;\nvar runningNative = false;\n\nvar identity = function(x) {\n\treturn x;\n};\n\n// symbols aren't enumerable ... we'd need a version of Object that treats them that way\nvar localOnPatchesSymbol = \"can.patches\";\n\nvar makeFilterCallback = function(props) {\n\treturn function(item) {\n\t\tfor (var prop in props) {\n\t\t\tif (item[prop] !== props[prop]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n};\n\nvar onKeyValue = define.eventsProto[canSymbol.for(\"can.onKeyValue\")];\nvar offKeyValue = define.eventsProto[canSymbol.for(\"can.offKeyValue\")];\nvar getSchemaSymbol = canSymbol.for(\"can.getSchema\");\n\nfunction getSchema() {\n\tvar definitions = this.prototype._define.definitions;\n\tvar schema = {\n\t\ttype: \"list\",\n\t\tkeys: {}\n\t};\n\tschema = define.updateSchemaKeys(schema, definitions);\n\tif(schema.keys[\"#\"]) {\n\t\tschema.values = definitions[\"#\"].Type;\n\t\tdelete schema.keys[\"#\"];\n\t}\n\n\treturn schema;\n}\n\n\n/** @add can-define/list/list */\nvar DefineList = Construct.extend(\"DefineList\",\n\t/** @static */\n\t{\n\t\tsetup: function(base) {\n\t\t\tif (DefineList) {\n\t\t\t\taddTypeEvents(this);\n\t\t\t\tvar prototype = this.prototype;\n\t\t\t\tvar result = define(prototype, prototype, base.prototype._define);\n\t\t\t\tdefine.makeDefineInstanceKey(this, result);\n\n\t\t\t\tvar itemsDefinition = result.definitions[\"#\"] || result.defaultDefinition;\n\n\t\t\t\tif (itemsDefinition) {\n\t\t\t\t\tif (itemsDefinition.Type) {\n\t\t\t\t\t\tthis.prototype.__type = make.set.Type(\"*\", itemsDefinition.Type, identity);\n\t\t\t\t\t} else if (itemsDefinition.type) {\n\t\t\t\t\t\tthis.prototype.__type = make.set.type(\"*\", itemsDefinition.type, identity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis[getSchemaSymbol] = getSchema;\n\t\t\t}\n\t\t}\n\t},\n\t/** @prototype */\n\t{\n\t\t// setup for only dynamic DefineMap instances\n\t\tsetup: function(items) {\n\t\t\tif (!this._define) {\n\t\t\t\tObject.defineProperty(this, \"_define\", {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tdefinitions: {\n\t\t\t\t\t\t\tlength: { type: \"number\" },\n\t\t\t\t\t\t\t_length: { type: \"number\" }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tObject.defineProperty(this, \"_data\", {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: {}\n\t\t\t\t});\n\t\t\t}\n\t\t\tdefine.setup.call(this, {}, false);\n\t\t\tObject.defineProperty(this, \"_length\", {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: 0\n\t\t\t});\n\t\t\tif (items) {\n\t\t\t\tthis.splice.apply(this, [ 0, 0 ].concat(canReflect.toArray(items)));\n\t\t\t}\n\t\t},\n\t\t__type: define.types.observable,\n\t\t_triggerChange: function(attr, how, newVal, oldVal) {\n\n\t\t\tvar index = +attr;\n\t\t\t// `batchTrigger` direct add and remove events...\n\n\t\t\t// Make sure this is not nested and not an expando\n\t\t\tif ( !isNaN(index)) {\n\t\t\t\tvar itemsDefinition = this._define.definitions[\"#\"];\n\t\t\t\tvar patches, dispatched;\n\t\t\t\tif (how === 'add') {\n\t\t\t\t\tif (itemsDefinition && typeof itemsDefinition.added === 'function') {\n\t\t\t\t\t\tObservationRecorder.ignore(itemsDefinition.added).call(this, newVal, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tpatches = [{type: \"splice\", insert: newVal, index: index, deleteCount: 0}];\n\t\t\t\t\tdispatched = {\n\t\t\t\t\t\ttype: how,\n\t\t\t\t\t\tpatches: patches\n\t\t\t\t\t};\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif(true) {\n\t\t\t\t\t\tdispatched.reasonLog = [ canReflect.getName(this), \"added\", newVal, \"at\", index ];\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tthis.dispatch(dispatched, [ newVal, index ]);\n\n\t\t\t\t} else if (how === 'remove') {\n\t\t\t\t\tif (itemsDefinition && typeof itemsDefinition.removed === 'function') {\n\t\t\t\t\t\tObservationRecorder.ignore(itemsDefinition.removed).call(this, oldVal, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tpatches = [{type: \"splice\", index: index, deleteCount: oldVal.length}];\n\t\t\t\t\tdispatched = {\n\t\t\t\t\t\ttype: how,\n\t\t\t\t\t\tpatches: patches\n\t\t\t\t\t};\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif(true) {\n\t\t\t\t\t\tdispatched.reasonLog = [ canReflect.getName(this), \"remove\", oldVal, \"at\", index ];\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tthis.dispatch(dispatched, [ oldVal, index ]);\n\n\t\t\t\t} else {\n\t\t\t\t\tthis.dispatch(how, [ newVal, index ]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.dispatch({\n\t\t\t\t\ttype: \"\" + attr,\n\t\t\t\t\ttarget: this\n\t\t\t\t}, [ newVal, oldVal ]);\n\t\t\t}\n\n\t\t},\n\t\t/**\n\t\t * @function can-define/list/list.prototype.get get\n\t\t * @parent can-define/list/list.prototype\n\t\t *\n\t\t * Gets an item or all items from a DefineList.\n\t\t *\n\t\t * @signature `list.get()`\n\t\t *\n\t\t * Returns the list converted into a plain JS array. Any items that also have a\n\t\t * `get` method will have their `get` method called and the resulting value will be used as item value.\n\t\t *\n\t\t * This can be used to recursively convert a list instance to an Array of other plain JavaScript objects.\n\t\t * Cycles are supported and only create one object.\n\t\t *\n\t\t * `get()` can still return other non-plain JS objects like Dates.\n\t\t * Use [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\n\t\t *\n\t\t * ```js\n\t\t * var list = new DefineList([\"A\",\"B\"]);\n\t\t * list.get() //-> [\"A\",\"B\"]\n\t\t * ```\n\t\t *\n\t\t *   @return {Array} A plain JavaScript `Array` that contains each item in the list.\n\t\t *\n\t\t * @signature `list.get(index)`\n\t\t *\n\t\t * Gets the item at `index`. `list.get(index)` should be used instead of\n\t\t * `list[index]` if the list's items are going to be updated via [can-define/list/list.prototype.set list.set(index, value)]\n\t\t * (as opposed to [can-define/list/list.prototype.splice] which is the better way).\n\t\t *\n\t\t * ```js\n\t\t * var list = new DefineList([\"A\",\"B\"]);\n\t\t * list.get(1) //-> \"B\"\n\t\t * ```\n\t\t *\n\t\t *   @param {Number} index A numeric position in the list.\n\t\t *\n\t\t *   @return {*} The value at index.\n\t\t *\n\t\t * @signature `list.get(prop)`\n\t\t *\n\t\t * Gets the property at `prop` if it might not have already been defined.\n\t\t *\n\t\t *\n\t\t * ```js\n\t\t * var list = new DefineList([\"A\",\"B\"]);\n\t\t * list.set(\"count\",1000)\n\t\t * list.get(\"count\") //-> 1000\n\t\t * ```\n\t\t *\n\t\t *   @param {String} prop A property on the list.\n\t\t *\n\t\t *   @return {*} The value at `prop`.\n\t\t */\n\t\tget: function(index) {\n\t\t\tif (arguments.length) {\n\t\t\t\tif(isNaN(index)) {\n\t\t\t\t\tObservationRecorder.add(this, index);\n\t\t\t\t} else {\n\t\t\t\t\tObservationRecorder.add(this, \"length\");\n\t\t\t\t}\n\t\t\t\treturn this[index];\n\t\t\t} else {\n\t\t\t\treturn canReflect.unwrap(this, Map);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can-define/list/list.prototype.set set\n\t\t * @parent can-define/list/list.prototype\n\t\t *\n\t\t * @deprecated {3.10.1} Using .set with {Object} `props` has been deprecated in favour of `assign` and `update`\n\t\t *\n\t\t * @description Sets an item or property or items or properties on a list.\n\t\t *\n\t\t * @signature `list.set(prop, value)`\n\t\t *\n\t\t * Sets the property at `prop`. This should be used when the property\n\t\t * isn't already defined.\n\t\t *\n\t\t * ```js\n\t\t * var list = new DefineList([\"A\",\"B\"]);\n\t\t * list.set(\"count\",1000);\n\t\t * list.get(\"count\") //-> 1000;\n\t\t * ```\n\t\t *\n\t\t *   @param {Number} prop A property name.\n\t\t *   @param {*} value The value to add to the list.\n\t\t *   @return {can-define/list/list} The list instance.\n\t\t *\n\t\t * @signature `list.set(newProps)`\n\t\t *\n\t\t * Updates the properties on the list with `newProps`.\n\t\t *\n\t\t * ```js\n\t\t * var list = new DefineList([\"A\",\"B\"]);\n\t\t * list.set({count: 1000, skip: 2});\n\t\t * list.get(\"count\") //-> 1000\n\t\t * ```\n\t\t *\n\t\t *   @param {Object} newProps An object of properties and values to set on the list.\n\t\t *   @return {can-define/list/list} The list instance.\n\t\t *\n\t\t * @signature `list.set(index, value)`\n\t\t *\n\t\t * Sets the item at `index`.  Typically, [can-define/list/list::splice] should be used instead.\n\t\t *\n\t\t * ```js\n\t\t * var list = new DefineList([\"A\",\"B\"]);\n\t\t * list.set(2,\"C\");\n\t\t * ```\n\t\t *\n\t\t *   @param {Number} index A numeric position in the list.\n\t\t *   @param {*} value The value to add to the list.\n\t\t *   @return {can-define/list/list} The list instance.\n\t\t *\n\t\t * @signature `list.set(newItems [,replaceAll])`\n\t\t *\n\t\t * Replaces items in the list with `newItems`\n\t\t *\n\t\t * ```js\n\t\t * var list = new DefineList([\"A\",\"B\"]);\n\t\t * list.set([\"c\"])        //-> DefineList[\"c\",\"B\"]\n\t\t * list.set([\"x\"], true)  //-> DefineList[\"x\"]\n\t\t * ```\n\t\t *\n\t\t *   @param {Array} newItems Items used to replace existing items in the list.\n\t\t *   @param {Boolean} [replaceAll] If true, will remove items at the end of the list.\n\t\t *   @return {can-define/list/list} The list instance.\n\t\t */\n\t\tset: function(prop, value) {\n\t\t\t// if we are setting a single value\n\t\t\tif (typeof prop !== \"object\") {\n\t\t\t\t// We want change events to notify using integers if we're\n\t\t\t\t// setting an integer index. Note that <float> % 1 !== 0;\n\t\t\t\tprop = isNaN(+prop) || (prop % 1) ? prop : +prop;\n\t\t\t\tif (typeof prop === \"number\") {\n\t\t\t\t\t// Check to see if we're doing a .attr() on an out of\n\t\t\t\t\t// bounds index property.\n\t\t\t\t\tif (typeof prop === \"number\" &&\n\t\t\t\t\t\tprop > this._length - 1) {\n\t\t\t\t\t\tvar newArr = new Array((prop + 1) - this._length);\n\t\t\t\t\t\tnewArr[newArr.length - 1] = value;\n\t\t\t\t\t\tthis.push.apply(this, newArr);\n\t\t\t\t\t\treturn newArr;\n\t\t\t\t\t}\n\t\t\t\t\tthis.splice(prop, 1, value);\n\t\t\t\t} else {\n\t\t\t\t\tvar defined = defineHelpers.defineExpando(this, prop, value);\n\t\t\t\t\tif (!defined) {\n\t\t\t\t\t\tthis[prop] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// otherwise we are setting multiple\n\t\t\telse {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tcanLogDev.warn('can-define/list/list.prototype.set is deprecated; please use can-define/list/list.prototype.assign or can-define/list/list.prototype.update instead');\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\t//we are deprecating this in #245\n\t\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tthis.replace(prop);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanReflect.assignList(this, prop);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcanReflect.assignMap(this, prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * @function can-define/list/list.prototype.assign assign\n\t\t * @parent can-define/list/list.prototype\n\t\t *\n\t\t * Sets items or properties on a list.\n\t\t *\n\t\t * @signature `list.assign(newProps)`\n\t\t *\n\t\t * Assigns the properties on the list with `newProps`. Properties not present in `newProps` will be left unchanged.\n\t\t *\n\t\t * ```js\n\t\t * var list = new DefineList([\"A\",\"B\"]);\n\t\t * list.assign({count: 1000, skip: 2});\n\t\t * list.get(\"count\") //-> 1000\n\t\t * ```\n\t\t *   @param {Array} newProps Properties that need to be assigned to the list instance\n\t\t *   @return {can-define/list/list} The list instance.\n\t\t */\n\t\tassign: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.assignList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.assignMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * @function can-define/list/list.prototype.update update\n\t\t * @parent can-define/list/list.prototype\n\t\t *\n\t\t * Sets an item or property or items or properties on a list.\n\t\t *\n\t\t * @signature `list.update(newProps)`\n\t\t *\n\t\t * Updates the properties on the list with `newProps`. Properties not in `newProps` will be set to `undefined`.\n\t\t *\n\t\t * ```js\n\t\t * var list = new DefineList([\"A\",\"B\"]);\n\t\t * list.assign({count: 0, skip: 2});\n\t\t * list.update({count: 1000});\n\t\t * list.get(\"count\") //-> 1000\n\t\t * list.get(\"skip\") //-> undefined\n\t\t * ```\n\t\t *   @param {Array} newProps Properties that need to be updated to the list instance\n\t\t *   @return {can-define/list/list} The list instance.\n\t\t */\n\t\tupdate: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.updateList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.updateMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * @function can-define/list/list.prototype.assignDeep assignDeep\n\t\t * @parent can-define/list/list.prototype\n\t\t *\n\t\t * Sets an item or property or items or properties on a list.\n\t\t *\n\t\t * @signature `list.assignDeep(newProps)`\n\t\t *\n\t\t * Updates the properties on the list with `newProps`. Properties not in `newProps` will be left unchanged.\n\t\t *\n\t\t * ```js\n\t\t * var list = new DefineList([\"A\",\"B\"]);\n\t\t * list.assign({count: 1, skip: 2});\n\t\t * list.get(\"count\") //-> 1\n\t\t *\n\t\t * list.assignDeep({count: 1000});\n\t\t * list.get(\"count\") //-> 1000\n\t\t * list.get(\"skip\") //-> 2\n\t\t * ```\n\t\t *\n\t\t *   @param {Array} newProps Properties that need to be assigned to the list instance\n\t\t *   @return {can-define/list/list} The list instance.\n\t\t */\n\t\tassignDeep: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.assignDeepList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.assignDeepMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * @function can-define/list/list.prototype.updateDeep updateDeep\n\t\t * @parent can-define/list/list.prototype\n\t\t *\n\t\t * Sets an item or property or items or properties on a list.\n\t\t *\n\t\t * @signature `list.updateDeep(newProps)`\n\t\t *\n\t\t * Recursively updates the properties on the list with `newProps`. Properties not in `newProps` will be set to `undefined`.\n\t\t *\n\t\t * ```js\n\t\t * var list = new DefineList([\"A\",\"B\"]);\n\t\t * list.assign({count: 0, skip: 2, foo: {bar: 'zed', a: 'b'}});\n\t\t * list.updateDeep({foo: {bar: 'yay'}});\n\t\t *\n\t\t * list.get(\"count\") //-> undefined\n\t\t * list.get(\"skip\") //-> undefined\n\t\t * list.get(\"foo\") // -> {bar: 'yay', a: undefined}\n\t\t * ```\n\t\t *   @param {Array} newProps Properties that need to be updated on the list instance\n\t\t *   @return {can-define/list/list} The list instance.\n\t\t */\n\t\tupdateDeep: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.updateDeepList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.updateDeepMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t_items: function() {\n\t\t\tvar arr = [];\n\t\t\tthis._each(function(item) {\n\t\t\t\tarr.push(item);\n\t\t\t});\n\t\t\treturn arr;\n\t\t},\n\t\t_each: function(callback) {\n\t\t\tfor (var i = 0, len = this._length; i < len; i++) {\n\t\t\t\tcallback(this[i], i);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-define/list/list.prototype.splice splice\n\t\t * @parent can-define/list/list.prototype\n\t\t * @description Insert and remove elements from a DefineList.\n\t\t * @signature `list.splice(index[, howMany[, ...newItems]])`\n\t\t *\n\t\t * Removes `howMany` items at `index` and adds `newItems` in their place.\n\t\t *\n\t\t *\n\t\t *\n\t\t * @param {Number} index Where to start removing or inserting elements.\n\t\t *\n\t\t * @param {Number} [howMany] The number of elements to remove\n\t\t * If _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the DefineList.\n\t\t *\n\t\t * @param {*} newItems Items to insert into the DefineList\n\t\t *\n\t\t * @return {Array} The elements removed by `splice`.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * `splice` lets you remove elements from and insert elements into a DefineList.\n\t\t *\n\t\t * This example demonstrates how to do surgery on a list of numbers:\n\t\t *\n\t\t * ```\n\t\t * var list = new DefineList([0, 1, 2, 3]);\n\t\t *\n\t\t * // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n\t\t * list.splice(2, 1, 'Alice', 'Bob');\n\t\t * list.get(); // [0, 1, 'Alice', 'Bob', 3]\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `splice` causes the DefineList it's called on to emit\n\t\t * _add_ events, _remove_ events, and _length_ events. If there are\n\t\t * any elements to remove, a _remove_ event, and a\n\t\t * _length_ event will be fired. If there are any elements to insert, a\n\t\t * separate _add_ event, and a separate _length_ event\n\t\t * will be fired.\n\t\t *\n\t\t */\n\t\tsplice: function(index, howMany) {\n\t\t\tvar args = canReflect.toArray(arguments),\n\t\t\t\tadded = [],\n\t\t\t\ti, len, listIndex,\n\t\t\t\tallSame = args.length > 2,\n\t\t\t\toldLength = this._length;\n\n\t\t\tindex = index || 0;\n\n\t\t\t// converting the arguments to the right type\n\t\t\tfor (i = 0, len = args.length - 2; i < len; i++) {\n\t\t\t\tlistIndex = i + 2;\n\t\t\t\targs[listIndex] = this.__type(args[listIndex], listIndex);\n\t\t\t\tadded.push(args[listIndex]);\n\n\t\t\t\t// Now lets check if anything will change\n\t\t\t\tif (this[i + index] !== args[listIndex]) {\n\t\t\t\t\tallSame = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if nothing has changed, then return\n\t\t\tif (allSame && this._length <= added.length) {\n\t\t\t\treturn added;\n\t\t\t}\n\n\t\t\t// default howMany if not provided\n\t\t\tif (howMany === undefined) {\n\t\t\t\thowMany = args[1] = this._length - index;\n\t\t\t}\n\n\t\t\trunningNative = true;\n\t\t\tvar removed = splice.apply(this, args);\n\t\t\trunningNative = false;\n\n\t\t\tqueues.batch.start();\n\t\t\tif (howMany > 0) {\n\t\t\t\t// tears down bubbling\n\t\t\t\tthis._triggerChange(\"\" + index, \"remove\", undefined, removed);\n\t\t\t}\n\t\t\tif (args.length > 2) {\n\t\t\t\tthis._triggerChange(\"\" + index, \"add\", added, removed);\n\t\t\t}\n\n\t\t\tthis.dispatch('length', [ this._length, oldLength ]);\n\n\t\t\tqueues.batch.stop();\n\t\t\treturn removed;\n\t\t},\n\n\t\t/**\n\t\t * @function can-define/list/list.prototype.serialize serialize\n\t\t * @parent can-define/list/list.prototype\n\t\t *\n\t\t * Returns the a serialized version of this list.\n\t\t *\n\t\t * @signature `list.serialize()`\n\t\t *\n\t\t * Goes through each item in the list and gets its serialized\n\t\t * value and returns them in a plain Array.\n\t\t *\n\t\t * Each items serialized value is the result of calling `.serialize()`\n\t\t * on the item or if the item doesn't have a `serialize` method,\n\t\t * the item itself.\n\t\t *\n\t\t * ```\n\t\t * var list = new DefineList([\"first\", {foo: \"bar\"}]);\n\t\t * var serializedList = list.serialize();\n\t\t *\n\t\t * serializedList //-> [\"first\", {foo: \"bar\"}]\n\t\t * ```\n\t\t *\n\t\t *   @return {Array} An array with each item's serialied value.\n\t\t */\n\t\tserialize: function() {\n\t\t\treturn canReflect.serialize(this, Map);\n\t\t}\n\t}\n);\n\nfor(var prop in define.eventsProto) {\n\tObject.defineProperty(DefineList.prototype, prop, {\n\t\tenumerable:false,\n\t\tvalue: define.eventsProto[prop],\n\t\twritable: true\n\t});\n}\n\nvar eventsProtoSymbols = (\"getOwnPropertySymbols\" in Object) ?\n  Object.getOwnPropertySymbols(define.eventsProto) :\n  [canSymbol.for(\"can.onKeyValue\"), canSymbol.for(\"can.offKeyValue\")];\n\neventsProtoSymbols.forEach(function(sym) {\n  Object.defineProperty(DefineList.prototype, sym, {\n    enumerable:false,\n    value: define.eventsProto[sym],\n    writable: true\n  });\n});\n\n// Converts to an `array` of arguments.\nvar getArgs = function(args) {\n\treturn args[0] && Array.isArray(args[0]) ?\n\t\targs[0] :\n\t\tcanReflect.toArray(args);\n};\n// Create `push`, `pop`, `shift`, and `unshift`\ncanReflect.eachKey({\n\t\t/**\n\t\t * @function can-define/list/list.prototype.push push\n\t\t * @description Add elements to the end of a list.\n\t\t * @signature `list.push(...elements)`\n\t\t *\n\t\t * `push` adds elements onto the end of a DefineList.\n\t\t *\n\t\t * ```\n\t\t * var names = new DefineList(['Alice']);\n\t\t * names.push('Bob', 'Eve');\n\t\t * names //-> DefineList['Alice','Bob', 'Eve']\n\t\t * ```\n\t\t *\n\t\t *   @param {*} elements the elements to add to the DefineList\n\t\t *\n\t\t *   @return {Number} the new length of the DefineList\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * `push` adds elements onto the end of a DefineList here is an example:\n\t\t *\n\t\t * ```\n\t\t * var list = new DefineList(['Alice']);\n\t\t *\n\t\t * list.push('Bob', 'Eve');\n\t\t * list.get(); // ['Alice', 'Bob', 'Eve']\n\t\t * ```\n\t\t *\n\t\t * If you have an array you want to concatenate to the end\n\t\t * of the DefineList, you can use `apply`:\n\t\t *\n\t\t * ```\n\t\t * var names = ['Bob', 'Eve'],\n\t\t *     list = new DefineList(['Alice']);\n\t\t *\n\t\t * list.push.apply(list, names);\n\t\t * list.get(); // ['Alice', 'Bob', 'Eve']\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `push` causes _add_, and _length_ events to be fired.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `push` has a counterpart in [can-define/list/list::pop pop], or you may be\n\t\t * looking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\n\t\t */\n\tpush: \"length\",\n\t\t/**\n\t\t * @function can-define/list/list.prototype.unshift unshift\n\t\t * @description Add items to the beginning of a DefineList.\n\t\t * @signature `list.unshift(...items)`\n\t\t *\n\t\t * `unshift` adds items onto the beginning of a DefineList.\n\t\t *\n\t\t * ```\n\t\t * var list = new DefineList(['Alice']);\n\t\t *\n\t\t * list.unshift('Bob', 'Eve');\n\t\t * list; // DefineList['Bob', 'Eve', 'Alice']\n\t\t * ```\n\t\t *\n\t\t * @param {*} items The items to add to the DefineList.\n\t\t *\n\t\t * @return {Number} The new length of the DefineList.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t *\n\t\t *\n\t\t * If you have an array you want to concatenate to the beginning\n\t\t * of the DefineList, you can use `apply`:\n\t\t *\n\t\t * ```\n\t\t * var names = ['Bob', 'Eve'],\n\t\t *     list = new DefineList(['Alice']);\n\t\t *\n\t\t * list.unshift.apply(list, names);\n\t\t * list.get(); // ['Bob', 'Eve', 'Alice']\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `unshift` causes _add_ and _length_ events to be fired.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `unshift` has a counterpart in [can-define/list/list::shift shift], or you may be\n\t\t * looking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\n\t\t */\n\tunshift: 0\n},\n\t// Adds a method\n\t// `name` - The method name.\n\t// `where` - Where items in the `array` should be added.\n\tfunction(where, name) {\n\t\tvar orig = [][name];\n\t\tDefineList.prototype[name] = function() {\n\t\t\t// Get the items being added.\n\t\t\tvar args = [],\n\t\t\t\t// Where we are going to add items.\n\t\t\t\tlen = where ? this._length : 0,\n\t\t\t\ti = arguments.length,\n\t\t\t\tres, val;\n\n\t\t\t// Go through and convert anything to a `map` that needs to be converted.\n\t\t\twhile (i--) {\n\t\t\t\tval = arguments[i];\n\t\t\t\targs[i] = this.__type(val, i);\n\t\t\t}\n\n\t\t\t// Call the original method.\n\t\t\trunningNative = true;\n\t\t\tres = orig.apply(this, args);\n\t\t\trunningNative = false;\n\n\t\t\tif (!this.comparator || args.length) {\n\t\t\t\tqueues.batch.start();\n\t\t\t\tthis._triggerChange(\"\" + len, \"add\", args, undefined);\n\t\t\t\tthis.dispatch('length', [ this._length, len ]);\n\t\t\t\tqueues.batch.stop();\n\t\t\t}\n\n\t\t\treturn res;\n\t\t};\n\t});\n\ncanReflect.eachKey({\n\t\t/**\n\t\t * @function can-define/list/list.prototype.pop pop\n\t\t * @description Remove an element from the end of a DefineList.\n\t\t * @signature `list.pop()`\n\t\t *\n\t\t * `pop` removes an element from the end of a DefineList.\n\t\t *\n\t\t * ```js\n\t\t * var names = new DefineList(['Alice', 'Bob', 'Eve']);\n\t\t * names.pop() //-> 'Eve'\n\t\t * ```\n\t\t *\n\t\t *   @return {*} The element just popped off the DefineList, or `undefined` if the DefineList was empty\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * `pop` is the opposite action from [can-define/list/list::push push]:\n\t\t *\n\t\t * ```\n\t\t * var list = new DefineList(['Alice', 'Bob', 'Eve']);\n\t\t *\n\t\t * list.pop(); // 'Eve'\n\t\t * list.pop(); // 'Bob'\n\t\t * list.pop(); // 'Alice'\n\t\t * list.pop(); // undefined\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\n\t\t * when it is called.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `pop` has its counterpart in [can-define/list/list::push push], or you may be\n\t\t * looking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\n\t\t */\n\tpop: \"length\",\n\t\t/**\n\t\t * @function can-define/list/list.prototype.shift shift\n\t\t * @description Remove an item from the front of a list.\n\t\t * @signature `list.shift()`\n\t\t *\n\t\t * `shift` removes an element from the beginning of a DefineList.\n\t\t *\n\t\t * ```\n\t\t * var list = new DefineList(['Alice','Adam']);\n\t\t * list.shift(); //-> 'Alice'\n\t\t * list.shift(); //-> 'Adam'\n\t\t * list.shift(); //-> undefined\n\t\t * ```\n\t\t *\n\t\t * @return {*} The element just shifted off the DefineList, or `undefined` if the DefineList is empty\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * `shift` is the opposite action from `[can-define/list/list::unshift unshift]`:\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\n\t\t * when it is called.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `shift` has a counterpart in [can-define/list/list::unshift unshift], or you may be\n\t\t * looking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\n\t\t */\n\tshift: 0\n},\n\t// Creates a `remove` type method\n\tfunction(where, name) {\n\t\tvar orig = [][name];\n\t\tDefineList.prototype[name] = function() {\n\t\t\tif (!this._length) {\n\t\t\t\t// For shift and pop, we just return undefined without\n\t\t\t\t// triggering events.\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tvar args = getArgs(arguments),\n\t\t\t\tlen = where && this._length ? this._length - 1 : 0,\n\t\t\t\toldLength = this._length ? this._length : 0,\n\t\t\t\tres;\n\n\t\t\t// Call the original method.\n\t\t\trunningNative = true;\n\t\t\tres = orig.apply(this, args);\n\t\t\trunningNative = false;\n\n\t\t\t// Create a change where the args are\n\t\t\t// `len` - Where these items were removed.\n\t\t\t// `remove` - Items removed.\n\t\t\t// `undefined` - The new values (there are none).\n\t\t\t// `res` - The old, removed values (should these be unbound).\n\t\t\tqueues.batch.start();\n\t\t\tthis._triggerChange(\"\" + len, \"remove\", undefined, [ res ]);\n\t\t\tthis.dispatch('length', [ this._length, oldLength ]);\n\t\t\tqueues.batch.stop();\n\n\t\t\treturn res;\n\t\t};\n\t});\n\ncanReflect.eachKey({\n\t/**\n\t * @function can-define/list/list.prototype.map map\n\t * @description Map the values in this list to another list.\n\t *\n\t * @signature `list.map(callback[, thisArg])`\n\t *\n\t * Loops through the values of the list, calling `callback` for each one until the list\n\t * ends.  The return values of `callback` are used to populate the returned list.\n\t *\n\t * ```js\n\t * var todos = new DefineList([\n\t *   {name: \"dishes\", complete: false},\n\t *   {name: \"lawn\", complete: true}\n\t * ]);\n\t * var names = todos.map(function(todo){\n\t *   return todo.name;\n\t * });\n\t * names //-> DefineList[\"dishes\",\"lawn\"]\n\t * ```\n\t *\n\t * @param {function(item, index, list)} callback A function to call with each element of the DefineList.\n\t * The three parameters that callback gets passed are:\n\t *    - item (*) - the element at index.\n\t *    - index (Integer) - the index of the current element of the list.\n\t *    - list (DefineList) - the `DefineList` the elements are coming from.\n\t *\n\t * The return value of `callback`, including `undefined` values are used to populate the resulting list.\n\t *\n\t * @param {Object} [thisArg] The object to use as `this` inside the callback.\n\t * @return {can-define/list/list} a new `DefineList` with the results of the map transform.\n\t * @body\n\t *\n\t */\n\t\"map\": 3,\n\t/**\n\t * @function can-define/list/list.prototype.filter filter\n\t *\n\t * Filter a list to a new list of the matched items.\n\t *\n\t * @signature `list.filter( callback [,thisArg] )`\n\t *\n\t * Filters `list` based on the return value of `callback`.\n\t *\n\t * ```\n\t * var names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\n\t * var aNames = names.filter(function(name){\n\t *   return name[0] === \"a\"\n\t * });\n\t * aNames //-> DefineList[\"alice\",\"adam\"]\n\t * ```\n\t *\n\t *   @param  {function(*, Number, can-define/list/list)} callback(item, index, list) A\n\t *   function to call with each element of the DefineList. The three parameters that callback gets passed are:\n\t *    - item (*) - the element at index.\n\t *    - index (Integer) - the index of the current element of the list.\n\t *    - list (DefineList) - the `DefineList` the elements are coming from.\n\t *\n\t *   If `callback` returns a truthy result, `item` will be added to the result.  Otherwise, the `item` will be\n\t *   excluded.\n\t *\n\t *   @param  {Object}  thisArg  What `this` should be in the `callback`.\n\t *   @return {can-define/list/list} A new instance of this `DefineList` (may be a subclass), containing the items that passed the filter.\n\t *\n\t * @signature `list.filter( props )`\n\t *\n\t * Filters items in `list` based on the property values in `props`.\n\t *\n\t * ```\n\t * var todos = new DefineList([\n\t *   {name: \"dishes\", complete: false},\n\t *   {name: \"lawn\", complete: true}\n\t * ]);\n\t * var complete = todos.filter({complete: true});\n\t * complete //-> DefineList[{name: \"lawn\", complete: true}]\n\t * ```\n\t *\n\t *    @param  {Object}  props An object of key-value properties.  Each key and value in\n\t *    `props` must be present on an `item` for the `item` to be in the returned list.\n\t *    @return {can-define/list/list} A new `DefineList` of the same type.\n\t */\n\t\"filter\": 3,\n\t/**\n\t * @function can-define/list/list.prototype.reduce reduce\n\t * @description Map the values in this list to a single value\n\t *\n\t * @signature `list.reduce(callback, initialValue, [, thisArg])`\n\t *\n\t * Loops through the values of the list, calling `callback` for each one until the list\n\t * ends.  The return value of `callback` is passed to the next iteration as the first argument,\n\t * and finally returned by `reduce`.\n\t *\n\t * ```js\n\t * var todos = new DefineList([\n\t *   {name: \"dishes\", complete: false},\n\t *   {name: \"lawn\", complete: true}\n\t * ]);\n\t * var todosAsOneObject = todos.reduce(function(todos, todo){\n\t *   todos[todo.name] = todo.complete;\n\t *   return todos;\n\t * }, {});\n\t * todosAsOneObject //-> { dishes: false, lawn: true }\n\t * ```\n\t *\n\t * @param {function(item, index, list)} callback A function to call with each element of the DefineList.\n\t * The four parameters that callback gets passed are:\n\t *    - current (*) - the current aggregate value of reducing over the list -- the initial value if the first iteration\n\t *    - item (*) - the element at index.\n\t *    - index (Integer) - the index of the current element of the list.\n\t *    - list (DefineList) - the `DefineList` the elements are coming from.\n\t *\n\t * The return value of `callback` is passed to the next iteration as the first argument, and returned from\n\t * `reduce` if the last iteration.\n\t *\n\t * @param {*} [initialValue] The initial value to use as `current` in the first iteration\n\t * @param {Object} [thisArg] The object to use as `this` inside the callback.\n\t * @return {*} The result of the final call of `callback` on the list.\n\t * @body\n\t *\n\t */\n\t\"reduce\": 4,\n\t/**\n\t * @function can-define/list/list.prototype.reduceRight reduceRight\n\t * @description Map the values in this list to a single value from right to left\n\t *\n\t * @signature `list.reduceRight(callback, initialValue, [, thisArg])`\n\t *\n\t * Loops through the values of the list in reverse order, calling `callback` for each one until the list\n\t * ends.  The return value of `callback` is passed to the next iteration as the first argument,\n\t * and finally returned by `reduce`.\n\t *\n\t * ```js\n\t * var todos = new DefineList([\n\t *   {name: \"dishes\", complete: false},\n\t *   {name: \"lawn\", complete: true}\n\t * ]);\n\t * var todosAsOneObject = todos.reduce(function(todos, todo){\n\t *   todos[todo.name] = todo.complete;\n\t *   return todos;\n\t * }, {});\n\t * todosAsOneObject //-> { dishes: false, lawn: true }\n\t * ```\n\t *\n\t * @param {function(item, index, list)} callback A function to call with each element of the DefineList.\n\t * The four parameters that callback gets passed are:\n\t *    - current (*) - the current aggregate value of reducing over the list -- the initial value if the first iteration\n\t *    - item (*) - the element at index.\n\t *    - index (Integer) - the index of the current element of the list.\n\t *    - list (DefineList) - the `DefineList` the elements are coming from.\n\t *\n\t * The return value of `callback` is passed to the next iteration as the first argument, and returned from\n\t * `reduce` if the last iteration.\n\t *\n\t * @param {*} [initialValue] The initial value to use as `current` in the first iteration\n\t * @param {Object} [thisArg] The object to use as `this` inside the callback.\n\t * @return {*} The result of the final call of `callback` on the list.\n\t * @body\n\t *\n\t */\n\t\"reduceRight\": 4,\n\t/**\n\t * @function can-define/list/list.prototype.every every\n\t *\n\t * Return true if every item in a list matches a predicate.\n\t *\n\t * @signature `list.every( callback [,thisArg] )`\n\t *\n\t * Tests each item in `list` by calling `callback` on it.  If `callback` returns truthy for every element in\n\t * `list`, `every` returns `true`.\n\t *\n\t * ```\n\t * var names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\n\t * var aNames = names.every(function(name){\n\t *   return name[0] === \"a\"\n\t * });\n\t * aNames //-> false\n\t * ```\n\t *\n\t *   @param  {function(*, Number, can-define/list/list)} callback(item, index, list) A\n\t *   function to call with each element of the DefineList. The three parameters that callback gets passed are:\n\t *    - item (*) - the element at index.\n\t *    - index (Integer) - the index of the current element of the list.\n\t *    - list (DefineList) - the `DefineList` the elements are coming from.\n\t *\n\t *   If `callback` returns a truthy result, `every` will evaluate the callback on the next element.  Otherwise, `every`\n\t *   will return `false`.\n\t *\n\t *   @param  {Object}  thisArg  What `this` should be in the `callback`.\n\t *   @return {Boolean} `true` if calling the callback on every element in `list` returns a truthy value, `false` otherwise.\n\t *\n\t * @signature `list.every( props )`\n\t *\n\t * Tests each item in `list` by comparing its properties to `props`.  If `props` match for every element in\n\t * `list`, `every` returns `true`.\n\t *\n\t * ```\n\t * var todos = new DefineList([\n\t *   {name: \"dishes\", complete: false},\n\t *   {name: \"lawn\", complete: true}\n\t * ]);\n\t * var complete = todos.every({complete: true});\n\t * complete //-> false\n\t * ```\n\t *\n\t *    @param  {Object}  props An object of key-value properties.  Each key and value in\n\t *    `props` must be present on an `item` for the `item` to match.\n\t *    @return {Boolean} `true` if every element in `list` matches `props`, `false` otherwise\n\t */\n\t\"every\": 3,\n\t/**\n\t * @function can-define/list/list.prototype.some some\n\t *\n\t * Return true if at least one item in a list matches a predicate.\n\t *\n\t * @signature `list.some( callback [,thisArg] )`\n\t *\n\t * Tests each item in `list` by calling `callback` on it.  If `callback` returns truthy for some element in\n\t * `list`, `some` returns `true`.\n\t *\n\t * ```\n\t * var names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\n\t * var aNames = names.some(function(name){\n\t *   return name[0] === \"a\"\n\t * });\n\t * aNames //-> false\n\t * ```\n\t *\n\t *   @param  {function(*, Number, can-define/list/list)} callback(item, index, list) A\n\t *   function to call with each element of the DefineList. The three parameters that callback gets passed are:\n\t *    - item (*) - the element at index.\n\t *    - index (Integer) - the index of the current element of the list.\n\t *    - list (DefineList) - the DefineList the elements are coming from.\n\t *\n\t *   If `callback` returns a falsy result, `some` will evaluate the callback on the next element.  Otherwise, `some`\n\t *   will return `true`.\n\t *\n\t *   @param  {Object}  thisArg  What `this` should be in the `callback`.\n\t *   @return {Boolean} `false` if calling the callback on some element in `list` returns a falsy value, `true` otherwise.\n\t *\n\t * @signature `list.some( props )`\n\t *\n\t * Tests each item in `list` by comparing its properties to `props`.  If `props` match for some element in\n\t * `list`, `some` returns `true`.\n\t *\n\t * ```\n\t * var todos = new DefineList([\n\t *   {name: \"dishes\", complete: false},\n\t *   {name: \"lawn\", complete: true}\n\t * ]);\n\t * var complete = todos.some({complete: true});\n\t * complete //-> false\n\t * ```\n\t *\n\t *    @param  {Object}  props An object of key-value properties.  Each key and value in\n\t *    `props` must be present on an `item` for the `item` to match.\n\t *    @return {Boolean} `false` if every element in `list` fails to match `props`, `true` otherwise\n\t */\n\t\"some\": 3\n},\nfunction a(fnLength, fnName) {\n\tDefineList.prototype[fnName] = function() {\n\t\tvar self = this;\n\t\tvar args = [].slice.call(arguments, 0);\n\t\tvar callback = args[0];\n\t\tvar thisArg = args[fnLength - 1] || self;\n\n\t\tif (typeof callback === \"object\") {\n\t\t\tcallback = makeFilterCallback(callback);\n\t\t}\n\n\t\targs[0] = function() {\n\t\t\tvar cbArgs = [].slice.call(arguments, 0);\n\t\t\t// use .get(index) to ensure observation added.\n\t\t\t// the arguments are (item, index) or (result, item, index)\n\t\t\tcbArgs[fnLength - 3] = self.get(cbArgs[fnLength - 2]);\n\t\t\treturn callback.apply(thisArg, cbArgs);\n\t\t};\n\t\tvar ret = Array.prototype[fnName].apply(this, args);\n\n\t\tif(fnName === \"map\") {\n\t\t\treturn new DefineList(ret);\n\t\t}\n\t\telse if(fnName === \"filter\") {\n\t\t\treturn new self.constructor(ret);\n\t\t} else {\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n\nassign(DefineList.prototype, {\n\t/**\n\t * @function can-define/list/list.prototype.indexOf indexOf\n\t * @description Look for an item in a DefineList.\n\t * @signature `list.indexOf(item)`\n\t *\n\t * `indexOf` finds the position of a given item in the DefineList.\n\t *\n\t * ```\n\t * var list = new DefineList(['Alice', 'Bob', 'Eve']);\n\t * list.indexOf('Alice');   // 0\n\t * list.indexOf('Charlie'); // -1\n\t * ```\n\t *\n\t *   @param {*} item The item to find.\n\t *\n\t *   @return {Number} The position of the item in the DefineList, or -1 if the item is not found.\n\t *\n\t * @body\n\t *\n\t */\n\tindexOf: function(item, fromIndex) {\n\t\tfor (var i = fromIndex || 0, len = this.length; i < len; i++) {\n\t\t\tif (this.get(i) === item) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\t\t/**\n\t * @function can-define/list/list.prototype.lastIndexOf lastIndexOf\n\t * @description Look for an item in a DefineList starting from the end.\n\t * @signature `list.lastIndexOf(item)`\n\t *\n\t * `lastIndexOf` finds the last position of a given item in the DefineList.\n\t *\n\t * ```\n\t * var list = new DefineList(['Alice', 'Bob', 'Alice', 'Eve']);\n\t * list.lastIndexOf('Alice');   // 2\n\t * list.lastIndexOf('Charlie'); // -1\n\t * ```\n\t *\n\t *   @param {*} item The item to find.\n\t *\n\t *   @return {Number} The position of the item in the DefineList, or -1 if the item is not found.\n\t *\n\t * @body\n\t *\n\t */\n\tlastIndexOf: function(item, fromIndex) {\n\t\tfromIndex = typeof fromIndex === \"undefined\" ? this.length - 1: fromIndex;\n\t\tfor (var i = fromIndex; i >= 0; i--) {\n\t\t\tif (this.get(i) === item) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\t/**\n\t * @function can-define/list/list.prototype.join join\n\t * @description Join a DefineList's elements into a string.\n\t * @signature `list.join(separator)`\n\t *\n\t * `join` turns a DefineList into a string by inserting _separator_ between the string representations\n\t * of all the elements of the DefineList.\n\t *\n\t * ```\n\t * var list = new DefineList(['Alice', 'Bob', 'Eve']);\n\t * list.join(', '); // 'Alice, Bob, Eve'\n\t * ```\n\t *\n\t * @param {String} separator The string to seperate elements.\n\t *\n\t * @return {String} The joined string.\n\t *\n\t */\n\tjoin: function() {\n\t\tObservationRecorder.add(this, \"length\");\n\t\treturn [].join.apply(this, arguments);\n\t},\n\n\t/**\n\t * @function can-define/list/list.prototype.reverse reverse\n\t * @description Reverse the order of a DefineList.\n\t * @signature `list.reverse()`\n\t *\n\t * Reverses the elements of the DefineList in place.\n\t *\n\t * ```\n\t * var list = new DefineList(['Alice', 'Bob', 'Eve']);\n\t * var reversedList = list.reverse();\n\t *\n\t * reversedList; //-> DefineList['Eve', 'Bob', 'Alice'];\n\t * list === reversedList; // true\n\t * ```\n\t *\n\t * @return {can-define/list/list} The DefineList, for chaining.\n\t *\n\t * @body\n\t *\n\t */\n\treverse: function() {\n\t\t// this shouldn't be observable\n\t\tvar list = [].reverse.call(this._items());\n\t\treturn this.replace(list);\n\t},\n\n\t/**\n\t * @function can-define/list/list.prototype.slice slice\n\t * @description Make a copy of a part of a DefineList.\n\t * @signature `list.slice([start[, end]])`\n\t *\n\t * `slice` creates a copy of a portion of the DefineList.\n\t *\n\t * ```js\n\t * var list = new DefineList(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\n\t * var newList = list.slice(1, 4);\n\t * newList //-> DefineList['Bob', 'Charlie', 'Daniel']\n\t * ```\n\t *\n\t * @param {Number} [start=0] The index to start copying from. Defaults to `0`.\n\t *\n\t * @param {Number} [end] The first index not to include in the copy\n\t * If _end_ is not supplied, `slice` will copy until the end of the list.\n\t *\n\t * @return {can-define/list/list} A new `DefineList` with the extracted elements.\n\t *\n\t * @body\n\t *\n\t * ## Use\n\t *\n\t * `slice` is the simplest way to copy a DefineList:\n\t *\n\t * ```\n\t * var list = new DefineList(['Alice', 'Bob', 'Eve']);\n\t * var copy = list.slice();\n\t *\n\t * copy           //-> DefineList['Alice', 'Bob', 'Eve']\n\t * list === copy; //-> false\n\t * ```\n\t */\n\tslice: function() {\n\t\t// tells computes to listen on length for changes.\n\t\tObservationRecorder.add(this, \"length\");\n\t\tvar temp = Array.prototype.slice.apply(this, arguments);\n\t\treturn new this.constructor(temp);\n\t},\n\n\t/**\n\t * @function can-define/list/list.prototype.concat concat\n\t * @description Merge many collections together into a DefineList.\n\t * @signature `list.concat(...args)`\n\t *\n\t * Returns a `DefineList` with the `list`'s items and the additional `args`.\n\t *\n\t * @param {Array|can-define/list/list|*} args Any number of arrays, Lists, or values to add in\n\t * For each parameter given, if it is an Array or a DefineList, each of its elements will be added to\n\t * the end of the concatenated DefineList. Otherwise, the parameter itself will be added.\n\t *\n\t * @return {can-define/list/list} A DefineList of the same type.\n\t *\n\t * @body\n\t *\n\t * ## Use\n\t *\n\t * `concat` makes a new DefineList with the elements of the DefineList followed by the elements of the parameters.\n\t *\n\t * ```\n\t * var list = new DefineList();\n\t * var newList = list.concat(\n\t *     'Alice',\n\t *     ['Bob', 'Charlie']),\n\t *     new DefineList(['Daniel', 'Eve']),\n\t *     {f: 'Francis'}\n\t * );\n\t * newList.get(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n\t * ```\n\t */\n\tconcat: function() {\n\t\tvar args = [];\n\t\t// Go through each of the passed `arguments` and\n\t\t// see if it is list-like, an array, or something else\n\t\tcanReflect.eachIndex(arguments, function(arg) {\n\t\t\tif (canReflect.isListLike(arg)) {\n\t\t\t\t// If it is list-like we want convert to a JS array then\n\t\t\t\t// pass each item of the array to this.__type\n\t\t\t\tvar arr = Array.isArray(arg) ? arg : canReflect.toArray(arg);\n\t\t\t\tarr.forEach(function(innerArg) {\n\t\t\t\t\targs.push(this.__type(innerArg));\n\t\t\t\t}, this);\n\t\t\t} else {\n\t\t\t\t// If it is a Map, Object, or some primitive\n\t\t\t\t// just pass arg to this.__type\n\t\t\t\targs.push(this.__type(arg));\n\t\t\t}\n\t\t}, this);\n\n\t\t// We will want to make `this` list into a JS array\n\t\t// as well (We know it should be list-like), then\n\t\t// concat with our passed in args, then pass it to\n\t\t// list constructor to make it back into a list\n\t\treturn new this.constructor(Array.prototype.concat.apply(canReflect.toArray(this), args));\n\t},\n\n\t/**\n\t * @function can-define/list/list.prototype.forEach forEach\n\t * @description Call a function for each element of a DefineList.\n\t * @signature `list.forEach(callback[, thisArg])`\n\t *\n\t * Loops through the values of the list, calling `callback` for each one until the list ends\n\t * or `false` is returned.\n\t *\n\t * ```\n\t * list.forEach(function(item, index, list){ ... })\n\t * ```\n\t *\n\t * @param {function(item, index, list)} callback A function to call with each element of the DefineList.\n\t * The three parameters that callback gets passed are:\n\t *    - item - the element at index.\n\t *    - index - the current element of the list.\n\t *    - list - the DefineList the elements are coming from.\n\t *\n\t * If the callback returns `false` the looping stops.\n\t *\n\t * @param {Object} [thisArg] The object to use as `this` inside the callback.\n\t * @return {can-define/list/list} The list instance.\n\t * @body\n\t *\n\t * ## Use\n\t *\n\t * `forEach` calls a callback for each element in the DefineList.\n\t *\n\t * ```\n\t * var list = new DefineList([1, 2, 3]);\n\t * list.forEach(function(element, index, list) {\n\t *     list.get(index, element * element);\n\t * });\n\t * list.get(); // [1, 4, 9]\n\t * ```\n\t */\n\tforEach: function(cb, thisarg) {\n\t\tvar item;\n\t\tfor (var i = 0, len = this.length; i < len; i++) {\n\t\t\titem = this.get(i);\n\t\t\tif (cb.call(thisarg || item, item, i, this) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * @function can-define/list/list.prototype.replace replace\n\t * @description Replace all the elements of a DefineList.\n\t * @signature `list.replace(collection)`\n\t *\n\t * Replaces every item in the list with `collection`.\n\t *\n\t * ```\n\t * var names = new DefineList([\"alice\",\"adam\",\"eve\"]);\n\t * names.replace([\"Justin\",\"Xena\"]);\n\t * names //-> DefineList[\"Justin\",\"Xena\"]\n\t * ```\n\t *\n\t * @param {Array|can-define/list/list} collection The collection of items that will be in `list`.\n\t * @return {can-define/list/list} Returns the `list`.\n\t *\n\t * @body\n\t *\n\t * ## Use\n\t *\n\t * `replace` is essentially a shortcut for [can-define/list/list.prototype.splice].\n\t *\n\t * ## Events\n\t *\n\t * `replace` causes _remove_, _add_, and _length_ events.\n\t */\n\treplace: function(newList) {\n\t\tvar patches = diff(this, newList);\n\n\t\tqueues.batch.start();\n\t\tfor (var i = 0, len = patches.length; i < len; i++) {\n\t\t\tthis.splice.apply(this, [\n\t\t\t\tpatches[i].index,\n\t\t\t\tpatches[i].deleteCount\n\t\t\t].concat(patches[i].insert));\n\t\t}\n\t\tqueues.batch.stop();\n\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-define/list/list.prototype.sort sort\n\t * @description Sort the properties of a list.\n\t *\n\t * @signature `list.sort([compareFunction])`\n\t *\n\t * Sorts the elements of a list in place and returns the list. The API is the\n\t * same as the native JavaScript `Array.prototype.sort` API.\n\t *\n\t * ```js\n\t * var accounts = new Account.List([\n\t *   { name: \"Savings\", amount: 20.00 },\n\t *   { name: \"Checking\", amount: 103.24 },\n\t *   { name: \"Kids Savings\", amount: 48155.13 }\n\t * ]);\n\t * accounts.sort(function(a, b){\n\t *   if (a.name < b.name) {\n\t *     return -1;\n\t *   } else if (a.name > b.name){\n\t *     return 1;\n\t *   } else {\n\t *     return 0;\n\t *   }\n\t * });\n\t * accounts[0].name === \"Checking\"\n\t * accounts[1].name === \"Kids Savings\"\n\t * accounts[2].name === \"Savings\"\n\t * ```\n\t *\n\t * @param {function(a, b)} compareFunction Specifies a function that defines the sort order.\n\t *\n\t * If `compareFunction` is supplied, the list elements are sorted according to the return\n\t * value of the compare function. If `a` and `b` are two elements being compared, then:\n\t *\n\t *  - If `compareFunction(a, b)` returns a value less than 0, `a` will be sorted to\n\t *  a lower index than `b`, so `a` will now come first.\n\t *  - If `compareFunction(a, b)` returns 0, the order of the two values will not be changed.\n\t *  - If `compareFunction(a, b)` returns a value greater than 0, `a` will be sorted to\n\t *  a higher index than `b`, so `b` will now come first.\n\t *\n\t * @return {can-define/list/list} The list instance.\n\t * @body\n\t * ```\n\t */\n\tsort: function(compareFunction) {\n\t\tvar sorting = Array.prototype.slice.call(this);\n\t\tArray.prototype.sort.call(sorting, compareFunction);\n\t\tthis.splice.apply(this, [0,sorting.length].concat(sorting) );\n\t\treturn this;\n\t}\n});\n\n\n// Add necessary event methods to this object.\nfor (var prop in define.eventsProto) {\n\tDefineList[prop] = define.eventsProto[prop];\n\tObject.defineProperty(DefineList.prototype, prop, {\n\t\tenumerable: false,\n\t\tvalue: define.eventsProto[prop],\n\t\twritable: true\n\t});\n}\n\nObject.defineProperty(DefineList.prototype, \"length\", {\n\tget: function() {\n\t\tif (!this.__inSetup) {\n\t\t\tObservationRecorder.add(this, \"length\");\n\t\t}\n\t\treturn this._length;\n\t},\n\tset: function(newVal) {\n\t\tif (runningNative) {\n\t\t\tthis._length = newVal;\n\t\t\treturn;\n\t\t}\n\n\t\t// Don't set _length if:\n\t\t//  - null or undefined\n\t\t//  - a string that doesn't convert to number\n\t\t//  - already the length being set\n\t\tif (newVal == null || isNaN(+newVal) || newVal === this._length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (newVal > this._length - 1) {\n\t\t\tvar newArr = new Array(newVal - this._length);\n\t\t\tthis.push.apply(this, newArr);\n\t\t}\n\t\telse {\n\t\t\tthis.splice(newVal);\n\t\t}\n\t},\n\tenumerable: true\n});\n\nDefineList.prototype.attr = function(prop, value) {\n\tcanLog.warn(\"DefineMap::attr shouldn't be called\");\n\tif (arguments.length === 0) {\n\t\treturn this.get();\n\t} else if (prop && typeof prop === \"object\") {\n\t\treturn this.set.apply(this, arguments);\n\t} else if (arguments.length === 1) {\n\t\treturn this.get(prop);\n\t} else {\n\t\treturn this.set(prop, value);\n\t}\n};\nDefineList.prototype.item = function(index, value) {\n\tif (arguments.length === 1) {\n\t\treturn this.get(index);\n\t} else {\n\t\treturn this.set(index, value);\n\t}\n};\nDefineList.prototype.items = function() {\n\tcanLog.warn(\"DefineList::get should should be used instead of DefineList::items\");\n\treturn this.get();\n};\n\nvar defineListProto = {\n\t// type\n\t\"can.isMoreListLikeThanMapLike\": true,\n\t\"can.isMapLike\": true,\n\t\"can.isListLike\": true,\n\t\"can.isValueLike\": false,\n\t// get/set\n\t\"can.getKeyValue\": DefineList.prototype.get,\n\t\"can.setKeyValue\": DefineList.prototype.set,\n\n\t// Called for every reference to a property in a template\n\t// if a key is a numerical index then translate to length event\n\t\"can.onKeyValue\": function(key, handler, queue) {\n\t\tvar translationHandler;\n\t\tif (isNaN(key)) {\n\t\t\treturn onKeyValue.apply(this, arguments);\n\t\t}\n\t\telse {\n\t\t\ttranslationHandler = function() {\n\t\t\t\thandler(this[key]);\n\t\t\t};\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tObject.defineProperty(translationHandler, \"name\", {\n\t\t\t\t\tvalue: \"translationHandler(\" + key + \")::\" + canReflect.getName(this) + \".onKeyValue('length',\" + canReflect.getName(handler) + \")\",\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tsingleReference.set(handler, this, translationHandler, key);\n\t\t\treturn onKeyValue.call(this, 'length',  translationHandler, queue);\n\t\t}\n\t},\n\t// Called when a property reference is removed\n\t\"can.offKeyValue\": function(key, handler, queue) {\n\t\tvar translationHandler;\n\t\tif ( isNaN(key)) {\n\t\t\treturn offKeyValue.apply(this, arguments);\n\t\t}\n\t\telse {\n\t\t\ttranslationHandler = singleReference.getAndDelete(handler, this, key);\n\t\t\treturn offKeyValue.call(this, 'length',  translationHandler, queue);\n\t\t}\n\t},\n\n\t\"can.deleteKeyValue\": function(prop) {\n\t\t// convert string key to number index if key can be an integer:\n\t\t//   isNaN if prop isn't a numeric representation\n\t\t//   (prop % 1) if numeric representation is a float\n\t\t//   In both of the above cases, leave as string.\n\t\tprop = isNaN(+prop) || (prop % 1) ? prop : +prop;\n\t\tif(typeof prop === \"number\") {\n\t\t\tthis.splice(prop, 1);\n\t\t} else if(prop === \"length\" || prop === \"_length\") {\n\t\t\treturn; // length must not be deleted\n\t\t} else {\n\t\t\tthis.set(prop, undefined);\n\t\t}\n\t\treturn this;\n\t},\n\t// shape get/set\n\t\"can.assignDeep\": function(source){\n\t\tqueues.batch.start();\n\t\tcanReflect.assignList(this, source);\n\t\tqueues.batch.stop();\n\t},\n\t\"can.updateDeep\": function(source){\n\t\tqueues.batch.start();\n\t\tthis.replace(source);\n\t\tqueues.batch.stop();\n\t},\n\n\t// observability\n\t\"can.keyHasDependencies\": function(key) {\n\t\treturn !!(this._computed && this._computed[key] && this._computed[key].compute);\n\t},\n\t\"can.getKeyDependencies\": function(key) {\n\t\tvar ret;\n\t\tif(this._computed && this._computed[key] && this._computed[key].compute) {\n\t\t\tret = {};\n\t\t\tret.valueDependencies = new Set([\n\t\t\t\tthis._computed[key].compute\n\t\t\t]);\n\t\t}\n\t\treturn ret;\n\t},\n\t/*\"can.onKeysAdded\": function(handler,queue) {\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](\"add\", handler,queue);\n\t},\n\t\"can.onKeysRemoved\": function(handler,queue) {\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](\"remove\", handler,queue);\n\t},*/\n\t\"can.splice\": function(index, deleteCount, insert){\n\t\tthis.splice.apply(this, [index, deleteCount].concat(insert));\n\t},\n\t\"can.onPatches\": function(handler,queue){\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](localOnPatchesSymbol, handler,queue);\n\t},\n\t\"can.offPatches\": function(handler,queue) {\n\t\tthis[canSymbol.for(\"can.offKeyValue\")](localOnPatchesSymbol, handler,queue);\n\t}\n};\n\n//!steal-remove-start\nif(true) {\n\tdefineListProto[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"[]\";\n\t};\n}\n//!steal-remove-end\n\ncanReflect.assignSymbols(DefineList.prototype, defineListProto);\n\ncanReflect.setKeyValue(DefineList.prototype, canSymbol.iterator, function() {\n\tvar index = -1;\n\tif(typeof this._length !== \"number\") {\n\t\tthis._length = 0;\n\t}\n\treturn {\n\t\tnext: function() {\n\t\t\tindex++;\n\t\t\treturn {\n\t\t\t\tvalue: this[index],\n\t\t\t\tdone: index >= this._length\n\t\t\t};\n\t\t}.bind(this)\n\t};\n});\n\n//!steal-remove-start\nif(true) {\n\t// call `list.log()` to log all event changes\n\t// pass `key` to only log the matching event, e.g: `list.log(\"add\")`\n\tDefineList.prototype.log = defineHelpers.log;\n}\n//!steal-remove-end\n\ndefine.DefineList = DefineList;\n\nmodule.exports = ns.DefineList = DefineList;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-define/list/list.js?");

/***/ }),

/***/ "../../node_modules/can-define/map/map.js":
/*!***************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-define/map/map.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Construct = __webpack_require__(/*! can-construct */ \"../../node_modules/can-construct/can-construct.js\");\nvar define = __webpack_require__(/*! can-define */ \"../../node_modules/can-define/can-define.js\");\nvar defineHelpers = __webpack_require__(/*! ../define-helpers/define-helpers */ \"../../node_modules/can-define/define-helpers/define-helpers.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar ns = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar canLog = __webpack_require__(/*! can-log */ \"../../node_modules/can-log/dist/cjs/can-log.js\");\nvar canLogDev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar addTypeEvents = __webpack_require__(/*! can-event-queue/type/type */ \"../../node_modules/can-event-queue/type/type.js\");\n\nvar keysForDefinition = function(definitions) {\n\tvar keys = [];\n\tfor(var prop in definitions) {\n\t\tvar definition = definitions[prop];\n\t\tif(typeof definition !== \"object\" || (\"serialize\" in definition ? !!definition.serialize : !definition.get)) {\n\t\t\tkeys.push(prop);\n\t\t}\n\t}\n\treturn keys;\n};\n\nfunction assign(source) {\n\tqueues.batch.start();\n\tcanReflect.assignMap(this, source || {});\n\tqueues.batch.stop();\n}\nfunction update(source) {\n\tqueues.batch.start();\n\tcanReflect.updateMap(this, source || {});\n\tqueues.batch.stop();\n}\nfunction assignDeep(source){\n\tqueues.batch.start();\n\t// TODO: we should probably just throw an error instead of cleaning\n\tcanReflect.assignDeepMap(this, source || {});\n\tqueues.batch.stop();\n}\nfunction updateDeep(source){\n\tqueues.batch.start();\n\t// TODO: we should probably just throw an error instead of cleaning\n\tcanReflect.updateDeepMap(this, source || {});\n\tqueues.batch.stop();\n}\nfunction setKeyValue(key, value) {\n\tvar defined = defineHelpers.defineExpando(this, key, value);\n\tif(!defined) {\n\t\tthis[key] = value;\n\t}\n}\nfunction getKeyValue(key) {\n\tvar value = this[key];\n\tif(value !== undefined || key in this || Object.isSealed(this)) {\n\t\treturn value;\n\t} else {\n\t\tObservationRecorder.add(this, key);\n\t\treturn this[key];\n\t}\n}\n\nvar getSchemaSymbol = canSymbol.for(\"can.getSchema\");\n\nfunction getSchema() {\n\tvar def = this.prototype._define;\n\tvar definitions = def ? def.definitions : {};\n\tvar schema = {\n\t\ttype: \"map\",\n\t\tidentity: [],\n\t\tkeys: {}\n\t};\n\treturn define.updateSchemaKeys(schema, definitions);\n}\n\nvar DefineMap = Construct.extend(\"DefineMap\",{\n\tsetup: function(base){\n\t\tvar key,\n\t\t\tprototype = this.prototype;\n\t\tif(DefineMap) {\n\t\t\t// we have already created\n\t\t\tvar result = define(prototype, prototype, base.prototype._define);\n\t\t\t\tdefine.makeDefineInstanceKey(this, result);\n\n\t\t\taddTypeEvents(this);\n\t\t\tfor(key in DefineMap.prototype) {\n\t\t\t\tdefine.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);\n\t\t\t}\n\n\t\t\tthis.prototype.setup = function(props){\n\t\t\t\tdefine.setup.call(\n\t\t\t\t\tthis,\n\t\t\t\t\tprops || {},\n\t\t\t\t\tthis.constructor.seal\n\t\t\t\t);\n\t\t\t};\n\t\t} else {\n\t\t\tfor(key in prototype) {\n\t\t\t\tdefine.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);\n\t\t\t}\n\t\t}\n\t\tdefine.defineConfigurableAndNotEnumerable(prototype, \"constructor\", this);\n\t\tthis[getSchemaSymbol] = getSchema;\n\t}\n},{\n\t// setup for only dynamic DefineMap instances\n\tsetup: function(props, sealed){\n\t\tif(!this._define) {\n\t\t\tObject.defineProperty(this,\"_define\",{\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: {\n\t\t\t\t\tdefinitions: {}\n\t\t\t\t}\n\t\t\t});\n\t\t\tObject.defineProperty(this,\"_data\",{\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: {}\n\t\t\t});\n\t\t}\n\t\tdefine.setup.call(\n\t\t\tthis,\n\t\t\tprops || {},\n\t\t\tsealed === true\n\t\t);\n\t},\n\t/**\n\t * @function can-define/map/map.prototype.get get\n\t * @parent can-define/map/map.prototype\n\t *\n\t * @description Get a value or all values from a DefineMap.\n\t *\n\t * @signature `map.get()`\n\t *\n\t * Returns a plain JavaScript object that contains the properties and values of the map instance.  Any property values\n\t * that also have a `get` method will have their `get` method called and the resulting value will be used as\n\t * the property value.  This can be used to recursively convert a map instance to an object of other plain\n\t * JavaScript objects.  Cycles are supported and only create one object.\n\t *\n\t * `.get()` can still return other non plain JS objects like Date.\n\t * Use [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\n\t *\n\t * ```js\n\t * var map = new DefineMap({foo: new DefineMap({bar: \"zed\"})});\n\t * map.get() //-> {foo: {bar: \"zed\"}};\n\t * ```\n\t *\n\t *   @return {Object} A plain JavaScript `Object` that contains all the properties and values of the map instance.\n\t *\n\t * @signature `map.get(propName)`\n\t *\n\t * Get a single property on a DefineMap instance.\n\t *\n\t * `.get(propName)` only should be used when reading properties that might not have been defined yet, but\n\t * will be later via [can-define/map/map.prototype.set].\n\t *\n\t * ```js\n\t * var map = new DefineMap();\n\t * map.get(\"name\") //-> undefined;\n\t * ```\n\t *\n\t *   @param {String} propName The property name of a property that may not have been defined yet.\n\t *   @return {*} The value of that property.\n\t */\n\tget: function(prop){\n\t\tif(prop) {\n\t\t\treturn getKeyValue.call(this, prop);\n\t\t} else {\n\t\t\treturn canReflect.unwrap(this, Map);\n\t\t}\n\t},\n\t/**\n\t * @function can-define/map/map.prototype.set set\n\t * @parent can-define/map/map.prototype\n\t *\n\t * @deprecated {3.10.1} Passing an {Object} to `.set` has been deprecated in favor of [can-define/map/map.prototype.assign] or [can-define/map/map.prototype.update]. `map.set(propName, value)` is _not_ deprecated.\n\t *\n\t * @description Sets multiple properties on a map instance or a property that wasn't predefined.\n\t *\n\t * @signature `map.set(props [,removeProps])`\n\t *\n\t * Assigns each value in `props` to a property on this map instance named after the\n\t * corresponding key in `props`, effectively merging `props` into the Map. If `removeProps` is true, properties not in\n\t * `props` will be set to `undefined`.\n\t *\n\t *   @param {Object} props A collection of key-value pairs to set.\n\t *   If any properties already exist on the map, they will be overwritten.\n\t *\n\t *   @param {Boolean} [removeProps=false] Whether to set keys not present in `props` to `undefined`.\n\t *\n\t *   @return {can-define/map/map} The map instance for chaining.\n\t *\n\t * @signature `map.set(propName, value)`\n\t *\n\t * Assigns _value_ to a property on this map instance called _propName_.  This will define\n\t * the property if it hasn't already been predefined.\n\t *\n\t *   @param {String} propName The property to set.\n\t *   @param {*} value The value to assign to `propName`.\n\t *   @return {can-define/map/map} This map instance, for chaining.\n\t */\n\tset: function(prop, value){\n\t\tif(typeof prop === \"object\") {\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tcanLogDev.warn('can-define/map/map.prototype.set is deprecated; please use can-define/map/map.prototype.assign or can-define/map/map.prototype.update instead');\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tif(value === true) {\n\t\t\t\tupdateDeep.call(this, prop);\n\t\t\t} else {\n\t\t\t\tassignDeep.call(this, prop);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsetKeyValue.call(this, prop, value);\n\t\t}\n\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-define/map/map.prototype.assignDeep assignDeep\n\t * @parent can-define/map/map.prototype\n\t *\n\t * @description Sets multiple properties on a map instance or a property that wasn't predefined.\n\t *\n\t * @signature `map.assignDeep(props)`\n\t *\n\t * Assigns each value in `props` to a property on this map instance named after the\n\t * corresponding key in `props`, effectively replacing `props` into the Map.\n\t * Properties not in `props` will not be changed.\n\t *\n\t * ```js\n\t * var MyMap = DefineMap.extend({\n\t * \tlist: DefineList,\n\t * \tname: 'string'\n\t * });\n\t * var obj = new MyMap({\n\t * \tlist: ['1', '2', '3'],\n\t * \tfoo: 'bar'\n\t * });\n\t * obj.assignDeep({\n\t * \tlist: ['first']\n \t * });\n\t *\n\t * obj.list //-> ['first']\n\t * obj.foo //-> 'bar'\n\t * ```\n\t *   @param {Object} props A collection of key-value pairs to set.\n\t *   If any properties already exist on the map, they will be overwritten.\n\t *\n\t *   @return {can-define/map/map} The map instance for chaining.\n\t *\n\t */\n\tassignDeep: function(prop) {\n\t\tassignDeep.call(this, prop);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-define/map/map.prototype.updateDeep updateDeep\n\t * @parent can-define/map/map.prototype\n\t *\n\t * @description Sets multiple properties on a map instance or a property that wasn't predefined.\n\t *\n\t * @signature `map.updateDeep(props)`\n\t *\n\t * Assigns each value in `props` to a property on this map instance named after the\n\t * corresponding key in `props`, effectively merging `props` into the Map.\n\t * Properties not in `props` will be set to `undefined`.\n\t *\n\t * ```js\n\t * var MyMap = DefineMap.extend({\n\t * \tlist: DefineList,\n\t * \tname: 'string'\n\t * });\n\t * var obj = new MyMap({\n\t * \tlist: ['1', '2', '3'],\n\t * \tname: 'bar',\n\t * \tfoo: {\n\t * \t\tbar: 'zed',\n\t * \t\tboo: 'goo'\n\t * \t}\n\t * });\n\t * obj.updateDeep({\n\t * \tlist: ['first'],\n\t * \tfoo: {\n\t * \t\tbar: 'abc'\n\t * \t}\n \t * });\n\t *\n\t * obj.list //-> ['first', '2', '3']\n\t * obj.foo\t//-> { bar: 'abc', boo: undefined }\n\t * obj.name //-> 'undefined'\n\t * ```\n\t *   @param {Object} props A collection of key-value pairs to set.\n\t *   If any properties already exist on the map, they will be overwritten.\n\t *\n\t *   @return {can-define/map/map} The map instance for chaining.\n\t *\n\t */\n\tupdateDeep: function(prop) {\n\t\tupdateDeep.call(this, prop);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-define/map/map.prototype.assign assign\n\t * @parent can-define/map/map.prototype\n\t *\n\t * @description Sets multiple properties on a map instance or a property that wasn't predefined.\n\t *\n\t * @signature `map.assign(props)`\n\t *\n\t * ```js\n\t * var MyMap = DefineMap.extend({\n\t * \tlist: DefineList,\n\t * \tname: 'string'\n\t * });\n\t * var obj = new MyMap({\n\t * \tlist: ['1', '2', '3'],\n\t * \tfoo: 'bar'\n\t * });\n\t * obj.assign({\n\t * \tlist: ['first']\n \t * });\n\t *\n\t * obj.list //-> ['first']\n\t * obj.foo //-> 'bar'\n\t * ```\n\t * Assigns each value in `props` to a property on this map instance named after the\n\t * corresponding key in `props`, effectively replacing `props` into the Map.\n\t * Properties not in `props` will not be changed.\n\t *\n\t *   @param {Object} props A collection of key-value pairs to set.\n\t *   If any properties already exist on the map, they will be overwritten.\n\t *\n\t *   @return {can-define/map/map} The map instance for chaining.\n\t *\n\t */\n\tassign: function(prop) {\n\t\tassign.call(this, prop);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-define/map/map.prototype.update update\n\t * @parent can-define/map/map.prototype\n\t *\n\t * @description Sets multiple properties on a map instance or a property that wasn't predefined.\n\t *\n\t * @signature `map.update(props)`\n\t *\n\t * ```js\n\t * var MyMap = DefineMap.extend({\n\t * \tlist: DefineList,\n\t * \tname: 'string'\n\t * });\n\t * var obj = new MyMap({\n\t * \tlist: ['1', '2', '3'],\n\t * \tfoo: 'bar'\n\t * });\n\t * obj.update({\n\t * \tlist: ['first']\n \t * });\n\t *\n\t * obj.list //-> ['first', '2', '3']\n\t * obj.foo //-> 'undefined'\n\t * ```\n\t * Assigns each value in `props` to a property on this map instance named after the\n\t * corresponding key in `props`, effectively merging `props` into the Map.\n\t * Properties not in `props` will be set to `undefined`.\n\t *\n\t *   @param {Object} props A collection of key-value pairs to set.\n\t *   If any properties already exist on the map, they will be overwritten.\n\t *\n\t *   @return {can-define/map/map} The map instance for chaining.\n\t *\n\t */\n\tupdate: function(prop) {\n\t\tupdate.call(this, prop);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-define/map/map.prototype.serialize serialize\n\t * @parent can-define/map/map.prototype\n\t *\n\t * @description Get a serialized representation of the map instance and its children.\n\t *\n\t * @signature `map.serialize()`\n\t *\n\t * Get the serialized Object form of the map.  Serialized\n\t * data is typically used to send back to a server.  Use [can-define.types.serialize]\n\t * to customize a property's serialized value or if the property should be added to\n\t * the result or not.\n\t *\n\t * `undefined` serialized values are not added to the result.\n\t *\n\t * ```js\n\t * var MyMap = DefineMap.extend({\n\t *   date: {\n\t *     type: \"date\",\n\t *     serialize: function(date){\n\t *       return date.getTime()\n\t *     }\n\t *   }\n\t * });\n\t *\n\t * var myMap = new MyMap({date: new Date(), count: 5});\n\t * myMap.serialize() //-> {date: 1469566698504, count: 5}\n\t * ```\n\t *\n\t *   @return {Object} A JavaScript Object that can be serialized with `JSON.stringify` or other methods.\n\t *\n\t */\n\tserialize: function () {\n\t\treturn canReflect.serialize(this, Map);\n\t},\n\tdeleteKey: defineHelpers.deleteKey,\n\tforEach: (function(){\n\n\t\tvar forEach = function(list, cb, thisarg){\n\t\t\treturn canReflect.eachKey(list, cb, thisarg);\n\t\t},\n\t\t\tnoObserve = ObservationRecorder.ignore(forEach);\n\n\t\treturn function(cb, thisarg, observe) {\n\t\t\treturn observe === false ? noObserve(this, cb, thisarg) : forEach(this, cb, thisarg);\n\t\t};\n\n\t})(),\n\t\"*\": {\n\t\ttype: define.types.observable\n\t}\n});\n\nvar defineMapProto = {\n\t// -type-\n\t\"can.isMapLike\": true,\n\t\"can.isListLike\":  false,\n\t\"can.isValueLike\": false,\n\n\t// -get/set-\n\t\"can.getKeyValue\": getKeyValue,\n\t\"can.setKeyValue\": setKeyValue,\n\t\"can.deleteKeyValue\": defineHelpers.deleteKey,\n\n\t// -shape\n\t\"can.getOwnKeys\": function() {\n\t\tvar keys = canReflect.getOwnEnumerableKeys(this);\n\t\tif(this._computed) {\n\t\t\tvar computedKeys = canReflect.getOwnKeys(this._computed);\n\n\t\t\tvar key;\n\t\t\tfor (var i=0; i<computedKeys.length; i++) {\n\t\t\t\tkey = computedKeys[i];\n\t\t\t\tif (keys.indexOf(key) < 0) {\n\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t},\n\t\"can.getOwnEnumerableKeys\": function(){\n\t\tObservationRecorder.add(this, 'can.keys');\n\t\treturn keysForDefinition(this._define.definitions).concat(keysForDefinition(this._instanceDefinitions) );\n\t},\n\t\"can.hasOwnKey\": function(key) {\n\t\treturn Object.hasOwnProperty.call(this._define.definitions, key);\n\t},\n\t\"can.hasKey\": function(key) {\n\t\treturn !!this._define.definitions[key];\n\t},\n\n\t// -shape get/set-\n\t\"can.assignDeep\": assignDeep,\n\t\"can.updateDeep\": updateDeep,\n\t\"can.unwrap\": defineHelpers.reflectUnwrap,\n\t\"can.serialize\": defineHelpers.reflectSerialize,\n\n\t// observable\n\t\"can.keyHasDependencies\": function(key) {\n\t\treturn !!(this._computed && this._computed[key] && this._computed[key].compute);\n\t},\n\t\"can.getKeyDependencies\": function(key) {\n\t\tvar ret;\n\t\tif(this._computed && this._computed[key] && this._computed[key].compute) {\n\t\t\tret = {};\n\t\t\tret.valueDependencies = new Set([\n\t\t\t\tthis._computed[key].compute\n\t\t\t]);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n//!steal-remove-start\nif(true) {\n\tdefineMapProto[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"{}\";\n\t};\n}\n//!steal-remove-end\n\ncanReflect.assignSymbols(DefineMap.prototype, defineMapProto);\n\ncanReflect.setKeyValue(DefineMap.prototype, canSymbol.iterator, function() {\n\treturn new define.Iterator(this);\n});\n\n// Add necessary event methods to this object.\nfor(var prop in define.eventsProto) {\n\tDefineMap[prop] = define.eventsProto[prop];\n\tObject.defineProperty(DefineMap.prototype, prop, {\n\t\tenumerable:false,\n\t\tvalue: define.eventsProto[prop],\n\t\twritable: true\n\t});\n}\n// @@can.onKeyValue and @@can.offKeyValue are also on define.eventsProto\n//  but symbols are not enumerated in for...in loops\nvar eventsProtoSymbols = (\"getOwnPropertySymbols\" in Object) ?\n  Object.getOwnPropertySymbols(define.eventsProto) :\n  [canSymbol.for(\"can.onKeyValue\"), canSymbol.for(\"can.offKeyValue\")];\n\neventsProtoSymbols.forEach(function(sym) {\n  Object.defineProperty(DefineMap.prototype, sym, {\n    enumerable:false,\n    value: define.eventsProto[sym],\n    writable: true\n  });\n});\n\n\n//!steal-remove-start\nif(true) {\n\t// call `map.log()` to log all event changes\n\t// pass `key` to only log the matching property, e.g: `map.log(\"foo\")`\n\tDefineMap.prototype.log = defineHelpers.log;\n}\n//!steal-remove-end\n\n// tells `can-define` to use this\ndefine.DefineMap = DefineMap;\n\nObject.defineProperty(DefineMap.prototype, \"toObject\", {\n\tenumerable: false,\n\twritable: true,\n\tvalue: function(){\n\t\tcanLog.warn(\"Use DefineMap::get instead of DefineMap::toObject\");\n\t\treturn this.get();\n\t}\n});\n\nmodule.exports = ns.DefineMap = DefineMap;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-define/map/map.js?");

/***/ }),

/***/ "../../node_modules/can-diff/list/list.js":
/*!***************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-diff/list/list.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nvar slice = [].slice;\n// a b c\n// a b c d\n// [[2,0, d]]\n\n\nfunction defaultIdentity(a, b){\n    return a === b;\n}\n\nfunction makeIdentityFromMapSchema(typeSchema) {\n    if(typeSchema.identity && typeSchema.identity.length) {\n        return function identityCheck(a, b) {\n            var aId = canReflect.getIdentity(a, typeSchema),\n                bId = canReflect.getIdentity(b, typeSchema);\n            return aId === bId;\n        };\n    } else {\n        return defaultIdentity;\n    }\n}\n\nfunction makeIdentityFromListSchema(listSchema) {\n    return listSchema.values != null ?\n        makeIdentityFromMapSchema( canReflect.getSchema(listSchema.values) ) :\n        defaultIdentity;\n}\n\nfunction makeIdentity(oldList, oldListLength) {\n    var listSchema = canReflect.getSchema(oldList),\n        typeSchema;\n    if(listSchema != null) {\n        if(listSchema.values != null) {\n            typeSchema = canReflect.getSchema(listSchema.values);\n        } else {\n            return defaultIdentity;\n        }\n    }\n    if(typeSchema == null && oldListLength > 0) {\n        typeSchema = canReflect.getSchema( canReflect.getKeyValue(oldList, 0) );\n    }\n    if(typeSchema) {\n        return makeIdentityFromMapSchema(typeSchema);\n    } else {\n        return defaultIdentity;\n    }\n}\n\n\n\nfunction reverseDiff(oldDiffStopIndex, newDiffStopIndex, oldList, newList, identity) {\n\tvar oldIndex = oldList.length - 1,\n\t\tnewIndex =  newList.length - 1;\n\n\twhile( oldIndex > oldDiffStopIndex && newIndex > newDiffStopIndex) {\n\t\tvar oldItem = oldList[oldIndex],\n\t\t\tnewItem = newList[newIndex];\n\n\t\tif( identity( oldItem, newItem ) ) {\n\t\t\toldIndex--;\n\t\t\tnewIndex--;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t// use newIndex because it reflects any deletions\n\t\t\treturn [{\n                type: \"splice\",\n\t\t\t\tindex: newDiffStopIndex,\n\t\t\t \tdeleteCount: (oldIndex-oldDiffStopIndex+1),\n\t\t\t \tinsert: slice.call(newList, newDiffStopIndex,newIndex+1)\n\t\t\t}];\n\t\t}\n\t}\n\t// if we've reached of either the new or old list\n\t// we simply return\n\treturn [{\n        type: \"splice\",\n\t\tindex: newDiffStopIndex,\n\t\tdeleteCount: (oldIndex-oldDiffStopIndex+1),\n\t\tinsert: slice.call(newList, newDiffStopIndex,newIndex+1)\n\t}];\n\n}\n\n/**\n * @module {function} can-diff/list/list\n * @parent can-diff\n *\n * @description Return a difference of two lists.\n *\n * @signature `diffList( oldList, newList, [identity] )`\n *\n * Compares two lists and produces a sequence of patches that can be applied to make `oldList` take\n * the shape of `newList`.\n *\n * ```js\n * var diffList = require(\"can-diff/list/list\");\n *\n * console.log(diff([1], [1, 2])); // -> [{type: \"splice\", index: 1, deleteCount: 0, insert: [2]}]\n * console.log(diff([1, 2], [1])); // -> [{type: \"splice\", index: 1, deleteCount: 1, insert: []}]\n *\n * // with an optional identity function:\n * diffList(\n *     [{id:1},{id:2}],\n *     [{id:1},{id:3}],\n *     (a,b) => a.id === b.id\n * ); // -> [{type: \"splice\", index: 1, deleteCount: 1, insert: [{id:3}]}]\n * ```\n *\n * The patch algorithm is linear with respect to the length of the lists and therefore does not produce a\n * [perfect edit distance](https://en.wikipedia.org/wiki/Edit_distance) (which would be at least quadratic).\n *\n * It is designed to work with most common list change scenarios, when items are inserted or removed\n * to a list (as opposed to moved with in the last).\n *\n * For example, it is able to produce the following patches:\n *\n * ```js\n * diffList(\n *     [\"a\",\"b\",\"c\",\"d\"],\n *     [\"a\",\"b\",\"X\",\"Y\",\"c\",\"d\"]\n * ); // -> [{type: \"splice\", index: 2, deleteCount: 0, insert: [\"X\",\"Y\"]}]\n * ```\n *\n * @param  {ArrayLike} oldList The source array or list to diff from.\n * @param  {ArrayLike} newList The array or list to diff to.\n * @param  {function|can-reflect.getSchema} schemaOrIdentity An optional identity function or a schema with\n * an identity property for comparing elements.  If a `schemaOrIdentity` is not provided, the schema of\n * the `oldList` will be used.  If a schema can not be found, items a default identity function will be created\n * that checks if the two values are strictly equal `===`.\n * @return {Array} An array of [can-symbol/types/Patch] objects representing the differences\n *\n * Returns the difference between two ArrayLike objects (that have nonnegative\n * integer keys and the `length` property) as an array of patch objects.\n *\n * A patch object returned by this function has the following properties:\n * - **type**: the type of patch (`\"splice\"`).\n * - **index**:  the index of newList where the patch begins\n * - **deleteCount**: the number of items deleted from that index in newList\n * - **insert**: an Array of items newly inserted at that index in newList\n *\n * Patches should be applied in the order they are returned.\n */\n\nmodule.exports = function(oldList, newList, schemaOrIdentity){\n    var oldIndex = 0,\n\t\tnewIndex =  0,\n\t\toldLength = canReflect.size( oldList ),\n\t\tnewLength = canReflect.size( newList ),\n\t\tpatches = [];\n\n    var schemaType = typeof schemaOrIdentity,\n        identity;\n    if(schemaType === \"function\") {\n        identity = schemaOrIdentity;\n    } else if(schemaOrIdentity != null) {\n        if(schemaOrIdentity.type === \"map\") {\n            identity = makeIdentityFromMapSchema(schemaOrIdentity);\n        } else {\n            identity = makeIdentityFromListSchema(schemaOrIdentity);\n        }\n    } else {\n        identity = makeIdentity(oldList, oldLength);\n    }\n\n\n\n\twhile(oldIndex < oldLength && newIndex < newLength) {\n\t\tvar oldItem = oldList[oldIndex],\n\t\t\tnewItem = newList[newIndex];\n\n\t\tif( identity( oldItem, newItem ) ) {\n\t\t\toldIndex++;\n\t\t\tnewIndex++;\n\t\t\tcontinue;\n\t\t}\n\t\t// look for single insert, does the next newList item equal the current oldList.\n\t\t// 1 2 3\n\t\t// 1 2 4 3\n\t\tif(  newIndex+1 < newLength && identity( oldItem, newList[newIndex+1] ) ) {\n\t\t\tpatches.push({index: newIndex, deleteCount: 0, insert: [ newList[newIndex] ], type: \"splice\"});\n\t\t\toldIndex++;\n\t\t\tnewIndex += 2;\n\t\t\tcontinue;\n\t\t}\n\t\t// look for single removal, does the next item in the oldList equal the current newList item.\n\t\t// 1 2 3\n\t\t// 1 3\n\t\telse if( oldIndex+1 < oldLength  && identity( oldList[oldIndex+1], newItem ) ) {\n\t\t\tpatches.push({index: newIndex, deleteCount: 1, insert: [], type: \"splice\"});\n\t\t\toldIndex += 2;\n\t\t\tnewIndex++;\n\t\t\tcontinue;\n\t\t}\n\t\t// just clean up the rest and exit\n\t\t// 1 2 3\n\t\t// 1 2 5 6 7\n\t\telse {\n\t\t\t// iterate backwards to `newIndex`\n\t\t\t// \"a\", \"b\", \"c\", \"d\", \"e\"\n\t\t\t// \"a\", \"x\", \"y\", \"z\", \"e\"\n\t\t\t// -> {}\n\t\t\tpatches.push.apply(patches, reverseDiff(oldIndex, newIndex , oldList, newList, identity) );\n\n\n\t\t\treturn patches;\n\t\t}\n\t}\n\tif( (newIndex === newLength) && (oldIndex === oldLength) ) {\n\t\treturn patches;\n\t}\n\t// a b\n\t// a b c d e\n\tpatches.push(\n\t\t\t\t{type: \"splice\", index: newIndex,\n\t\t\t\t deleteCount: oldLength-oldIndex,\n\t\t\t\t insert: slice.call(newList, newIndex) } );\n\n\treturn patches;\n};\n\n\n\n\n// a b c\n// a d e b c\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-diff/list/list.js?");

/***/ }),

/***/ "../../node_modules/can-diff/patcher/patcher.js":
/*!*********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-diff/patcher/patcher.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"../../node_modules/can-key-tree/dist/cjs/can-key-tree.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar diff = __webpack_require__(/*! ../list/list */ \"../../node_modules/can-diff/list/list.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n\nvar onValueSymbol = canSymbol.for(\"can.onValue\"),\n\toffValueSymbol = canSymbol.for(\"can.offValue\");\nvar onPatchesSymbol = canSymbol.for(\"can.onPatches\");\nvar offPatchesSymbol = canSymbol.for(\"can.offPatches\");\n\n// Patcher takes a observable that might wrap a list type.\n// When the observable changes, it will diff, and emit patches,\n// and if the list emits patches, it will emit those too.\n// It is expected that only `domUI` handlers are registered.\n/*\nvar observable = new SimpleObservable( new DefineList([ \"a\", \"b\", \"c\" ]) )\nvar patcher = new Patcher(observable)\ncanReflect.onPatches( patcher,function(patches){\n  console.log(patches) // a patch removing c, then a\n})\nvar newList = new DefineList([\"a\",\"b\"]);\nobservable.set(newList);\nnewList.unshift(\"X\");\n[\n    {type: \"splice\", index: 2, deleteCount: 1}\n]\nvar patches2 = [\n    {type: \"splice\", index: 0, deleteCount: 0, inserted: [\"X\"]}\n]\n */\nvar Patcher = function(observableOrList, priority) {\n\t// stores listeners for this patcher\n\tthis.handlers = new KeyTree([Object, Array], {\n\t\t// call setup when the first handler is bound\n\t\tonFirst: this.setup.bind(this),\n\t\t// call teardown when the last handler is removed\n\t\tonEmpty: this.teardown.bind(this)\n\t});\n\n\t// save this value observable or patch emitter (list)\n\tthis.observableOrList = observableOrList;\n\t// if we were passed an observable value that we need to read its array for changes\n\tthis.isObservableValue = canReflect.isValueLike(this.observableOrList) || canReflect.isObservableLike(this.observableOrList);\n\tif(this.isObservableValue) {\n\t    this.priority = canReflect.getPriority(observableOrList);\n\t} else {\n\t    this.priority = priority || 0;\n\t}\n\tthis.onList = this.onList.bind(this);\n\tthis.onPatchesNotify = this.onPatchesNotify.bind(this);\n\t// needs to be unique so the derive queue doesn't only add one.\n\tthis.onPatchesDerive = this.onPatchesDerive.bind(this);\n\n\t// stores patches that have happened between notification and\n\t// when we queue the  `onPatches` handlers in the `domUI` queue\n\tthis.patches = [];\n\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tObject.defineProperty(this.onList, \"name\", {\n\t\t\tvalue: \"live.list new list::\"+canReflect.getName(observableOrList),\n\t\t});\n\t\tObject.defineProperty(this.onPatchesNotify, \"name\", {\n\t\t\tvalue: \"live.list notify::\"+canReflect.getName(observableOrList),\n\t\t});\n\t\tObject.defineProperty(this.onPatchesDerive, \"name\", {\n\t\t\tvalue: \"live.list derive::\"+canReflect.getName(observableOrList),\n\t\t});\n\t}\n\t//!steal-remove-end\n};\n\n\nPatcher.prototype = {\n\tconstructor: Patcher,\n\tsetup: function() {\n\t\tif (this.observableOrList[onValueSymbol]) {\n\t\t\t// if we have an observable value, listen to when it changes to get a\n\t\t\t// new list.\n\t\t\tcanReflect.onValue(this.observableOrList, this.onList, \"notify\");\n\t\t\t// listen on the current value (which shoudl be a list) if there is one\n\t\t\tthis.setupList(canReflect.getValue(this.observableOrList));\n\t\t} else {\n\t\t\tthis.setupList(this.observableOrList);\n\t\t}\n\t},\n\tteardown: function() {\n\t\tif (this.observableOrList[offValueSymbol]) {\n\t\t\tcanReflect.offValue(this.observableOrList, this.onList, \"notify\");\n\t\t}\n\t},\n\t// listen to the list for patches\n\tsetupList: function(list) {\n\t\tthis.currentList = list;\n\t\tif (list && list[onPatchesSymbol]) {\n\t\t\t// If observable, set up bindings on list changes\n\t\t\tlist[onPatchesSymbol](this.onPatchesNotify, \"notify\");\n\t\t}\n\t},\n\t// when the list changes, teardown the old list bindings\n\t// and setup the new list\n\tonList: function onList(newList) {\n\t\tvar current = this.currentList || [];\n\t\tnewList = newList || [];\n\t\tif (current[offPatchesSymbol]) {\n\t\t\tcurrent[offPatchesSymbol](this.onPatchesNotify, \"notify\");\n\t\t}\n\t\tvar patches = diff(current, newList);\n\t\tthis.currentList = newList;\n\t\tthis.onPatchesNotify(patches);\n\t\tif (newList[onPatchesSymbol]) {\n\t\t\t// If observable, set up bindings on list changes\n\t\t\tnewList[onPatchesSymbol](this.onPatchesNotify, \"notify\");\n\t\t}\n\t},\n\t// This is when we get notified of patches on the underlying list.\n\t// Save the patches and queue up a `derive` task that will\n\t// call `domUI` updates.\n\tonPatchesNotify: function onPatchesNotify(patches) {\n\t\t// we are going to collect all patches\n\t\tthis.patches.push.apply(this.patches, patches);\n\t\t// TODO: share priority\n\t\tqueues.deriveQueue.enqueue(this.onPatchesDerive, this, [], {\n\t\t\tpriority: this.priority\n\t\t});\n\t},\n\t// Let handlers (which should only be registered in `domUI`) know about patches\n\t// that they can apply.\n\tonPatchesDerive: function onPatchesDerive() {\n\t\tvar patches = this.patches;\n\t\tthis.patches = [];\n\t\tqueues.enqueueByQueue(this.handlers.getNode([]), this.currentList, [patches, this.currentList], null,[\"Apply patches\", patches]);\n\t}\n};\n\ncanReflect.assignSymbols(Patcher.prototype, {\n\t\"can.onPatches\": function(handler, queue) {\n\t\tthis.handlers.add([queue || \"mutate\", handler]);\n\t},\n\t\"can.offPatches\": function(handler, queue) {\n\t\tthis.handlers.delete([queue || \"mutate\", handler]);\n\t}\n});\n\nmodule.exports = Patcher;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-diff/patcher/patcher.js?");

/***/ }),

/***/ "../../node_modules/can-dom-data-state/can-dom-data-state.js":
/*!**********************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-data-state/can-dom-data-state.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"../../node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar CID = __webpack_require__(/*! can-cid */ \"../../node_modules/can-cid/can-cid.js\");\n\nvar isEmptyObject = function(obj){\n\t/* jshint -W098 */\n\tfor(var prop in obj) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\nvar data = {};\nvar removedDisposalMap = {};\n\n// delete this node's `data`\n// returns true if the node was deleted.\nvar deleteNode = function() {\n\tvar id = CID.get(this);\n\tvar nodeDeleted = false;\n\tif(id && data[id]) {\n\t\tnodeDeleted = true;\n\t\tdelete data[id];\n\t}\n\tif (removedDisposalMap[id]) {\n\t\tremovedDisposalMap[id]();\n\t\tdelete removedDisposalMap[id];\n\t}\n\treturn nodeDeleted;\n};\n\nvar setData = function(name, value) {\n\tvar id = CID(this);\n\tvar store = data[id] || (data[id] = {});\n\tif (name !== undefined) {\n\t\tstore[name] = value;\n\t\tvar isNode = !!(this && typeof this.nodeType === 'number');\n\t\tif (isNode && !removedDisposalMap[id]) {\n\t\t\tvar target = this;\n\t\t\tremovedDisposalMap[id] = domMutate.onNodeRemoval(target, function () {\n\t\t\t\tif (!target.ownerDocument.contains(target)) {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tdeleteNode(target);\n\t\t\t\t\t}, 13);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\treturn store;\n};\n\n/*\n * Core of domData that does not depend on mutationDocument\n * This is separated in order to prevent circular dependencies\n */\nvar domDataState = {\n\t_data: data,\n\t_removalDisposalMap: removedDisposalMap,\n\n\tgetCid: function() {\n\t\t// TODO log warning! to use can-cid directly\n\t\treturn CID.get(this);\n\t},\n\n\tcid: function(){\n\t\t// TODO log warning!\n\t\treturn CID(this);\n\t},\n\n\texpando: CID.domExpando,\n\n\tget: function(key) {\n\t\tvar id = CID.get(this),\n\t\t\tstore = id && data[id];\n\t\treturn key === undefined ? store : store && store[key];\n\t},\n\n\tset: setData,\n\n\tclean: function(prop) {\n\t\tvar id = CID.get(this);\n\t\tvar itemData = data[id];\n\t\tif (itemData && itemData[prop]) {\n\t\t\tdelete itemData[prop];\n\t\t}\n\t\tif(isEmptyObject(itemData)) {\n\t\t\tdeleteNode.call(this);\n\t\t}\n\t},\n\n\tdelete: deleteNode\n};\n\nif (namespace.domDataState) {\n\tthrow new Error(\"You can't have two versions of can-dom-data-state, check your dependencies\");\n} else {\n\tmodule.exports = namespace.domDataState = domDataState;\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-data-state/can-dom-data-state.js?");

/***/ }),

/***/ "../../node_modules/can-dom-data/can-dom-data.js":
/*!**********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-data/can-dom-data.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\n\nvar isEmptyObject = function(obj){\n\t/* jshint -W098 */\n\tfor(var prop in obj) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\nvar data = new WeakMap();\n\n// delete this node's `data`\n// returns true if the node was deleted.\nvar deleteNode = function(node) {\n\tvar nodeDeleted = false;\n\tif (data.has(node)) {\n\t\tnodeDeleted = true;\n\t\tdata.delete(node);\n\t}\n\treturn nodeDeleted;\n};\n\nvar setData = function(node, name, value) {\n\tvar store = data.get(node);\n\tif (store === undefined) {\n\t\tstore = {};\n\t\tdata.set(node, store);\n\t}\n\tif (name !== undefined) {\n\t\tstore[name] = value;\n\t}\n\treturn store;\n};\n\n/*\n * Core of domData that does not depend on mutationDocument\n * This is separated in order to prevent circular dependencies\n */\nvar domData = {\n\t_data: data,\n\n\tget: function(node, key) {\n\t\tvar store = data.get(node);\n\t\treturn key === undefined ? store : store && store[key];\n\t},\n\n\tset: setData,\n\n\tclean: function(node, prop) {\n\t\tvar itemData = data.get(node);\n\t\tif (itemData && itemData[prop]) {\n\t\t\tdelete itemData[prop];\n\t\t}\n\t\tif (isEmptyObject(itemData)) {\n\t\t\tdeleteNode(node);\n\t\t}\n\t},\n\n\tdelete: deleteNode\n};\n\nif (namespace.domData) {\n\tthrow new Error(\"You can't have two versions of can-dom-data, check your dependencies\");\n} else {\n\tmodule.exports = namespace.domData = domData;\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-data/can-dom-data.js?");

/***/ }),

/***/ "../../node_modules/can-dom-events/can-dom-events.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-events/can-dom-events.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar util = __webpack_require__(/*! ./helpers/util */ \"../../node_modules/can-dom-events/helpers/util.js\");\nvar makeEventRegistry = __webpack_require__(/*! ./helpers/make-event-registry */ \"../../node_modules/can-dom-events/helpers/make-event-registry.js\");\nvar makeDelegateEventTree = __webpack_require__(/*! ./helpers/-make-delegate-event-tree */ \"../../node_modules/can-dom-events/helpers/-make-delegate-event-tree.js\");\n\n\nvar domEvents = {\n\t_eventRegistry: makeEventRegistry(),\n\n\t/**\n\t* @function can-dom-events.addEvent addEvent\n\t* @parent can-dom-events.static\n\t*\n\t* Add a custom event to the global event registry.\n\t*\n\t* @signature `addEvent( event [, eventType ] )`\n\t*\n\t* ```js\n\t* var removeReturnEvent = domEvents.addEvent(enterEvent, \"return\");\n\t* ```\n\t*\n\t* @param {can-dom-events/EventDefinition} event The custom event definition.\n\t* @param {String} eventType The event type to associated with the custom event.\n\t* @return {function} The callback to remove the custom event from the registry.\n\t*/\n\taddEvent: function(event, eventType) {\n\t\treturn this._eventRegistry.add(event, eventType);\n\t},\n\n\t/**\n\t* @function can-dom-events.addEventListener addEventListener\n\t*\n\t* Add an event listener for eventType to the target.\n\t*\n\t* @signature `addEventListener( target, eventType, ...eventArgs )`\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} target The object to which to add the listener.\n\t* @param {String} eventType The event type with which to register.\n\t* @param {*} eventArgs The arguments which configure the associated event's behavior. This is usually a\n\t* function event handler.\n\t*/\n\taddEventListener: function(target, eventType) {\n\t\tvar hasCustomEvent = domEvents._eventRegistry.has(eventType);\n\t\tif (hasCustomEvent) {\n\t\t\tvar event = domEvents._eventRegistry.get(eventType);\n\t\t\treturn event.addEventListener.apply(domEvents, arguments);\n\t\t}\n\n\t\tvar eventArgs = Array.prototype.slice.call(arguments, 1);\n\t\treturn target.addEventListener.apply(target, eventArgs);\n\t},\n\n\t/**\n\t* @function can-dom-events.removeEventListener removeEventListener\n\t*\n\t* Remove an event listener for eventType to the target.\n\t*\n\t* @signature `removeEventListener( target, eventType, ...eventArgs )`\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} target The object to which to add the listener.\n\t* @param {String} eventType The event type with which to unregister.\n\t* @param {*} eventArgs The arguments which configure the associated event's behavior. This is usually a\n\t* function event handler.\n\t*/\n\tremoveEventListener: function(target, eventType) {\n\t\tvar hasCustomEvent = domEvents._eventRegistry.has(eventType);\n\t\tif (hasCustomEvent) {\n\t\t\tvar event = domEvents._eventRegistry.get(eventType);\n\t\t\treturn event.removeEventListener.apply(domEvents, arguments);\n\t\t}\n\n\t\tvar eventArgs = Array.prototype.slice.call(arguments, 1);\n\t\treturn target.removeEventListener.apply(target, eventArgs);\n\t},\n\n\t/**\n\t* @function can-dom-events.addDelegateListener addDelegateListener\n\t*\n\t* Attach a handler for an event for all elements that match the selector,\n\t* now or in the future, based on a root element.\n\t*\n\t* @signature `addDelegateListener( target, eventType, selector, handler )`\n\t*\n\t* ```js\n\t* // Prevents all anchor elements from changing the page\n\t* domEvents.addDelegateListener(document.body,\"click\", \"a\", function(event){\n\t*   event.preventDefault();\n\t* })\n\t* ```\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} root The html element to listen to events that match selector within.\n\t* @param {String} eventType The event name to listen to.\n\t* @param {String} selector A selector to filter the elements that trigger the event.\n\t* @param {function} handler A function to execute at the time the event is triggered.\n\t*/\n\taddDelegateListener: function(root, eventType, selector, handler) {\n\t\tdomEvents._eventTree.add([root, eventType, selector, handler]);\n\t},\n\t/**\n\t* @function can-dom-events.removeDelegateListener removeDelegateListener\n\t*\n\t* Remove a handler for an event for all elements that match the selector.\n\t*\n\t* @signature `removeDelegateListener( target, eventType, selector, handler )`\n\t*\n\t* ```js\n\t* // Prevents all anchor elements from changing the page\n\t* function handler(event) {\n\t*   event.preventDefault();\n\t* }\n\t* domEvents.addDelegateListener(document.body,\"click\", \"a\", handler);\n\t*\n\t* domEvents.removeDelegateListener(document.body,\"click\", \"a\", handler);\n\t* ```\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} root The html element to listen to events that match selector within.\n\t* @param {String} eventType The event name to listen to.\n\t* @param {String} selector A selector to filter the elements that trigger the event.\n\t* @param {function} handler A function that was previously passed to `addDelegateListener`.\n\t*/\n\tremoveDelegateListener: function(target, eventType, selector, handler) {\n\t\tdomEvents._eventTree.delete([target, eventType, selector, handler]);\n\t},\n\n\t/**\n\t* @function can-dom-events.dispatch dispatch\n\t*\n\t* Create and dispatch a configured event on the target.\n\t*\n\t* @signature `dispatch( target, eventData [, bubbles ][, cancelable ] )`\n\t* @parent can-dom-events.static\n\t* @param {DomEventTarget} target The object to which to add the listener.\n\t* @param {Object | String} eventData The data to be assigned to the event. If it is a string, that will be the event type.\n\t* @param {Boolean} bubbles Whether the event should bubble; defaults to true.\n\t* @param {Boolean} cancelable Whether the event can be cancelled; defaults to false.\n\t* @return {Boolean} notCancelled Whether the event dispatched without being cancelled.\n\t*/\n\tdispatch: function(target, eventData, bubbles, cancelable) {\n\t\tvar event = util.createEvent(target, eventData, bubbles, cancelable);\n\t\tvar enableForDispatch = util.forceEnabledForDispatch(target, event);\n\t\tif(enableForDispatch) {\n\t\t\ttarget.disabled = false;\n\t\t}\n\n\t\tvar ret = target.dispatchEvent(event);\n\t\tif(enableForDispatch) {\n\t\t\ttarget.disabled = true;\n\t\t}\n\n\t\treturn ret;\n\t}\n};\n\ndomEvents._eventTree = makeDelegateEventTree(domEvents);\n\n\n\n\n\nmodule.exports = namespace.domEvents = domEvents;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-events/can-dom-events.js?");

/***/ }),

/***/ "../../node_modules/can-dom-events/helpers/-make-delegate-event-tree.js":
/*!*********************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-events/helpers/-make-delegate-event-tree.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"../../node_modules/can-key-tree/dist/cjs/can-key-tree.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\n// Some events do not bubble, so delegating them requires registering the handler in the\n// capturing phase.\n// http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\nvar useCapture = function(eventType) {\n\treturn eventType === 'focus' || eventType === 'blur';\n};\n\nfunction makeDelegator (domEvents) {\n\tvar Delegator = function Delegator (parentKey){\n\t\tthis.element = parentKey; // HTMLElement\n\t\tthis.events = {}; // {[eventType: string]: Array<(event) -> void>}\n\t\tthis.delegated = {}; // {[eventType: string]: (event) -> void}\n\t};\n\n\tcanReflect.assignSymbols( Delegator.prototype, {\n\t\t\"can.setKeyValue\": function(eventType, handlersBySelector){\n\t\t\tvar handler = this.delegated[eventType] = function(ev){\n\t\t\t\tcanReflect.each(handlersBySelector, function(handlers, selector){\n\t\t\t\t\tvar cur = ev.target;\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// document does not implement `.matches` but documentElement does\n\t\t\t\t\t\tvar el = cur === document ? document.documentElement : cur;\n\t\t\t\t\t\tvar matches = el.matches || el.msMatchesSelector;\n\n\t\t\t\t\t\tif (matches.call(el, selector)) {\n\t\t\t\t\t\t\thandlers.forEach(function(handler){\n\t\t\t\t\t\t\t\thandler.call(el, ev);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// since `el` points to `documentElement` when `cur` === document,\n\t\t\t\t\t\t// we need to continue using `cur` as the loop pointer, otherwhise\n\t\t\t\t\t\t// it will never end as documentElement.parentNode === document\n\t\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t\t} while (cur && cur !== ev.currentTarget);\n\t\t\t\t});\n\t\t\t};\n\t\t\tthis.events[eventType] = handlersBySelector;\n\t\t\tdomEvents.addEventListener(this.element, eventType, handler, useCapture(eventType));\n\t\t},\n\t\t\"can.getKeyValue\": function(eventType) {\n\t\t\treturn this.events[eventType];\n\t\t},\n\t\t\"can.deleteKeyValue\": function(eventType) {\n\t\t\tdomEvents.removeEventListener(this.element, eventType, this.delegated[eventType], useCapture(eventType));\n\t\t\tdelete this.delegated[eventType];\n\t\t\tdelete this.events[eventType];\n\t\t},\n\t\t\"can.getOwnEnumerableKeys\": function() {\n\t\t\treturn Object.keys(this.events);\n\t\t}\n\t});\n\n\treturn Delegator;\n}\n\nmodule.exports = function makeDelegateEventTree (domEvents) {\n\tvar Delegator = makeDelegator(domEvents);\n\treturn new KeyTree([Map, Delegator, Object, Array]);\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-events/helpers/-make-delegate-event-tree.js?");

/***/ }),

/***/ "../../node_modules/can-dom-events/helpers/make-event-registry.js":
/*!***************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-events/helpers/make-event-registry.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction EventRegistry () {\n\tthis._registry = {};\n}\n\n/**\n * @module can-dom-events/helpers/make-event-registry\n * @parent can-dom-events.helpers\n * @description Create an event registry.\n * @signature `makeEventRegistry()`\n *   @return {can-dom-events/EventRegistry}\n * @hide\n * \n * @body\n *\n * ```js\n * var makeEventRegistry = require('can-dom-events/helpers/make-event-registry');\n * var registry = makeEventRegistry();\n *\n * var radioChange = require('can-events-dom-radiochange');\n * var removeRadioChange = registry.add(radioChange);\n *\n * registry.has('radiochange'); // => true\n * registry.get('radiochange'); // => radioChange\n *\n * removeRadioChange();\n * ```\n */\nmodule.exports = function makeEventRegistry () {\n\treturn new EventRegistry();\n};\n\n/**\n * @function make-event-registry.has eventRegistry.has\n *\n * Check whether an event type has already been registered.\n *\n * @signature `eventRegistry.has( eventType )`\n * @parent can-dom-events/EventRegistry\n * @param {String} eventType The event type for which to check.\n * @return {Boolean} Whether the event type is registered.\n*/\nEventRegistry.prototype.has = function (eventType) {\n\treturn !!this._registry[eventType];\n};\n\n/**\n * @function make-event-registry.get eventRegistry.get\n *\n * Retrieve an event type which has already been registered.\n *\n * @signature `eventRegistry.get( eventType )`\n * @parent can-dom-events/EventRegistry\n * @param {String} eventType The event type for which to retrieve.\n * @return {EventDefinition} The registered event definition, or undefined if unregistered.\n*/\nEventRegistry.prototype.get = function (eventType) {\n\treturn this._registry[eventType];\n};\n\n/**\n * @function make-event-registry.add eventRegistry.add\n *\n * Add an event to the registry.\n *\n * @signature `eventRegistry.add( event [, eventType ] )`\n * @parent can-dom-events/EventRegistry\n * @param {EventDefinition} event The event definition to register.\n * @param {String} eventType The event type with which to register the event.\n * @return {function} The callback to remove the event from the registry.\n*/\nEventRegistry.prototype.add = function (event, eventType) {\n\tif (!event) {\n\t\tthrow new Error('An EventDefinition must be provided');\n\t}\n\tif (typeof event.addEventListener !== 'function') {\n\t\tthrow new TypeError('EventDefinition addEventListener must be a function');\n\t}\n\tif (typeof event.removeEventListener !== 'function') {\n\t\tthrow new TypeError('EventDefinition removeEventListener must be a function');\n\t}\n\n\teventType = eventType || event.defaultEventType;\n\tif (typeof eventType !== 'string') {\n\t\tthrow new TypeError('Event type must be a string, not ' + eventType);\n\t}\n\n\tif (this.has(eventType)) {\n\t\tthrow new Error('Event \"' + eventType + '\" is already registered');\n\t}\n\n\tthis._registry[eventType] = event;\n\tvar self = this;\n\treturn function remove () {\n\t\tself._registry[eventType] = undefined;\n\t};\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-events/helpers/make-event-registry.js?");

/***/ }),

/***/ "../../node_modules/can-dom-events/helpers/util.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-events/helpers/util.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getCurrentDocument = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\nvar isBrowserWindow = __webpack_require__(/*! can-globals/is-browser-window/is-browser-window */ \"../../node_modules/can-globals/is-browser-window/is-browser-window.js\");\n\nfunction getTargetDocument (target) {\n\treturn target.ownerDocument || getCurrentDocument();\n}\n\nfunction createEvent (target, eventData, bubbles, cancelable) {\n\tvar doc = getTargetDocument(target);\n\tvar event = doc.createEvent('HTMLEvents');\n\tvar eventType;\n\tif (typeof eventData === 'string') {\n\t\teventType = eventData;\n\t} else {\n\t\teventType = eventData.type;\n\t\tfor (var prop in eventData) {\n\t\t\tif (event[prop] === undefined) {\n\t\t\t\tevent[prop] = eventData[prop];\n\t\t\t}\n\t\t}\n\t}\n\tif (bubbles === undefined) {\n\t\tbubbles = true;\n\t}\n\tevent.initEvent(eventType, bubbles, cancelable);\n\treturn event;\n}\n\n// We do not account for all EventTarget classes,\n// only EventTarget DOM nodes, fragments, and the window.\nfunction isDomEventTarget (obj) {\n\tif (!(obj && obj.nodeName)) {\n\t\treturn obj === window;\n\t}\n\tvar nodeType = obj.nodeType;\n\treturn (\n\t\tnodeType === 1 || // Node.ELEMENT_NODE\n\t\tnodeType === 9 || // Node.DOCUMENT_NODE\n\t\tnodeType === 11 // Node.DOCUMENT_FRAGMENT_NODE\n\t);\n}\n\nfunction addDomContext (context, args) {\n\tif (isDomEventTarget(context)) {\n\t\targs = Array.prototype.slice.call(args, 0);\n\t\targs.unshift(context);\n\t}\n\treturn args;\n}\n\nfunction removeDomContext (context, args) {\n\tif (!isDomEventTarget(context)) {\n\t\targs = Array.prototype.slice.call(args, 0);\n\t\tcontext = args.shift();\n\t}\n\treturn {\n\t\tcontext: context,\n\t\targs: args\n\t};\n}\n\nvar fixSyntheticEventsOnDisabled = false;\n// In FireFox, dispatching a synthetic event on a disabled element throws an error.\n// Other browsers, like IE 10 do not dispatch synthetic events on disabled elements at all.\n// This determines if we have to work around that when dispatching events.\n// https://bugzilla.mozilla.org/show_bug.cgi?id=329509\n(function() {\n\tif(!isBrowserWindow()) {\n\t\treturn;\n\t}\n\n\tvar testEventName = 'fix_synthetic_events_on_disabled_test';\n\tvar input = document.createElement(\"input\");\n\tinput.disabled = true;\n\tvar timer = setTimeout(function() {\n\t\tfixSyntheticEventsOnDisabled = true;\n\t}, 50);\n\tvar onTest = function onTest (){\n\t\tclearTimeout(timer);\n\t\tinput.removeEventListener(testEventName, onTest);\n\t};\n\tinput.addEventListener(testEventName, onTest);\n\ttry {\n\t\tvar event = document.create('HTMLEvents');\n\t\tevent.initEvent(testEventName, false);\n\t\tinput.dispatchEvent(event);\n\t} catch(e) {\n\t\tonTest();\n\t\tfixSyntheticEventsOnDisabled = true;\n\t}\n})();\n\nfunction isDispatchingOnDisabled(element, event) {\n\tvar eventType = event.type;\n\tvar isInsertedOrRemoved = eventType === 'inserted' || eventType === 'removed';\n\tvar isDisabled = !!element.disabled;\n\treturn isInsertedOrRemoved && isDisabled;\n}\n\nfunction forceEnabledForDispatch (element, event) {\n\treturn fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(element, event);\n}\n\nmodule.exports = {\n\tcreateEvent: createEvent,\n\taddDomContext: addDomContext,\n\tremoveDomContext: removeDomContext,\n\tisDomEventTarget: isDomEventTarget,\n\tgetTargetDocument: getTargetDocument,\n\tforceEnabledForDispatch: forceEnabledForDispatch\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-events/helpers/util.js?");

/***/ }),

/***/ "../../node_modules/can-dom-mutate/-util.js":
/*!*****************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-mutate/-util.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\n\nvar push = Array.prototype.push;\n\nfunction eliminate(array, item) {\n\tvar index = array.indexOf(item);\n\tif (index >= 0) {\n\t\tarray.splice(index, 1);\n\t}\n}\n\nfunction isInDocument (node) {\n\tvar root = getDocument().documentElement;\n\tif (root === node) {\n\t\treturn true;\n\t}\n\treturn root.contains(node);\n}\n\nfunction isDocumentElement (node) {\n\treturn getDocument().documentElement === node;\n}\n\nfunction isFragment (node) {\n\treturn !!(node && node.nodeType === 11);\n}\n\nfunction getChildren (parentNode) {\n\tvar nodes = [];\n\tvar node = parentNode.firstChild;\n\twhile (node) {\n\t\tnodes.push(node);\n\t\tnode = node.nextSibling;\n\t}\n\treturn nodes;\n}\n\nfunction getParents (node) {\n\tvar nodes;\n\tif (isFragment(node)) {\n\t\tnodes = getChildren(node);\n\t} else {\n\t\tnodes = [node];\n\t}\n\treturn nodes;\n}\n\nfunction getAllNodes (node) {\n\tvar nodes = getParents(node);\n\tvar cLen = nodes.length;\n\tfor (var c = 0; c < cLen; c++) {\n\t\tvar element = nodes[c];\n\t\tif (element.getElementsByTagName) {\n\t\t\tvar descendants = element.getElementsByTagName('*');\n\t\t\tpush.apply(nodes, descendants);\n\t\t}\n\t}\n\n\treturn nodes;\n}\n\nfunction subscription (fn) {\n\treturn function _subscription () {\n\t\tvar disposal = fn.apply(this, arguments);\n\t\tvar isDisposed = false;\n\t\treturn function _disposal () {\n\t\t\tif (isDisposed) {\n\t\t\t\tvar fnName = fn.name || fn.displayName || 'an anonymous function';\n\t\t\t\tvar message = 'Disposal function returned by ' + fnName + ' called more than once.';\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t\tdisposal.apply(this, arguments);\n\t\t\tisDisposed = true;\n\t\t};\n\t};\n}\n\nmodule.exports = {\n\teliminate: eliminate,\n\tisInDocument: isInDocument,\n\tgetDocument: getDocument,\n\tisDocumentElement: isDocumentElement,\n\tisFragment: isFragment,\n\tgetParents: getParents,\n\tgetAllNodes: getAllNodes,\n\tgetChildren: getChildren,\n\tsubscription: subscription\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-mutate/-util.js?");

/***/ }),

/***/ "../../node_modules/can-dom-mutate/can-dom-mutate.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-mutate/can-dom-mutate.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals */ \"../../node_modules/can-globals/can-globals.js\");\nvar getRoot = __webpack_require__(/*! can-globals/global/global */ \"../../node_modules/can-globals/global/global.js\");\nvar getMutationObserver = __webpack_require__(/*! can-globals/mutation-observer/mutation-observer */ \"../../node_modules/can-globals/mutation-observer/mutation-observer.js\");\nvar setImmediate = getRoot().setImmediate || function (cb) {\n\treturn setTimeout(cb, 0);\n};\n\nvar util = __webpack_require__(/*! ./-util */ \"../../node_modules/can-dom-mutate/-util.js\");\nvar getDocument = util.getDocument;\nvar eliminate = util.eliminate;\nvar subscription = util.subscription;\nvar isDocumentElement = util.isDocumentElement;\nvar getAllNodes = util.getAllNodes;\n\nvar push = Array.prototype.push;\nvar slice = Array.prototype.slice;\n\nvar domMutate;\nvar dataStore = new WeakMap();\n\nfunction getRelatedData(node, key) {\n\tvar data = dataStore.get(node);\n\tif (data) {\n\t\treturn data[key];\n\t}\n}\n\nfunction setRelatedData(node, key, targetListenersMap) {\n\tvar data = dataStore.get(node) || dataStore.set(node, {}).get(node);\n\tdata[key] = targetListenersMap;\n}\n\nfunction deleteRelatedData(node, key) {\n\tvar data = dataStore.get(node);\n\treturn delete data[key];\n}\n\nfunction batch(processBatchItems, shouldDeduplicate) {\n\tvar waitingBatch = [];\n\tvar waitingCalls = [];\n\tvar dispatchSet = new Set();\n\tvar isPrimed = false;\n\treturn function batchAdd(items, callback) {\n\t\tif (shouldDeduplicate) {\n\t\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\t\tvar item = items[i];\n\t\t\t\tvar target = item.target;\n\t\t\t\tif (!dispatchSet.has(target)) {\n\t\t\t\t\twaitingBatch.push(item);\n\t\t\t\t\tdispatchSet.add(target);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tpush.apply(waitingBatch, items);\n\t\t}\n\t\tif (callback) {\n\t\t\twaitingCalls.push(callback);\n\t\t}\n\n\t\tvar shouldPrime = !isPrimed && waitingBatch.length > 0;\n\t\tif (shouldPrime) {\n\t\t\tisPrimed = true;\n\t\t\tsetImmediate(function processBatch() {\n\t\t\t\tvar currentBatch = waitingBatch;\n\t\t\t\twaitingBatch = [];\n\t\t\t\tvar currentCalls = waitingCalls;\n\t\t\t\twaitingCalls = [];\n\t\t\t\tif (shouldDeduplicate) {\n\t\t\t\t\tdispatchSet = new Set();\n\t\t\t\t}\n\t\t\t\tisPrimed = false;\n\t\t\t\tprocessBatchItems(currentBatch);\n\t\t\t\tvar callCount = currentCalls.length;\n\t\t\t\tfor (var c = 0; c < callCount; c++) {\n\t\t\t\t\tcurrentCalls[c]();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction getDocumentListeners (target, key) {\n\tvar doc = getDocument();\n\tvar data = getRelatedData(doc, key);\n\tif (data) {\n\t\treturn data.listeners;\n\t}\n}\n\nfunction getTargetListeners (target, key) {\n\tvar doc = getDocument();\n\tvar targetListenersMap = getRelatedData(doc, key);\n\tif (!targetListenersMap) {\n\t\treturn;\n\t}\n\n\treturn targetListenersMap.get(target);\n}\n\nfunction addTargetListener (target, key, listener) {\n\tvar doc = getDocument();\n\tvar targetListenersMap = getRelatedData(doc, key);\n\tif (!targetListenersMap) {\n\t\ttargetListenersMap = new Map();\n\t\tsetRelatedData(doc, key, targetListenersMap);\n\t}\n\tvar targetListeners = targetListenersMap.get(target);\n\tif (!targetListeners) {\n\t\ttargetListeners = [];\n\t\ttargetListenersMap.set(target, targetListeners);\n\t}\n\ttargetListeners.push(listener);\n}\n\nfunction removeTargetListener (target, key, listener) {\n\tvar doc = getDocument();\n\tvar targetListenersMap = getRelatedData(doc, key);\n\tif (!targetListenersMap) {\n\t\treturn;\n\t}\n\tvar targetListeners = targetListenersMap.get(target);\n\tif (!targetListeners) {\n\t\treturn;\n\t}\n\teliminate(targetListeners, listener);\n\tif (targetListeners.length === 0) {\n\t\ttargetListenersMap['delete'](target);\n\t\tif (targetListenersMap.size === 0) {\n\t\t\tdeleteRelatedData(doc, key);\n\t\t}\n\t}\n}\n\nfunction fire (callbacks, arg) {\n\tvar safeCallbacks = slice.call(callbacks, 0);\n\tvar safeCallbackCount = safeCallbacks.length;\n\tfor (var i = 0; i < safeCallbackCount; i++) {\n\t\tsafeCallbacks[i](arg);\n\t}\n}\n\nfunction dispatch(listenerKey, documentDataKey) {\n\treturn function dispatchEvents(events) {\n\t\tfor (var e = 0; e < events.length; e++) {\n\t\t\tvar event = events[e];\n\t\t\tvar target = event.target;\n\n\t\t\tvar targetListeners = getTargetListeners(target, listenerKey);\n\t\t\tif (targetListeners) {\n\t\t\t\tfire(targetListeners, event);\n\t\t\t}\n\n\t\t\tif (!documentDataKey) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar documentListeners = getDocumentListeners(target, documentDataKey);\n\t\t\tif (documentListeners) {\n\t\t\t\tfire(documentListeners, event);\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction observeMutations(target, observerKey, config, handler) {\n\tvar observerData = getRelatedData(target, observerKey);\n\tif (!observerData) {\n\t\tobserverData = {\n\t\t\tobservingCount: 0\n\t\t};\n\t\tsetRelatedData(target, observerKey, observerData);\n\t}\n\n\tvar setupObserver = function () {\n\t\tvar MutationObserver = getMutationObserver();\n\t\tif (MutationObserver) {\n\t\t\tvar Node = getRoot().Node;\n\t\t\tvar isRealNode = !!(Node && target instanceof Node);\n\t\t\tif (isRealNode) {\n\t\t\t\tvar targetObserver = new MutationObserver(handler);\n\t\t\t\ttargetObserver.observe(target, config);\n\t\t\t\tobserverData.observer = targetObserver;\n\t\t\t}\n\t\t} else {\n\t\t\tif (observerData.observer) {\n\t\t\t\tobserverData.observer.disconnect();\n\t\t\t\tobserverData.observer = null;\n\t\t\t}\n\t\t}\n\t};\n\n\tif (observerData.observingCount === 0) {\n\t\tglobals.onKeyValue('MutationObserver', setupObserver);\n\t\tsetupObserver();\n\t}\n\n\tobserverData.observingCount++;\n\treturn function stopObservingMutations() {\n\t\tvar observerData = getRelatedData(target, observerKey);\n\t\tif (observerData) {\n\t\t\tobserverData.observingCount--;\n\t\t\tif (observerData.observingCount <= 0) {\n\t\t\t\tif (observerData.observer) {\n\t\t\t\t\tobserverData.observer.disconnect();\n\t\t\t\t}\n\t\t\t\tdeleteRelatedData(target, observerKey);\n\t\t\t\tglobals.offKeyValue('MutationObserver', setupObserver);\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction handleTreeMutations(mutations) {\n\tvar mutationCount = mutations.length;\n\tfor (var m = 0; m < mutationCount; m++) {\n\t\tvar mutation = mutations[m];\n\n\t\tvar addedNodes = mutation.addedNodes;\n\t\tvar addedCount = addedNodes.length;\n\t\tfor (var a = 0; a < addedCount; a++) {\n\t\t\tdomMutate.dispatchNodeInsertion(addedNodes[a]);\n\t\t}\n\n\t\tvar removedNodes = mutation.removedNodes;\n\t\tvar removedCount = removedNodes.length;\n\t\tfor (var r = 0; r < removedCount; r++) {\n\t\t\tdomMutate.dispatchNodeRemoval(removedNodes[r]);\n\t\t}\n\t}\n}\n\nfunction handleAttributeMutations(mutations) {\n\tvar mutationCount = mutations.length;\n\tfor (var m = 0; m < mutationCount; m++) {\n\t\tvar mutation = mutations[m];\n\t\tif (mutation.type === 'attributes') {\n\t\t\tvar node = mutation.target;\n\t\t\tvar attributeName = mutation.attributeName;\n\t\t\tvar oldValue = mutation.oldValue;\n\t\t\tdomMutate.dispatchNodeAttributeChange(node, attributeName, oldValue);\n\t\t}\n\t}\n}\n\nvar treeMutationConfig = {\n\tsubtree: true,\n\tchildList: true\n};\n\nvar attributeMutationConfig = {\n\tattributes: true,\n\tattributeOldValue: true\n};\n\nfunction addNodeListener(listenerKey, observerKey, isAttributes) {\n\treturn subscription(function _addNodeListener(target, listener) {\n\t\tvar stopObserving;\n\t\tif (isAttributes) {\n\t\t\tstopObserving = observeMutations(target, observerKey, attributeMutationConfig, handleAttributeMutations);\n\t\t} else {\n\t\t\tstopObserving = observeMutations(getDocument(), observerKey, treeMutationConfig, handleTreeMutations);\n\t\t}\n\n\t\taddTargetListener(target, listenerKey, listener);\n\t\treturn function removeNodeListener() {\n\t\t\tstopObserving();\n\t\t\tremoveTargetListener(target, listenerKey, listener);\n\t\t};\n\t});\n}\n\nfunction addGlobalListener(globalDataKey, addNodeListener) {\n\treturn subscription(function addGlobalGroupListener(documentElement, listener) {\n\t\tif (!isDocumentElement(documentElement)) {\n\t\t\tthrow new Error('Global mutation listeners must pass a documentElement');\n\t\t}\n\n\t\tvar doc = getDocument();\n\t\tvar documentData = getRelatedData(doc, globalDataKey);\n\t\tif (!documentData) {\n\t\t\tdocumentData = {listeners: []};\n\t\t\tsetRelatedData(doc, globalDataKey, documentData);\n\t\t}\n\n\t\tvar listeners = documentData.listeners;\n\t\tif (listeners.length === 0) {\n\t\t\t// We need at least on listener for mutation events to propagate\n\t\t\tdocumentData.removeListener = addNodeListener(doc, function () {});\n\t\t}\n\n\t\tlisteners.push(listener);\n\n\t\treturn function removeGlobalGroupListener() {\n\t\t\tvar documentData = getRelatedData(doc, globalDataKey);\n\t\t\tif (!documentData) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar listeners = documentData.listeners;\n\t\t\teliminate(listeners, listener);\n\t\t\tif (listeners.length === 0) {\n\t\t\t\tdocumentData.removeListener();\n\t\t\t\tdeleteRelatedData(doc, globalDataKey);\n\t\t\t}\n\t\t};\n\t});\n}\n\nfunction toMutationEvents (nodes) {\n\tvar events = [];\n\tfor (var i = 0; i < nodes.length; i++) {\n\t\tevents.push({target: nodes[i]});\n\t}\n\treturn events;\n}\n\nvar domMutationPrefix = 'domMutation';\n\n// target listener keys\nvar insertionDataKey = domMutationPrefix + 'InsertionData';\nvar removalDataKey = domMutationPrefix + 'RemovalData';\nvar attributeChangeDataKey = domMutationPrefix + 'AttributeChangeData';\n\n// document listener keys\nvar documentInsertionDataKey = domMutationPrefix + 'DocumentInsertionData';\nvar documentRemovalDataKey = domMutationPrefix + 'DocumentRemovalData';\nvar documentAttributeChangeDataKey = domMutationPrefix + 'DocumentAttributeChangeData';\n\n// observer keys\nvar treeDataKey = domMutationPrefix + 'TreeData';\nvar attributeDataKey = domMutationPrefix + 'AttributeData';\n\nvar dispatchInsertion = batch(dispatch(insertionDataKey, documentInsertionDataKey), true);\nvar dispatchRemoval = batch(dispatch(removalDataKey, documentRemovalDataKey), true);\nvar dispatchAttributeChange = batch(dispatch(attributeChangeDataKey, documentAttributeChangeDataKey));\n\n// node listeners\nvar addNodeInsertionListener = addNodeListener(insertionDataKey, treeDataKey);\nvar addNodeRemovalListener = addNodeListener(removalDataKey, treeDataKey);\nvar addNodeAttributeChangeListener = addNodeListener(attributeChangeDataKey, attributeDataKey, true);\n\n// global listeners\nvar addInsertionListener = addGlobalListener(\n\tdocumentInsertionDataKey,\n\taddNodeInsertionListener\n);\nvar addRemovalListener = addGlobalListener(\n\tdocumentRemovalDataKey,\n\taddNodeRemovalListener\n);\nvar addAttributeChangeListener = addGlobalListener(\n\tdocumentAttributeChangeDataKey,\n\taddNodeAttributeChangeListener\n);\n\n/**\n * @module {{}} can-dom-mutate\n * @parent can-dom-utilities\n * @collection can-infrastructure\n *\n * @description Dispatch and listen for DOM mutations.\n * @group can-dom-mutate.static 0 methods\n * @group can-dom-mutate/modules 1 modules\n * @signature `domMutate`\n *\n * `can-dom-mutate` exports an object that lets you listen to changes\n * in the DOM using the [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n * API.\n *\n * ```js\n * import domMutate from \"can-dom-mutate\";\n *\n * domMutate //->\n * {\n *   onAttributeChange( documentElement, callback ),\n *   onInsertion( documentElement, callback ),\n *   onRemoval( documentElement, callback ),\n *   onNodeAttributeChange( node, callback ),\n *   onNodeInsertion( node, callback ),\n *   onNodeRemoval( node, callback )\n * }\n *\n * // listen to every attribute change within the document:\n * domMutate.onAttributeChange(document.documentElement, function(mutationRecord){\n *   mutationRecord.target        //-> <input>\n *   mutationRecord.attributeName //-> \"name\"\n *   mutationRecord.oldValue      //-> \"Ramiya\"\n * })\n * ```\n *\n * If you want to support browsers that do not support the `MutationObserver` api, use\n * [can-dom-mutate/node] to update the DOM. Every module within CanJS should do this:\n *\n * ```js\n * var mutate = require('can-dom-mutate/node');\n * var el = document.createElement('div');\n *\n * mutate.appendChild.call(document.body, el);\n * ```\n */\ndomMutate = {\n\t/**\n\t* @function can-dom-mutate.dispatchNodeInsertion dispatchNodeInsertion\n\t* @hide\n\t*\n\t* Dispatch an insertion mutation on the given node.\n\t*\n\t* @signature `dispatchNodeInsertion( node [, callback ] )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to dispatch an insertion mutation.\n\t* @param {function} callback The optional callback called after the mutation is dispatched.\n\t*/\n\tdispatchNodeInsertion: function (node, callback) {\n\t\tvar events = toMutationEvents(getAllNodes(node));\n\t\tdispatchInsertion(events, callback);\n\t},\n\n\t/**\n\t* @function can-dom-mutate.dispatchNodeRemoval dispatchNodeRemoval\n\t* @hide\n\t*\n\t* Dispatch a removal mutation on the given node.\n\t*\n\t* @signature `dispatchNodeRemoval( node [, callback ] )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to dispatch a removal mutation.\n\t* @param {function} callback The optional callback called after the mutation is dispatched.\n\t*/\n\tdispatchNodeRemoval: function (node, callback) {\n\t\tvar events = toMutationEvents(getAllNodes(node));\n\t\tdispatchRemoval(events, callback);\n\t},\n\n\t/**\n\t* @function can-dom-mutate.dispatchNodeAttributeChange dispatchNodeAttributeChange\n\t* @parent can-dom-mutate.static\n\t* @hide\n\t*\n\t* Dispatch an attribute change mutation on the given node.\n\t*\n\t* @signature `dispatchNodeAttributeChange( node, attributeName, oldValue [, callback ] )`\n\t*\n\t* ```\n\t* input.setAttribute(\"value\", \"newValue\")\n\t* domMutate.dispatchNodeAttributeChange(input, \"value\",\"oldValue\")\n\t* ```\n\t*\n\t*\n\t* @param {Node} target The node on which to dispatch an attribute change mutation.\n\t* @param {String} attributeName The attribute name whose value has changed.\n\t* @param {String} oldValue The attribute value before the change.\n\t* @param {function} callback The optional callback called after the mutation is dispatched.\n\t*/\n\tdispatchNodeAttributeChange: function (target, attributeName, oldValue, callback) {\n\t\tdispatchAttributeChange([{\n\t\t\ttarget: target,\n\t\t\tattributeName: attributeName,\n\t\t\toldValue: oldValue\n\t\t}], callback);\n\t},\n\n\t/**\n\t* @function can-dom-mutate.onNodeInsertion onNodeInsertion\n\t*\n\t* Listen for insertion mutations on the given node.\n\t*\n\t* @signature `onNodeInsertion( node, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to listen for insertion mutations.\n\t* @param {function} callback The callback called when an insertion mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonNodeInsertion: addNodeInsertionListener,\n\n\t/**\n\t* @function can-dom-mutate.onNodeRemoval onNodeRemoval\n\t*\n\t* Listen for removal mutations on the given node.\n\t*\n\t* @signature `onNodeRemoval( node, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to listen for removal mutations.\n\t* @param {function} callback The callback called when a removal mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonNodeRemoval: addNodeRemovalListener,\n\n\t/**\n\t* @function can-dom-mutate.onNodeAttributeChange onNodeAttributeChange\n\t*\n\t* Listen for attribute change mutations on the given node.\n\t*\n\t* @signature `onNodeAttributeChange( node, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} node The node on which to listen for attribute change mutations.\n\t* @param {function} callback The callback called when an attribute change mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonNodeAttributeChange: addNodeAttributeChangeListener,\n\n\t/**\n\t* @function can-dom-mutate.onRemoval onRemoval\n\t*\n\t* Listen for removal mutations on any node within the documentElement.\n\t*\n\t* @signature `onRemoval( documentElement, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} documentElement The documentElement on which to listen for removal mutations.\n\t* @param {function} callback The callback called when a removal mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonRemoval: addRemovalListener,\n\n\t/**\n\t* @function can-dom-mutate.onInsertion onInsertion\n\t*\n\t* Listen for insertion mutations on any node within the documentElement.\n\t*\n\t* @signature `onInsertion( documentElement, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} documentElement The documentElement on which to listen for removal mutations.\n\t* @param {function} callback The callback called when a insertion mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonInsertion: addInsertionListener,\n\n\t/**\n\t* @function can-dom-mutate.onAttributeChange onAttributeChange\n\t*\n\t* Listen for attribute change mutations on any node within the documentElement.\n\t*\n\t* @signature `onAttributeChange( documentElement, callback )`\n\t* @parent can-dom-mutate.static\n\t* @param {Node} documentElement The documentElement on which to listen for removal mutations.\n\t* @param {function} callback The callback called when an attribute change mutation is dispatched.\n\t* @return {function} The callback to remove the mutation listener.\n\t*/\n\tonAttributeChange: addAttributeChangeListener\n};\n\nmodule.exports = domMutate;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-mutate/can-dom-mutate.js?");

/***/ }),

/***/ "../../node_modules/can-dom-mutate/node.js":
/*!****************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-mutate/node.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals */ \"../../node_modules/can-globals/can-globals.js\");\nvar domMutate = __webpack_require__(/*! ./can-dom-mutate */ \"../../node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar util = __webpack_require__(/*! ./-util */ \"../../node_modules/can-dom-mutate/-util.js\");\n\nvar isInDocument = util.isInDocument;\nvar getParents = util.getParents;\n\nvar synthetic = {\n\tdispatchNodeInsertion: function (container, node) {\n\t\tif (isInDocument(node)) {\n\t\t\tdomMutate.dispatchNodeInsertion(node);\n\t\t}\n\t},\n\tdispatchNodeRemoval: function (container, node) {\n\t\tif (isInDocument(container) && !isInDocument(node)) {\n\t\t\tdomMutate.dispatchNodeRemoval(node);\n\t\t}\n\t}\n};\n\nvar compat = {\n\treplaceChild: function (newChild, oldChild) {\n\t\tvar newChildren = getParents(newChild);\n\t\tvar result = this.replaceChild(newChild, oldChild);\n\t\tsynthetic.dispatchNodeRemoval(this, oldChild);\n\t\tfor (var i = 0; i < newChildren.length; i++) {\n\t\t\tsynthetic.dispatchNodeInsertion(this, newChildren[i]);\n\t\t}\n\t\treturn result;\n\t},\n\tsetAttribute: function (name, value) {\n\t\tvar oldAttributeValue = this.getAttribute(name);\n\t\tvar result = this.setAttribute(name, value);\n\t\tvar newAttributeValue = this.getAttribute(name);\n\t\tif (oldAttributeValue !== newAttributeValue) {\n\t\t\tdomMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);\n\t\t}\n\t\treturn result;\n\t},\n\tremoveAttribute: function (name) {\n\t\tvar oldAttributeValue = this.getAttribute(name);\n\t\tvar result = this.removeAttribute(name);\n\t\tif (oldAttributeValue) {\n\t\t\tdomMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);\n\t\t}\n\t\treturn result;\n\t}\n};\n\nvar compatData = [\n\t['appendChild', 'Insertion'],\n\t['insertBefore', 'Insertion'],\n\t['removeChild', 'Removal']\n];\ncompatData.forEach(function (pair) {\n\tvar nodeMethod = pair[0];\n\tvar dispatchMethod = 'dispatchNode' + pair[1];\n\tcompat[nodeMethod] = function (node) {\n\t\tvar nodes = getParents(node);\n\t\tvar result = this[nodeMethod].apply(this, arguments);\n\t\tfor (var i = 0; i < nodes.length; i++) {\n\t\t\tsynthetic[dispatchMethod](this, nodes[i]);\n\t\t}\n\t\treturn result;\n\t};\n});\n\nvar normal = {};\nvar nodeMethods = ['appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute'];\nnodeMethods.forEach(function (methodName) {\n\tnormal[methodName] = function () {\n\t\treturn this[methodName].apply(this, arguments);\n\t};\n});\n\n/**\n* @module {{}} can-dom-mutate/node node\n* @parent can-dom-mutate/modules\n*\n* Append, insert, and remove DOM nodes. Also, change node attributes.\n* This allows mutations to be dispatched in environments where MutationObserver is not supported.\n* @signature `mutateNode`\n*\n* Exports an `Object` with methods that shouhld be used to mutate HTML.\n* \n* ```js\n* var mutateNode = require('can-dom-mutate/node');\n* var el = document.createElement('div');\n*\n* mutateNode.appendChild.call(document.body, el);\n*\n* ```\n*/\nvar mutate = {};\n\n/**\n* @function can-dom-mutate/node.appendChild appendChild\n* @parent can-dom-mutate/node\n*\n* Append a node to an element, effectively `Node.prototype.appendChild`.\n*\n* @signature `mutate.appendChild.call(parent, child)`\n*\n* @param {Node} parent The parent into which the child is inserted.\n* @param {Node} child The child which will be inserted into the parent.\n* @return {Node} The appended child.\n*/\n\n/**\n* @function can-dom-mutate/node.insertBefore insertBefore\n* @parent can-dom-mutate/node\n*\n* Insert a node before a given reference node in an element, effectively `Node.prototype.insertBefore`.\n*\n* @signature `mutate.insertBefore.call(parent, child, reference)`\n* @param {Node} parent The parent into which the child is inserted.\n* @param {Node} child The child which will be inserted into the parent.\n* @param {Node} reference The reference which the child will be placed before.\n* @return {Node} The inserted child.\n*/\n\n/**\n* @function can-dom-mutate/node.removeChild removeChild\n* @parent can-dom-mutate/node\n*\n* Remove a node from an element, effectively `Node.prototype.removeChild`.\n*\n* @signature `mutate.removeChild.call(parent, child)`\n*\n* @param {Node} parent The parent from which the child is removed.\n* @param {Node} child The child which will be removed from the parent.\n* @return {Node} The removed child.\n*/\n\n/**\n* @function can-dom-mutate/node.replaceChild replaceChild\n* @parent can-dom-mutate/node\n*\n* Insert a node before a given reference node in an element, effectively `Node.prototype.replaceChild`.\n*\n* @signature `mutate.replaceChild.call(parent, newChild, oldChild)`\n*\n* @param {Node} parent The parent into which the newChild is inserted.\n* @param {Node} newChild The child which is inserted into the parent.\n* @param {Node} oldChild The child which is removed from the parent.\n* @return {Node} The replaced child.\n*/\n\n/**\n* @function can-dom-mutate/node.setAttribute setAttribute\n* @parent can-dom-mutate/node\n*\n* Set an attribute value on an element, effectively `Element.prototype.setAttribute`.\n*\n* @signature `mutate.setAttribute.call(element, name, value)`\n*\n* @param {Element} element The element on which to set the attribute.\n* @param {String} name The name of the attribute to set.\n* @param {String} value The value to set on the attribute.\n*/\n\n/**\n* @function can-dom-mutate/node.removeAttribute removeAttribute\n* @parent can-dom-mutate/node\n*\n* Removes an attribute from an element, effectively `Element.prototype.removeAttribute`.\n*\n* @signature `mutate.removeAttribute.call(element, name, value)`\n*\n* @param {Element} element The element from which to remove the attribute.\n* @param {String} name The name of the attribute to remove.\n*/\n\nfunction setMutateStrategy(observer) {\n\tvar strategy = observer ? normal : compat;\n\tfor (var key in strategy) {\n\t\tmutate[key] = strategy[key];\n\t}\n}\n\nvar mutationObserverKey = 'MutationObserver';\nsetMutateStrategy(globals.getKeyValue(mutationObserverKey));\nglobals.onKeyValue(mutationObserverKey, setMutateStrategy);\n\nmodule.exports = mutate;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-dom-mutate/node.js?");

/***/ }),

/***/ "../../node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js":
/*!************************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\n\nfunction getRoot () {\n\treturn getDocument().documentElement;\n}\n\nfunction findParentForm (el) {\n\twhile (el) {\n\t\tif (el.nodeName === 'FORM') {\n\t\t\tbreak;\n\t\t}\n\t\tel = el.parentNode;\n\t}\n\treturn el;\n}\n\nfunction shouldReceiveEventFromRadio (source, dest) {\n\t// Must have the same name attribute and parent form\n\tvar name = source.getAttribute('name');\n\treturn (\n\t\tname &&\n\t\tname === dest.getAttribute('name') &&\n\t\tfindParentForm(source) === findParentForm(dest)\n\t);\n}\n\nfunction isRadioInput (el) {\n\treturn el.nodeName === 'INPUT' && el.type === 'radio';\n}\n\n\nfunction attachRootListener (domEvents, eventTypeTargets) {\n\tvar root = getRoot();\n\tvar newListener = function (event) {\n\t\tvar target = event.target;\n\t\tif (!isRadioInput(target)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var eventType in eventTypeTargets) {\n\t\t\tvar newEvent = {type: eventType};\n\t\t\tvar listeningNodes = eventTypeTargets[eventType];\n\t\t\tlisteningNodes.forEach(function (el) {\n\t\t\t\tif (shouldReceiveEventFromRadio(target, el)) {\n\t\t\t\t\tdomEvents.dispatch(el, newEvent, false);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\tdomEvents.addEventListener(root, 'change', newListener);\n\treturn newListener;\n}\n\nfunction detachRootListener (domEvents, listener) {\n\tvar root = getRoot();\n\tdomEvents.removeEventListener(root, 'change', listener);\n}\n\n/**\n * @module {events} can-event-dom-radiochange\n * @parent can-dom-utilities\n * @collection can-infrastructure\n * @package ./package.json\n *\n * A custom event for listening to changes of inputs with type \"radio\",\n * which fires when a conflicting radio input changes. A \"conflicting\"\n * radio button has the same \"name\" attribute and exists within in the\n * same form, or lack thereof. This event coordinates state bound to\n * whether a radio is checked. The \"change\" event does not fire for deselected\n * radios. By using this event instead, deselected radios receive notification.\n *\n * ```js\n * var domEvents = require('can-dom-events');\n * var radioChange = require('can-event-dom-radiochange');\n * domEvents.addEvent(radioChange);\n *\n * var target = document.createElement('input');\n *\n * function handler () {\n * \tconsole.log('radiochange event fired');\n * }\n *\n * domEvents.addEventListener(target, 'radiochange', handler);\n * domEvents.removeEventListener(target, 'radiochange', handler);\n * ```\n */\nvar radioChangeEvent = {\n\tdefaultEventType: 'radiochange',\n\n\taddEventListener: function (target, eventType, handler) {\n\t\tif (!isRadioInput(target)) {\n\t\t\tthrow new Error('Listeners for ' + eventType + ' must be radio inputs');\n\t\t}\n\n\t\tvar eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;\n\t\tif (!eventTypeTrackedRadios) {\n\t\t\teventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios = {};\n\t\t\tif (!radioChangeEvent._rootListener) {\n\t\t\t\tradioChangeEvent._rootListener = attachRootListener(this, eventTypeTrackedRadios);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tvar trackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType];\n\t\tif (!trackedRadios) {\n\t\t\ttrackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType] = new Set();\n\t\t}\n\n\t\ttrackedRadios.add(target);\n\t\ttarget.addEventListener(eventType, handler);\n\t},\n\n\tremoveEventListener: function (target, eventType, handler) {\n\t\ttarget.removeEventListener(eventType, handler);\n\n\t\tvar eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;\n\t\tif (!eventTypeTrackedRadios) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar trackedRadios = eventTypeTrackedRadios[eventType];\n\t\tif (!trackedRadios) {\n\t\t\treturn;\n\t\t}\n\t\n\t\ttrackedRadios.delete(target);\n\t\tif (trackedRadios.size === 0) {\n\t\t\tdelete eventTypeTrackedRadios[eventType];\n\t\t\tfor (var key in eventTypeTrackedRadios) {\n\t\t\t\tif (eventTypeTrackedRadios.hasOwnProperty(key)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\t\t\t\t\t\t\n\t\t\t}\n\t\t\tdelete radioChangeEvent._eventTypeTrackedRadios;\n\t\t\tdetachRootListener(this, radioChangeEvent._rootListener);\n\t\t\tdelete radioChangeEvent._rootListener;\n\t\t}\n\t}\n};\n\nmodule.exports = namespace.domEventRadioChange = radioChangeEvent;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js?");

/***/ }),

/***/ "../../node_modules/can-event-queue/dependency-record/merge.js":
/*!************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-event-queue/dependency-record/merge.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nvar mergeValueDependencies = function mergeValueDependencies(obj, source) {\n\tvar sourceValueDeps = source.valueDependencies;\n\n\tif (sourceValueDeps) {\n\t\tvar destValueDeps = obj.valueDependencies;\n\n\t\t// make sure there is a valueDependencies Set\n\t\t// in the [obj] dependency record\n\t\tif (!destValueDeps) {\n\t\t\tdestValueDeps = new Set();\n\t\t\tobj.valueDependencies = destValueDeps;\n\t\t}\n\n\t\tcanReflect.eachIndex(sourceValueDeps, function(dep) {\n\t\t\tdestValueDeps.add(dep);\n\t\t});\n\t}\n};\n\nvar mergeKeyDependencies = function mergeKeyDependencies(obj, source) {\n\tvar sourcekeyDeps = source.keyDependencies;\n\n\tif (sourcekeyDeps) {\n\t\tvar destKeyDeps = obj.keyDependencies;\n\n\t\t// make sure there is a keyDependencies Map\n\t\t// in the [obj] dependency record\n\t\tif (!destKeyDeps) {\n\t\t\tdestKeyDeps = new Map();\n\t\t\tobj.keyDependencies = destKeyDeps;\n\t\t}\n\n\t\tcanReflect.eachKey(sourcekeyDeps, function(keys, obj) {\n\t\t\tvar entry = destKeyDeps.get(obj);\n\n\t\t\tif (!entry) {\n\t\t\t\tentry = new Set();\n\t\t\t\tdestKeyDeps.set(obj, entry);\n\t\t\t}\n\n\t\t\tcanReflect.eachIndex(keys, function(key) {\n\t\t\t\tentry.add(key);\n\t\t\t});\n\t\t});\n\t}\n};\n\n// Merges the key and value dependencies of the source object into the\n// destination object\nmodule.exports = function mergeDependencyRecords(object, source) {\n\tmergeKeyDependencies(object, source);\n\tmergeValueDependencies(object, source);\n\treturn object;\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-event-queue/dependency-record/merge.js?");

/***/ }),

/***/ "../../node_modules/can-event-queue/map/map.js":
/*!********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-event-queue/map/map.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-event-queue/map/map\n * @parent can-event-queue\n * @templateRender true\n *\n * @description Mixin methods and symbols to make this object or prototype object\n * behave like a key-value observable.\n *\n * @signature `mixinMapBindings( obj )`\n *\n * Adds symbols and methods that make `obj` or instances having `obj` on their prototype\n * behave like key-value observables.\n *\n * When `mixinMapBindings` is called on an `obj` like:\n *\n * ```js\n * var mixinMapBindings = require(\"can-event-queue/map/map\");\n *\n * var observable = mixinValueBindings({});\n *\n * observable.on(\"prop\",function(ev, newVal, oldVal){\n *   console.log(newVal);\n * });\n *\n * observable[canSymbol.for(\"can.dispatch\")](\"prop\",[2,1]);\n * // Logs: 2\n * ```\n *\n * `mixinMapBindings` adds the following properties and symbols to the object:\n *\n * {{#each (getChildren [can-event-queue/map/map])}}\n * - [{{name}}] - {{description}}{{/each}}\n *\n * Furthermore, `mixinMapBindings` looks for the following symbols on the object's `.constructor`\n * property:\n *\n * - `@can.dispatchInstanceBoundChange` - Called when the bind status of an instance changes.\n * - `@can.dispatchInstanceOnPatches` - Called if [can-event-queue/map/map.dispatch] is called with `event.patches` as an array of\n *   patches.\n */\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"../../node_modules/can-key-tree/dist/cjs/can-key-tree.js\");\n\nvar domEvents = __webpack_require__(/*! can-dom-events */ \"../../node_modules/can-dom-events/can-dom-events.js\");\nvar isDomEventTarget = __webpack_require__(/*! can-dom-events/helpers/util */ \"../../node_modules/can-dom-events/helpers/util.js\").isDomEventTarget;\n\nvar mergeDependencyRecords = __webpack_require__(/*! ../dependency-record/merge */ \"../../node_modules/can-event-queue/dependency-record/merge.js\");\n\nvar metaSymbol = canSymbol.for(\"can.meta\"),\n\tdispatchBoundChangeSymbol = canSymbol.for(\"can.dispatchInstanceBoundChange\"),\n\tdispatchInstanceOnPatchesSymbol = canSymbol.for(\"can.dispatchInstanceOnPatches\"),\n\tonKeyValueSymbol = canSymbol.for(\"can.onKeyValue\"),\n\toffKeyValueSymbol = canSymbol.for(\"can.offKeyValue\"),\n\tonEventSymbol = canSymbol.for(\"can.onEvent\"),\n\toffEventSymbol = canSymbol.for(\"can.offEvent\"),\n\tonValueSymbol = canSymbol.for(\"can.onValue\"),\n\toffValueSymbol = canSymbol.for(\"can.offValue\");\n\nvar legacyMapBindings;\n\nfunction addHandlers(obj, meta) {\n\tif (!meta.handlers) {\n\t\t// Handlers are organized by:\n\t\t// event name - the type of event bound to\n\t\t// binding type - \"event\" for things that expect an event object (legacy), \"onKeyValue\" for reflective bindings.\n\t\t// queue name - mutate, queue, etc\n\t\t// handlers - the handlers.\n\t\tmeta.handlers = new KeyTree([Object, Object, Object, Array], {\n\t\t\tonFirst: function() {\n\t\t\t\tif (obj._eventSetup !== undefined) {\n\t\t\t\t\tobj._eventSetup();\n\t\t\t\t}\n\t\t\t\tif(obj.constructor[dispatchBoundChangeSymbol]) {\n\t\t\t\t\tobj.constructor[dispatchBoundChangeSymbol](obj, true);\n\t\t\t\t}\n\t\t\t\t//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [true]);\n\t\t\t},\n\t\t\tonEmpty: function() {\n\t\t\t\tif (obj._eventTeardown !== undefined) {\n\t\t\t\t\tobj._eventTeardown();\n\t\t\t\t}\n\t\t\t\tif(obj.constructor[dispatchBoundChangeSymbol]) {\n\t\t\t\t\tobj.constructor[dispatchBoundChangeSymbol](obj, false);\n\t\t\t\t}\n\t\t\t\t//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [false]);\n\t\t\t}\n\t\t});\n\t}\n\n\tif (!meta.listenHandlers) {\n\t\t// context, eventName (might be undefined), queue, handlers\n\t\tmeta.listenHandlers = new KeyTree([Map, Map, Object, Array]);\n\t}\n}\n\n\n// getHandlers returns a KeyTree used for event handling.\n// `handlers` will be on the `can.meta` symbol on the object.\n// Ensure the \"obj\" passed as an argument has an object on @@can.meta\nvar ensureMeta = function ensureMeta(obj) {\n\tvar meta = obj[metaSymbol];\n\n\tif (!meta) {\n\t\tmeta = {};\n\t\tcanReflect.setKeyValue(obj, metaSymbol, meta);\n\t}\n\taddHandlers(obj, meta);\n\n\treturn meta;\n};\n\nfunction stopListeningArgumentsToKeys(bindTarget, event, handler, queueName) {\n\tif(arguments.length && canReflect.isPrimitive(bindTarget)) {\n\t\tqueueName = handler;\n\t\thandler = event;\n\t\tevent = bindTarget;\n\t\tbindTarget = this.context;\n\t}\n\tif(typeof event === \"function\") {\n\t\tqueueName = handler;\n\t\thandler = event;\n\t\tevent = undefined;\n\t}\n\tif(typeof handler === \"string\") {\n\t\tqueueName = handler;\n\t\thandler = undefined;\n\t}\n\tvar keys = [];\n\tif(bindTarget) {\n\t\tkeys.push(bindTarget);\n\t\tif(event || handler || queueName) {\n\t\t\tkeys.push(event);\n\t\t\tif(queueName || handler) {\n\t\t\t\tkeys.push(queueName || this.defaultQueue);\n\t\t\t\tif(handler) {\n\t\t\t\t\tkeys.push(handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn keys;\n}\n\n\n// These are the properties we are going to add to objects\nvar props = {\n\t/**\n\t * @function can-event-queue/map/map.dispatch dispatch\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Dispatch event and key binding handlers.\n\t *\n\t * @signature `obj.dispatch(event, [args])`\n\t *\n\t * Dispatches registered [can-event-queue/map/map.addEventListener] and\n\t * [can-event-queue/map/map.can.onKeyValue] value binding handlers.\n\t *\n\t * The following shows dispatching the `property` event and\n\t * `keyValue` handlers:\n\t *\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * obj.addEventListener(\"property\", function(event, newVal){\n\t *   event.type //-> \"property\"\n\t *   newVal     //-> 5\n\t * });\n\t *\n\t * canReflect.onKeyValue(\"property\", function(newVal){\n\t *   newVal     //-> 5\n\t * })\n\t *\n\t * obj.dispatch(\"property\", [5]);\n\t * ```\n\t *\n\t * > NOTE: Event handlers have an additional `event` argument.\n\t *\n\t * @param {String|Object} event The event to dispatch. If a string is passed,\n\t *   it will be used as the `type` of the event that will be dispatched and dispatch matching\n\t *   [can-event-queue/map/map.can.onKeyValue] bindings:\n\t *\n\t *   ```js\n\t *   obs.dispatch(\"key\")\n\t *   ```\n\t *\n\t *   If `event` is an object, it __MUST__ have a `type` property. The If a string is passed,\n\t *   it will be used as the `type` of the event that will be dispatched and dispatch matching\n\t *   [can-event-queue/map/map.can.onKeyValue] bindings:\n\t *\n\t *   ```js\n\t *   obs.dispatch({type: \"key\"})\n\t *   ```\n\t *\n\t *   The `event` object can also have the following properties and values:\n\t *   - __reasonLog__ `{Array}` - The reason this event happened. This will be passed to\n\t *     [can-queues.enqueueByQueue] for debugging purposes.\n\t *   - __makeMeta__ `{function}` - Details about the handler being called. This will be passed to\n\t *     [can-queues.enqueueByQueue] for debugging purposes.\n\t *   - __patches__ `{Array<Patch>}` - The patch objects this event represents.  The `.patches` value will be\n\t *     passed to the object's `.constructor`'s `@can.dispatchInstanceOnPatches` method.\n\t *\n\t * @param {Array} [args] Additional arguments to pass to event handlers.\n\t * @return {Object} event The resulting event object.\n\t */\n\tdispatch: function(event, args) {\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif (arguments.length > 4) {\n\t\t\t\tcanDev.warn('Arguments to dispatch should be an array, not multiple arguments.');\n\t\t\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\t\t}\n\n\t\t\tif (args && !Array.isArray(args)) {\n\t\t\t\tcanDev.warn('Arguments to dispatch should be an array.');\n\t\t\t\targs = [args];\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// Don't send events if initalizing.\n\t\tif (!this.__inSetup) {\n\t\t\tif (typeof event === 'string') {\n\t\t\t\tevent = {\n\t\t\t\t\ttype: event\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar meta = ensureMeta(this);\n\n\t\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\t\tif (!event.reasonLog) {\n\t\t\t\t\tevent.reasonLog = [canReflect.getName(this), \"dispatched\", '\"' + event.type + '\"', \"with\"].concat(args);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof meta._log === \"function\") {\n\t\t\t\tmeta._log.call(this, event, args);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar handlers = meta.handlers;\n\t\t\tvar handlersByType = event.type !== undefined && handlers.getNode([event.type]);\n\t\t\tvar dispatchConstructorPatches = event.patches && this.constructor[dispatchInstanceOnPatchesSymbol];\n\t\t\tvar patchesNode = event.patches !== undefined && handlers.getNode([\"can.patches\",\"onKeyValue\"]);\n\t\t\tvar keysNode = event.keyChanged !== undefined && handlers.getNode([\"can.keys\",\"onKeyValue\"]);\n\t\t\tvar batch = dispatchConstructorPatches || handlersByType || patchesNode || keysNode;\n\t\t\tif ( batch ) {\n\t\t\t\tqueues.batch.start();\n\t\t\t}\n\t\t\tif(handlersByType) {\n\t\t\t\tif (handlersByType.onKeyValue) {\n\t\t\t\t\tqueues.enqueueByQueue(handlersByType.onKeyValue, this, args, event.makeMeta, event.reasonLog);\n\t\t\t\t}\n\t\t\t\tif (handlersByType.event) {\n\t\t\t\t\tevent.batchNum = queues.batch.number();\n\t\t\t\t\tvar eventAndArgs = [event].concat(args);\n\t\t\t\t\tqueues.enqueueByQueue(handlersByType.event, this, eventAndArgs, event.makeMeta, event.reasonLog);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(keysNode) {\n\t\t\t\tqueues.enqueueByQueue(keysNode, this, [event.keyChanged], event.makeMeta, event.reasonLog);\n\t\t\t}\n\t\t\tif(patchesNode) {\n\t\t\t\tqueues.enqueueByQueue(patchesNode, this, [event.patches], event.makeMeta, event.reasonLog);\n\t\t\t}\n\t\t\tif(dispatchConstructorPatches) {\n\t\t\t\tthis.constructor[dispatchInstanceOnPatchesSymbol](this, event.patches);\n\t\t\t}\n\t\t\tif ( batch ) {\n\t\t\t\tqueues.batch.stop();\n\t\t\t}\n\t\t}\n\t\treturn event;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.addEventListener addEventListener\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `obj.addEventListener(eventName, handler(event, ...) [,queueName] )`\n\t *\n\t * Add a event listener to an object.  Handlers attached by `.addEventListener` get\n\t * called back with the [can-event-queue/map/map.dispatch]\n\t * `event` object and any arguments used to dispatch. [can-event-queue/map/map.can.onKeyValue] bindings do\n\t * not get the event object.\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * obj.addEventListener(\"foo\", function(event){ ... });\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to listen for.\n\t * @param {Function} handler(event,arg...) The handler that will be executed to handle the event.  The handler will be called\n\t *   with the dispatched `event` and `args`.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called\n\t *   back within. Defaults to `\"mutate\"`.\n\t * @return {Object} Returns the object `.addEventListener` was called on.\n\t *\n\t */\n\taddEventListener: function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.add([key, \"event\", queueName || \"mutate\", handler]);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.removeEventListener removeEventListener\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Unregister an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `obj.removeEventListener(eventName, [handler [,queueName]] )`\n\t *\n\t * Removes one or more handlers from being called when `eventName`\n\t * is [can-event-queue/map/map.dispatch]ed.\n\t *\n\t * ```js\n\t * // Removes `handler` if it is in the notify queue.\n\t * obj.removeEventListener(\"closed\", handler, \"notify\")\n\t *\n\t * // Removes `handler` if it is in the mutate queue.\n\t * obj.removeEventListener(\"closed\", handler)\n\t *\n\t * // Removes all \"closed\" handlers.\n\t * obj.removeEventListener(\"closed\")\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to remove. If not specified, all events are removed.\n\t * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `\"mutate\"`.\n\t * @return {Object} Returns the object `.removeEventListener` was called on.\n\t */\n\tremoveEventListener: function(key, handler, queueName) {\n\t\tif(key === undefined) {\n\t\t\t// This isn't super fast, but this pattern isn't used much.\n\t\t\t// We could re-arrange the tree so it would be faster.\n\t\t\tvar handlers = ensureMeta(this).handlers;\n\t\t\tvar keyHandlers = handlers.getNode([]);\n\t\t\tObject.keys(keyHandlers).forEach(function(key){\n\t\t\t\thandlers.delete([key,\"event\"]);\n\t\t\t});\n\t\t} else if (!handler && !queueName) {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\"]);\n\t\t} else if (!handler) {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\", queueName || \"mutate\"]);\n\t\t} else {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\", queueName || \"mutate\", handler]);\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.one one\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler that gets called only once.\n\t *\n\t * @signature `obj.one(event, handler(event, args...) )`\n\t *\n\t * Adds a basic event listener that listens to an event once and only once.\n\t *\n\t * ```js\n\t * obj.one(\"prop\", function(){\n\t *   console.log(\"prop dispatched\");\n\t * })\n\t *\n\t * obj[canSymbol.for(\"prop\")](\"prop\") //-> logs \"prop dispatched\"\n\t * obj[canSymbol.for(\"prop\")](\"prop\")\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to listen to.\n\t * @param {Function} handler(event, args...) The handler that will be run when the\n\t *   event is dispached.\n\t * @return {Object} this\n\t */\n\tone: function(event, handler) {\n\t\t// Unbind the listener after it has been executed\n\t\tvar one = function() {\n\t\t\tlegacyMapBindings.off.call(this, event, one);\n\t\t\treturn handler.apply(this, arguments);\n\t\t};\n\n\t\t// Bind the altered listener\n\t\tlegacyMapBindings.on.call(this, event, one);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.listenTo listenTo\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Listen to an event and register the binding for simplified unbinding.\n\t *\n\t * @signature `obj.listenTo([bindTarget,] event, handler)`\n\t *\n\t * `.listenTo` is useful for creating bindings that can can be torn down with\n\t * [can-event-queue/map/map.stopListening].  This is useful when creating\n\t * rich behaviors that can't be accomplished using computed values, or if you are trying to\n\t * avoid streams.\n\t *\n\t * For example, the following creates an observable that counts how many times its\n\t * `name` property has changed:\n\t *\n\t * ```js\n\t * class Person {\n\t *   constructor(){\n\t *     this.nameChanged = 0;\n\t *     this.listenTo(\"name\", function(){\n\t *       this.nameChanged++;\n\t *     })\n\t *   },\n\t *   setName(newVal) {\n\t *     this.name = newVal;\n\t *     this.dispatch(\"name\",[newVal])\n\t *   }\n\t * }\n\t * mixinMapBindings(Person.prototype);\n\t *\n\t * var person = new Person();\n\t * person.setName(\"Justin\");\n\t * person.setName(\"Ramiya\");\n\t * person.nameChanged //-> 2\n\t * ```\n\t *\n\t * `.listenTo` event bindings are stored on an observable and MUST be unbound using\n\t * [can-event-queue/map/map.stopListening]. `.stopListening` make it easy to unbind\n\t * all of the `.listenTo` event bindings when the observable is no longer needed:\n\t *\n\t * ```js\n\t * person.stopListening();\n\t * ```\n\t *\n\t * If no `bindTarget` is passed, `.listenTo` binds to the current\n\t * observable.\n\t *\n\t * [can-component]'s `connectedCallback` lifecyle hook is often used to call\n\t * `.listenTo` to setup bindings that update viewmodel properties.\n\t *\n\t *\n\t * @param {Object} [bindTarget] The object to listen for events on.  If `bindTarget` is not provided,\n\t * the observable `.listenTo` was called on will be the `bindTarget`.\n\t * @param {String} event The name of the event to listen for.\n\t * @param {Function} handler The handler that will be executed to handle the event.\n\t * @return {Object} this\n\t */\n\tlistenTo: function (bindTarget, event, handler, queueName) {\n\n\t\tif(canReflect.isPrimitive(bindTarget)) {\n\t\t\tqueueName = handler;\n\t\t\thandler = event;\n\t\t\tevent = bindTarget;\n\t\t\tbindTarget = this;\n\t\t}\n\n\t\tif(typeof event === \"function\") {\n\t\t\tqueueName = handler;\n\t\t\thandler = event;\n\t\t\tevent = undefined;\n\t\t}\n\n\t\t// Initialize event cache\n\t\tensureMeta(this).listenHandlers.add([bindTarget, event, queueName || \"mutate\", handler]);\n\n\t\tlegacyMapBindings.on.call(bindTarget, event, handler, queueName || \"mutate\");\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.stopListening stopListening\n\t * @parent can-event-queue/map/map\n\t * @description Stops listening for registered event handlers.\n\t *\n\t * @signature `obj.stopListening( [bindTarget], [event,] handler]] )`\n\t *\n\t * `.stopListening` unbinds on event handlers registered through\n\t * [can-event-queue/map/map.listenTo]. All event handlers\n\t * that match the arguments will be unbound. For example:\n\t *\n\t * ```js\n\t * // Unbinds all .listenTo registered handlers\n\t * obj.stopListening()\n\t *\n\t * // Unbinds all .listenTo registered with `bindTarget`\n\t * obj.stopListening(bindTarget)\n\t *\n\t * // Unbinds all .listenTo registered with `bindTarget`, `event`\n\t * obj.stopListening(bindTarget, event)\n\t *\n\t * // Unbinds the handler registered with `bindTarget`, `event`, `handler`\n\t * obj.stopListening(bindTarget, event, handler)\n\t * ```\n\t *\n\t * `.listenTo` is often returned by [can-component]'s `connectedCallback` lifecyle hook.\n\t *\n\t * @param {Object} [bindTarget] The object we will stop listening to event on. If `bindTarget` is\n\t * not provided, the observable `.stopListening` was called on will be the `bindTarget`.\n\t * @param {String} [event] The name of the event to listen for.\n\t * @param {Function} [handler] The handler that will be executed to handle the event.\n\t * @return {Object} this\n\t *\n\t */\n\tstopListening: function () {\n\t\tvar keys = stopListeningArgumentsToKeys.apply({context: this, defaultQueue: \"mutate\"}, arguments);\n\n\t\tvar listenHandlers = ensureMeta(this).listenHandlers;\n\n\t\tfunction deleteHandler(bindTarget, event, queue, handler){\n\t\t\tlegacyMapBindings.off.call(bindTarget, event, handler, queue);\n\t\t}\n\t\tlistenHandlers.delete(keys, deleteHandler);\n\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.on on\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description A shorthand method for listening to event.\n\t *\n\t * @signature `obj.on( event, handler [, queue] )`\n\t *\n\t * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]\n\t * change, or a [can-reflect/observe.onValue] change in that order.\n\t *\n\t * As this is the __legacy__ `.on`, it will look for an `.addEventListener`\n\t * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]\n\t * and then [can-symbol/symbols/onValue] symbol.\n\t *\n\t * @param {String} eventName\n\t * @param {Function} handler\n\t * @param {String} [queue]\n\t * @return {Any} The object `on` was called on.\n\t */\n\ton: function(eventName, handler, queue) {\n\t\tvar listenWithDOM = isDomEventTarget(this);\n\t\tif (listenWithDOM) {\n\t\t\tif (typeof handler === 'string') {\n\t\t\t\tdomEvents.addDelegateListener(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tdomEvents.addEventListener(this, eventName, handler, queue);\n\t\t\t}\n\t\t} else {\n\t\t\tif (\"addEventListener\" in this) {\n\t\t\t\tthis.addEventListener(eventName, handler, queue);\n\t\t\t} else if (this[onKeyValueSymbol]) {\n\t\t\t\tcanReflect.onKeyValue(this, eventName, handler, queue);\n\t\t\t} else if (this[onEventSymbol]) {\n\t\t\t\tthis[onEventSymbol](eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tif (!eventName && this[onValueSymbol]) {\n\t\t\t\t\tcanReflect.onValue(this, handler, queue);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"can-event-queue: Unable to bind \" + eventName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.off off\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description A shorthand method for unbinding an event.\n\t *\n\t * @signature `obj.on( event, handler [, queue] )`\n\t *\n\t * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]\n\t * change, or a [can-reflect/observe.onValue] change in that order.\n\t *\n\t * As this is the __legacy__ `.on`, it will look for an `.addEventListener`\n\t * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]\n\t * and then [can-symbol/symbols/onValue] symbol.\n\t *\n\t * @param {String} eventName\n\t * @param {Function} handler\n\t * @param {String} [queue]\n\t * @return {Any} The object `on` was called on.\n\t */\n\toff: function(eventName, handler, queue) {\n\t\tvar listenWithDOM = isDomEventTarget(this);\n\t\tif (listenWithDOM) {\n\t\t\tif (typeof handler === 'string') {\n\t\t\t\tdomEvents.removeDelegateListener(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tdomEvents.removeEventListener(this, eventName, handler, queue);\n\t\t\t}\n\t\t} else {\n\t\t\tif (\"removeEventListener\" in this) {\n\t\t\t\tthis.removeEventListener(eventName, handler, queue);\n\t\t\t} else if (this[offKeyValueSymbol]) {\n\t\t\t\tcanReflect.offKeyValue(this, eventName, handler, queue);\n\t\t\t} else if (this[offEventSymbol]) {\n\t\t\t\tthis[offEventSymbol](eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tif (!eventName && this[offValueSymbol]) {\n\t\t\t\t\tcanReflect.offValue(this, handler, queue);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"can-event-queue: Unable to unbind \" + eventName);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n};\n\n// The symbols we'll add to objects\nvar symbols = {\n\t/**\n\t * @function can-event-queue/map/map.can.onKeyValue @can.onKeyValue\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler to be called when a key value changes.\n\t *\n\t * @signature `canReflect.onKeyValue( obj, key, handler(newVal) [,queueName] )`\n\t *\n\t * Add a key change handler to an object.  Handlers attached by `.onKeyValue` get\n\t * called back with the new value of the `key`. Handlers attached with [can-event-queue/map/map.can.addEventListener]\n\t * get the event object.\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * canReflect.onKeyValue( obj, \"prop\", function(newPropValue){ ... });\n\t * ```\n\t *\n\t * @param {String} key The name of property to listen to changes in values.\n\t * @param {Function} handler(newVal, oldValue) The handler that will be called\n\t *   back with the new and old value of the key.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called\n\t *   back within. Defaults to `\"mutate\"`.\n\t */\n\t\"can.onKeyValue\": function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.add([key, \"onKeyValue\", queueName || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.offKeyValue @can.offKeyValue\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Unregister an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `canReflect.offKeyValue( obj, key, handler, queueName )`\n\t *\n\t * Removes a handlers from being called when `key` changes are\n\t * [can-event-queue/map/map.dispatch]ed.\n\t *\n\t * ```js\n\t * // Removes `handler` if it is in the notify queue.\n\t * canReflect.offKeyValue( obj, \"prop\", handler, \"notify\" )\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to remove. If not specified, all events are removed.\n\t * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `\"mutate\"`.\n\t */\n\t\"can.offKeyValue\": function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.delete([key, \"onKeyValue\", queueName || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.isBound @can.isBound\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Return if the observable is bound to.\n\t *\n\t * @signature `canReflect.isBound(obj)`\n\t *\n\t * The `@can.isBound` symbol is added to make [can-reflect/observe.isBound]\n\t * return if `obj` is bound or not.\n\t *\n\t * @return {Boolean} True if the observable has been bound to with `.onKeyValue` or `.addEventListener`.\n\t */\n\t\"can.isBound\": function() {\n\t\treturn !ensureMeta(this).handlers.isEmpty();\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.getWhatIChange @can.getWhatIChange\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Return observables whose values are affected by attached event handlers\n\t * @signature `@can.getWhatIChange(key)`\n\t *\n\t * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report\n\t * all the observables whose values are set by a given observable's key.\n\t *\n\t * This function iterates over the event handlers attached to a given `key` and\n\t * collects the result of calling `@@can.getChangesDependencyRecord` on each handler;\n\t * this symbol allows the caller to tell what observables are being mutated by\n\t * the event handler when it is executed.\n\t *\n\t * In the following example a [can-simple-map] instance named `me` is created\n\t * and when its `age` property changes, the value of a [can-simple-observable]\n\t * instance is set. The event handler that causes the mutation is then decatorated\n\t * with `@@can.getChangesDependencyRecord` to register the mutation dependency.\n\t *\n\t * ```js\n\t * var obs = new SimpleObservable(\"a\");\n\t * var me = new SimpleMap({ age: 30 });\n\t * var canReflect = require(\"can-reflect\");\n\t *\n\t * var onAgeChange = function onAgeChange() {\n\t *\tcanReflect.setValue(obs, \"b\");\n\t * };\n\t *\n\t * onAgeChange[canSymbol.for(\"can.getChangesDependencyRecord\")] = function() {\n\t *\treturn {\n\t *\t\tvalueDependencies: new Set([ obs ]);\n\t *\t}\n\t * };\n\t *\n\t * canReflect.onKeyValue(me, \"age\", onAgeChange);\n\t * me[canSymbol.for(\"can.getWhatIChange\")](\"age\");\n\t * ```\n\t *\n\t * The dependency records collected from the event handlers are divided into\n\t * two categories:\n\t *\n\t * - mutate: Handlers in the mutate/domUI queues\n\t * - derive: Handlers in the notify queue\n\t *\n\t * Since event handlers are added by default to the \"mutate\" queue, calling\n\t * `@@can.getWhatIChange` on the `me` instance returns an object with a mutate\n\t * property and the `valueDependencies` Set registered on the `onAgeChange`\n\t * handler.\n\t *\n\t * Please check out the [can-reflect-dependencies] docs to learn more about\n\t * how this symbol is used to keep track of custom observable dependencies.\n\t */\n\t\"can.getWhatIChange\": function getWhatIChange(key) {\n\t\t//!steal-remove-start\n\t\t\tif(true) {\n\t\t\tvar whatIChange = {};\n\t\t\tvar meta = ensureMeta(this);\n\n\t\t\tvar notifyHandlers = [].concat(\n\t\t\t\tmeta.handlers.get([key, \"event\", \"notify\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"notify\"])\n\t\t\t);\n\n\t\t\tvar mutateHandlers = [].concat(\n\t\t\t\tmeta.handlers.get([key, \"event\", \"mutate\"]),\n\t\t\t\tmeta.handlers.get([key, \"event\", \"domUI\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"mutate\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"domUI\"])\n\t\t\t);\n\n\t\t\tif (notifyHandlers.length) {\n\t\t\t\tnotifyHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.derive;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.derive = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (mutateHandlers.length) {\n\t\t\t\tmutateHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.mutate;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.mutate = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Object.keys(whatIChange).length ? whatIChange : undefined;\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t\"can.onPatches\": function(handler, queue) {\n\t\tvar handlers = ensureMeta(this).handlers;\n\t\thandlers.add([\"can.patches\", \"onKeyValue\", queue || \"notify\", handler]);\n\t},\n\t\"can.offPatches\": function(handler, queue) {\n\t\tvar handlers = ensureMeta(this).handlers;\n\t\thandlers.delete([\"can.patches\", \"onKeyValue\", queue || \"notify\", handler]);\n\t}\n};\n\n// This can be removed in a future version.\nfunction defineNonEnumerable(obj, prop, value) {\n\tObject.defineProperty(obj, prop, {\n\t\tenumerable: false,\n\t\tvalue: value\n\t});\n}\n\n// The actual legacyMapBindings mixin function\nlegacyMapBindings = function(obj) {\n\t// add properties\n\tcanReflect.assignMap(obj, props);\n\t// add symbols\n\treturn canReflect.assignSymbols(obj, symbols);\n};\n\ndefineNonEnumerable(legacyMapBindings, \"addHandlers\", addHandlers);\ndefineNonEnumerable(legacyMapBindings, \"stopListeningArgumentsToKeys\", stopListeningArgumentsToKeys);\n\n\n\n// ## LEGACY\n// The following is for compatability with the old can-event\nprops.bind = props.addEventListener;\nprops.unbind = props.removeEventListener;\n\n\n\n// Adds methods directly to method so it can be used like `can-event` used to be used.\ncanReflect.assignMap(legacyMapBindings, props);\ncanReflect.assignSymbols(legacyMapBindings, symbols);\n\ndefineNonEnumerable(legacyMapBindings, \"start\", function() {\n\tconsole.warn(\"use can-queues.batch.start()\");\n\tqueues.batch.start();\n});\ndefineNonEnumerable(legacyMapBindings, \"stop\", function() {\n\tconsole.warn(\"use can-queues.batch.stop()\");\n\tqueues.batch.stop();\n});\ndefineNonEnumerable(legacyMapBindings, \"flush\", function() {\n\tconsole.warn(\"use can-queues.flush()\");\n\tqueues.flush();\n});\n\ndefineNonEnumerable(legacyMapBindings, \"afterPreviousEvents\", function(handler) {\n\tconsole.warn(\"don't use afterPreviousEvents\");\n\tqueues.mutateQueue.enqueue(function afterPreviousEvents() {\n\t\tqueues.mutateQueue.enqueue(handler);\n\t});\n\tqueues.flush();\n});\n\ndefineNonEnumerable(legacyMapBindings, \"after\", function(handler) {\n\tconsole.warn(\"don't use after\");\n\tqueues.mutateQueue.enqueue(handler);\n\tqueues.flush();\n});\n\nmodule.exports = legacyMapBindings;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-event-queue/map/map.js?");

/***/ }),

/***/ "../../node_modules/can-event-queue/type/type.js":
/*!**********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-event-queue/type/type.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-event-queue/type/type\n * @parent can-event-queue\n *\n * @description Mixin methods and symbols to make a type constructor function able to\n * broadcast changes in its instances.\n *\n * @signature `mixinTypeBindings( type )`\n *\n * Adds symbols and methods that make `type` work with the following [can-reflect] APIs:\n *\n * - [can-reflect/observe.onInstanceBoundChange] - Observe when instances are bound.\n * - [can-reflect/observe.onInstancePatches] - Observe patche events on all instances.\n *\n * When `mixinTypeBindings` is called on an `Person` _type_ like:\n *\n * ```js\n * var mixinTypeBindings = require(\"can-event-queue/type/type\");\n * var mixinLegacyMapBindings = require(\"can-event-queue/map/map\");\n *\n * class Person {\n *   constructor(data){\n *     this.data = data;\n *   }\n * }\n * mixinTypeBindings(Person);\n * mixinLegacyMapBindings(Person.prototype);\n *\n * var me = new Person({first: \"Justin\", last: \"Meyer\"});\n *\n * // mixinTypeBindings allows you to listen to\n * // when a person instance's bind stache changes\n * canReflect.onInstanceBoundChange(Person, function(person, isBound){\n *    console.log(\"isBound\");\n * });\n *\n * // mixinTypeBindings allows you to listen to\n * // when a patch change happens.\n * canReflect.onInstancePatches(Person, function(person, patches){\n *    console.log(patches[0]);\n * });\n *\n * me.on(\"name\",function(ev, newVal, oldVal){}) //-> logs: \"isBound\"\n *\n * me.dispatch({\n *   type: \"first\",\n *   patches: [{type: \"set\", key: \"first\", value: \"Ramiya\"}]\n * }, [\"Ramiya\",\"Justin\"])\n * //-> logs: {type: \"set\", key: \"first\", value: \"Ramiya\"}\n * ```\n *\n */\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"../../node_modules/can-key-tree/dist/cjs/can-key-tree.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\n\nvar metaSymbol = canSymbol.for(\"can.meta\");\n\nfunction addHandlers(obj, meta) {\n    if (!meta.lifecycleHandlers) {\n        meta.lifecycleHandlers = new KeyTree([Object, Array]);\n    }\n    if (!meta.instancePatchesHandlers) {\n        meta.instancePatchesHandlers = new KeyTree([Object, Array]);\n    }\n}\n\nfunction ensureMeta(obj) {\n    var meta = obj[metaSymbol];\n\n    if (!meta) {\n        meta = {};\n        canReflect.setKeyValue(obj, metaSymbol, meta);\n    }\n\n    addHandlers(obj, meta);\n    return meta;\n}\n\nvar props = {\n    /**\n     * @function can-event-queue/type/type.can.onInstanceBoundChange @can.onInstanceBoundChange\n     * @parent can-event-queue/type/type\n     * @description Listen to when any instance is bound for the first time or all handlers are removed.\n     *\n     * @signature `canReflect.onInstanceBoundChange(Type, handler(instance, isBound) )`\n     *\n     * ```js\n     * canReflect.onInstanceBoundChange(Person, function(person, isBound){\n     *    console.log(\"isBound\");\n     * });\n     * ```\n     *\n     * @param {function(Any,Boolean)} handler(instance,isBound) A function is called\n     * when an instance is bound or unbound.  `isBound` will be `true` when the instance\n     * becomes bound and `false` when unbound.\n     */\n\n    /**\n     * @function can-event-queue/type/type.can.offInstanceBoundChange @can.offInstanceBoundChange\n     * @parent can-event-queue/type/type\n     *\n     * @description Stop listening to when an instance's bound status changes.\n     *\n     * @signature `canReflect.offInstanceBoundChange(Type, handler )`\n     *\n     * Stop listening to a handler bound with\n     * [can-event-queue/type/type.can.onInstanceBoundChange].\n     */\n\n\n    /**\n     * @function can-event-queue/type/type.can.onInstancePatches @can.onInstancePatches\n     * @parent can-event-queue/type/type\n     *\n     * @description Listen to patch changes on any isntance.\n     *\n     * @signature `canReflect.onInstancePatches(Type, handler(instance, patches) )`\n     *\n     * Listen to patch changes on any instance of `Type`. This is used by\n     * [can-connect] to know when a potentially `unbound` instance's `id`\n     * changes. If the `id` changes, the instance can be moved into the store\n     * while it is being saved.\n     *\n     */\n\n    /**\n     * @function can-event-queue/type/type.can.offInstancePatches @can.offInstancePatches\n     * @parent can-event-queue/type/type\n     *\n     * @description Stop listening to patch changes on any instance.\n     *\n     * @signature `canReflect.onInstancePatches(Type, handler )`\n     *\n     * Stop listening to a handler bound with [can-event-queue/type/type.can.onInstancePatches].\n     */\n};\n\nfunction onOffAndDispatch(symbolName, dispatchName, handlersName){\n    props[\"can.on\"+symbolName] = function(handler, queueName) {\n        ensureMeta(this)[handlersName].add([queueName || \"mutate\", handler]);\n    };\n    props[\"can.off\"+symbolName] = function(handler, queueName) {\n        ensureMeta(this)[handlersName].delete([queueName || \"mutate\", handler]);\n    };\n    props[\"can.\"+dispatchName] = function(instance, arg){\n        queues.enqueueByQueue(ensureMeta(this)[handlersName].getNode([]), this, [instance, arg]);\n    };\n}\n\nonOffAndDispatch(\"InstancePatches\",\"dispatchInstanceOnPatches\",\"instancePatchesHandlers\");\nonOffAndDispatch(\"InstanceBoundChange\",\"dispatchInstanceBoundChange\",\"lifecycleHandlers\");\n\nfunction mixinTypeBindings(obj){\n    return canReflect.assignSymbols(obj,props);\n}\n\nObject.defineProperty(mixinTypeBindings, \"addHandlers\", {\n    enumerable: false,\n    value: addHandlers\n});\n\nmodule.exports = mixinTypeBindings;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-event-queue/type/type.js?");

/***/ }),

/***/ "../../node_modules/can-event-queue/value/value.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-event-queue/value/value.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"../../node_modules/can-key-tree/dist/cjs/can-key-tree.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"../../node_modules/can-define-lazy-value/define-lazy-value.js\");\nvar mergeDependencyRecords = __webpack_require__(/*! ../dependency-record/merge */ \"../../node_modules/can-event-queue/dependency-record/merge.js\");\n\nvar properties = {\n\t/**\n\t * @function can-event-queue/value/value.on on\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Listen to changes in the observable's value.\n\t *\n\t * @signature `.on( handler[, queue='mutate'] )`\n\t *\n\t * This adds an event handler in the observable's [can-event-queue/value/value.handlers]\n\t * tree. If this is the first handler, the observable's [can-event-queue/value/value.onBound] method is called.\n\t *\n\t * ```js\n\t * observable.on(function(newVal){ ... });\n\t * observable.on(function(newVal){ ... }, \"notify\");\n\t * ```\n\t *\n\t * @param {function(*)} handler(newValue,oldValue) A handler that will be called with the new value of the\n\t * observable and optionally the old value of the observable.\n\t * @param {String} [queue] The [can-queues] queue this event handler should be bound to.  By default the handler will\n\t * be called within the `mutate` queue.\n\t */\n\ton: function(handler, queue) {\n\t\tthis.handlers.add([queue || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/value/value.off off\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Stop listening to changes in the observable's value.\n\t *\n\t * @signature `.off( [handler [, queue='mutate']] )`\n\t *\n\t * Removes one or more event handler in the observable's [can-event-queue/value/value.handlers]\n\t * tree. If the las handler is removed, the observable's [can-event-queue/value/value.onUnbound] method is called.\n\t *\n\t * ```js\n\t * observable.off(function(newVal){ ... });\n\t * observable.off(function(newVal){ ... }, \"notify\");\n\t * observable.off();\n\t * observable.off(undefined, \"mutate\");\n\t * ```\n\t *\n\t * @param {function(*)} handler(newValue,oldValue) The handler to be removed.  If no handler is provided and no\n\t * `queue` is provided, all handlers will be removed.\n\t * @param {String} [queue] The [can-queues] queue this event handler should be removed from.\n\t *\n\t *  If a `handler` is\n\t *  provided and no `queue` is provided, the `queue` will default to `\"mutate\"`.\n\t *\n\t *   If a `handler` is not provided, but a `queue` is provided, all handlers for the provided queue will be\n\t *   removed.\n\t */\n\toff: function(handler, queueName) {\n\t\tif (handler === undefined) {\n\t\t\tif (queueName === undefined) {\n\t\t\t\tthis.handlers.delete([]);\n\t\t\t} else {\n\t\t\t\tthis.handlers.delete([queueName]);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.handlers.delete([queueName || \"mutate\", handler]);\n\t\t}\n\t}\n};\n\nvar symbols = {\n\t/**\n\t * @function can-event-queue/value/value.can.onValue @can.onValue\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Listen to changes in this observable value.\n\t *\n\t * This is an alias for [can-event-queue/value/value.on].  It satisfies [can-reflect].[can-reflect/observe.onValue].\n\t */\n\t\"can.onValue\": properties.on,\n\t/**\n\t * @function can-event-queue/value/value.can.offValue @can.offValue\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Stop listening to changes in this observable value.\n\t *\n\t * This is an alias for [can-event-queue/value/value.off].  It satisfies [can-reflect].[can-reflect/observe.offValue].\n\t */\n\t\"can.offValue\": properties.off,\n\t/**\n\t * @function can-event-queue/value/value.can.dispatch @can.dispatch\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Dispatch all event handlers within their appropriate queues.\n\t *\n\t * @signature `@can.dispatch(newValue, oldValue)`\n\t *\n\t * This is a helper method that will dispatch all [can-event-queue/value/value.handlers] within\n\t * their appropriate [can-queues] queue.\n\t *\n\t * Furthermore, it will make sure the handlers include useful meta data for debugging.\n\t *\n\t * ```js\n\t * var observable = mixinValueBindings({});\n\t * observable[canSymbol.for(\"can.dispatch\")]( 2, 1 );\n\t * ```\n\t *\n\t * @param {Any} newValue The new value of the observable.\n\t * @param {Any} oldValue The old value of the observable.\n\t */\n\t\"can.dispatch\": function(value, old) {\n\t\tvar queuesArgs = [];\n\t\tqueuesArgs = [\n\t\t\tthis.handlers.getNode([]),\n\t\t\tthis,\n\t\t\t[value, old]\n\t\t];\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\tthis,\n\t\t\t\t[value, old]\n\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t, null\n\t\t\t\t, [canReflect.getName(this), \"changed to\", value, \"from\", old]\n\t\t\t\t/* jshint laxcomma: false */\n\t\t\t];\n\t\t}\n\t\t//!steal-remove-end\n\t\tqueues.enqueueByQueue.apply(queues, queuesArgs);\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\tthis._log(old, value);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-event-queue/value/value.can.getWhatIChange @can.getWhatIChange\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Return observables whose values are affected by attached event handlers\n\t * @signature `@can.getWhatIChange()`\n\t *\n\t * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report\n\t * all the observables whose values are set by value-like observables.\n\t *\n\t * This function iterates over the event handlers attached to  the observable's value\n\t * event and collects the result of calling `@@can.getChangesDependencyRecord` on each\n\t * handler; this symbol allows the caller to tell what observables are being mutated\n\t * by the event handler when it is executed.\n\t *\n\t * In the following example a [can-simple-observable] instance named `month` is\n\t * created and when its value changes the `age` property of the `map` [can-simple-map]\n\t * instance is set. The event handler that causes the mutation is then decatorated with\n\t * `@@can.getChangesDependencyRecord` to register the mutation dependency.\n\t *\n\t * ```js\n\t * var month = new SimpleObservable(11);\n\t * var map = new SimpleMap({ age: 30 });\n\t * var canReflect = require(\"can-reflect\");\n\t *\n\t * var onValueChange = function onValueChange() {\n\t *\tmap.set(\"age\", 31);\n\t * };\n\t *\n\t * onValueChange[canSymbol.for(\"can.getChangesDependencyRecord\")] = function() {\n\t *\treturn {\n\t *\t\tkeyDependencies: new Map([ [map, new Set([\"age\"])] ])\n\t *\t}\n\t * };\n\t *\n\t * canReflect.onValue(month, onValueChange);\n\t * month[canSymbol.for(\"can.getWhatIChange\")]();\n\t * ```\n\t *\n\t * The dependency records collected from the event handlers are divided into\n\t * two categories:\n\t *\n\t * - mutate: Handlers in the mutate/domUI queues\n\t * - derive: Handlers in the notify queue\n\t *\n\t * Since event handlers are added by default to the \"mutate\" queue, calling\n\t * `@@can.getWhatIChange` on the `month` instance returns an object with a mutate\n\t * property and the `keyDependencies` Map registered on the `onValueChange` handler.\n\t *\n\t * If multiple event handlers were attached to `month`, the dependency records\n\t * of each handler are merged by `@@can.getWhatIChange`. Please check out the\n\t * [can-reflect-dependencies] docs to learn more about how this symbol is used\n\t * to keep track of custom observable dependencies.\n\t */\n\t\"can.getWhatIChange\": function getWhatIChange() {\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tvar whatIChange = {};\n\n\t\t\tvar notifyHandlers = this.handlers.get([\"notify\"]);\n\t\t\tvar mutateHandlers = [].concat(\n\t\t\t\tthis.handlers.get([\"mutate\"]),\n\t\t\t\tthis.handlers.get([\"domUI\"])\n\t\t\t);\n\n\t\t\tif (notifyHandlers.length) {\n\t\t\t\tnotifyHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.derive;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.derive = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (mutateHandlers.length) {\n\t\t\t\tmutateHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.mutate;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.mutate = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Object.keys(whatIChange).length ? whatIChange : undefined;\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\n\t/**\n\t * @function can-event-queue/value/value.can.isBound @can.isBound\n\t * @parent can-event-queue/value/value\n\t */\n\t\"can.isBound\": function isBound() {\n\t\treturn !this.handlers.isEmpty();\n\t}\n};\n\n/**\n * @property {can-key-tree} can-event-queue/value/value.handlers handlers\n * @parent can-event-queue/value/value\n *\n * @description Access the handlers tree directly.\n *\n * @type {can-key-tree}\n *\n *  The handlers property is a [can-define-lazy-value lazily] defined property containing\n *  all handlers bound with [can-event-queue/value/value.on] and\n *  [can-event-queue/value/value.can.onValue].  It is a [can-key-tree] defined like:\n *\n *  ```js\n *  this.handlers = new KeyTree([Object, Array])\n *  ```\n *\n *  It is configured to call [can-event-queue/value/value.onBound] and\n *  [can-event-queue/value/value.onUnbound] on the instances when the first item is\n *  added to the tree and when the tree is emptied.\n */\nfunction defineLazyHandlers(){\n\treturn new KeyTree([Object, Array], {\n\t\tonFirst: this.onBound !== undefined && this.onBound.bind(this),\n\t\tonEmpty: this.onUnbound !== undefined && this.onUnbound.bind(this)\n\t});\n}\n\n/**\n * @function can-event-queue/value/value.onBound onBound\n * @parent can-event-queue/value/value\n *\n * @description Perform operations when an observable is gains its first event handler.\n *\n * @signature `.onBound()`\n *\n * This method is not implemented by `can-event-queue/value/value`. Instead, the object\n * should implement it if it wants to perform some actions when it becomes bound.\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({\n *   onBound: function(){\n *     console.log(\"I AM BOUND!\");\n *   }\n * });\n *\n * observable.on(function(){});\n * // Logs: \"I AM BOUND!\"\n * ```\n *\n */\n\n/**\n * @function can-event-queue/value/value.onUnbound onUnbound\n * @parent can-event-queue/value/value\n *\n * @description Perform operations when an observable loses all of its event handlers.\n *\n * @signature `.onBound()`\n *\n * This method is not implemented by `can-event-queue/value/value`. Instead, the object\n * should implement it if it wants to perform some actions when it becomes unbound.\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({\n *   onUnbound: function(){\n *     console.log(\"I AM UNBOUND!\");\n *   }\n * });\n * var handler = function(){}\n * observable.on(function(){});\n * observable.off(function(){});\n * // Logs: \"I AM UNBOUND!\"\n * ```\n */\n\n/**\n * @module {function} can-event-queue/value/value\n * @parent can-event-queue\n *\n * @description Mixin methods and symbols to make this object or prototype object\n * behave like a single-value observable.\n *\n * @signature `mixinValueBindings( obj )`\n *\n * Adds symbols and methods that make `obj` or instances having `obj` on their prototype\n * behave like single-value observables.\n *\n * When `mixinValueBindings` is called on an `obj` like:\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({});\n *\n * observable.on(function(newVal, oldVal){\n *   console.log(newVal);\n * });\n *\n * observable[canSymbol.for(\"can.dispatch\")](2,1);\n * // Logs: 2\n * ```\n *\n * `mixinValueBindings` adds the following properties and symbols to the object:\n *\n * - [can-event-queue/value/value.on]\n * - [can-event-queue/value/value.off]\n * - [can-event-queue/value/value.can.dispatch]\n * - [can-event-queue/value/value.can.getWhatIChange]\n * - [can-event-queue/value/value.handlers]\n *\n * When the object is bound to for the first time with `.on` or `@can.onValue`, it will look for an [can-event-queue/value/value.onBound]\n * function on the object and call it.\n *\n * When the object is has no more handlers, it will look for an [can-event-queue/value/value.onUnbound]\n * function on the object and call it.\n */\nvar mixinValueEventBindings = function(obj) {\n\tcanReflect.assign(obj, properties);\n\tcanReflect.assignSymbols(obj, symbols);\n\tdefineLazyValue(obj,\"handlers\",defineLazyHandlers, true);\n\treturn obj;\n};\n\n// callbacks is optional\nmixinValueEventBindings.addHandlers = function(obj, callbacks) {\n\tconsole.warn(\"can-event-queue/value: Avoid using addHandlers. Add onBound and onUnbound methods instead.\");\n\tobj.handlers = new KeyTree([Object, Array], callbacks);\n\treturn obj;\n};\n\nmodule.exports = mixinValueEventBindings;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-event-queue/value/value.js?");

/***/ }),

/***/ "../../node_modules/can-fragment/can-fragment.js":
/*!**********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-fragment/can-fragment.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar childNodes = __webpack_require__(/*! can-child-nodes */ \"../../node_modules/can-child-nodes/can-child-nodes.js\");\n\n/**\n@module {function} can-fragment\n@parent can-dom-utilities\n@collection can-infrastructure\n\nConvert a String, HTMLElement, documentFragment, or contentArray into a documentFragment.\n\n@signature `fragment(item, doc)`\n\n@param {String|HTMLElement|documentFragment|contentArray} item\n@param {Document} doc   an optional DOM document in which to build the fragment\n\n@return {documentFragment}\n\n@body\n\n## Use\n\nContentArrays can be used to combine multiple HTMLElements into a single document fragment.  For example:\n\n    var fragment = require(\"can-fragment\");\n\n    var p = document.createElement(\"p\");\n    p.innerHTML = \"Welcome to <b>CanJS</b>\";\n    var contentArray = [\"<h1>Hi There</h1>\", p];\n    var fragment = fragment( contentArray )\n\n`fragment` will be a documentFragment with the following elements:\n\n    <h1>Hi There</h1>\n    <p>Welcome to <b>CanJS</b></p>\n\n */\n\n\n// fragment.js\n// ---------\n// _DOM Fragment support._\nvar fragmentRE = /^\\s*<(\\w+)[^>]*>/,\n\ttoString = {}.toString;\n\nfunction makeFragment(html, name, doc) {\n\tif (name === undefined) {\n\t\tname = fragmentRE.test(html) && RegExp.$1;\n\t}\n\tif (html && toString.call(html.replace) === \"[object Function]\") {\n\t\t// Fix \"XHTML\"-style tags in all browsers\n\t\thtml = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi, '<$1></$2>');\n\t}\n\tvar container = doc.createElement('div'),\n\t\ttemp = doc.createElement('div');\n\t// IE's parser will strip any `<tr><td>` tags when `innerHTML`\n\t// is called on a `tbody`. To get around this, we construct a\n\t// valid table with a `tbody` that has the `innerHTML` we want.\n\t// Then the container is the `firstChild` of the `tbody`.\n\t// [source](http://www.ericvasilik.com/2006/07/code-karma.html).\n\tif (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {\n\t\ttemp.innerHTML = '<table>' + html + '</table>';\n\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;\n\t} else if (name === 'col') {\n\t\ttemp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';\n\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;\n\t} else if (name === 'tr') {\n\t\ttemp.innerHTML = '<table><tbody>' + html + '</tbody></table>';\n\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;\n\t} else if (name === 'td' || name === 'th') {\n\t\ttemp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';\n\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;\n\t} else if (name === 'option') {\n\t\ttemp.innerHTML = '<select>' + html + '</select>';\n\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;\n\t} else {\n\t\tcontainer.innerHTML = '' + html;\n\t}\n\n\treturn [].slice.call(childNodes(container));\n}\n\nfunction fragment(html, doc) {\n\tif (html && html.nodeType === 11) {\n\t\treturn html;\n\t}\n\tif (!doc) {\n\t\tdoc = getDocument();\n\t} else if (doc.length) {\n\t\tdoc = doc[0];\n\t}\n\n\tvar parts = makeFragment(html, undefined, doc),\n\t\tfrag = (doc || document).createDocumentFragment();\n\tfor (var i = 0, length = parts.length; i < length; i++) {\n\t\tfrag.appendChild(parts[i]);\n\t}\n\treturn frag;\n}\n\nvar makeFrag = function(item, doc) {\n\tvar document = doc || getDocument();\n\tvar frag;\n\tif (!item || typeof item === \"string\") {\n\t\tfrag = fragment(item == null ? \"\" : \"\" + item, document);\n\t\t// If we have an empty frag...\n\t} else if (item.nodeType === 11) {\n\t\treturn item;\n\t} else if (typeof item.nodeType === \"number\") {\n\t\tfrag = document.createDocumentFragment();\n\t\tfrag.appendChild(item);\n\t\treturn frag;\n\t} else if (canReflect.isListLike(item)) {\n\t\tfrag = document.createDocumentFragment();\n\t\tcanReflect.eachIndex(item, function(item) {\n\t\t\tfrag.appendChild(makeFrag(item));\n\t\t});\n\t} else {\n\t\tfrag = fragment(\"\" + item, document);\n\t}\n    if (!childNodes(frag).length) {\n        frag.appendChild(document.createTextNode(''));\n    }\n    return frag;\n};\n\nmodule.exports = namespace.fragment = namespace.frag = makeFrag;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-fragment/can-fragment.js?");

/***/ }),

/***/ "../../node_modules/can-globals/base-url/base-url.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/base-url/base-url.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\n\nvar globals = __webpack_require__(/*! ../can-globals-instance */ \"../../node_modules/can-globals/can-globals-instance.js\");\n__webpack_require__(/*! ../global/global */ \"../../node_modules/can-globals/global/global.js\");\n__webpack_require__(/*! ../document/document */ \"../../node_modules/can-globals/document/document.js\");\n\n/**\n * @module {function} can-globals/base-url/base-url base-url\n * @parent can-globals/modules\n *\n * @signature `baseUrl(optionalBaseUrlToSet)`\n *\n * Get and/or set the \"base\" (containing path) of the document.\n *\n * ```js\n * var baseUrl = require(\"can-globals/base-url/base-url\");\n *\n * console.log(baseUrl());           // -> \"http://localhost:8080\"\n * console.log(baseUrl(baseUrl() + \"/foo/bar\")); // -> \"http://localhost:8080/foo/bar\"\n * console.log(baseUrl());           // -> \"http://localhost:8080/foo/bar\"\n * ```\n *\n * @param {String} setUrl An optional base url to override reading the base URL from the known path.\n *\n * @return {String} Returns the set or computed base URL\n */\n\nglobals.define('base-url', function(){\n\tvar global = globals.getKeyValue('global');\n\tvar domDocument = globals.getKeyValue('document');\n\tif (domDocument && 'baseURI' in domDocument) {\n\t\treturn domDocument.baseURI;\n\t} else if(global.location) {\n\t\tvar href = global.location.href;\n\t\tvar lastSlash = href.lastIndexOf(\"/\");\n\t\treturn lastSlash !== -1 ? href.substr(0, lastSlash) : href;\n\t} else if(typeof process !== \"undefined\") {\n\t\treturn process.cwd();\n\t}\n});\n\nmodule.exports = globals.makeExport('base-url');\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/base-url/base-url.js?");

/***/ }),

/***/ "../../node_modules/can-globals/can-globals-instance.js":
/*!*****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/can-globals-instance.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar Globals = __webpack_require__(/*! ./can-globals-proto */ \"../../node_modules/can-globals/can-globals-proto.js\");\nvar globals = new Globals();\n\nif (namespace.globals) {\n\tthrow new Error(\"You can't have two versions of can-globals, check your dependencies\");\n} else {\n\tmodule.exports = namespace.globals = globals;\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/can-globals-instance.js?");

/***/ }),

/***/ "../../node_modules/can-globals/can-globals-proto.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/can-globals-proto.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nfunction dispatch(key) {\n\t// jshint -W040\n\tvar handlers = this.eventHandlers[key];\n\tif (handlers) {\n\t\tvar handlersCopy = handlers.slice();\n\t\tvar value = this.getKeyValue(key);\n\t\tfor (var i = 0; i < handlersCopy.length; i++) {\n\t\t\thandlersCopy[i](value);\n\t\t}\n\t}\n}\n\nfunction Globals() {\n\tthis.eventHandlers = {};\n\tthis.properties = {};\n}\n\n/**\n * @function define \n * @parent can-globals/methods\n * \n * Create a new global environment variable.\n * \n * @signature `globals.define(key, value[, cache])`\n * \n * Defines a new global called `key`, who's value defaults to `value`.\n * \n * The following example defines the `global` key's default value to the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window) object:\n * ```javascript\n * globals.define('global', window);\n * globals.getKeyValue('window') //-> window\n * ```\n * \n * If a function is provided and `cache` is falsy, that function is run every time the key value is read:\n * ```javascript\n * globals.define('isBrowserWindow', function() {\n *   console.log('EVALUATING')\n *   return typeof window !== 'undefined' &&\n *     typeof document !== 'undefined' && typeof SimpleDOM === 'undefined'\n * }, false);\n * globals.get('isBrowserWindow') // logs 'EVALUATING'\n *                                // -> true\n * globals.get('isBrowserWindow') // logs 'EVALUATING' again\n *                                // -> true\n * ```\n * \n * If a function is provided and `cache` is truthy, that function is run only the first time the value is read:\n * ```javascript\n * globals.define('isWebkit', function() {\n *   console.log('EVALUATING')\n *   var div = document.createElement('div')\n *   return 'WebkitTransition' in div.style\n * })\n * globals.getKeyValue('isWebkit') // logs 'EVALUATING'\n * \t\t\t\t\t\t\t\t   // -> true\n * globals.getKeyValue('isWebkit') // Does NOT log again!\n * \t\t\t\t\t\t\t\t   // -> true\n * ```\n * \n * @param {String} key\n * The key value to create.\n * \n * @param {*} value\n * The default value. If this is a function, its return value will be used.\n * \n * @param {Boolean} [cache=true]\n * Enable cache. If false the `value` function is run every time the key value is read.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.define = function (key, value, enableCache) {\n\tif (enableCache === undefined) {\n\t\tenableCache = true;\n\t}\n\tif (!this.properties[key]) {\n\t\tthis.properties[key] = {\n\t\t\tdefault: value,\n\t\t\tvalue: value,\n\t\t\tenableCache: enableCache\n\t\t};\n\t}\n\treturn this;\n};\n\n/**\n * @function getKeyValue \n * @parent can-globals/methods\n * \n * Get a global environment variable by name.\n * \n * @signature `globals.getKeyValue(key)`\n * \n * Returns the current value at `key`. If no value has been set, it will return the default value (if it is not a function). If the default value is a function, it will return the output of the function. This execution is cached if the cache flag was set on initialization.\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.getKeyValue('foo'); //-> 'bar'\n * ```\n * \n * @param {String} key\n * The key value to access.\n * \n * @return {*}\n * Returns the value of a given key.\n */\nGlobals.prototype.getKeyValue = function (key) {\n\tvar property = this.properties[key];\n\tif (property) {\n\t\tif (typeof property.value === 'function') {\n\t\t\tif (property.cachedValue) {\n\t\t\t\treturn property.cachedValue;\n\t\t\t}\n\t\t\tif (property.enableCache) {\n\t\t\t\tproperty.cachedValue = property.value();\n\t\t\t\treturn property.cachedValue;\n\t\t\t} else {\n\t\t\t\treturn property.value();\n\t\t\t}\n\t\t}\n\t\treturn property.value;\n\t}\n};\n\nGlobals.prototype.makeExport = function (key) {\n\treturn function (value) {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.getKeyValue(key);\n\t\t}\n\n\t\tif (typeof value === 'undefined' || value === null) {\n\t\t\tthis.deleteKeyValue(key);\n\t\t} else {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\tthis.setKeyValue(key, function () {\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.setKeyValue(key, value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}.bind(this);\n};\n\n/**\n * @function offKeyValue \n * @parent can-globals/methods\n * \n * Remove handler from event queue.\n * \n * @signature `globals.offKeyValue(key, handler)`\n * \n * Removes `handler` from future change events for `key`.\n * \n * \n * ```javascript\n * var handler = (value) => {\n *   value === 'baz' //-> true\n * };\n * globals.define('foo', 'bar');\n * globals.onKeyValue('foo', handler);\n * globals.setKeyValue('foo', 'baz');\n * globals.offKeyValue('foo', handler);\n * ```\n * \n * @param {String} key\n * The key value to observe.\n * \n * @param {Function} handler([value])\n * The observer callback.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.offKeyValue = function (key, handler) {\n\tif (this.properties[key]) {\n\t\tvar handlers = this.eventHandlers[key];\n\t\tif (handlers) {\n\t\t\tvar i = handlers.indexOf(handler);\n\t\t\thandlers.splice(i, 1);\n\t\t}\n\t}\n\treturn this;\n};\n\n/**\n * @function onKeyValue \n * @parent can-globals/methods\n * \n * Add handler to event queue.\n * \n * @signature `globals.onKeyValue(key, handler)`\n * \n * Calls `handler` each time the value of `key` is set or reset.\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.onKeyValue('foo', (value) => {\n *   value === 'baz' //-> true\n * });\n * globals.setKeyValue('foo', 'baz');\n * ```\n * \n * @param {String} key\n * The key value to observe.\n * \n * @param {function(*)} handler([value])\n * The observer callback.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.onKeyValue = function (key, handler) {\n\tif (this.properties[key]) {\n\t\tif (!this.eventHandlers[key]) {\n\t\t\tthis.eventHandlers[key] = [];\n\t\t}\n\t\tthis.eventHandlers[key].push(handler);\n\t}\n\treturn this;\n};\n\n/**\n * @function deleteKeyValue \n * @parent can-globals/methods\n * \n * Reset global environment variable.\n * \n * @signature `globals.deleteKeyValue(key)`\n * \n * Deletes the current value at `key`. Future `get`s will use the default value.\n * \n * ```javascript\n * globals.define('global', window);\n * globals.setKeyValue('global', {});\n * globals.deleteKeyValue('global');\n * globals.getKeyValue('global') === window; //-> true\n * ```\n * \n * @param {String} key\n * The key value to access.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.deleteKeyValue = function (key) {\n\tvar property = this.properties[key];\n\tif (property !== undefined) {\n\t\tproperty.value = property.default;\n\t\tproperty.cachedValue = undefined;\n\t\tdispatch.call(this, key);\n\t}\n\treturn this;\n};\n\n/**\n * @function setKeyValue \n * @parent can-globals/methods\n * \n * Overwrite an existing global environment variable.\n * \n * @signature `globals.setKeyValue(key, value)`\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.setKeyValue('foo', 'baz');\n * globals.getKeyValue('foo'); //-> 'baz'\n * ```\n * \n * Sets the new value at `key`. Will override previously set values, but preserves the default (see `deleteKeyValue`).\n * \n * Setting a key which was not previously defined will call `define` with the key and value.\n * \n * @param {String} key\n * The key value to access.\n * \n * @param {*} value\n * The new value.\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.setKeyValue = function (key, value) {\n\tif (!this.properties[key]) {\n\t\treturn this.define(key, value);\n\t}\n\tvar property = this.properties[key];\n\tproperty.value = value;\n\tproperty.cachedValue = undefined;\n\tdispatch.call(this, key);\n\treturn this;\n};\n\n/**\n * @function reset \n * @parent can-globals/methods\n * \n * Reset all keys to their default value and clear their caches.\n * \n * @signature `globals.setKeyValue(key, value)`\n * \n * ```javascript\n * globals.define('foo', 'bar');\n * globals.setKeyValue('foo', 'baz');\n * globals.getKeyValue('foo'); //-> 'baz'\n * globals.reset();\n * globals.getKeyValue('foo'); //-> 'bar'\n * ```\n * \n * @return {can-globals}\n * Returns the instance of `can-globals` for chaining.\n */\nGlobals.prototype.reset = function () {\n\tfor (var key in this.properties) {\n\t\tif (this.properties.hasOwnProperty(key)) {\n\t\t\tthis.properties[key].value = this.properties[key].default;\n\t\t\tthis.properties[key].cachedValue = undefined;\n\t\t\tdispatch.call(this, key);\n\t\t}\n\t}\n\treturn this;\n};\n\ncanReflect.assignSymbols(Globals.prototype, {\n\t'can.getKeyValue': Globals.prototype.getKeyValue,\n\t'can.setKeyValue': Globals.prototype.setKeyValue,\n\t'can.deleteKeyValue': Globals.prototype.deleteKeyValue,\n\t'can.onKeyValue': Globals.prototype.onKeyValue,\n\t'can.offKeyValue': Globals.prototype.offKeyValue\n});\n\nmodule.exports = Globals;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/can-globals-proto.js?");

/***/ }),

/***/ "../../node_modules/can-globals/can-globals.js":
/*!********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/can-globals.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../node_modules/can-globals/can-globals-instance.js\");\n\n__webpack_require__(/*! ./global/global */ \"../../node_modules/can-globals/global/global.js\");\n__webpack_require__(/*! ./document/document */ \"../../node_modules/can-globals/document/document.js\");\n__webpack_require__(/*! ./location/location */ \"../../node_modules/can-globals/location/location.js\");\n__webpack_require__(/*! ./mutation-observer/mutation-observer */ \"../../node_modules/can-globals/mutation-observer/mutation-observer.js\");\n__webpack_require__(/*! ./is-browser-window/is-browser-window */ \"../../node_modules/can-globals/is-browser-window/is-browser-window.js\");\n__webpack_require__(/*! ./is-node/is-node */ \"../../node_modules/can-globals/is-node/is-node.js\");\n__webpack_require__(/*! ./custom-elements/custom-elements */ \"../../node_modules/can-globals/custom-elements/custom-elements.js\");\n\nmodule.exports = globals;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/can-globals.js?");

/***/ }),

/***/ "../../node_modules/can-globals/custom-elements/custom-elements.js":
/*!****************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/custom-elements/custom-elements.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"../../node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/custom-elements/custom-elements custom-elements\n * @parent can-globals/modules\n *\n * Get the global [`customElements`](https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements) object for the current context.\n *\n * @signature `CUSTOMELEMENTS([newCustomElements])`\n *\n * Optionally sets, and returns, the [`customElements`](https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements) object for the context.\n *\n * ```js\n * var customElementsShim = require('some-custom-elements-shim');\n * CUSTOMELEMENTS(customElementsShim);\n * CUSTOMELEMENTS() //-> customElementsShim\n * ```\n *\n * @param {Object} customElements An optional CustomElementRegistry-like object to set as the context's customElements\n *\n * @return {Object} The customElements object for this JavaScript environment.\n */\n\nglobals.define('customElements', function(){\n\tvar GLOBAL = globals.getKeyValue('global');\n\treturn GLOBAL.customElements;\n});\n\nmodule.exports = globals.makeExport('customElements');\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/custom-elements/custom-elements.js?");

/***/ }),

/***/ "../../node_modules/can-globals/document/document.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/document/document.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"../../node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/document/document document\n * @parent can-globals/modules\n * \n * Get the global [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the current context.\n * \n * @signature `DOCUMENT([newDocument])`\n * \n * Optionally sets, and returns, the [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the context.\n * \n * ```js\n * var documentShim = { getElementById() {...} };\n * var DOCUMENT = require('can-globals/document/document');\n * DOCUMENT(documentShim); //-> document\n * DOCUMENT().getElementById('foo');\n * ```\n *\n * @param {Object} [newDocument] An optional document-like object to set as the context's document \n * \n * @return {Object} The window object for this JavaScript environment.\n */\nglobals.define('document', function(){\n\treturn globals.getKeyValue('global').document;\n});\n\nmodule.exports = globals.makeExport('document');\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/document/document.js?");

/***/ }),

/***/ "../../node_modules/can-globals/global/global.js":
/*!**********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/global/global.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {\n\n/* global self */\n/* global WorkerGlobalScope */\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/global/global global\n * @parent can-globals/modules\n * \n * Get the global object for the current context.\n * \n * @signature `GLOBAL([newGlobal])`\n *\n * Optionally sets, and returns the global that this environment provides. It will be one of:\n * \n * ```js\n * var GLOBAL = require('can-globals/global/global');\n * var g = GLOBAL();\n * // In a browser\n * console.log(g === window); // -> true\n * ```\n *\n * - **Browser**: [`window`](https://developer.mozilla.org/en-US/docs/Web/API/window)\n * - **Web Worker**: [`self`](https://developer.mozilla.org/en-US/docs/Web/API/Window/self)\n * - **Node.js**: [`global`](https://nodejs.org/api/globals.html#globals_global)\n * \n * @param {Object} [newGlobal] An optional global-like object to set as the context's global \n *\n * @return {Object} The global object for this JavaScript environment.\n */\nglobals.define('global', function(){\n\t// Web Worker\n\treturn (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) ? self :\n\n\t\t// Node.js\n\t\ttypeof process === 'object' &&\n\t\t{}.toString.call(process) === '[object process]' ? global :\n\n\t\t// Browser window\n\t\twindow;\n});\n\nmodule.exports = globals.makeExport('global');\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"../../node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/global/global.js?");

/***/ }),

/***/ "../../node_modules/can-globals/is-browser-window/is-browser-window.js":
/*!********************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/is-browser-window/is-browser-window.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../node_modules/can-globals/can-globals-instance.js\");\n\n// This module depends on isNode being defined\n__webpack_require__(/*! ../is-node/is-node */ \"../../node_modules/can-globals/is-node/is-node.js\");\n\n/**\n * @module {function} can-globals/is-browser-window/is-browser-window is-browser-window\n * @parent can-globals/modules\n * @signature `isBrowserWindow()`\n *\n * Returns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).\n *\n * ```js\n * var isBrowserWindow = require(\"can-globals/is-browser-window/is-browser-window\");\n * var GLOBAL = require(\"can-globals/global/global\");\n *\n * if(isBrowserWindow()) {\n *   console.log(GLOBAL() === window); // -> true\n * }\n * ```\n *\n * @return {Boolean} True if the environment is a Browser window.\n */\n\nglobals.define('isBrowserWindow', function(){\n\tvar isNode = globals.getKeyValue('isNode');\n\treturn typeof window !== \"undefined\" &&\n\t\ttypeof document !== \"undefined\" &&\n\t\tisNode === false;\n});\n\nmodule.exports = globals.makeExport('isBrowserWindow');\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/is-browser-window/is-browser-window.js?");

/***/ }),

/***/ "../../node_modules/can-globals/is-node/is-node.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/is-node/is-node.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/is-node/is-node is-node\n * @parent can-globals/modules\n * @description Determines if your code is running in [Node.js](https://nodejs.org).\n * @signature `isNode()`\n *\n * ```js\n * var isNode = require(\"can-globals/is-node/is-node\");\n * var GLOBAL = require(\"can-globals/global/global\");\n *\n * if(isNode()) {\n *   console.log(GLOBAL() === global); // -> true\n * }\n * ```\n *\n * @return {Boolean} True if running in Node.js\n */\n\nglobals.define('isNode', function(){\n\treturn typeof process === \"object\" &&\n\t\t{}.toString.call(process) === \"[object process]\";\n});\n\nmodule.exports = globals.makeExport('isNode');\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/is-node/is-node.js?");

/***/ }),

/***/ "../../node_modules/can-globals/location/location.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/location/location.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"../../node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/location/location location\n * @parent can-globals/modules\n * \n * Get the global [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the current context.\n * \n * @signature `LOCATION([newLocation])`\n * \n * Optionally sets, and returns, the [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the context.\n * \n * ```js\n * var locationShim = { path: '/' };\n * var LOCATION = require('can-globals/location/location');\n * LOCATION(locationShim);\n * LOCATION().path; // -> '/'\n * ```\n *\n * @param {Object} location An optional location-like object to set as the context's location\n *\n * @return {Object} The location object for this JavaScript environment.\n */\nglobals.define('location', function(){\n\treturn globals.getKeyValue('global').location;\n});\n\nmodule.exports = globals.makeExport('location');\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/location/location.js?");

/***/ }),

/***/ "../../node_modules/can-globals/mutation-observer/mutation-observer.js":
/*!********************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/mutation-observer/mutation-observer.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! can-globals/global/global */ \"../../node_modules/can-globals/global/global.js\");\nvar globals = __webpack_require__(/*! can-globals/can-globals-instance */ \"../../node_modules/can-globals/can-globals-instance.js\");\n\n/**\n * @module {function} can-globals/mutation-observer/mutation-observer mutation-observer\n * @parent can-globals/modules\n * \n * Get the global [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the current context.\n * \n * @signature `MUTATIONOBSERVER([newMutationObserver])`\n * \n * Optionally sets, and returns, the [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the context.\n * \n * ```js\n * var mutationObserverShim = require('can-globals/mutation-observer/mutation-observer');\n * MUTATIONOBSERVER(mutationObserverShim);\n * MUTATIONOBSERVER() //-> MutationObserver\n * ```\n *\n * @param {Object} MutationObserver An optional MutationObserver-like object to set as the context's MutationObserver\n *\n * @return {Object} The MutationObserver object for this JavaScript environment.\n */\n\nglobals.define('MutationObserver', function(){\n\tvar GLOBAL = globals.getKeyValue('global');\n\treturn GLOBAL.MutationObserver || GLOBAL.WebKitMutationObserver || GLOBAL.MozMutationObserver;\n});\n\nmodule.exports = globals.makeExport('MutationObserver');\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-globals/mutation-observer/mutation-observer.js?");

/***/ }),

/***/ "../../node_modules/can-import-module/can-import-module.js":
/*!********************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-import-module/can-import-module.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar getGlobal = __webpack_require__(/*! can-globals/global/global */ \"../../node_modules/can-globals/global/global.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\n\n/**\n * @module {function} can-util/js/import/import import\n * @parent can-util/js\n * @signature `importModule(moduleName, parentName)`\n *\n * ```js\n * var importModule = require(\"can-util/js/import/import\");\n *\n * importModule(\"foo.stache\").then(function(){\n *   // module was imported\n * });\n * ```\n *\n * @param {String} moduleName The module to be imported.\n * @param {String} [parentName] A parent module that will be used as a reference for resolving relative module imports.\n * @return {Promise} A Promise that will resolve when the module has been imported.\n */\n\nmodule.exports = namespace.import = function(moduleName, parentName) {\n\treturn new Promise(function(resolve, reject) {\n\t\ttry {\n\t\t\tvar global = getGlobal();\n\t\t\tif(typeof global.System === \"object\" && isFunction(global.System[\"import\"])) {\n\t\t\t\tglobal.System[\"import\"](moduleName, {\n\t\t\t\t\tname: parentName\n\t\t\t\t}).then(resolve, reject);\n\t\t\t} else if(global.define && global.define.amd){\n\t\t\t\tglobal.require([moduleName], function(value){\n\t\t\t\t\tresolve(value);\n\t\t\t\t});\n\t\t\t} else if(global.require){\n\t\t\t\tresolve(global.require(moduleName));\n\t\t\t} else {\n\t\t\t\t// steal optimized build\n\t\t\t\tif (typeof stealRequire !== \"undefined\") {\n\t\t\t\t\tsteal.import(moduleName, { name: parentName }).then(resolve, reject);\n\t\t\t\t} else {\n\t\t\t\t\t// ideally this will use can.getObject\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(err) {\n\t\t\treject(err);\n\t\t}\n\t});\n};\n\nfunction isFunction(fn) {\n\treturn typeof fn === \"function\";\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-import-module/can-import-module.js?");

/***/ }),

/***/ "../../node_modules/can-join-uris/can-join-uris.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-join-uris/can-join-uris.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar parseURI = __webpack_require__(/*! can-parse-uri */ \"../../node_modules/can-parse-uri/can-parse-uri.js\");\n\nmodule.exports = namespace.joinURIs = function(base, href) {\n\tfunction removeDotSegments(input) {\n\t\tvar output = [];\n\t\tinput.replace(/^(\\.\\.?(\\/|$))+/, '')\n\t\t\t.replace(/\\/(\\.(\\/|$))+/g, '/')\n\t\t\t.replace(/\\/\\.\\.$/, '/../')\n\t\t\t.replace(/\\/?[^\\/]*/g, function (p) {\n\t\t\t\tif (p === '/..') {\n\t\t\t\t\toutput.pop();\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(p);\n\t\t\t\t}\n\t\t\t});\n\t\treturn output.join('').replace(/^\\//, input.charAt(0) === '/' ? '/' : '');\n\t}\n\n\thref = parseURI(href || '');\n\tbase = parseURI(base || '');\n\n\treturn !href || !base ? null : (href.protocol || base.protocol) +\n\t\t(href.protocol || href.authority ? href.authority : base.authority) +\n\t\tremoveDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +\n\t\t\t(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +\n\t\t\thref.hash;\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-join-uris/can-join-uris.js?");

/***/ }),

/***/ "../../node_modules/can-key-tree/dist/cjs/can-key-tree.js":
/*!*******************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-key-tree/dist/cjs/can-key-tree.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*can-key-tree@1.1.0#can-key-tree*/\n\nvar reflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nfunction isBuiltInPrototype(obj) {\n    if (obj === Object.prototype) {\n        return true;\n    }\n    var protoString = Object.prototype.toString.call(obj);\n    var isNotObjObj = protoString !== '[object Object]';\n    var isObjSomething = protoString.indexOf('[object ') !== -1;\n    return isNotObjObj && isObjSomething;\n}\nfunction getDeepSize(root, level) {\n    if (level === 0) {\n        return reflect.size(root);\n    } else if (reflect.size(root) === 0) {\n        return 0;\n    } else {\n        var count = 0;\n        reflect.each(root, function (value) {\n            count += getDeepSize(value, level - 1);\n        });\n        return count;\n    }\n}\nfunction getDeep(node, items, depth, maxDepth) {\n    if (!node) {\n        return;\n    }\n    if (maxDepth === depth) {\n        if (reflect.isMoreListLikeThanMapLike(node)) {\n            reflect.addValues(items, reflect.toArray(node));\n        } else {\n            throw new Error('can-key-tree: Map-type leaf containers are not supported yet.');\n        }\n    } else {\n        reflect.each(node, function (value) {\n            getDeep(value, items, depth + 1, maxDepth);\n        });\n    }\n}\nfunction clearDeep(node, keys, maxDepth, deleteHandler) {\n    if (maxDepth === keys.length) {\n        if (reflect.isMoreListLikeThanMapLike(node)) {\n            var valuesToRemove = reflect.toArray(node);\n            if (deleteHandler) {\n                valuesToRemove.forEach(function (value) {\n                    deleteHandler.apply(null, keys.concat(value));\n                });\n            }\n            reflect.removeValues(node, valuesToRemove);\n        } else {\n            throw new Error('can-key-tree: Map-type leaf containers are not supported yet.');\n        }\n    } else {\n        reflect.each(node, function (value, key) {\n            clearDeep(value, keys.concat(key), maxDepth, deleteHandler);\n            reflect.deleteKeyValue(node, key);\n        });\n    }\n}\nvar KeyTree = function (treeStructure, callbacks) {\n    var FirstConstructor = treeStructure[0];\n    if (reflect.isConstructorLike(FirstConstructor)) {\n        this.root = new FirstConstructor();\n    } else {\n        this.root = FirstConstructor;\n    }\n    this.callbacks = callbacks || {};\n    this.treeStructure = treeStructure;\n    this.empty = true;\n};\nreflect.assign(KeyTree.prototype, {\n    add: function (keys) {\n        if (keys.length > this.treeStructure.length) {\n            throw new Error('can-key-tree: Can not add path deeper than tree.');\n        }\n        var place = this.root;\n        var rootWasEmpty = this.empty === true;\n        for (var i = 0; i < keys.length - 1; i++) {\n            var key = keys[i];\n            var childNode = reflect.getKeyValue(place, key);\n            if (!childNode) {\n                var Constructor = this.treeStructure[i + 1];\n                if (isBuiltInPrototype(Constructor.prototype)) {\n                    childNode = new Constructor();\n                } else {\n                    childNode = new Constructor(key);\n                }\n                reflect.setKeyValue(place, key, childNode);\n            }\n            place = childNode;\n        }\n        if (reflect.isMoreListLikeThanMapLike(place)) {\n            reflect.addValues(place, [keys[keys.length - 1]]);\n        } else {\n            throw new Error('can-key-tree: Map types are not supported yet.');\n        }\n        if (rootWasEmpty) {\n            this.empty = false;\n            if (this.callbacks.onFirst) {\n                this.callbacks.onFirst.call(this);\n            }\n        }\n        return this;\n    },\n    getNode: function (keys) {\n        var node = this.root;\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            node = reflect.getKeyValue(node, key);\n            if (!node) {\n                return;\n            }\n        }\n        return node;\n    },\n    get: function (keys) {\n        var node = this.getNode(keys);\n        if (this.treeStructure.length === keys.length) {\n            return node;\n        } else {\n            var Type = this.treeStructure[this.treeStructure.length - 1];\n            var items = new Type();\n            getDeep(node, items, keys.length, this.treeStructure.length - 1);\n            return items;\n        }\n    },\n    delete: function (keys, deleteHandler) {\n        var parentNode = this.root, path = [this.root], lastKey = keys[keys.length - 1];\n        for (var i = 0; i < keys.length - 1; i++) {\n            var key = keys[i];\n            var childNode = reflect.getKeyValue(parentNode, key);\n            if (childNode === undefined) {\n                return false;\n            } else {\n                path.push(childNode);\n            }\n            parentNode = childNode;\n        }\n        if (!keys.length) {\n            clearDeep(parentNode, [], this.treeStructure.length - 1, deleteHandler);\n        } else if (keys.length === this.treeStructure.length) {\n            if (reflect.isMoreListLikeThanMapLike(parentNode)) {\n                if (deleteHandler) {\n                    deleteHandler.apply(null, keys.concat(lastKey));\n                }\n                reflect.removeValues(parentNode, [lastKey]);\n            } else {\n                throw new Error('can-key-tree: Map types are not supported yet.');\n            }\n        } else {\n            var nodeToRemove = reflect.getKeyValue(parentNode, lastKey);\n            if (nodeToRemove !== undefined) {\n                clearDeep(nodeToRemove, keys, this.treeStructure.length - 1, deleteHandler);\n                reflect.deleteKeyValue(parentNode, lastKey);\n            } else {\n                return false;\n            }\n        }\n        for (i = path.length - 2; i >= 0; i--) {\n            if (reflect.size(parentNode) === 0) {\n                parentNode = path[i];\n                reflect.deleteKeyValue(parentNode, keys[i]);\n            } else {\n                break;\n            }\n        }\n        if (reflect.size(this.root) === 0) {\n            this.empty = true;\n            if (this.callbacks.onEmpty) {\n                this.callbacks.onEmpty.call(this);\n            }\n        }\n        return true;\n    },\n    size: function () {\n        return getDeepSize(this.root, this.treeStructure.length - 1);\n    },\n    isEmpty: function () {\n        return this.empty;\n    }\n});\nmodule.exports = KeyTree;\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-key-tree/dist/cjs/can-key-tree.js?");

/***/ }),

/***/ "../../node_modules/can-key/get/get.js":
/*!************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-key/get/get.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"../../node_modules/can-key/utils.js\");\n\n/**\n * @module {function} can-key/get/get\n * @parent can-key\n * @description Get properties on deep/nested objects of different types: Object, Map, [can-reflect] types, etc.\n *\n * @signature `get(obj, path)`\n * @param  {Object} obj the object to use as the root for property-based navigation\n * @param  {String} path a String of dot-separated keys, representing a path of properties\n * @return {*}       the value at the property path\n *\n * @body\n *\n * A *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n * 'bar' of the object at the property 'foo' of the root.\"  An empty path returns the object passed.\n *\n * ```js\n * var get = require(\"can-key\");\n * console.log(get({a: {b: {c: \"foo\"}}}, \"a.b.c\")); // -> \"foo\"\n * console.log(get({a: {}}, \"a.b.c\")); // -> undefined\n * console.log(get([{a: {}}, {a: {b: \"bar\"}}], \"a.b\")); // -> \"bar\"\n *\n * var map = new Map();\n * map.set(\"first\", {second: \"third\"});\n *\n * get(map, \"first.second\") //-> \"third\"\n * ```\n */\nfunction get(obj, name) {\n    // The parts of the name we are looking up\n    // `['App','Models','Recipe']`\n    var parts = utils.parts(name);\n\n    var length = parts.length,\n        current, i, container;\n\n    if (!length) {\n        return obj;\n    }\n\n    current = obj;\n\n    // Walk current to the 2nd to last object or until there\n    // is not a container.\n    for (i = 0; i < length && utils.isContainer(current) && current !== null; i++) {\n        container = current;\n        current = canReflect.getKeyValue( container, parts[i] );\n    }\n\n    return current;\n}\n\nmodule.exports = get;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-key/get/get.js?");

/***/ }),

/***/ "../../node_modules/can-key/utils.js":
/*!**********************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-key/utils.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = {\n    isContainer: function (current) {\n        var type = typeof current;\n        return current && (type === \"object\" || type === \"function\");\n    },\n    strReplacer: /\\{([^\\}]+)\\}/g,\n\n    parts: function(name) {\n        if(Array.isArray(name)) {\n            return name;\n        } else {\n            return typeof name !== 'undefined' ? (name + '').replace(/\\[/g,'.')\n            \t\t.replace(/]/g,'').split('.') : [];\n        }\n    }\n};\n\nmodule.exports= utils;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-key/utils.js?");

/***/ }),

/***/ "../../node_modules/can-log/can-log.js":
/*!************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-log/can-log.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.warnTimeout = 5000;\nexports.logLevel = 0;\n\n/**\n * @module {{}} can-log log\n * @parent can-js-utilities\n * @collection can-infrastructure\n * @hide\n *\n * Utilities for logging to the console.\n */\n\n/**\n * @function can-log.warn warn\n * @parent can-log\n * @description\n *\n * Adds a warning message to the console.\n *\n * ```\n * var canLog = require(\"can-log\");\n *\n * canLog.warn(\"something evil\");\n * ```\n *\n * @signature `canLog.warn(msg)`\n * @param {String} msg the message to be logged.\n */\nexports.warn = function() {\n\tvar ll = this.logLevel;\n\tif (ll < 2) {\n\t\tif (typeof console !== \"undefined\" && console.warn) {\n\t\t\tthis._logger(\"warn\", Array.prototype.slice.call(arguments));\n\t\t} else if (typeof console !== \"undefined\" && console.log) {\n\t\t\tthis._logger(\"log\", Array.prototype.slice.call(arguments));\n\t\t}\n\t}\n};\n\n/**\n * @function can-log.log log\n * @parent can-log\n * @description\n * Adds a message to the console.\n * @hide\n *\n * ```\n * var canLog = require(\"can-log\");\n *\n * canLog.log(\"hi\");\n * ```\n *\n * @signature `canLog.log(msg)`\n * @param {String} msg the message\n */\nexports.log = function() {\n\tvar ll = this.logLevel;\n\tif (ll < 1) {\n\t\tif (typeof console !== \"undefined\" && console.log) {\n\t\t\tthis._logger(\"log\", Array.prototype.slice.call(arguments));\n\t\t}\n\t}\n};\n\n/**\n * @function can-log.error error\n * @parent can-log\n * @description\n * Adds an error message to the console.\n * @hide\n *\n * ```\n * var canLog = require(\"can-log\");\n *\n * canLog.error(new Error(\"Oh no!\"));\n * ```\n *\n * @signature `canLog.error(err)`\n * @param {String|Error} err The error to be logged.\n */\nexports.error = function() {\n\tvar ll = this.logLevel;\n\tif (ll < 1) {\n\t\tif (typeof console !== \"undefined\" && console.error) {\n\t\t\tthis._logger(\"error\", Array.prototype.slice.call(arguments));\n\t\t}\n\t}\n};\n\nexports._logger = function (type, arr) {\n\ttry {\n\t\tconsole[type].apply(console, arr);\n\t} catch(e) {\n\t\tconsole[type](arr);\n\t}\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-log/can-log.js?");

/***/ }),

/***/ "../../node_modules/can-log/dev/dev.js":
/*!************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-log/dev/dev.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar canLog = __webpack_require__(/*! ../can-log */ \"../../node_modules/can-log/can-log.js\");\n\n/**\n * @module {{}} can-log/dev dev\n * @parent can-log\n * @hide\n * \n * Utilities for logging development-mode messages. Use this module for\n * anything that should be shown to the user during development but isn't\n * needed in production. In production these functions become noops.\n */\nmodule.exports = {\n\twarnTimeout: 5000,\n\tlogLevel: 0,\n\t/**\n\t * @function can-log/dev.stringify stringify\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * JSON stringifies a value, but unlike JSON, will output properties with\n\t * a value of `undefined` (e.g. `{ \"prop\": undefined }`, not `{}`).\n\t *\n\t * ```\n\t * var dev = require('can-log/dev');\n\t * var query = { where: undefined };\n\t * \n\t * dev.warn('No records found: ' + dev.stringify(query));\n\t * ```\n\t *\n\t * @signature `dev.stringify(value)`\n\t * @param {Any} value A value to stringify.\n\t * @return {String} A stringified representation of the passed in value.\n\t */\n\tstringify: function(value) {\n\t\tvar flagUndefined = function flagUndefined(key, value) {\n\t\t\treturn value === undefined ?\n\t\t\t\t \"/* void(undefined) */\" : value;\n\t\t};\n\t\t\n\t\treturn JSON.stringify(value, flagUndefined, \"  \").replace(\n\t\t\t/\"\\/\\* void\\(undefined\\) \\*\\/\"/g, \"undefined\");\n\t},\n\t/**\n\t * @function can-log/dev.warn warn\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * Adds a warning message to the console.\n\t *\n\t * ```\n\t * var dev = require('can-log/dev');\n\t * \n\t * dev.warn(\"something evil\");\n\t * ```\n\t *\n\t * @signature `dev.warn(msg)`\n\t * @param {String} msg The warning message.\n\t */\n\twarn: function() {\n\t\t//!steal-remove-start\n\t\tcanLog.warn.apply(this, arguments);\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-log/dev.log log\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * Adds a message to the console.\n\t *\n\t * ```\n\t * var dev = require('can-log/dev');\n\t * \n\t * dev.log(\"hi\");\n\t * ```\n\t *\n\t * @signature `dev.log(msg)`\n\t * @param {String} msg The message.\n\t */\n\tlog: function() {\n\t\t//!steal-remove-start\n\t\tcanLog.log.apply(this, arguments);\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-log/dev.error error\n\t * @parent can-log\n\t * @description\n\t * @hide\n\t *\n\t * Adds an error message to the console.\n\t *\n\t * ```\n\t * var dev = require(\"can-log/dev\");\n\t * \n\t * dev.error(new Error(\"Oh no!\"));\n\t * ```\n\t *\n\t * @signature `dev.error(err)`\n\t * @param {String|Error} err The error to be logged.\n\t */\n\terror: function() {\n\t\t//!steal-remove-start\n\t\tcanLog.error.apply(this, arguments);\n\t\t//!steal-remove-end\n\t},\n\t_logger: canLog._logger\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-log/dev/dev.js?");

/***/ }),

/***/ "../../node_modules/can-log/dist/cjs/can-log.js":
/*!*********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-log/dist/cjs/can-log.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*can-log@0.1.2#can-log*/\n\nexports.warnTimeout = 5000;\nexports.logLevel = 0;\nexports.warn = function () {\n    var ll = this.logLevel;\n    if (ll < 2) {\n        if (typeof console !== 'undefined' && console.warn) {\n            this._logger('warn', Array.prototype.slice.call(arguments));\n        } else if (typeof console !== 'undefined' && console.log) {\n            this._logger('log', Array.prototype.slice.call(arguments));\n        }\n    }\n};\nexports.log = function () {\n    var ll = this.logLevel;\n    if (ll < 1) {\n        if (typeof console !== 'undefined' && console.log) {\n            this._logger('log', Array.prototype.slice.call(arguments));\n        }\n    }\n};\nexports.error = function () {\n    var ll = this.logLevel;\n    if (ll < 1) {\n        if (typeof console !== 'undefined' && console.error) {\n            this._logger('error', Array.prototype.slice.call(arguments));\n        }\n    }\n};\nexports._logger = function (type, arr) {\n    try {\n        console[type].apply(console, arr);\n    } catch (e) {\n        console[type](arr);\n    }\n};\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-log/dist/cjs/can-log.js?");

/***/ }),

/***/ "../../node_modules/can-namespace/can-namespace.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-namespace/can-namespace.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-namespace/can-namespace.js?");

/***/ }),

/***/ "../../node_modules/can-observation-recorder/can-observation-recorder.js":
/*!**********************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-observation-recorder/can-observation-recorder.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n\n// Contains stack of observation records created by pushing with `.start`\n// and popping with `.stop()`.\n// The top of the stack is the \"target\" observation record - the record that calls\n// to `ObservationRecorder.add` get added to.\nvar stack = [];\n\nvar addParentSymbol = canSymbol.for(\"can.addParent\");\n\nvar ObservationRecorder = {\n    stack: stack,\n    start: function(){\n    \tvar deps = {\n            keyDependencies: new Map(),\n            valueDependencies: new Set(),\n\t\t\t\t\t\tchildDependencies: new Set(),\n\n            // `traps` and `ignore` are here only for performance\n            // reasons. They work with `ObservationRecorder.ignore` and `ObservationRecorder.trap`.\n            traps: null,\n            ignore: 0\n    \t};\n\n        stack.push(deps);\n\n        return deps;\n    },\n    stop: function() {\n    \treturn stack.pop();\n    },\n\n    add: function(obj, event) {\n        var top = stack[stack.length-1];\n    \tif (top && top.ignore === 0) {\n\n    \t\tif(top.traps) {\n    \t\t\ttop.traps.push([obj, event]);\n    \t\t}\n    \t\telse {\n                // Use `=== undefined` instead of `arguments.length` for performance.\n                if(event === undefined) {\n                    top.valueDependencies.add(obj);\n                } else {\n                    var eventSet = top.keyDependencies.get(obj);\n        \t\t\tif(!eventSet) {\n        \t\t\t\teventSet = new Set();\n        \t\t\t\ttop.keyDependencies.set(obj, eventSet);\n        \t\t\t}\n        \t\t\teventSet.add(event);\n                }\n    \t\t}\n    \t}\n    },\n\n    addMany: function(observes){\n        var top = stack[stack.length-1];\n    \tif (top) {\n    \t\tif(top.traps) {\n    \t\t\ttop.traps.push.apply(top.traps, observes);\n    \t\t} else {\n    \t\t\tfor(var i =0, len = observes.length; i < len; i++) {\n                    this.add(observes[i][0],observes[i][1]);\n    \t\t\t}\n    \t\t}\n    \t}\n    },\n\t\tcreated: function(obs){\n\t\t\tvar top = stack[stack.length - 1];\n\t\t\tif(top) {\n\t\t\t\ttop.childDependencies.add(obs);\n\t\t\t\tif(obs[addParentSymbol]) {\n\t\t\t\t\tobs[addParentSymbol](top);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n    ignore: function(fn){\n    \treturn function(){\n    \t\tif (stack.length) {\n    \t\t\tvar top = stack[stack.length-1];\n    \t\t\ttop.ignore++;\n    \t\t\tvar res = fn.apply(this, arguments);\n    \t\t\ttop.ignore--;\n    \t\t\treturn res;\n    \t\t} else {\n    \t\t\treturn fn.apply(this, arguments);\n    \t\t}\n    \t};\n    },\n    isRecording: function(){\n    \tvar len = stack.length;\n    \tvar last = len && stack[len-1];\n    \treturn last && (last.ignore === 0) && last;\n    },\n    // `can-observation` uses this to do diffs more easily.\n    makeDependenciesRecord: function(){\n        return {\n            traps: null,\n            keyDependencies: new Map(),\n            valueDependencies: new Set(),\n\t\t\t\t\t\t//childDependencies: new Set(),\n            ignore: 0\n        };\n    },\n    // The following are legacy methods we should do away with.\n    makeDependenciesRecorder: function(){\n        return ObservationRecorder.makeDependenciesRecord();\n    },\n    // Traps should be replace by calling `.start()` and `.stop()`.\n    // To do this, we'd need a method that accepts a dependency record.\n    trap: function(){\n    \tif (stack.length) {\n    \t\tvar top = stack[stack.length-1];\n    \t\tvar oldTraps = top.traps;\n    \t\tvar traps = top.traps = [];\n    \t\treturn function(){\n    \t\t\ttop.traps = oldTraps;\n    \t\t\treturn traps;\n    \t\t};\n    \t} else {\n    \t\treturn function(){return [];};\n    \t}\n    },\n    trapsCount: function(){\n    \tif (stack.length) {\n    \t\tvar top = stack[stack.length-1];\n    \t\treturn top.traps.length;\n    \t} else {\n    \t\treturn 0;\n    \t}\n    }\n};\n\nif (namespace.ObservationRecorder) {\n\tthrow new Error(\"You can't have two versions of can-observation-recorder, check your dependencies\");\n} else {\n\tmodule.exports = namespace.ObservationRecorder = ObservationRecorder;\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-observation-recorder/can-observation-recorder.js?");

/***/ }),

/***/ "../../node_modules/can-observation/can-observation.js":
/*!****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-observation/can-observation.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* global require */\n// # can-observation\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"../../node_modules/can-event-queue/value/value.js\");\n\nvar recorderHelpers = __webpack_require__(/*! ./recorder-dependency-helpers */ \"../../node_modules/can-observation/recorder-dependency-helpers.js\");\nvar temporarilyBind = __webpack_require__(/*! ./temporarily-bind */ \"../../node_modules/can-observation/temporarily-bind.js\");\n\nvar dispatchSymbol = canSymbol.for(\"can.dispatch\");\nvar getChangesSymbol = canSymbol.for(\"can.getChangesDependencyRecord\");\nvar getValueDependenciesSymbol = canSymbol.for(\"can.getValueDependencies\");\n\n// ## Observation constructor\nfunction Observation(func, context, options){\n\tthis.func = func;\n\tthis.context = context;\n\tthis.options = options || {priority: 0, isObservable: true};\n\t// A flag if we are bound or not\n\tthis.bound = false;\n\n\t// Set _value to undefined so can-view-scope & can-compute can check for it\n\tthis._value = undefined;\n\n\t// These properties will manage what our new and old dependencies are.\n\tthis.newDependencies = ObservationRecorder.makeDependenciesRecord();\n\tthis.oldDependencies = null;\n\n\t// Make functions we need to pass around and maintain `this`.\n\tvar self = this;\n\tthis.onDependencyChange = function(newVal){\n\t\tself.dependencyChange(this, newVal);\n\t};\n\tthis.update = this.update.bind(this);\n\n\n\t// Add debugging names.\n\t//!steal-remove-start\n\tif (true) {\n\t\tthis.onDependencyChange[getChangesSymbol] = function getChanges() {\n\t\t\treturn {\n\t\t\t\tvalueDependencies: new Set([self])\n\t\t\t};\n\t\t};\n\t\tObject.defineProperty(this.onDependencyChange, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".onDependencyChange\",\n\t\t});\n\t\tObject.defineProperty(this.update, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".update\",\n\t\t});\n\t}\n\t//!steal-remove-end\n}\n\n// ## Observation prototype methods\n\n// Mixin value event bindings. This is where the following are added:\n// - `.handlers` which call `onBound` and `onUnbound`\n// - `.on` / `.off`\n// - `can.onValue` `can.offValue`\n// - `can.getWhatIChange`\nvalueEventBindings(Observation.prototype);\n\ncanReflect.assign(Observation.prototype, {\n\t// Starts observing changes and adds event listeners.\n\tonBound: function(){\n\t\tthis.bound = true;\n\n\t\t// Store the old dependencies\n\t\tthis.oldDependencies = this.newDependencies;\n\t\t// Start recording dependencies.\n\t\tObservationRecorder.start();\n\t\t// Call the observation's function and update the new value.\n\t\tthis._value = this.func.call(this.context);\n\t\t// Get the new dependencies.\n\t\tthis.newDependencies = ObservationRecorder.stop();\n\n\t\t// Diff and update the bindings. On change, everything will call\n\t\t// `this.onDependencyChange`, which calls `this.dependencyChange`.\n\t\trecorderHelpers.updateObservations(this);\n\t},\n\t// This is called when any of the dependencies change.\n\t// It queues up an update in the `deriveQueue` to be run after all source\n\t// observables have had time to notify all observables that \"derive\" their value.\n\tdependencyChange: function(context, args){\n\t\tif(this.bound === true) {\n\t\t\tvar queuesArgs = [];\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.update,\n\t\t\t\tthis,\n\t\t\t\t[],\n\t\t\t\t{\n\t\t\t\t\tpriority: this.options.priority\n\t\t\t\t}\n\t\t\t];\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tqueuesArgs = [\n\t\t\t\t\tthis.update,\n\t\t\t\t\tthis,\n\t\t\t\t\t[],\n\t\t\t\t\t{\n\t\t\t\t\t\tpriority: this.options.priority\n\t\t\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t\t\t, log: [ canReflect.getName(this.update) ]\n\t\t\t\t\t\t/* jshint laxcomma: false */\n\t\t\t\t\t}\n\t\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t\t, [canReflect.getName(context), \"changed\"]\n\t\t\t\t\t/* jshint laxcomma: false */\n\t\t\t\t];\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t// Update this observation after all `notify` tasks have been run.\n\t\t\tqueues.deriveQueue.enqueue.apply(queues.deriveQueue, queuesArgs);\n\t\t}\n\t},\n\t// Called to update its value as part of the `derive` queue.\n\tupdate: function() {\n\t\tif (this.bound === true) {\n\t\t\t// Keep the old value.\n\t\t\tvar oldValue = this._value;\n\t\t\tthis.oldValue = null;\n\t\t\t// Re-run `this.func` and update dependency bindings.\n\t\t\tthis.onBound();\n\t\t\t// If our value changed, call the `dispatch` method provided by `can-event-queue/value/value`.\n\t\t\tif (oldValue !== this._value) {\n\t\t\t\tthis[dispatchSymbol](this._value, oldValue);\n\t\t\t}\n\t\t}\n\t},\n\t// Called when nothing is bound to this observation.\n\t// Removes all event listeners on all dependency observables.\n\tonUnbound: function(){\n\t\tthis.bound = false;\n\t\trecorderHelpers.stopObserving(this.newDependencies, this.onDependencyChange);\n\t\t// Setup newDependencies in case someone binds again to this observable.\n\t\tthis.newDependencies = ObservationRecorder.makeDependenciesRecorder();\n\t},\n\t// Reads the value of the observation.\n\tget: function(){\n\n\t\t// If an external observation is tracking observables and\n\t\t// this compute can be listened to by \"function\" based computes ....\n\t\tif( this.options.isObservable && ObservationRecorder.isRecording() ) {\n\n\t\t\t// ... tell the tracking compute to listen to change on this observation.\n\t\t\tObservationRecorder.add(this);\n\t\t\t// ... if we are not bound, we should bind so that\n\t\t\t// we don't have to re-read to get the value of this observation.\n\t\t\tif (!this.bound) {\n\t\t\t\tObservation.temporarilyBind(this);\n\t\t\t}\n\n\t\t}\n\n\n\t\tif(this.bound === true ) {\n\t\t\t// It's possible that a child dependency of this observable might be queued\n\t\t\t// to change. Check all child dependencies and make sure they are up-to-date by\n\t\t\t// possibly running what they have registered in the derive queue.\n\t\t\tif(queues.deriveQueue.tasksRemainingCount() > 0) {\n\t\t\t\tObservation.updateChildrenAndSelf(this);\n\t\t\t}\n\n\t\t\treturn this._value;\n\t\t} else {\n\t\t\t// If we are not bound, just call the function.\n\t\t\treturn this.func.call(this.context);\n\t\t}\n\t},\n\n\thasDependencies: function(){\n\t\tvar newDependencies = this.newDependencies;\n\t\treturn this.bound ?\n\t\t\t(newDependencies.valueDependencies.size + newDependencies.keyDependencies.size) > 0  :\n\t\t\tundefined;\n\t},\n\t/**\n\t * @function can-observation.prototype.log log\n\t * @parent can-observation.prototype prototype\n\t *\n\t * @signature `observation.log()`\n\t *\n\t * Turns on logging of changes to the browser console.\n\t */\n\tlog: function() {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tvar quoteString = function quoteString(x) {\n\t\t\t\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n\t\t\t};\n\t\t\tthis._log = function(previous, current) {\n\t\t\t\tdev.log(\n\t\t\t\t\tcanReflect.getName(this),\n\t\t\t\t\t\"\\n is  \", quoteString(current),\n\t\t\t\t\t\"\\n was \", quoteString(previous)\n\t\t\t\t);\n\t\t\t};\n\t\t}\n\t\t//!steal-remove-end\n\t}\n});\n\nObject.defineProperty(Observation.prototype, \"value\", {\n\tget: function() {\n\t\treturn this.get();\n\t}\n});\n\nvar observationProto = {\n\t\"can.getValue\": Observation.prototype.get,\n\t\"can.isValueLike\": true,\n\t\"can.isMapLike\": false,\n\t\"can.isListLike\": false,\n\t\"can.valueHasDependencies\": Observation.prototype.hasDependencies,\n\t\"can.getValueDependencies\": function(){\n\t\tif (this.bound === true) {\n\t\t\t// Only provide `keyDependencies` and `valueDependencies` properties\n\t\t\t// if there's actually something there.\n\t\t\tvar deps = this.newDependencies,\n\t\t\t\tresult = {};\n\n\t\t\tif (deps.keyDependencies.size) {\n\t\t\t\tresult.keyDependencies = deps.keyDependencies;\n\t\t\t}\n\n\t\t\tif (deps.valueDependencies.size) {\n\t\t\t\tresult.valueDependencies = deps.valueDependencies;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\treturn undefined;\n\t},\n\t\"can.getPriority\": function(){\n\t\treturn this.options.priority;\n\t},\n\t\"can.setPriority\": function(priority){\n\t\tthis.options.priority = priority;\n\t}\n};\n\n//!steal-remove-start\nif (true) {\n\tobservationProto[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"<\" + canReflect.getName(this.func) + \">\";\n\t};\n}\n//!steal-remove-end\ncanReflect.assignSymbols(Observation.prototype, observationProto);\n\n// ## Observation.updateChildrenAndSelf\n// This recursively checks if an observation's dependencies might be in the `derive` queue.\n// If it is, we need to update that value so the reading of this value will be correct.\n// This can happen if an observation suddenly switches to depending on something that has higher\n// priority than itself.  We need to make sure that value is completely updated.\nObservation.updateChildrenAndSelf = function(observation){\n\t// If the observable has an `update` method and it's enqueued, flush that task immediately so\n\t// the value is right.\n\t// > NOTE: This only works for `Observation` right now.  We need a way of knowing how\n\t// > to find what an observable might have in the `deriveQueue`.\n\tif(observation.update !== undefined && queues.deriveQueue.isEnqueued( observation.update ) === true) {\n\t\t// TODO: In the future, we should be able to send log information\n\t\t// to explain why this needed to be updated.\n\t\tqueues.deriveQueue.flushQueuedTask(observation.update);\n\t\treturn true;\n\t}\n\n\t// If we can get dependency values from this observable ...\n\tif(observation[getValueDependenciesSymbol]) {\n\t\t// ... Loop through each dependency and see if any of them (or their children) needed an update.\n\t\tvar childHasChanged = false;\n\t\tvar valueDependencies = observation[getValueDependenciesSymbol]().valueDependencies || [];\n\t\tvalueDependencies.forEach(function(observable){\n\t\t\tif( Observation.updateChildrenAndSelf( observable ) === true) {\n\t\t\t\tchildHasChanged = true;\n\t\t\t}\n\t\t});\n\t\treturn childHasChanged;\n\t} else {\n\t\treturn false;\n\t}\n};\n\n// ## Legacy Stuff\n// Warn when `ObservationRecorder` methods are called on `Observation`.\nvar alias = {addAll: \"addMany\"};\n[\"add\",\"addAll\",\"ignore\",\"trap\",\"trapsCount\",\"isRecording\"].forEach(function(methodName){\n\tObservation[methodName] = function(){\n\t\tvar name = alias[methodName] ? alias[methodName] : methodName;\n\t\tconsole.warn(\"can-observation: Call \"+name+\"() on can-observation-recorder.\");\n\t\treturn ObservationRecorder[name].apply(this, arguments);\n\t};\n});\nObservation.prototype.start = function(){\n\tconsole.warn(\"can-observation: Use .on and .off to bind.\");\n\treturn this.onBound();\n};\nObservation.prototype.stop = function(){\n\tconsole.warn(\"can-observation: Use .on and .off to bind.\");\n\treturn this.onUnbound();\n};\n\n// ### temporarilyBind\n// Will bind an observable value temporarily.  This should be part of queues probably.\nObservation.temporarilyBind = temporarilyBind;\n\n\nmodule.exports = namespace.Observation = Observation;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-observation/can-observation.js?");

/***/ }),

/***/ "../../node_modules/can-observation/recorder-dependency-helpers.js":
/*!****************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-observation/recorder-dependency-helpers.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # Recorder Dependency Helpers\n// This exposes two helpers:\n// - `updateObservations` - binds and unbinds a diff of two observation records\n//   (see can-observation-recorder for details on this data type).\n// - `stopObserving` - unbinds an observation record.\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\n\n\n// ## Helpers\n// The following helpers all use `this` to pass additional arguments. This\n// is for performance reasons as it avoids creating new functions.\n\nfunction addNewKeyDependenciesIfNotInOld(event) {\n    // Expects `this` to have:\n    // - `.observable` - the observable we might be binding to.\n    // - `.oldEventSet` - the bound keys on the old dependency record for `observable`.\n    // - `.onDependencyChange` - the handler we will call back when the key is changed.\n    // If there wasn't any keys, or when we tried to delete we couldn't because the key\n    // wasn't in the set, start binding.\n    if(this.oldEventSet === undefined || this.oldEventSet[\"delete\"](event) === false) {\n        canReflect.onKeyValue(this.observable, event, this.onDependencyChange,\"notify\");\n    }\n}\n\n// ### addObservablesNewKeyDependenciesIfNotInOld\n// For each event in the `eventSet` of new observables,\n// setup a binding (or delete the key).\nfunction addObservablesNewKeyDependenciesIfNotInOld(eventSet, observable){\n    eventSet.forEach(addNewKeyDependenciesIfNotInOld, {\n        onDependencyChange: this.onDependencyChange,\n        observable: observable,\n        oldEventSet: this.oldDependencies.keyDependencies.get(observable)\n    });\n}\n\nfunction removeKeyDependencies(event) {\n    canReflect.offKeyValue(this.observable, event, this.onDependencyChange,\"notify\");\n}\n\nfunction removeObservablesKeyDependencies(oldEventSet, observable){\n    oldEventSet.forEach(removeKeyDependencies, {onDependencyChange: this.onDependencyChange, observable: observable});\n}\n\nfunction addValueDependencies(observable) {\n    // If we were unable to delete the key in the old set, setup a binding.\n    if(this.oldDependencies.valueDependencies.delete(observable) === false) {\n        canReflect.onValue(observable, this.onDependencyChange,\"notify\");\n    }\n}\nfunction removeValueDependencies(observable) {\n    canReflect.offValue(observable, this.onDependencyChange,\"notify\");\n}\n\n\nmodule.exports = {\n    // ## updateObservations\n    //\n    // Binds `observationData.onDependencyChange` to dependencies in `observationData.newDependencies` that are not currently in\n    // `observationData.oldDependencies`.  Anything in `observationData.oldDependencies`\n    // left over is unbound.\n    //\n    // The algorthim works by:\n    // 1. Loop through the `new` dependencies, checking if an equivalent is in the `old` bindings.\n    //    - If there is an equivalent binding, delete that dependency from `old`.\n    //    - If there is __not__ an equivalent binding, setup a binding from that dependency to `.onDependencyChange`.\n    // 2. Loop through the remaining `old` dependencies, teardown bindings.\n    //\n    // For performance, this method mutates the values in `.oldDependencies`.\n    updateObservations: function(observationData){\n        observationData.newDependencies.keyDependencies.forEach(addObservablesNewKeyDependenciesIfNotInOld, observationData);\n        observationData.oldDependencies.keyDependencies.forEach(removeObservablesKeyDependencies, observationData);\n        observationData.newDependencies.valueDependencies.forEach(addValueDependencies, observationData);\n        observationData.oldDependencies.valueDependencies.forEach(removeValueDependencies, observationData);\n    },\n    stopObserving: function(observationReciever, onDependencyChange){\n        observationReciever.keyDependencies.forEach(removeObservablesKeyDependencies, {onDependencyChange: onDependencyChange});\n        observationReciever.valueDependencies.forEach(removeValueDependencies, {onDependencyChange: onDependencyChange});\n    }\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-observation/recorder-dependency-helpers.js?");

/***/ }),

/***/ "../../node_modules/can-observation/temporarily-bind.js":
/*!*****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-observation/temporarily-bind.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nvar temporarilyBoundNoOperation = function(){};\n// A list of temporarily bound computes\nvar observables;\n// Unbinds all temporarily bound computes.\nvar unbindTemporarilyBoundValue = function () {\n\tfor (var i = 0, len = observables.length; i < len; i++) {\n\t\tcanReflect.offValue(observables[i], temporarilyBoundNoOperation);\n\t}\n\tobservables = null;\n};\n\n// ### temporarilyBind\n// Binds computes for a moment to cache their value and prevent re-calculating it.\nfunction temporarilyBind(compute) {\n\tvar computeInstance = compute.computeInstance || compute;\n\tcanReflect.onValue(computeInstance, temporarilyBoundNoOperation);\n\tif (!observables) {\n\t\tobservables = [];\n\t\tsetTimeout(unbindTemporarilyBoundValue, 10);\n\t}\n\tobservables.push(computeInstance);\n}\n\nmodule.exports = temporarilyBind;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-observation/temporarily-bind.js?");

/***/ }),

/***/ "../../node_modules/can-parse-uri/can-parse-uri.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-parse-uri/can-parse-uri.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module {function} can-parse-uri can-parse-uri\n * @parent can-js-utilities\n * @collection can-infrastructure\n * @signature `parseURI(url)`\n *\n * Parse a URI into its components.\n *\n * ```js\n * import {parseURI} from \"can\"\n * parseURI(\"http://foo:8080/bar.html?query#change\")\n * //-> {\n * //  authority: \"//foo:8080\",\n * //  hash: \"#change\",\n * //  host: \"foo:8080\",\n * //  hostname: \"foo\",\n * //  href: \"http://foo:8080/bar.html?query#change\",\n * //  pathname: \"/bar.html\",\n * //  port: \"8080\",\n * //  protocol: \"http:\",\n * //  search: \"?query\"\n * // }\n * ```\n *\n * @param {String} url The URL you want to parse.\n *\n * @return {Object} Returns an object with properties for each part of the URL. `null`\n * is returned if the url can not be parsed.\n */\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nmodule.exports = namespace.parseURI = function(url){\n\t\tvar m = String(url).replace(/^\\s+|\\s+$/g, '').match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);\n\t\t\t// authority = '//' + user + ':' + pass '@' + hostname + ':' port\n\t\treturn (m ? {\n\t\t\thref     : m[0] || '',\n\t\t\tprotocol : m[1] || '',\n\t\t\tauthority: m[2] || '',\n\t\t\thost     : m[3] || '',\n\t\t\thostname : m[4] || '',\n\t\t\tport     : m[5] || '',\n\t\t\tpathname : m[6] || '',\n\t\t\tsearch   : m[7] || '',\n\t\t\thash     : m[8] || ''\n\t\t} : null);\n\t};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-parse-uri/can-parse-uri.js?");

/***/ }),

/***/ "../../node_modules/can-queues/can-queues.js":
/*!******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-queues/can-queues.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var canDev = __webpack_require__( /*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\" );\nvar Queue = __webpack_require__( /*! ./queue */ \"../../node_modules/can-queues/queue.js\" );\nvar PriorityQueue = __webpack_require__( /*! ./priority-queue */ \"../../node_modules/can-queues/priority-queue.js\" );\nvar queueState = __webpack_require__( /*! ./queue-state */ \"../../node_modules/can-queues/queue-state.js\" );\nvar CompletionQueue = __webpack_require__( /*! ./completion-queue */ \"../../node_modules/can-queues/completion-queue.js\" );\nvar ns = __webpack_require__( /*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\" );\n\n// How many `batch.start` - `batch.stop` calls have been made.\nvar batchStartCounter = 0;\n// If a task was added since the last flush caused by `batch.stop`.\nvar addedTask = false;\n// If we are flushing due to a `batch.stop`.\nvar isFlushing = false;\n\n// Legacy values for the old batchNum.\nvar batchNum = 0;\nvar batchData;\n\n// Used by `.enqueueByQueue` to know the property names that might be passed.\nvar queueNames = [\"notify\", \"derive\", \"domUI\", \"mutate\"];\n// Create all the queues so that when one is complete,\n// the next queue is flushed.\nvar NOTIFY_QUEUE, DERIVE_QUEUE, DOM_UI_QUEUE, MUTATE_QUEUE;\n\nNOTIFY_QUEUE = new Queue( \"NOTIFY\", {\n\tonComplete: function () {\n\t\tDERIVE_QUEUE.flush();\n\t},\n\tonFirstTask: function () {\n\t\t// Flush right away if we aren't in a batch.\n\t\tif ( !batchStartCounter ) {\n\t\t\tNOTIFY_QUEUE.flush();\n\t\t} else {\n\t\t\taddedTask = true;\n\t\t}\n\t}\n});\n\nDERIVE_QUEUE = new PriorityQueue( \"DERIVE\", {\n\tonComplete: function () {\n\t\tDOM_UI_QUEUE.flush();\n\t},\n\tonFirstTask: function () {\n\t\taddedTask = true;\n\t}\n});\n\nDOM_UI_QUEUE = new CompletionQueue( \"DOM_UI\", {\n\tonComplete: function () {\n\t\tMUTATE_QUEUE.flush();\n\t},\n\tonFirstTask: function () {\n\t\taddedTask = true;\n\t}\n});\n\nMUTATE_QUEUE = new Queue( \"MUTATE\", {\n\tonComplete: function () {\n\t\tqueueState.lastTask = null;\n\t\tisFlushing = false;\n\t},\n\tonFirstTask: function () {\n\t\taddedTask = true;\n\t}\n});\n\nvar queues = {\n\tQueue: Queue,\n\tPriorityQueue: PriorityQueue,\n\tCompletionQueue: CompletionQueue,\n\tnotifyQueue: NOTIFY_QUEUE,\n\tderiveQueue: DERIVE_QUEUE,\n\tdomUIQueue: DOM_UI_QUEUE,\n\tmutateQueue: MUTATE_QUEUE,\n\tbatch: {\n\t\tstart: function () {\n\t\t\tbatchStartCounter++;\n\t\t\tif ( batchStartCounter === 1 ) {\n\t\t\t\tbatchNum++;\n\t\t\t\tbatchData = {number: batchNum};\n\t\t\t}\n\t\t},\n\t\tstop: function () {\n\t\t\tbatchStartCounter--;\n\t\t\tif ( batchStartCounter === 0 ) {\n\t\t\t\tif ( addedTask ) {\n\t\t\t\t\taddedTask = false;\n\t\t\t\t\tisFlushing = true;\n\t\t\t\t\tNOTIFY_QUEUE.flush();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Legacy method to return if we are between start and stop calls.\n\t\tisCollecting: function () {\n\t\t\treturn batchStartCounter > 0;\n\t\t},\n\t\t// Legacy method provide a number for each batch.\n\t\tnumber: function () {\n\t\t\treturn batchNum;\n\t\t},\n\t\t// Legacy method to provide batch information.\n\t\tdata: function () {\n\t\t\treturn batchData;\n\t\t}\n\t},\n\tenqueueByQueue: function enqueueByQueue ( fnByQueue, context, args, makeMeta, reasonLog ) {\n\t\tif ( fnByQueue ) {\n\t\t\tqueues.batch.start();\n\t\t\t// For each queue, check if there are tasks for it.\n\t\t\tqueueNames.forEach( function ( queueName ) {\n\t\t\t\tvar name = queueName + \"Queue\";\n\t\t\t\tvar QUEUE = queues[name];\n\t\t\t\tvar tasks = fnByQueue[queueName];\n\t\t\t\tif ( tasks !== undefined ) {\n\t\t\t\t\t// For each task function, setup the meta and enqueue it.\n\t\t\t\t\ttasks.forEach( function ( fn ) {\n\t\t\t\t\t\tvar meta = makeMeta != null ? makeMeta( fn, context, args ) : {};\n\t\t\t\t\t\tmeta.reasonLog = reasonLog;\n\t\t\t\t\t\tQUEUE.enqueue( fn, context, args, meta );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tqueues.batch.stop();\n\t\t}\n\t},\n\t// Currently an internal method that provides the task stack.\n\t// Returns an array with the first task as the first item.\n\tstack: function () {\n\t\tvar current = queueState.lastTask;\n\t\tvar stack = [];\n\t\twhile ( current ) {\n\t\t\tstack.unshift( current );\n\t\t\t// Queue.prototype._logEnqueue ensures\n\t\t\t// that the `parentTask` is always set.\n\t\t\tcurrent = current.meta.parentTask;\n\t\t}\n\t\treturn stack;\n\t},\n\tlogStack: function () {\n\t\tvar stack = this.stack();\n\t\tstack.forEach( function ( task, i ) {\n\t\t\tvar meta = task.meta;\n\t\t\tif( i === 0 && meta && meta.reasonLog) {\n\t\t\t\tcanDev.log.apply( canDev, meta.reasonLog);\n\t\t\t}\n\t\t\tvar log = meta && meta.log ? meta.log : [task.fn.name, task];\n\t\t\tcanDev.log.apply( canDev, [task.meta.stack.name + \" ran task:\"].concat( log ));\n\t\t});\n\t},\n\t// A method that is not used.  It should return the number of tasks\n\t// remaining, but doesn't seem to actually work.\n\ttaskCount: function () {\n\t\treturn NOTIFY_QUEUE.tasks.length + DERIVE_QUEUE.tasks.length + DOM_UI_QUEUE.tasks.length + MUTATE_QUEUE.tasks.length;\n\t},\n\t// A shortcut for flushign the notify queue.  `batch.start` and `batch.stop` should be\n\t// used instead.\n\tflush: function () {\n\t\tNOTIFY_QUEUE.flush();\n\t},\n\tlog: function () {\n\t\tNOTIFY_QUEUE.log.apply( NOTIFY_QUEUE, arguments );\n\t\tDERIVE_QUEUE.log.apply( DERIVE_QUEUE, arguments );\n\t\tDOM_UI_QUEUE.log.apply( DOM_UI_QUEUE, arguments );\n\t\tMUTATE_QUEUE.log.apply( MUTATE_QUEUE, arguments );\n\t}\n};\n\nif ( ns.queues ) {\n\tthrow new Error( \"You can't have two versions of can-queues, check your dependencies\" );\n} else {\n\tmodule.exports = ns.queues = queues;\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-queues/can-queues.js?");

/***/ }),

/***/ "../../node_modules/can-queues/completion-queue.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-queues/completion-queue.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Queue = __webpack_require__( /*! ./queue */ \"../../node_modules/can-queues/queue.js\" );\n\n// This queue does not allow another task to run until this one is complete\nvar CompletionQueue = function () {\n\tQueue.apply( this, arguments );\n\tthis.flushCount = 0;\n};\nCompletionQueue.prototype = Object.create( Queue.prototype );\nCompletionQueue.prototype.constructor = CompletionQueue;\n\nCompletionQueue.prototype.flush = function () {\n\tif ( this.flushCount === 0 ) {\n\t\tthis.flushCount ++;\n\t\twhile ( this.index < this.tasks.length ) {\n\t\t\tvar task = this.tasks[this.index++];\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tthis._logFlush( task );\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\ttask.fn.apply( task.context, task.args );\n\t\t}\n\t\tthis.index = 0;\n\t\tthis.tasks = [];\n\t\tthis.flushCount--;\n\t\tthis.callbacks.onComplete( this );\n\t}\n};\n\nmodule.exports = CompletionQueue;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-queues/completion-queue.js?");

/***/ }),

/***/ "../../node_modules/can-queues/priority-queue.js":
/*!**********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-queues/priority-queue.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Queue = __webpack_require__( /*! ./queue */ \"../../node_modules/can-queues/queue.js\" );\n\nvar PriorityQueue = function () {\n\tQueue.apply( this, arguments );\n\t// A map of a task's function to the task for that function.\n\t// This is so we can prevent duplicate functions from being enqueued\n\t// and so `flushQueuedTask` can find the task and run it.\n\tthis.taskMap = new Map();\n\t// An \"array-of-arrays\"-ish data structure that stores\n\t// each task organized by its priority.  Each object in this list\n\t// looks like `{tasks: [...], index: 0}` where:\n\t// - `tasks` - the tasks for a particular priority.\n\t// - `index` - the index of the task waiting to be prioritized.\n\tthis.taskContainersByPriority = [];\n\n\t// The index within `taskContainersByPriority` of the first `taskContainer`\n\t// which has tasks that have not been run.\n\tthis.curPriorityIndex = Infinity;\n\t// The index within `taskContainersByPriority` of the last `taskContainer`\n\t// which has tasks that have not been run.\n\tthis.curPriorityMax = 0;\n\n\tthis.isFlushing = false;\n\n\t// Manage the number of tasks remaining to keep\n\t// this lookup fast.\n\tthis.tasksRemaining = 0;\n};\nPriorityQueue.prototype = Object.create( Queue.prototype );\nPriorityQueue.prototype.constructor = PriorityQueue;\n\nPriorityQueue.prototype.enqueue = function ( fn, context, args, meta ) {\n\t// Only allow the enqueing of a given function once.\n\tif ( !this.taskMap.has( fn ) ) {\n\n\t\tthis.tasksRemaining++;\n\n\t\tvar isFirst = this.taskContainersByPriority.length === 0;\n\n\t\tvar task = {\n\t\t\tfn: fn,\n\t\t\tcontext: context,\n\t\t\targs: args,\n\t\t\tmeta: meta || {}\n\t\t};\n\n\t\tvar taskContainer = this.getTaskContainerAndUpdateRange( task );\n\t\ttaskContainer.tasks.push( task );\n\t\tthis.taskMap.set( fn, task );\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logEnqueue( task );\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif ( isFirst ) {\n\t\t\tthis.callbacks.onFirstTask( this );\n\t\t}\n\t}\n};\n\n// Given a task, updates the queue's cursors so that `flush`\n// will be able to run the task.\nPriorityQueue.prototype.getTaskContainerAndUpdateRange = function ( task ) {\n\tvar priority = task.meta.priority || 0;\n\n\tif ( priority < this.curPriorityIndex ) {\n\t\tthis.curPriorityIndex = priority;\n\t}\n\n\tif ( priority > this.curPriorityMax ) {\n\t\tthis.curPriorityMax = priority;\n\t}\n\n\tvar tcByPriority = this.taskContainersByPriority;\n\tvar taskContainer = tcByPriority[priority];\n\tif ( !taskContainer ) {\n\t\ttaskContainer = tcByPriority[priority] = {tasks: [], index: 0};\n\t}\n\treturn taskContainer;\n};\n\nPriorityQueue.prototype.flush = function () {\n\t// Only allow one task to run at a time.\n\tif ( this.isFlushing ) {\n\t\treturn;\n\t}\n\tthis.isFlushing = true;\n\twhile ( true ) {\n\t\t// If the first prioritized taskContainer with tasks remaining\n\t\t// is before the last prioritized taskContainer ...\n\t\tif ( this.curPriorityIndex <= this.curPriorityMax ) {\n\t\t\tvar taskContainer = this.taskContainersByPriority[this.curPriorityIndex];\n\n\t\t\t// If that task container actually has tasks remaining ...\n\t\t\tif ( taskContainer && ( taskContainer.tasks.length > taskContainer.index ) ) {\n\n\t\t\t\t// Run the task.\n\t\t\t\tvar task = taskContainer.tasks[taskContainer.index++];\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tthis._logFlush( task );\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\tthis.tasksRemaining--;\n\t\t\t\tthis.taskMap[\"delete\"]( task.fn );\n\t\t\t\ttask.fn.apply( task.context, task.args );\n\n\t\t\t} else {\n\t\t\t\t// Otherwise, move to the next taskContainer.\n\t\t\t\tthis.curPriorityIndex++;\n\t\t\t}\n\t\t} else {\n\t\t\t// Otherwise, reset the state for the next `.flush()`.\n\t\t\tthis.taskMap = new Map();\n\t\t\tthis.curPriorityIndex = Infinity;\n\t\t\tthis.curPriorityMax = 0;\n\t\t\tthis.taskContainersByPriority = [];\n\t\t\tthis.isFlushing = false;\n\t\t\tthis.callbacks.onComplete( this );\n\t\t\treturn;\n\t\t}\n\t}\n};\n\nPriorityQueue.prototype.isEnqueued = function ( fn ) {\n\treturn this.taskMap.has( fn );\n};\n\nPriorityQueue.prototype.flushQueuedTask = function ( fn ) {\n\tvar task = this.dequeue(fn);\n\tif(task) {\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logFlush( task );\n\t\t}\n\t\t//!steal-remove-end\n\t\ttask.fn.apply( task.context, task.args );\n\t}\n};\nPriorityQueue.prototype.dequeue = function(fn){\n\tvar task = this.taskMap.get( fn );\n\tif ( task ) {\n\t\tvar priority = task.meta.priority || 0;\n\t\tvar taskContainer = this.taskContainersByPriority[priority];\n\t\tvar index = taskContainer.tasks.indexOf( task, taskContainer.index );\n\n\t\tif ( index >= 0 ) {\n\t\t\ttaskContainer.tasks.splice( index, 1 );\n\t\t\tthis.tasksRemaining--;\n\t\t\tthis.taskMap[\"delete\"]( task.fn );\n\t\t\treturn task;\n\t\t} else {\n\t\t\tconsole.warn(\"Task\", fn, \"has already run\");\n\t\t}\n\t}\n};\n\nPriorityQueue.prototype.tasksRemainingCount = function () {\n\treturn this.tasksRemaining;\n};\n\nmodule.exports = PriorityQueue;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-queues/priority-queue.js?");

/***/ }),

/***/ "../../node_modules/can-queues/queue-state.js":
/*!*******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-queues/queue-state.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n\tlastTask: null\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-queues/queue-state.js?");

/***/ }),

/***/ "../../node_modules/can-queues/queue.js":
/*!*************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-queues/queue.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var queueState = __webpack_require__(/*! ./queue-state */ \"../../node_modules/can-queues/queue-state.js\");\nvar canDev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\n\nfunction noOperation () {}\n\nvar Queue = function ( name, callbacks ) {\n\tthis.callbacks = assign( {\n\t\tonFirstTask: noOperation,\n\t\t// The default behavior is to clear the lastTask state.\n\t\t// This is overwritten by `can-queues.js`.\n\t\tonComplete: function () {\n\t\t\tqueueState.lastTask = null;\n\t\t}\n\t}, callbacks || {});\n\tthis.name = name;\n\tthis.index = 0;\n\tthis.tasks = [];\n\tthis._log = false;\n};\n\nQueue.prototype.constructor = Queue;\n\nQueue.noop = noOperation;\n\nQueue.prototype.enqueue = function ( fn, context, args, meta ) {\n\tvar len = this.tasks.push({\n\t\tfn: fn,\n\t\tcontext: context,\n\t\targs: args,\n\t\tmeta: meta || {}\n\t});\n\t//!steal-remove-start\n\tif(true) {\n\t\tthis._logEnqueue( this.tasks[len - 1] );\n\t}\n\t//!steal-remove-end\n\n\tif ( len === 1 ) {\n\t\tthis.callbacks.onFirstTask( this );\n\t}\n};\n\nQueue.prototype.flush = function () {\n\twhile ( this.index < this.tasks.length ) {\n\t\tvar task = this.tasks[this.index++];\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tthis._logFlush( task );\n\t\t}\n\n\t\t//!steal-remove-end\n\t\ttask.fn.apply( task.context, task.args );\n\t}\n\tthis.index = 0;\n\tthis.tasks = [];\n\tthis.callbacks.onComplete( this );\n};\n\nQueue.prototype.log = function () {\n\tthis._log = arguments.length ? arguments[0] : true;\n};\n\n//The following are removed in production.\n//!steal-remove-start\nif(true) {\n\tQueue.prototype._logEnqueue = function ( task ) {\n\t\t// For debugging, set the parentTask to the last\n\t\t// run task.\n\t\ttask.meta.parentTask = queueState.lastTask;\n\t\t// Also let the task know which stack it was run within.\n\t\ttask.meta.stack = this;\n\n\t\tif ( this._log === true || this._log === \"enqueue\" ) {\n\t\t\tvar log = task.meta.log ? task.meta.log.concat( task ) : [task.fn.name, task];\n\t\t\tcanDev.log.apply( canDev, [this.name + \" enqueuing:\"].concat( log ));\n\t\t}\n\t};\n\t// `_logFlush` MUST be called by all queues prior to flushing in\n\t// development.\n\tQueue.prototype._logFlush = function ( task ) {\n\t\tif ( this._log === true || this._log === \"flush\" ) {\n\t\t\tvar log = task.meta.log ? task.meta.log.concat( task ) : [task.fn.name, task];\n\t\t\tcanDev.log.apply( canDev, [this.name + \" running  :\"].concat( log ));\n\t\t}\n\t\t// Update the state to mark this as the task that was run last.\n\t\tqueueState.lastTask = task;\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-queues/queue.js?");

/***/ }),

/***/ "../../node_modules/can-reflect-dependencies/can-reflect-dependencies.js":
/*!**********************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-dependencies/can-reflect-dependencies.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar addMutatedBy = __webpack_require__(/*! ./src/add-mutated-by */ \"../../node_modules/can-reflect-dependencies/src/add-mutated-by.js\");\nvar deleteMutatedBy = __webpack_require__(/*! ./src/delete-mutated-by */ \"../../node_modules/can-reflect-dependencies/src/delete-mutated-by.js\");\nvar getDependencyDataOf = __webpack_require__(/*! ./src/get-dependency-data-of */ \"../../node_modules/can-reflect-dependencies/src/get-dependency-data-of.js\");\n\n// mutatedByMap :: WeakMap<obj, {\n//\tmutateDependenciesForKey:   Map<key, DependencyRecord>,\n//\tmutateDependenciesForValue: DependencyRecord\n// }>\nvar mutatedByMap = new WeakMap();\n\nmodule.exports = {\n\t// Track mutations between observable as dependencies\n\t// addMutatedBy(obs, obs2);\n\t// addMutatedBy(obs, key, obs2);\n\t// addMutatedBy(obs, { valueDependencies: Set, keyDependencies: Map })\n\t// addMutatedBy(obs, key, { valueDependencies: Set, keyDependencies: Map })\n\taddMutatedBy: addMutatedBy(mutatedByMap),\n\n\t// Call this method with the same arguments as `addMutatedBy`\n\t// to unregister the mutation dependency\n\tdeleteMutatedBy: deleteMutatedBy(mutatedByMap),\n\n\t// Returns an object with the dependecies of the given argument\n\t//\t{\n\t//\t\twhatIChange: { mutate: DependencyRecord, derive: DependencyRecord },\n\t//\t\twhatChangesMe: { mutate: DependencyRecord, derive: DependencyRecord }\n\t//\t}\n\tgetDependencyDataOf: getDependencyDataOf(mutatedByMap)\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-dependencies/can-reflect-dependencies.js?");

/***/ }),

/***/ "../../node_modules/can-reflect-dependencies/src/add-mutated-by.js":
/*!****************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-dependencies/src/add-mutated-by.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\n// DependencyRecord :: { keyDependencies: Map, valueDependencies: Set }\nvar makeDependencyRecord = function makeDependencyRecord() {\n\treturn {\n\t\tkeyDependencies: new Map(),\n\t\tvalueDependencies: new Set()\n\t};\n};\n\nvar makeRootRecord = function makeRootRecord() {\n\treturn {\n\t\t// holds mutated key dependencies of a key-value like object, e.g:\n\t\t// if person.first is mutated by other observable, this map will have a\n\t\t// key `first` (the mutated property) mapped to a DependencyRecord\n\t\tmutateDependenciesForKey: new Map(),\n\n\t\t// holds mutated value dependencies of value-like objects\n\t\tmutateDependenciesForValue: makeDependencyRecord()\n\t};\n};\n\nmodule.exports = function(mutatedByMap) {\n\treturn function addMutatedBy(mutated, key, mutator) {\n\t\tvar gotKey = arguments.length === 3;\n\n\t\t// normalize arguments\n\t\tif (arguments.length === 2) {\n\t\t\tmutator = key;\n\t\t\tkey = undefined;\n\t\t}\n\n\t\t// normalize mutator when shorthand is used\n\t\tif (!mutator.keyDependencies && !mutator.valueDependencies) {\n\t\t\tmutator = { valueDependencies: new Set([mutator]) };\n\t\t}\n\n\t\t// retrieve root record from the state map or create a new one\n\t\tvar root = mutatedByMap.get(mutated);\n\t\tif (!root) {\n\t\t\troot = makeRootRecord();\n\t\t\tmutatedByMap.set(mutated, root);\n\t\t}\n\n\t\t// create a [key] DependencyRecord if [key] was provided\n\t\t// and Record does not already exist\n\t\tif (gotKey && !root.mutateDependenciesForKey.get(key)) {\n\t\t\troot.mutateDependenciesForKey.set(key, makeDependencyRecord());\n\t\t}\n\n\t\t// retrieve DependencyRecord\n\t\tvar dependencyRecord = gotKey ?\n\t\t\troot.mutateDependenciesForKey.get(key) :\n\t\t\troot.mutateDependenciesForValue;\n\n\t\tif (mutator.valueDependencies) {\n\t\t\tcanReflect.addValues(\n\t\t\t\tdependencyRecord.valueDependencies,\n\t\t\t\tmutator.valueDependencies\n\t\t\t);\n\t\t}\n\n\t\tif (mutator.keyDependencies) {\n\t\t\tcanReflect.each(mutator.keyDependencies, function(keysSet, obj) {\n\t\t\t\tvar entry = dependencyRecord.keyDependencies.get(obj);\n\n\t\t\t\tif (!entry) {\n\t\t\t\t\tentry = new Set();\n\t\t\t\t\tdependencyRecord.keyDependencies.set(obj, entry);\n\t\t\t\t}\n\n\t\t\t\tcanReflect.addValues(entry, keysSet);\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-dependencies/src/add-mutated-by.js?");

/***/ }),

/***/ "../../node_modules/can-reflect-dependencies/src/delete-mutated-by.js":
/*!*******************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-dependencies/src/delete-mutated-by.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nmodule.exports = function(mutatedByMap) {\n\treturn function deleteMutatedBy(mutated, key, mutator) {\n\t\tvar gotKey = arguments.length === 3;\n\t\tvar root = mutatedByMap.get(mutated);\n\n\t\t// normalize arguments\n\t\tif (arguments.length === 2) {\n\t\t\tmutator = key;\n\t\t\tkey = undefined;\n\t\t}\n\n\t\t// normalize mutator when shorthand is used\n\t\tif (!mutator.keyDependencies && !mutator.valueDependencies) {\n\t\t\tmutator = { valueDependencies: new Set([mutator]) };\n\t\t}\n\n\t\tvar dependencyRecord = gotKey ?\n\t\t\troot.mutateDependenciesForKey.get(key) :\n\t\t\troot.mutateDependenciesForValue;\n\n\t\tif (mutator.valueDependencies) {\n\t\t\tcanReflect.removeValues(\n\t\t\t\tdependencyRecord.valueDependencies,\n\t\t\t\tmutator.valueDependencies\n\t\t\t);\n\t\t}\n\n\t\tif (mutator.keyDependencies) {\n\t\t\tcanReflect.each(mutator.keyDependencies, function(keysSet, obj) {\n\t\t\t\tvar entry = dependencyRecord.keyDependencies.get(obj);\n\n\t\t\t\tif (entry) {\n\t\t\t\t\tcanReflect.removeValues(entry, keysSet);\n\t\t\t\t\tif (!entry.size) {\n\t\t\t\t\t\tdependencyRecord.keyDependencies.delete(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-dependencies/src/delete-mutated-by.js?");

/***/ }),

/***/ "../../node_modules/can-reflect-dependencies/src/get-dependency-data-of.js":
/*!************************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-dependencies/src/get-dependency-data-of.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar isFunction = __webpack_require__(/*! ./is-function */ \"../../node_modules/can-reflect-dependencies/src/is-function.js\");\n\nvar getWhatIChangeSymbol = canSymbol.for(\"can.getWhatIChange\");\nvar getKeyDependenciesSymbol = canSymbol.for(\"can.getKeyDependencies\");\nvar getValueDependenciesSymbol = canSymbol.for(\"can.getValueDependencies\");\n\nvar getKeyDependencies = function getKeyDependencies(obj, key) {\n\tif (isFunction(obj[getKeyDependenciesSymbol])) {\n\t\treturn canReflect.getKeyDependencies(obj, key);\n\t}\n};\n\nvar getValueDependencies = function getValueDependencies(obj) {\n\tif (isFunction(obj[getValueDependenciesSymbol])) {\n\t\treturn canReflect.getValueDependencies(obj);\n\t}\n};\n\nvar getMutatedKeyDependencies =\n\tfunction getMutatedKeyDependencies(mutatedByMap, obj, key) {\n\t\tvar root = mutatedByMap.get(obj);\n\t\tvar dependencyRecord;\n\n\t\tif (root && root.mutateDependenciesForKey.has(key)) {\n\t\t\tdependencyRecord = root.mutateDependenciesForKey.get(key);\n\t\t}\n\n\t\treturn dependencyRecord;\n\t};\n\nvar getMutatedValueDependencies =\n\tfunction getMutatedValueDependencies( mutatedByMap, obj) {\n\t\tvar result;\n\t\tvar root = mutatedByMap.get(obj);\n\n\t\tif (root) {\n\t\t\tvar\tdependencyRecord = root.mutateDependenciesForValue;\n\n\t\t\tif (dependencyRecord.keyDependencies.size) {\n\t\t\t\tresult = result || {};\n\t\t\t\tresult.keyDependencies = dependencyRecord.keyDependencies;\n\t\t\t}\n\n\t\t\tif (dependencyRecord.valueDependencies.size) {\n\t\t\t\tresult = result || {};\n\t\t\t\tresult.valueDependencies = dependencyRecord.valueDependencies;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\nvar getWhatIChange = function getWhatIChange(obj, key) {\n\tif (isFunction(obj[getWhatIChangeSymbol])) {\n\t\tvar gotKey = arguments.length === 2;\n\n\t\treturn gotKey ?\n\t\t\tcanReflect.getWhatIChange(obj, key) :\n\t\t\tcanReflect.getWhatIChange(obj);\n\t}\n};\n\nvar isEmptyRecord = function isEmptyRecord(record) {\n\treturn (\n\t\trecord == null ||\n\t\t!Object.keys(record).length ||\n\t\t(record.keyDependencies && !record.keyDependencies.size) &&\n\t\t(record.valueDependencies && !record.valueDependencies.size)\n\t);\n};\n\nvar getWhatChangesMe = function getWhatChangesMe(mutatedByMap, obj, key) {\n\tvar gotKey = arguments.length === 3;\n\n\tvar mutate = gotKey ?\n\t\tgetMutatedKeyDependencies(mutatedByMap, obj, key) :\n\t\tgetMutatedValueDependencies(mutatedByMap, obj);\n\n\tvar derive = gotKey ?\n\t\tgetKeyDependencies(obj, key) :\n\t\tgetValueDependencies(obj);\n\n\tif (!isEmptyRecord(mutate) || !isEmptyRecord(derive)) {\n\t\treturn Object.assign(\n\t\t\t{},\n\t\t\tmutate ? { mutate: mutate } : null,\n\t\t\tderive ? { derive: derive } : null\n\t\t);\n\t}\n};\n\nmodule.exports = function(mutatedByMap) {\n\treturn function getDependencyDataOf(obj, key) {\n\t\tvar gotKey = arguments.length === 2;\n\n\t\tvar whatChangesMe = gotKey ?\n\t\t\tgetWhatChangesMe(mutatedByMap, obj, key) :\n\t\t\tgetWhatChangesMe(mutatedByMap, obj);\n\n\t\tvar whatIChange = gotKey ? getWhatIChange(obj, key) : getWhatIChange(obj);\n\n\t\tif (whatChangesMe || whatIChange) {\n\t\t\treturn Object.assign(\n\t\t\t\t{},\n\t\t\t\twhatIChange ? { whatIChange: whatIChange } : null,\n\t\t\t\twhatChangesMe ? { whatChangesMe: whatChangesMe } : null\n\t\t\t);\n\t\t}\n\t};\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-dependencies/src/get-dependency-data-of.js?");

/***/ }),

/***/ "../../node_modules/can-reflect-dependencies/src/is-function.js":
/*!*************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-dependencies/src/is-function.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function isFunction(value) {\n\treturn typeof value === \"function\";\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-dependencies/src/is-function.js?");

/***/ }),

/***/ "../../node_modules/can-reflect-promise/can-reflect-promise.js":
/*!************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-promise/can-reflect-promise.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar KeyTree = __webpack_require__(/*! can-key-tree */ \"../../node_modules/can-key-tree/dist/cjs/can-key-tree.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\n\n\nvar getKeyValueSymbol = canSymbol.for(\"can.getKeyValue\"),\n\tobserveDataSymbol = canSymbol.for(\"can.meta\");\n\nvar promiseDataPrototype = {\n\tisPending: true,\n\tstate: \"pending\",\n\tisResolved: false,\n\tisRejected: false,\n\tvalue: undefined,\n\treason: undefined\n};\n\nfunction setVirtualProp(promise, property, value) {\n\tvar observeData = promise[observeDataSymbol];\n\tvar old = observeData[property];\n\tobserveData[property] = value;\n\tqueues.enqueueByQueue(observeData.handlers.getNode([property]), promise, [value,old], function() {\n\t\treturn {};\n\t},[\"Promise\", promise, \"resolved with value\", value, \"and changed virtual property: \"+property]);\n}\n\nfunction initPromise(promise) {\n\tvar observeData = promise[observeDataSymbol];\n\tif(!observeData) {\n\t\tObject.defineProperty(promise, observeDataSymbol, {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: false,\n\t\t\twritable: false,\n\t\t\tvalue: Object.create(promiseDataPrototype)\n\t\t});\n\t\tobserveData = promise[observeDataSymbol];\n\t\tobserveData.handlers = new KeyTree([Object, Object, Array]);\n\t}\n\tpromise.then(function(value){\n\t\tqueues.batch.start();\n\t\tsetVirtualProp(promise, \"isPending\", false);\n\t\tsetVirtualProp(promise, \"isResolved\", true);\n\t\tsetVirtualProp(promise, \"value\", value);\n\t\tsetVirtualProp(promise, \"state\", \"resolved\");\n\t\tqueues.batch.stop();\n\t}, function(reason){\n\t\tqueues.batch.start();\n\t\tsetVirtualProp(promise, \"isPending\", false);\n\t\tsetVirtualProp(promise, \"isRejected\", true);\n\t\tsetVirtualProp(promise, \"reason\", reason);\n\t\tsetVirtualProp(promise, \"state\", \"rejected\");\n\t\tqueues.batch.stop();\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.error(\"Failed promise:\", reason);\n\t\t}\n\t\t//!steal-remove-end\n\t});\n}\n\nfunction setupPromise(value) {\n\tvar oldPromiseFn;\n\tvar proto = \"getPrototypeOf\" in Object ? Object.getPrototypeOf(value) : value.__proto__; //jshint ignore:line\n\n\tif(value[getKeyValueSymbol] && value[observeDataSymbol]) {\n\t\t// promise has already been set up.  Don't overwrite.\n\t\treturn;\n\t}\n\n\tif(proto === null || proto === Object.prototype) {\n\t\t// promise type is a plain object or dictionary.  Set up object instead of proto.\n\t\tproto = value;\n\n\t\tif(typeof proto.promise === \"function\") {\n\t\t\t// Duck-type identification as a jQuery.Deferred;\n\t\t\t// In that case, the promise() function returns a new object\n\t\t\t//  that needs to be decorated.\n\t\t\toldPromiseFn = proto.promise;\n\t\t\tproto.promise = function() {\n\t\t\t\tvar result = oldPromiseFn.call(proto);\n\t\t\t\tsetupPromise(result);\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t}\n\n\tcanReflect.assignSymbols(proto, {\n\t\t\"can.getKeyValue\": function(key) {\n\t\t\tif(!this[observeDataSymbol]) {\n\t\t\t\tinitPromise(this);\n\t\t\t}\n\n\t\t\tObservationRecorder.add(this, key);\n\t\t\tswitch(key) {\n\t\t\t\tcase \"state\":\n\t\t\t\tcase \"isPending\":\n\t\t\t\tcase \"isResolved\":\n\t\t\t\tcase \"isRejected\":\n\t\t\t\tcase \"value\":\n\t\t\t\tcase \"reason\":\n\t\t\t\treturn this[observeDataSymbol][key];\n\t\t\t\tdefault:\n\t\t\t\treturn this[key];\n\t\t\t}\n\t\t},\n\t\t\"can.getValue\": function() {\n\t\t\treturn this[getKeyValueSymbol](\"value\");\n\t\t},\n\t\t\"can.isValueLike\": false,\n\t\t\"can.onKeyValue\": function(key, handler, queue) {\n\t\t\tif(!this[observeDataSymbol]) {\n\t\t\t\tinitPromise(this);\n\t\t\t}\n\t\t\tthis[observeDataSymbol].handlers.add([key, queue || \"mutate\", handler]);\n\t\t},\n\t\t\"can.offKeyValue\": function(key, handler, queue) {\n\t\t\tif(!this[observeDataSymbol]) {\n\t\t\t\tinitPromise(this);\n\t\t\t}\n\t\t\tthis[observeDataSymbol].handlers.delete([key, queue || \"mutate\", handler]);\n\t\t}\n\t});\n}\n\nmodule.exports = setupPromise;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect-promise/can-reflect-promise.js?");

/***/ }),

/***/ "../../node_modules/can-reflect/can-reflect.js":
/*!********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/can-reflect.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar functionReflections = __webpack_require__(/*! ./reflections/call/call */ \"../../node_modules/can-reflect/reflections/call/call.js\");\nvar getSet = __webpack_require__(/*! ./reflections/get-set/get-set */ \"../../node_modules/can-reflect/reflections/get-set/get-set.js\");\nvar observe = __webpack_require__(/*! ./reflections/observe/observe */ \"../../node_modules/can-reflect/reflections/observe/observe.js\");\nvar shape = __webpack_require__(/*! ./reflections/shape/shape */ \"../../node_modules/can-reflect/reflections/shape/shape.js\");\nvar schema = __webpack_require__(/*! ./reflections/shape/schema/schema */ \"../../node_modules/can-reflect/reflections/shape/schema/schema.js\");\nvar type = __webpack_require__(/*! ./reflections/type/type */ \"../../node_modules/can-reflect/reflections/type/type.js\");\nvar getName = __webpack_require__(/*! ./reflections/get-name/get-name */ \"../../node_modules/can-reflect/reflections/get-name/get-name.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\n\nvar reflect = {};\n[\n\tfunctionReflections,\n\tgetSet,\n\tobserve,\n\tshape,\n\ttype,\n\tgetName,\n\tschema\n].forEach(function(reflections){\n\tfor(var prop in reflections) {\n\t\treflect[prop] = reflections[prop];\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tif(typeof reflections[prop] === \"function\") {\n\t\t\t\tvar propDescriptor = Object.getOwnPropertyDescriptor(reflections[prop], 'name');\n\t\t\t\tif (!propDescriptor || propDescriptor.writable && propDescriptor.configurable) {\n\t\t\t\t\tObject.defineProperty(reflections[prop],\"name\",{\n\t\t\t\t\t\tvalue: \"canReflect.\"+prop\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t}\n});\n\n__webpack_require__(/*! ./types/map */ \"../../node_modules/can-reflect/types/map.js\");\n__webpack_require__(/*! ./types/set */ \"../../node_modules/can-reflect/types/set.js\");\n\nmodule.exports = namespace.Reflect = reflect;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/can-reflect.js?");

/***/ }),

/***/ "../../node_modules/can-reflect/reflections/call/call.js":
/*!******************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/call/call.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"../../node_modules/can-reflect/reflections/type/type.js\");\n\nmodule.exports = {\n\t/**\n\t * @function {function(...), Object, ...} can-reflect/call.call call\n\t * @parent can-reflect/call\n\t * @description  Call a callable, with a context object and parameters\n\t *\n\t * @signature `call(func, context, ...rest)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters\n\t * occurring after `context` set to the positional parameters.\n\t *\n\t * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],\n\t * or have a callable `apply` property to work with `canReflect.call`\n\t *\n\t * ```\n\t * var compute = canCompute(\"foo\");\n\t *\n\t * canReflect.call(compute, null, \"bar\");\n\t * canReflect.call(compute, null); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {function(...)} func the function to call with the supplied arguments\n\t * @param  {Object} context the context object to set as `this` on the function call\n\t * @param  {*} rest any arguments after `context` will be passed to the function call\n\t * @return {*}  return types and values are determined by the call to `func`\n\t */\n\tcall: function(func, context){\n\t\tvar args = [].slice.call(arguments, 2);\n\t\tvar apply = func[canSymbol.for(\"can.apply\")];\n\t\tif(apply) {\n\t\t\treturn apply.call(func, context, args);\n\t\t} else {\n\t\t\treturn func.apply(context, args);\n\t\t}\n\t},\n\t/**\n\t * @function {function(...), Object, ...} can-reflect/call.apply apply\n\t * @parent can-reflect/call\n\t * @description  Call a callable, with a context object and a list of parameters\n\t *\n\t * @signature `apply(func, context, args)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters\n\t * contained in the Array-like `args`\n\t *\n\t * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],\n\t * or have a callable `apply` property to work with `canReflect.apply`\n\t *\n\t * ```\n\t * var compute = canCompute(\"foo\");\n\t *\n\t * canReflect.apply(compute, null, [\"bar\"]);\n\t * canReflect.apply(compute, null, []); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {function(...)} func the function to call\n\t * @param  {Object} context the context object to set as `this` on the function call\n\t * @param  {*} args arguments to be passed to the function call\n\t * @return {*}  return types and values are determined by the call to `func`\n\t */\n\tapply: function(func, context, args){\n\t\tvar apply = func[canSymbol.for(\"can.apply\")];\n\t\tif(apply) {\n\t\t\treturn apply.call(func, context, args);\n\t\t} else {\n\t\t\treturn func.apply(context, args);\n\t\t}\n\t},\n\t/**\n\t * @function {function(...), ...} can-reflect/call.new new\n\t * @parent can-reflect/call\n\t * @description  Construct a new instance of a callable constructor\n\t *\n\t * @signature `new(func, ...rest)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to a new instance of `func`, and with any additional\n\t * parameters occurring after `func` set to the positional parameters.\n\t *\n\t * Note that `func` *must* either implement [can-symbol/symbols/new @@@@can.new],\n\t * or have a callable `apply` property *and* a prototype to work with `canReflect.new`\n\t *\n\t * ```\n\t * canReflect.new(DefineList, [\"foo\"]); // -> [\"foo\"]<DefineList>\n\t * ```\n\t *\n\t * @param  {function(...)} func a constructor\n\t * @param  {*} rest arguments to be passed to the constructor\n\t * @return {Object}  if `func` returns an Object, that returned Object; otherwise a new instance of `func`\n\t */\n\t\"new\": function(func){\n\t\tvar args = [].slice.call(arguments, 1);\n\t\tvar makeNew = func[canSymbol.for(\"can.new\")];\n\t\tif(makeNew) {\n\t\t\treturn makeNew.apply(func, args);\n\t\t} else {\n\t\t\tvar context = Object.create(func.prototype);\n\t\t\tvar ret = func.apply(context, args);\n\t\t\tif(typeReflections.isPrimitive(ret)) {\n\t\t\t\treturn context;\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/call/call.js?");

/***/ }),

/***/ "../../node_modules/can-reflect/reflections/get-name/get-name.js":
/*!**************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/get-name/get-name.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"../../node_modules/can-reflect/reflections/type/type.js\");\n\nvar getNameSymbol = canSymbol.for(\"can.getName\");\n\n/**\n * @function {Object, String} can-reflect.setName setName\n * @parent can-reflect/shape\n * @description Set a human-readable name of an object.\n *\n * @signature `setName(obj, value)`\n *\n * ```\n * var f = function() {};\n *\n * canReflect.setName(f, \"myFunction\")\n * f.name //-> \"myFunction\"\n * ```\n *\n * @param {Object} obj   the object to set on\n * @param {String} value the value to set for the object\n */\nfunction setName(obj, nameGetter) {\n\tif (typeof nameGetter !== \"function\") {\n\t\tvar value = nameGetter;\n\t\tnameGetter = function() {\n\t\t\treturn value;\n\t\t};\n\t}\n\n\tObject.defineProperty(obj, getNameSymbol, {\n\t\tvalue: nameGetter\n\t});\n}\n\n/**\n * @function {Object} can-reflect.getName getName\n * @parent can-reflect/shape\n * @description Get the name of an object.\n *\n * @signature `getValue(obj)`\n *\n * @body\n *\n * The [@@@can.getName](can-symbol/symbols/getName.html) symbol is used to\n * provide objects human readable names; the main goal of these names is to help\n * users get a glance of what the object does and what it is used for.\n *\n * There are no hard rules to define names but CanJS uses the following convention\n * for consistent names across its observable types:\n *\n * - The name starts with the observable constructor name\n * - The constructor name is decorated with the following characters based on its type:\n *\t\t- `<>`: for [value-like](can-reflect.isValueLike.html) observables, e.g: `SimpleObservable<>`\n *\t\t- `[]`: for [list-like](can-reflect.isListLike.html) observables, e.g: `DefineList[]`\n *\t\t- `{}`: for [map-like](can-reflect.isMapLike.html) observables, e.g: `DefineMap{}`\n * - Any property that makes the instance unique (like ids) are printed inside\n *    the chars mentioned before.\n *\n * The example below shows how to implement [@@@can.getName](can-symbol/symbols/getName.html),\n * in a value-like observable (similar to [can-simple-observable]).\n *\n * ```js\n * var canReflect = require(\"can-reflect\");\n *\n * function MySimpleObservable(value) {\n *\t\tthis.value = value;\n * }\n *\n * canReflect.assignSymbols(MySimpleObservable.prototype, {\n *\t\t\"can.getName\": function() {\n *\t\t\t//!steal-remove-start\n *\t\t\tif (process.env.NODE_ENV !== 'production') {\n *\t\t\t\tvar value = JSON.stringify(this.value);\n *\t\t\t\treturn canReflect.getName(this.constructor) + \"<\" + value + \">\";\n *\t\t\t}\n *\t\t\t//!steal-remove-end\n *\t\t}\n * });\n * ```\n *\n * With that in place, `MySimpleObservable` can be used like this:\n *\n * ```js\n * var one = new MySimpleObservable(1);\n * canReflect.getName(one); // MySimpleObservable<1>\n * ```\n *\n * @param  {Object} obj The object to get from\n * @return {String} The human-readable name of the object\n */\nfunction getName(obj) {\n\tvar type = typeof obj;\n\tif(obj === null || (type !== \"object\" && type !== \"function\")) {\n\t\treturn \"\"+obj;\n\t}\n\tvar nameGetter = obj[getNameSymbol];\n\tif (nameGetter) {\n\t\treturn nameGetter.call(obj);\n\t}\n\n\tif (type === \"function\") {\n\t\treturn obj.name; // + \"()\" // should we do this?\n\t}\n\n\tif (obj.constructor && obj !== obj.constructor) {\n\t\tvar parent = getName(obj.constructor);\n\t\tif (parent) {\n\t\t\tif (typeReflections.isValueLike(obj)) {\n\t\t\t\treturn parent + \"<>\";\n\t\t\t}\n\n\t\t\tif (typeReflections.isMoreListLikeThanMapLike(obj)) {\n\t\t\t\treturn parent + \"[]\";\n\t\t\t}\n\n\t\t\tif (typeReflections.isMapLike(obj)) {\n\t\t\t\treturn parent + \"{}\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nmodule.exports = {\n\tsetName: setName,\n\tgetName: getName\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/get-name/get-name.js?");

/***/ }),

/***/ "../../node_modules/can-reflect/reflections/get-set/get-set.js":
/*!************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/get-set/get-set.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"../../node_modules/can-reflect/reflections/type/type.js\");\n\nvar setKeyValueSymbol = canSymbol.for(\"can.setKeyValue\"),\n\tgetKeyValueSymbol = canSymbol.for(\"can.getKeyValue\"),\n\tgetValueSymbol = canSymbol.for(\"can.getValue\"),\n\tsetValueSymbol = canSymbol.for(\"can.setValue\");\n\nvar reflections = {\n\t/**\n\t * @function {Object, String, *} can-reflect.setKeyValue setKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Set the value of a named property on a MapLike object.\n\t *\n\t * @signature `setKeyValue(obj, key, value)`\n\t *\n\t * Set the property on Map-like `obj`, identified by the String, Symbol or Object value `key`, to the value `value`.\n\t * The default behavior can be overridden on `obj` by implementing [can-symbol/symbols/setKeyValue @@@@can.setKeyValue],\n\t * otherwise native named property access is used for string keys, and `Object.defineProperty` is used to set symbols.\n\t *\n\t * ```\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.setKeyValue(foo, \"bar\", \"quux\");\n\t * foo[bar]; // -> \"quux\"\n\t * ```\n\t * @param  {Object} obj   the object to set on\n\t * @param  {String} key   the key for the property to set\n\t * @param  {*} value      the value to set on the object\n\t */\n\tsetKeyValue: function(obj, key, value){\n\t\tif( typeReflections.isSymbolLike(key) ) {\n\t\t\tif(typeof key === \"symbol\") {\n\t\t\t\tobj[key] = value;\n\t\t\t} else {\n\t\t\t\tObject.defineProperty(obj, key, {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\twritable: true\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tvar setKeyValue = obj[setKeyValueSymbol];\n\t\tif(setKeyValue !== undefined) {\n\t\t\treturn setKeyValue.call(obj, key, value);\n\t\t} else {\n\t\t\tobj[key] = value;\n\t\t}\n\t},\n\t/**\n\t * @function {Object, String} can-reflect.getKeyValue getKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Get the value of a named property on a MapLike object.\n\t *\n\t * @signature `getKeyValue(obj, key)`\n\t *\n\t * Retrieve the property on Map-like `obj` identified by the String or Symbol value `key`.  The default behavior\n\t * can be overridden on `obj` by implementing [can-symbol/symbols/getKeyValue @@@@can.getKeyValue],\n\t * otherwise native named property access is used.\n\t *\n\t * ```\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.getKeyValue(foo, \"bar\"); // -> \"baz\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to get from\n\t * @param  {String} key   the key of the property to get\n\t */\n\tgetKeyValue: function(obj, key) {\n\t\tvar getKeyValue = obj[getKeyValueSymbol];\n\t\tif(getKeyValue) {\n\t\t\treturn getKeyValue.call(obj, key);\n\t\t}\n\t\treturn obj[key];\n\t},\n\t/**\n\t * @function {Object, String} can-reflect.deleteKeyValue deleteKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Delete a named property from a MapLike object.\n\t *\n\t * @signature `deleteKeyValue(obj, key)`\n\t *\n\t * Remove the property identified by the String or Symbol `key` from the Map-like object `obj`, if possible.\n\t * Property definitions may interfere with deleting key values; the behavior on `obj` if `obj[key]` cannot\n\t * be deleted is undefined.  The default use of the native `delete` keyword can be overridden by `obj` if it\n\t * implements [can-symbol/symbols/deleteKeyValue @@@@can.deleteKeyValue].\n\t *\n\t * ```\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t * var quux = new CanMap({ thud: \"jeek\" });\n\t *\n\t * canReflect.deleteKeyValue(foo, \"bar\");\n\t * canReflect.deleteKeyValue(quux, \"thud\");\n\t *\n\t * \"bar\" in foo; // ->  true  -- DefineMaps use property defs which cannot be un-defined\n\t * foo.bar // -> undefined    --  but set values to undefined when deleting\n\t *\n\t * \"thud\" in quux; // -> false\n\t * quux.thud; // -> undefined\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to delete on\n\t * @param  {String} key   the key for the property to delete\n\t */\n\tdeleteKeyValue: function(obj, key) {\n\t\tvar deleteKeyValue = obj[canSymbol.for(\"can.deleteKeyValue\")];\n\t\tif(deleteKeyValue) {\n\t\t\treturn deleteKeyValue.call(obj, key);\n\t\t}\n\t\tdelete obj[key];\n\t},\n\t/**\n\t * @function {Object} can-reflect.getValue getValue\n\t * @parent can-reflect/get-set\n\t * @description Get the value of an object with a gettable value\n\t *\n\t * @signature `getValue(obj)`\n\t *\n\t * Return the value of the Value-like object `obj`.  Unless `obj` implements\n\t * [can-symbol/symbols/getValue @@@@can.getValue], the result of `getValue` on\n\t * `obj` will always be `obj`.  Observable Map-like objects may want to implement\n\t * `@@@@can.getValue` to return non-observable or plain representations of themselves.\n\t *\n\t * ```\n\t * var compute = canCompute(\"foo\");\n\t * var primitive = \"bar\";\n\t *\n\t * canReflect.getValue(compute); // -> \"foo\"\n\t * canReflect.getValue(primitive); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to get from\n\t * @return {*} the value of the object via `@@can.getValue`, or the value itself.\n\t */\n\tgetValue: function(value){\n\t\tif(typeReflections.isPrimitive(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tvar getValue = value[getValueSymbol];\n\t\tif(getValue) {\n\t\t\treturn getValue.call(value);\n\t\t}\n\t\treturn value;\n\t},\n\t/**\n\t * @function {Object, *} can-reflect.setValue setValue\n\t * @parent can-reflect/get-set\n\t * @description Set the value of a mutable object.\n\t *\n\t * @signature `setValue(obj, value)`\n\t *\n\t * Set the value of a Value-like object `obj` to the value `value`.  `obj` *must* implement\n\t * [can-symbol/symbols/setValue @@@@can.setValue] to be used with `canReflect.setValue`.\n\t * Map-like objects may want to implement `@@@@can.setValue` to merge objects of properties\n\t * into themselves.\n\t *\n\t * ```\n\t * var compute = canCompute(\"foo\");\n\t * var plain = {};\n\t *\n\t * canReflect.setValue(compute, \"bar\");\n\t * compute(); // -> bar\n\t *\n\t * canReflect.setValue(plain, { quux: \"thud\" }); // throws \"can-reflect.setValue - Can not set value.\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to set on\n\t * @param  {*} value      the value to set for the object\n\t */\n\tsetValue: function(item, value){\n\t\tvar setValue = item && item[setValueSymbol];\n\t\tif(setValue) {\n\t\t\treturn setValue.call(item, value);\n\t\t} else {\n\t\t\tthrow new Error(\"can-reflect.setValue - Can not set value.\");\n\t\t}\n\t},\n\n\tsplice: function(obj, index, removing, adding){\n\t\tvar howMany;\n\t\tif(typeof removing !== \"number\") {\n\t\t\tvar updateValues = obj[canSymbol.for(\"can.updateValues\")];\n\t\t\tif(updateValues) {\n\t\t\t\treturn updateValues.call(obj, index, removing, adding);\n\t\t\t}\n\t\t\thowMany = removing.length;\n\t\t} else {\n\t\t\thowMany = removing;\n\t\t}\n\n\t\tif(arguments.length <= 3){\n\t\t\tadding = [];\n\t\t}\n\n\t\tvar splice = obj[canSymbol.for(\"can.splice\")];\n\t\tif(splice) {\n\t\t\treturn splice.call(obj, index, howMany, adding);\n\t\t}\n\t\treturn [].splice.apply(obj, [index, howMany].concat(adding) );\n\t},\n\taddValues: function(obj, adding, index) {\n\t\tvar add = obj[canSymbol.for(\"can.addValues\")];\n\t\tif(add) {\n\t\t\treturn add.call(obj, adding, index);\n\t\t}\n\t\tif(Array.isArray(obj) && index === undefined) {\n\t\t\treturn obj.push.apply(obj, adding);\n\t\t}\n\t\treturn reflections.splice(obj, index, [], adding);\n\t},\n\tremoveValues: function(obj, removing, index) {\n\t\tvar removeValues = obj[canSymbol.for(\"can.removeValues\")];\n\t\tif(removeValues) {\n\t\t\treturn removeValues.call(obj, removing, index);\n\t\t}\n\t\tif(Array.isArray(obj) && index === undefined) {\n\t\t\tremoving.forEach(function(item){\n\t\t\t\tvar index = obj.indexOf(item);\n\t\t\t\tif(index >=0) {\n\t\t\t\t\tobj.splice(index, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\treturn reflections.splice(obj, index, removing, []);\n\t}\n};\n/**\n * @function {Object, String} can-reflect.get get\n * @hide\n * @description an alias for [can-reflect.getKeyValue getKeyValue]\n */\nreflections.get = reflections.getKeyValue;\n/**\n * @function {Object, String} can-reflect.set set\n * @hide\n * @description an alias for [can-reflect.setKeyValue setKeyValue]\n */\nreflections.set = reflections.setKeyValue;\n/**\n * @function {Object, String} can-reflect.delete delete\n * @hide\n * @description an alias for [can-reflect.deleteKeyValue deleteKeyValue]\n */\nreflections[\"delete\"] = reflections.deleteKeyValue;\n\nmodule.exports = reflections;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/get-set/get-set.js?");

/***/ }),

/***/ "../../node_modules/can-reflect/reflections/helpers.js":
/*!****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/helpers.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n\nmodule.exports = {\n\tmakeGetFirstSymbolValue: function(symbolNames){\n\t\tvar symbols = symbolNames.map(function(name){\n\t\t\treturn canSymbol.for(name);\n\t\t});\n\t\tvar length = symbols.length;\n\n\t\treturn function getFirstSymbol(obj){\n\t\t\tvar index = -1;\n\n\t\t\twhile (++index < length) {\n\t\t\t\tif(obj[symbols[index]] !== undefined) {\n\t\t\t\t\treturn obj[symbols[index]];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t},\n\t// The `in` check is from jQuery’s fix for an iOS 8 64-bit JIT object length bug:\n\t// https://github.com/jquery/jquery/pull/2185\n\thasLength: function(list){\n\t\tvar type = typeof list;\n\t\tif(type === \"string\" || Array.isArray(list)) {\n\t\t\treturn true;\n\t\t}\n\t\tvar length = list && (type !== 'boolean' && type !== 'number' && \"length\" in list) && list.length;\n\n\t\t// var length = \"length\" in obj && obj.length;\n\t\treturn typeof list !== \"function\" &&\n\t\t\t( length === 0 || typeof length === \"number\" && length > 0 && ( length - 1 ) in list );\n\t}\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/helpers.js?");

/***/ }),

/***/ "../../node_modules/can-reflect/reflections/observe/observe.js":
/*!************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/observe/observe.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n\nvar slice = [].slice;\n\nfunction makeFallback(symbolName, fallbackName) {\n\treturn function(obj, event, handler, queueName){\n\t\tvar method = obj[canSymbol.for(symbolName)];\n\t\tif(method !== undefined) {\n\t\t\treturn method.call(obj, event, handler, queueName);\n\t\t}\n\t\treturn this[fallbackName].apply(this, arguments);\n\t};\n}\n\nfunction makeErrorIfMissing(symbolName, errorMessage){\n\treturn function(obj){\n\t\tvar method = obj[canSymbol.for(symbolName)];\n\t\tif(method !== undefined) {\n\t\t\tvar args = slice.call(arguments, 1);\n\t\t\treturn method.apply(obj, args);\n\t\t}\n\t\tthrow new Error(errorMessage);\n\t};\n}\n\nmodule.exports = {\n\t// KEY\n\t/**\n\t * @function {Object, String, function(*, *), String} can-reflect/observe.onKeyValue onKeyValue\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `onKeyValue(obj, key, handler, [queueName])`\n\t *\n\t * Register a handler on the Map-like object `obj` to trigger when the property key `key` changes.\n\t * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onKeyValue] to be compatible with\n\t * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of the property\n\t * as the first argument, and the previous value of the property as the second argument.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeyValue(obj, \"foo\", function(newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * obj.foo = \"baz\";  // -> logs \"foo is now baz , was bar\"\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {String} key  the key to listen to\n\t * @param {function(*, *)} handler a callback function that recieves the new value\n\t * @param {String} [queueName]  the queue to dispatch events to\n\t */\n\tonKeyValue: makeFallback(\"can.onKeyValue\", \"onEvent\"),\n\t/**\n\t * @function {Object, String, function(*), String} can-reflect/observe.offKeyValue offKeyValue\n\t * @parent can-reflect/observe\n\t * @description  Unregister an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `offKeyValue(obj, key, handler, [queueName])`\n\t *\n\t * Unregister a handler from the Map-like object `obj` that had previously been registered with\n\t * [can-reflect/observe.onKeyValue onKeyValue]. The function passed as `handler` will no longer be called\n\t * when the value of `key` on `obj` changes.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * var handler = function(newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onKeyValue(obj, \"foo\", handler);\n\t * canReflect.offKeyValue(obj, \"foo\", handler);\n\t *\n\t * obj.foo = \"baz\";  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {String} key  the key to stop listening to\n\t * @param {function(*)} handler the callback function that should be removed from the event handlers for `key`\n\t * @param {String} [queueName]  the queue that the handler was set to receive events from\n\t */\n\toffKeyValue: makeFallback(\"can.offKeyValue\",\"offEvent\"),\n\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeys onKeys\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on the key set changing\n\t *\n\t * @signature `onKeys(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when `obj`'s keyset changes.\n\t * `obj` *must* implement [can-symbol/symbols/onKeys @@@@can.onKeys] to be compatible with\n\t * can-reflect.onKeys.  The function passed as `handler` will receive an Array of object diffs (see\n\t * [can-util/js/diff-object/diff-object diffObject] for the format) as its one argument.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeys(obj, function(diffs) {\n\t * \tconsole.log(diffs);\n\t * });\n\t *\n\t * obj.set(\"baz\", \"quux\");  // -> logs '[{\"property\": \"baz\", \"type\": \"add\", \"value\": \"quux\"}]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the diffs in the key set\n\t */\n\t// any key change (diff would normally happen)\n\tonKeys: makeErrorIfMissing(\"can.onKeys\",\"can-reflect: can not observe an onKeys event\"),\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeysAdded onKeysAdded\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on new keys being added.\n\t *\n\t * @signature `onKeysAdded(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when a new key or keys are set on\n\t * `obj`. `obj` *must* implement [can-symbol/symbols/onKeysAdded @@@@can.onKeysAdded] to be compatible with\n\t * can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of Strings as its one\n\t * argument.\n\t *\n\t * ```\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeysAded(obj, function(newKeys) {\n\t * \tconsole.log(newKeys);\n\t * });\n\t *\n\t * foo.set(\"baz\", \"quux\");  // -> logs '[\"baz\"]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the array of added keys\n\t */\n\t// keys added at a certain point {key: 1}, index\n\tonKeysAdded: makeErrorIfMissing(\"can.onKeysAdded\",\"can-reflect: can not observe an onKeysAdded event\"),\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeysRemoved onKeysRemoved\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on keys being deleted.\n\t *\n\t * @signature `onKeysRemoved(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when a key or keys are removed from\n\t * `obj`'s keyset. `obj` *must* implement [can-symbol/symbols/onKeysRemoved @@@@can.onKeysRemoved] to be\n\t * compatible with can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of\n\t * Strings as its one argument.\n\t *\n\t * ```\n\t * var obj = new CanMap({ foo: \"bar\" });\n\t * canReflect.onKeys(obj, function(diffs) {\n\t * \tconsole.log(JSON.stringify(diffs));\n\t * });\n\t *\n\t * foo.removeAttr(\"foo\");  // -> logs '[\"foo\"]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the array of removed keys\n\t */\n\tonKeysRemoved: makeErrorIfMissing(\"can.onKeysRemoved\",\"can-reflect: can not unobserve an onKeysRemoved event\"),\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.getKeyDependencies getKeyDependencies\n\t * @parent can-reflect/observe\n\t * @description  Return the observable objects that compute to the value of a named property on an object\n\t *\n\t * @signature `getKeyDependencies(obj, key)`\n\t *\n\t * Return the observable objects that provide input values to generate the computed value of the\n\t * property `key` on Map-like object `obj`.  If `key` does not have dependencies on `obj`, returns `undefined`.\n\t * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that\n\t * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a\n\t * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/getKeyDependencies @@@@can.getKeyDependencies] to work with\n\t * `canReflect.getKeyDependencies`.\n\t *\n\t *\n\t * ```\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = new (DefineMap.extend({\n\t * \t baz: {\n\t * \t   get: function() {\n\t * \t     return foo.bar;\n\t * \t   }\n\t * \t }\n\t * }))();\n\t *\n\t * canReflect.getKeyDependencies(obj, \"baz\");  // -> { valueDependencies: CIDSet }\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for key dependencies\n\t * @param {String} key the key on the object to check\n\t * @return {Object} the observable values that this keyed value depends on\n\t */\n\tgetKeyDependencies: makeErrorIfMissing(\"can.getKeyDependencies\", \"can-reflect: can not determine dependencies\"),\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.getWhatIChange getWhatIChange\n\t * @hide\n\t * @parent can-reflect/observe\n\t * @description Return the observable objects that derive their value from the\n\t * obj, passed in.\n\t *\n\t * @signature `getWhatIChange(obj, key)`\n\t *\n\t * `obj` *must* implement `@@@@can.getWhatIChange` to work with\n\t * `canReflect.getWhatIChange`.\n\t *\n\t * @param {Object} obj the object to check for what it changes\n\t * @param {String} [key] the key on the object to check\n\t * @return {Object} the observable values that derive their value from `obj`\n\t */\n\tgetWhatIChange: makeErrorIfMissing(\n\t\t\"can.getWhatIChange\",\n\t\t\"can-reflect: can not determine dependencies\"\n\t),\n\n\t/**\n\t * @function {Function} can-reflect/observe.getChangesDependencyRecord getChangesDependencyRecord\n\t * @hide\n\t * @parent can-reflect/observe\n\t * @description Return the observable objects that are mutated by the handler\n\t * passed in as argument.\n\t *\n\t * @signature `getChangesDependencyRecord(handler)`\n\t *\n\t * `handler` *must* implement `@@@@can.getChangesDependencyRecord` to work with\n\t * `canReflect.getChangesDependencyRecord`.\n\t *\n\t * ```\n\t * var one = new SimpleObservable(\"one\");\n\t * var two = new SimpleObservable(\"two\");\n\t *\n\t * var handler = function() {\n\t *\ttwo.set(\"2\");\n\t * };\n\t *\n\t * canReflect.onValue(one, handler);\n\t * canReflect.getChangesDependencyRecord(handler); // -> { valueDependencies: new Set([two]) }\n\t * ```\n\t *\n\t * @param {Function} handler the event handler to check for what it changes\n\t * @return {Object} the observable values that are mutated by the handler\n\t */\n\tgetChangesDependencyRecord: function getChangesDependencyRecord(handler) {\n\t\tvar fn = handler[canSymbol.for(\"can.getChangesDependencyRecord\")];\n\n\t\tif (typeof fn === \"function\") {\n\t\t\treturn fn();\n\t\t}\n\t},\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.keyHasDependencies keyHasDependencies\n\t * @parent can-reflect/observe\n\t * @description  Determine whether the value for a named property on an object is bound to other events\n\t *\n\t * @signature `keyHasDependencies(obj, key)`\n\t *\n\t * Returns `true` if the computed value of the property `key` on Map-like object `obj` derives from other values.\n\t * Returns `false` if `key` is computed on `obj` but does not have dependencies on other objects. If `key` is not\n\t * a computed value on `obj`, returns `undefined`.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/keyHasDependencies @@@@can.keyHasDependencies] to work with\n\t * `canReflect.keyHasDependencies`.\n\t *\n\t * ```\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = new (DefineMap.extend({\n\t * \t baz: {\n\t * \t   get: function() {\n\t * \t     return foo.bar;\n\t * \t   }\n\t * \t },\n\t * \t quux: {\n\t * \t \t get: function() {\n\t * \t \t   return \"thud\";\n\t * \t \t }\n\t * \t }\n\t * }))();\n\t *\n\t * canReflect.keyHasDependencies(obj, \"baz\");  // -> true\n\t * canReflect.keyHasDependencies(obj, \"quux\");  // -> false\n\t * canReflect.keyHasDependencies(foo, \"bar\");  // -> undefined\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for key dependencies\n\t * @param {String} key the key on the object to check\n\t * @return {Boolean} `true` if there are other objects that may update the keyed value; `false` otherwise\n\t *\n\t */\n\t// TODO: use getKeyDeps once we know what that needs to look like\n\tkeyHasDependencies: makeErrorIfMissing(\"can.keyHasDependencies\",\"can-reflect: can not determine if this has key dependencies\"),\n\n\t// VALUE\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.onValue onValue\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on an observable ValueLike object, based on a change in its value\n\t *\n\t * @signature `onValue(handler, [queueName])`\n\t *\n\t * Register an event handler on the Value-like object `obj` to trigger when its value changes.\n\t * `obj` *must* implement [can-symbol/symbols/onValue @@@@can.onValue] to be compatible with\n\t * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of `obj`\n\t * as the first argument, and the previous value of `obj` as the second argument.\n\t *\n\t * ```\n\t * var obj = canCompute(\"foo\");\n\t * canReflect.onValue(obj, function(newVal, oldVal) {\n\t * \tconsole.log(\"compute is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * obj(\"bar\");  // -> logs \"compute is now bar , was foo\"\n\t * ```\n\t *\n\t * @param {*} obj  any object implementing @@can.onValue\n\t * @param {function(*, *)} handler  a callback function that receives the new and old values\n\t */\n\tonValue: makeErrorIfMissing(\"can.onValue\",\"can-reflect: can not observe value change\"),\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.offValue offValue\n\t * @parent can-reflect/observe\n\t * @description  Unregister an value change handler from an observable ValueLike object\n\t *\n\t * @signature `offValue(handler, [queueName])`\n\t *\n\t * Unregister an event handler from the Value-like object `obj` that had previously been registered with\n\t * [can-reflect/observe.onValue onValue]. The function passed as `handler` will no longer be called\n\t * when the value of `obj` changes.\n\t *\n\t * ```\n\t * var obj = canCompute( \"foo\" );\n\t * var handler = function(newVal, oldVal) {\n\t * \tconsole.log(\"compute is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onKeyValue(obj, handler);\n\t * canReflect.offKeyValue(obj, handler);\n\t *\n\t * obj(\"baz\");  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t */\n\toffValue: makeErrorIfMissing(\"can.offValue\",\"can-reflect: can not unobserve value change\"),\n\n\t/**\n\t * @function {Object} can-reflect/observe.getValueDependencies getValueDependencies\n\t * @parent can-reflect/observe\n\t * @description  Return all the events that bind to the value of an observable, Value-like object\n\t *\n\t * @signature `getValueDependencies(obj)`\n\t *\n\t * Return the observable objects that provide input values to generate the computed value of the\n\t * Value-like object `obj`.  If `obj` does not have dependencies, returns `undefined`.\n\t * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that\n\t * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a\n\t * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/getValueDependencies @@@@can.getValueDependencies] to work with\n\t * `canReflect.getValueDependencies`.\n\t *\n\t *\n\t * ```\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = canCompute(function() {\n\t * \t return foo.bar;\n\t * });\n\t *\n\t * canReflect.getValueDependencies(obj);  // -> { valueDependencies: CIDSet } because `obj` is internally backed by\n\t * a [can-observation]\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for value dependencies\n\t * @return {Object} the observable objects that `obj`'s value depends on\n\t *\n\t */\n\tgetValueDependencies: makeErrorIfMissing(\"can.getValueDependencies\",\"can-reflect: can not determine dependencies\"),\n\n\t/**\n\t * @function {Object} can-reflect/observe.valueHasDependencies valueHasDependencies\n\t * @parent can-reflect/observe\n\t * @description  Determine whether the value of an observable object is bound to other events\n\t *\n\t * @signature `valueHasDependencies(obj)`\n\t *\n\t * Returns `true` if the computed value of the Value-like object `obj` derives from other values.\n\t * Returns `false` if `obj` is computed but does not have dependencies on other objects. If `obj` is not\n\t * a computed value, returns `undefined`.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/valueHasDependencies @@@@can.valueHasDependencies] to work with\n\t * `canReflect.valueHasDependencies`.\n\t *\n\t * ```\n\t * var foo = canCompute( \"bar\" );\n\t * var baz = canCompute(function() {\n\t * \t return foo();\n\t * });\n\t * var quux = \"thud\";\n\t * var jeek = canCompute(function(plonk) {\n\t * \t if(argument.length) {\n\t * \t \t  quux = plonk;\n\t * \t }\n\t * \t return quux;\n\t * });\n\t *\n\t * canReflect.valueHasDependencies(baz);  // -> true\n\t * canReflect.valueHasDependencies(jeek);  // -> false\n\t * canReflect.valueHasDependencies(foo);  // -> undefined\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for dependencies\n\t * @return {Boolean} `true` if there are other dependencies that may update the object's value; `false` otherwise\n\t *\n\t */\n\tvalueHasDependencies: makeErrorIfMissing(\"can.valueHasDependencies\",\"can-reflect: can not determine if value has dependencies\"),\n\n\t// PATCHES\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.onPatches onPatches\n\t * @parent can-reflect/observe\n\t * @description  Register an handler on an observable that listens to any key changes\n\t *\n\t * @signature `onPatches(obj, handler, [queueName])`\n\t *\n\t * Register an event handler on the object `obj` that fires when anything changes on an object: a key value is added,\n\t * an existing key has is value changed, or a key is deleted from the object.\n\t *\n\t * If object is an array-like and the changed property includes numeric indexes, patch sets will include array-specific\n\t * patches in addition to object-style patches\n\t *\n\t * For more on the patch formats, see [can-util/js/diff-object/diff-object] and [can-util/js/diff-array/diff-array].\n\t *\n\t * ```\n\t * var obj = new DefineMap({});\n\t * var handler = function(patches) {\n\t * \tconsole.log(patches);\n\t * };\n\t *\n\t * canReflect.onPatches(obj, handler);\n\t * obj.set(\"foo\", \"bar\");  // logs [{ type: \"add\", property: \"foo\", value: \"bar\" }]\n\t * obj.set(\"foo\", \"baz\");  // logs [{ type: \"set\", property: \"foo\", value: \"baz\" }]\n\t *\n\t * var arr = new DefineList([]);\n\t * canReflect.onPatches(arr, handler);\n\t * arr.push(\"foo\");  // logs [{type: \"add\", property:\"0\", value: \"foo\"},\n\t *                            {index: 0, deleteCount: 0, insert: [\"foo\"]}]\n   * arr.pop();  // logs [{type: \"remove\", property:\"0\"},\n\t *                            {index: 0, deleteCount: 1, insert: []}]\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue\n\t */\n\tonPatches: makeErrorIfMissing(\"can.onPatches\", \"can-reflect: can not observe patches on object\"),\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.offPatches offPatches\n\t * @parent can-reflect/observe\n\t * @description  Unregister an object patches handler from an observable object\n\t *\n\t * @signature `offPatches(obj, handler, [queueName])`\n\t *\n\t * Unregister an event handler from the object `obj` that had previously been registered with\n\t * [can-reflect/observe.onPatches onPatches]. The function passed as `handler` will no longer be called\n\t * when `obj` has key or index changes.\n\t *\n\t * ```\n\t * var obj = new DefineMap({});\n\t * var handler = function(patches) {\n\t * \tconsole.log(patches);\n\t * };\n\t *\n\t * canReflect.onPatches(obj, handler);\n\t * canReflect.offPatches(obj, handler);\n\t *\n\t * obj.set(\"foo\", \"bar\");  // nothing is logged\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under\n\t */\n\toffPatches: makeErrorIfMissing(\"can.offPatches\", \"can-reflect: can not unobserve patches on object\"),\n\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.onInstancePatches onInstancePatches\n\t * @parent can-reflect/observe\n\t *\n\t * @description Registers a handler that listens to patch events on any instance\n\t *\n\t * @signature `onInstancePatches(Type, handler(instance, patches))`\n\t *\n\t * Listens to patch changes on any instance of `Type`. This is used by [can-connect]\n\t * to know when a potentially `unbound` instance's `id` changes. If the `id` changes,\n\t * the instance can be moved into the store while it is being saved. E.g:\n\t *\n\t * ```js\n\t * canReflect.onInstancePatches(Map, function onInstancePatches(instance, patches) {\n\t *\tpatches.forEach(function(patch) {\n\t *\t\tif (\n\t *\t\t\t(patch.type === \"add\" || patch.type === \"set\") &&\n\t *\t\t\tpatch.key === connection.idProp &&\n\t *\t\t\tcanReflect.isBound(instance)\n\t *\t\t) {\n\t *\t\t\tconnection.addInstanceReference(instance);\n\t *\t\t}\n\t *\t});\n\t *});\n\t * ```\n\t *\n\t * @param {*} Type\n\t * @param {function(*)} handler\n\t */\n\tonInstancePatches: makeErrorIfMissing(\n\t\t\"can.onInstancePatches\",\n\t\t\"can-reflect: can not observe onInstancePatches on Type\"\n\t),\n\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.offInstancePatches offInstancePatches\n\t * @parent can-reflect/observe\n\t *\n\t * @description Unregisters a handler registered through [can-reflect/observe.onInstancePatches]\n\t *\n\t * @signature `offInstancePatches(Type, handler(instance, patches))`\n\t *\n\t * ```js\n\t * canReflect.offInstancePatches(Map, onInstancePatches);\n\t * ```\n\t *\n\t * @param {*} Type\n\t * @param {function(*)} handler\n\t */\n\toffInstancePatches: makeErrorIfMissing(\n\t\t\"can.offInstancePatches\",\n\t\t\"can-reflect: can not unobserve onInstancePatches on Type\"\n\t),\n\n\t// HAS BINDINGS VS DOES NOT HAVE BINDINGS\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.onInstanceBoundChange onInstanceBoundChange\n\t * @parent can-reflect/observe\n\t * @description Listen to when observables of a type are bound and unbound.\n\t *\n\t * @signature `onInstanceBoundChange(Type, handler, [queueName])`\n\t *\n\t * Register an event handler on the object `Type` that fires when instances of the type become bound (the first handler is added)\n\t * or unbound (the last remaining handler is removed). The function passed as `handler` will be called\n\t * with the `instance` as the first argument and `true` as the second argument when `instance` gains its first binding,\n\t * and called with `false` when `instance` loses its\n\t * last binding.\n\t *\n\t * ```\n\t * Person = DefineMap.extend({ ... });\n\t *\n\t * var person = Person({});\n\t * var handler = function(instance, newVal) {\n\t * \tconsole.log(instance, \"bound state is now\", newVal);\n\t * };\n\t * var keyHandler = function() {};\n\t *\n\t * canReflect.onInstanceBoundChange(Person, handler);\n\t * canReflect.onKeyValue(obj, \"name\", keyHandler);  // logs person Bound state is now true\n\t * canReflect.offKeyValue(obj, \"name\", keyHandler);  // logs person Bound state is now false\n\t * ```\n\t *\n\t * @param {function} Type A constructor function\n\t * @param {function(*,Boolean)} handler(instance,isBound) A function called with the `instance` whose bound status changed and the state of the bound status.\n\t * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue\n\t */\n\tonInstanceBoundChange: makeErrorIfMissing(\"can.onInstanceBoundChange\", \"can-reflect: can not observe bound state change in instances.\"),\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.offInstanceBoundChange offInstanceBoundChange\n\t * @parent can-reflect/observe\n\t * @description Stop listening to when observables of a type are bound and unbound.\n\t *\n\t * @signature `offInstanceBoundChange(Type, handler, [queueName])`\n\t *\n\t * Unregister an event handler from the type `Type` that had previously been registered with\n\t * [can-reflect/observe.onInstanceBoundChange onInstanceBoundChange]. The function passed as `handler` will no longer be called\n\t * when instances of `Type` gains its first or loses its last binding.\n\t *\n\t * ```\n\t * Person = DefineMap.extend({ ... });\n\t *\n\t * var person = Person({});\n\t * var handler = function(instance, newVal) {\n\t * \tconsole.log(instance, \"bound state is now\", newVal);\n\t * };\n\t * var keyHandler = function() {};\n\t *\n\t * canReflect.onInstanceBoundChange(Person, handler);\n\t * canReflect.offInstanceBoundChange(Person, handler);\n\t * canReflect.onKeyValue(obj, \"name\", keyHandler);  // nothing is logged\n\t * canReflect.offKeyValue(obj, \"name\", keyHandler); // nothing is logged\n\t * ```\n\t *\n\t * @param {function} Type A constructor function\n\t * @param {function(*,Boolean)} handler(instance,isBound) The `handler` passed to `canReflect.onInstanceBoundChange`.\n\t * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under\n\t */\n\toffInstanceBoundChange: makeErrorIfMissing(\"can.offInstanceBoundChange\", \"can-reflect: can not unobserve bound state change\"),\n\t/**\n\t * @function {Object} can-reflect/observe.isBound isBound\n\t * @parent can-reflect/observe\n\t * @description  Determine whether any listeners are bound to the observable object\n\t *\n\t * @signature `isBound(obj)`\n\t *\n\t * `isBound` queries an observable object to find out whether any listeners have been set on it using\n\t * [can-reflect/observe.onKeyValue onKeyValue] or [can-reflect/observe.onValue onValue]\n\t *\n\t * ```\n\t * var obj = new DefineMap({});\n\t * var handler = function() {};\n\t * canReflect.isBound(obj); // -> false\n\t * canReflect.onKeyValue(obj, \"foo\", handler);\n\t * canReflect.isBound(obj); // -> true\n\t * canReflect.offKeyValue(obj, \"foo\", handler);\n\t * canReflect.isBound(obj); // -> false\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @return {Boolean} `true` if obj has at least one key-value or value listener, `false` otherwise\n\t */\n\tisBound: makeErrorIfMissing(\"can.isBound\", \"can-reflect: cannot determine if object is bound\"),\n\n\t// EVENT\n\t/**\n\t * @function {Object, String, function(*)} can-reflect/observe.onEvent onEvent\n\t * @parent can-reflect/observe\n\t * @description  Register a named event handler on an observable object\n\t *\n\t * @signature `onEvent(obj, eventName, callback)`\n\t *\n\t *\n\t * Register an event handler on the object `obj` to trigger when the event `eventName` is dispatched.\n\t * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onEvent] or `.addEventListener()` to be compatible\n\t * with can-reflect.onKeyValue.  The function passed as `callback` will receive the event descriptor as the first\n\t * argument, and any data passed to the event dispatch as subsequent arguments.\n\t *\n\t * ```\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onEvent(obj, \"foo\", function(ev, newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * canEvent.dispatch.call(obj, \"foo\", [\"baz\", \"quux\"]);  // -> logs \"foo is now baz , was quux\"\n\t * ```\n\t *\n\t * @param {Object} obj the object to bind a new event handler to\n\t * @param {String} eventName the name of the event to bind the handler to\n\t * @param {function(*)} callback  the handler function to bind to the event\n\t */\n\tonEvent: function(obj, eventName, callback, queue){\n\t\tif(obj) {\n\t\t\tvar onEvent = obj[canSymbol.for(\"can.onEvent\")];\n\t\t\tif(onEvent !== undefined) {\n\t\t\t\treturn onEvent.call(obj, eventName, callback, queue);\n\t\t\t} else if(obj.addEventListener) {\n\t\t\t\tobj.addEventListener(eventName, callback, queue);\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * @function {Object, String, function(*)} can-reflect/observe.offValue offEvent\n\t * @parent can-reflect/observe\n\t * @description  Unregister an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `offEvent(obj, eventName, callback)`\n\t *\n\t * Unregister an event handler from the object `obj` that had previously been registered with\n\t * [can-reflect/observe.onEvent onEvent]. The function passed as `callback` will no longer be called\n\t * when the event named `eventName` is dispatched on `obj`.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * var handler = function(ev, newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onEvent(obj, \"foo\", handler);\n\t * canReflect.offEvent(obj, \"foo\", handler);\n\t *\n\t * canEvent.dispatch.call(obj, \"foo\", [\"baz\", \"quux\"]);  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {Object} obj the object to unbind an event handler from\n\t * @param {String} eventName the name of the event to unbind the handler from\n\t * @param {function(*)} callback the handler function to unbind from the event\n\t */\n\toffEvent: function(obj, eventName, callback, queue){\n\t\tif(obj) {\n\t\t\tvar offEvent = obj[canSymbol.for(\"can.offEvent\")];\n\t\t\tif(offEvent !== undefined) {\n\t\t\t\treturn offEvent.call(obj, eventName, callback, queue);\n\t\t\t}  else if(obj.removeEventListener) {\n\t\t\t\tobj.removeEventListener(eventName, callback, queue);\n\t\t\t}\n\t\t}\n\n\t},\n\t/**\n\t * @function {function} can-reflect/setPriority setPriority\n\t * @parent can-reflect/observe\n\t * @description  Provide a priority for when an observable that derives its\n\t * value should be re-evaluated.\n\t *\n\t * @signature `setPriority(obj, priority)`\n\t *\n\t * Calls an underlying `@@can.setPriority` symbol on `obj` if it exists with `priorty`.\n\t * Returns `true` if a priority was set, `false` if otherwise.\n\t *\n\t * Lower priorities (`0` being the lowest), will be an indication to run earlier than\n\t * higher priorities.\n\t *\n\t * ```js\n\t * var obj = canReflect.assignSymbols({},{\n\t *   \"can.setPriority\": function(priority){\n\t *     return this.priority = priority;\n\t *   }\n\t * });\n\t *\n\t * canReflect.setPriority(obj, 0) //-> true\n\t * obj.priority //-> 0\n\t *\n\t * canReflect.setPriority({},20) //-> false\n\t * ```\n\t *\n\t * @param {Object} obj An observable that will update its priority.\n\t * @param {Number} priority The priority number.  Lower priorities (`0` being the lowest),\n\t * indicate to run earlier than higher priorities.\n\t * @return {Boolean} `true` if a priority was able to be set, `false` if otherwise.\n\t *\n\t * @body\n\t *\n\t * ## Use\n\t *\n\t * There's often a need to specify the order of re-evaluation for\n\t * __observables__ that derive (or compute) their value from other observables.\n\t *\n\t * This is needed by templates to avoid unnecessary re-evaluation.  Say we had the following template:\n\t *\n\t * ```js\n\t * {{#if value}}\n\t *   {{value}}\n\t * {{/if}}\n\t * ```\n\t *\n\t * If `value` became falsey, we'd want the `{{#if}}` to be aware of it before\n\t * the `{{value}}` magic tags updated. We can do that by setting priorities:\n\t *\n\t * ```js\n\t * canReflect.setPriority(magicIfObservable, 0);\n\t * canReflect.setPriority(magicValueObservable,1);\n\t * ```\n\t *\n\t * Internally, those observables will use that `priority` to register their\n\t * re-evaluation with the `derive` queue in [can-queues].\n\t *\n\t */\n\tsetPriority: function(obj, priority) {\n\t\tif(obj) {\n\t\t\tvar setPriority =  obj[canSymbol.for(\"can.setPriority\")];\n\t\t\tif(setPriority !== undefined) {\n\t\t\t\tsetPriority.call(obj, priority);\n\t\t\t \treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\t/**\n\t * @function {function} can-reflect/getPriority getPriority\n\t * @parent can-reflect/observe\n\t * @description  Read the priority for an observable that derives its\n\t * value.\n\t *\n\t * @signature `getPriority(obj)`\n\t *\n\t * Calls an underlying `@@can.getPriority` symbol on `obj` if it exists\n\t * and returns its value. Read [can-reflect/setPriority] for more information.\n\t *\n\t *\n\t *\n\t * @param {Object} obj An observable.\n\t * @return {Undefined|Number} Returns the priority number if\n\t * available, undefined if this object does not support the `can.getPriority`\n\t * symbol.\n\t *\n\t * @body\n\t *\n\t */\n\tgetPriority: function(obj) {\n\t\tif(obj) {\n\t\t\tvar getPriority =  obj[canSymbol.for(\"can.getPriority\")];\n\t\t\tif(getPriority !== undefined) {\n\t\t\t\treturn getPriority.call(obj);\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/observe/observe.js?");

/***/ }),

/***/ "../../node_modules/can-reflect/reflections/shape/schema/schema.js":
/*!****************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/shape/schema/schema.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar typeReflections = __webpack_require__(/*! ../../type/type */ \"../../node_modules/can-reflect/reflections/type/type.js\");\nvar getSetReflections = __webpack_require__(/*! ../../get-set/get-set */ \"../../node_modules/can-reflect/reflections/get-set/get-set.js\");\nvar shapeReflections = __webpack_require__(/*! ../shape */ \"../../node_modules/can-reflect/reflections/shape/shape.js\");\n\nvar getSchemaSymbol = canSymbol.for(\"can.getSchema\"),\n    isMemberSymbol = canSymbol.for(\"can.isMember\"),\n    newSymbol = canSymbol.for(\"can.new\");\n\nfunction comparator(a, b) {\n    return a.localeCompare(b);\n}\n\nfunction sort(obj) {\n    if(typeReflections.isPrimitive(obj)) {\n        return obj;\n    }\n    var out;\n    if (typeReflections.isListLike(obj)) {\n        out = [];\n        shapeReflections.eachKey(obj, function(item){\n            out.push(sort(item));\n        });\n        return out;\n    }\n    if( typeReflections.isMapLike(obj) ) {\n\n        out = {};\n\n        shapeReflections.getOwnKeys(obj).sort(comparator).forEach(function (key) {\n            out[key] = sort( getSetReflections.getKeyValue(obj, key) );\n        });\n\n        return out;\n    }\n\n\n    return obj;\n}\n\nfunction isPrimitiveConverter(Type){\n    return Type === Number || Type === String || Type === Boolean;\n}\n\nvar schemaReflections =  {\n    /**\n\t * @function can-reflect.getSchema getSchema\n\t * @parent can-reflect/shape\n\t * @description Returns the schema for a type or value.\n\t *\n\t * @signature `getSchema(valueOrType)`\n\t *\n     * Calls the `@can.getSchema` property on the `valueOrType` argument. If it's not available and\n     * `valueOrType` has a `constructor` property, calls the `constructor[@can.getSchema]`\n     * and returns the result.\n     *\n     * ```js\n     * import canReflect from \"can-reflect\";\n     *\n     * var Type = DefineMap.extend({\n     *   name: \"string\",\n     *   id: \"number\"\n     * });\n     *\n     * canReflect.getSchema( Type ) //-> {\n     * //   type: \"map\",\n     * //   keys: {\n     * //     name: MaybeString\n     * //     id: MaybeNumber\n     * //   }\n     * // }\n     * ```\n\t *\n\t *\n\t * @param  {Object|Function} valueOrType A value, constructor function, or class to get the schema from.\n\t * @return {Object} A schema. A schema for a [can-reflect.isMapLike] looks like:\n     *\n     *\n     * ```js\n     * {\n     *   type: \"map\",\n     *   identity: [\"id\"],\n     *   keys: {\n     *     id: Number,\n     *     name: String,\n     *     complete: Boolean,\n     *     owner: User\n     *   }\n     * }\n     * ```\n     *\n     * A schema for a list looks like:\n     *\n     * ```js\n     * {\n     *   type: \"list\",\n     *   values: String\n     *   keys: {\n     *     count: Number\n     *   }\n     * }\n     * ```\n     *\n\t */\n    getSchema: function(type){\n        if (type === undefined) {\n            return undefined;\n        }\n        var getSchema = type[getSchemaSymbol];\n        if(getSchema === undefined ) {\n            type = type.constructor;\n            getSchema = type && type[getSchemaSymbol];\n        }\n        return getSchema !== undefined ? getSchema.call(type) : undefined;\n    },\n    /**\n\t * @function can-reflect.getIdentity getIdentity\n\t * @parent can-reflect/shape\n\t * @description Get a unique primitive representing an object.\n\t *\n\t * @signature `getIdentity( object [,schema] )`\n\t *\n\t * This uses the object's schema, or the provided schema to return a unique string or number that\n     * represents the object.\n     *\n     * ```js\n     * import canReflect from \"can-reflect\";\n     *\n     * canReflect.getIdentity({id: 5}, {identity: [\"id\"]}) //-> 5\n     * ```\n     *\n     * If the schema has multiple identity keys, the identity keys and values\n     * are return stringified (and sorted):\n     *\n     * ```js\n     * canReflect.getIdentity(\n     *   {z: \"Z\", a: \"A\", foo: \"bar\"},\n     *   {identity: [\"a\",\"b\"]}) //-> '{\"a\":\"A\",\"b\":\"B\"}'\n     * ```\n\t *\n\t * @param  {Object|Function} object A map-like object.\n     * @param {Object} [schema] A schema object with an `identity` array of the unique\n     * keys of the object like:\n     *   ```js\n     *   {identity: [\"id\"]}\n     *   ```\n\t * @return {Number|String} A value that uniquely represents the object.\n\t */\n    getIdentity: function(value, schema){\n        schema = schema || schemaReflections.getSchema(value);\n        if(schema === undefined) {\n            throw new Error(\"can-reflect.getIdentity - Unable to find a schema for the given value.\");\n        }\n\n        var identity = schema.identity;\n        if(!identity || identity.length === 0) {\n            throw new Error(\"can-reflect.getIdentity - Provided schema lacks an identity property.\");\n        } else if(identity.length === 1) {\n            return getSetReflections.getKeyValue(value, identity[0]);\n        } else {\n            var id = {};\n            identity.forEach(function(key){\n                id[key] = getSetReflections.getKeyValue(value, key);\n            });\n            return JSON.stringify(schemaReflections.cloneKeySort(id));\n        }\n    },\n    /**\n\t * @function can-reflect.cloneKeySort cloneKeySort\n\t * @parent can-reflect/shape\n\t * @description Copy a value while sorting its keys.\n\t *\n\t * @signature `cloneKeySort(value)`\n\t *\n     * `cloneKeySort` returns a copy of `value` with its [can-reflect.isMapLike]\n     * key values sorted. If you just want a copy of a value,\n     * use [can-reflect.serialize].\n     *\n     * ```js\n     * import canRefect from \"can-reflect\";\n     *\n     * canReflect.cloneKeySort({z: \"Z\", a: \"A\"}) //-> {a:\"A\",z:\"Z\"}\n     * ```\n     *\n     * Nested objects are also sorted.\n\t *\n     * This is useful if you need to store a representation of an object that can be used as a\n     * key.\n\t *\n\t * @param  {Object} value An object or array.\n\t * @return {Object} A copy of the object with its keys sorted.\n\t */\n    cloneKeySort: function(obj) {\n        return sort(obj);\n    },\n    /**\n\t * @function can-reflect.convert convert\n\t * @parent can-reflect/shape\n\t * @description Convert one value to another type.\n\t *\n\t * @signature `convert(value, Type)`\n\t *\n     * `convert` attempts to convert `value` to the type specified by `Type`.\n     *\n     * ```js\n     * import canRefect from \"can-reflect\";\n     *\n     * canReflect.convert(\"1\", Number) //-> 1\n     * ```\n     *\n     * `convert` works by performing the following logic:\n     *\n     * 1. If the `Type` is a primitive like `Number`, `String`, `Boolean`, the\n     *    `value` will be passed to the `Type` function and the result returned.\n     *    ```js\n     *    return Type(value);\n     *    ```\n     * 2. The value will be checked if it is already an instance of the type\n     *    by performing the following:\n     *    1. If the `Type` has a `can.isMember` symbol value, that value will be used\n     *       to determine if the `value` is already an instance.\n     *    2. If the `Type` is a [can-reflect.isConstructorLike] function, `instanceof Type`\n     *       will be used to check if `value` is already an instance.\n     * 3. If `value` is already an instance, `value` will be returned.\n     * 4. If `Type` has a `can.new` symbol, `value` will be passed to it and the result\n     *    returned.\n     * 5. If `Type` is a [can-reflect.isConstructorLike] function, `new Type(value)` will be\n     *    called the the result returned.\n     * 6. If `Type` is a regular function, `Type(value)` will be called and the result returned.\n     * 7. If a value hasn't been returned, an error is thrown.\n\t *\n\t * @param  {Object|Primitive} value A value to be converted.\n     * @param  {Object|Function} Type A constructor function or an object that implements the\n     * necessary symbols.\n\t * @return {Object} The `value` converted to a member of `Type`.\n\t */\n    convert: function(value, Type){\n        if(isPrimitiveConverter(Type)) {\n            return Type(value);\n        }\n        // check if value is already a member\n        var isMemberTest = Type[isMemberSymbol],\n            isMember = false,\n            type = typeof Type,\n            createNew = Type[newSymbol];\n        if(isMemberTest !== undefined) {\n            isMember = isMemberTest.call(Type, value);\n        } else if(type === \"function\") {\n            if(typeReflections.isConstructorLike(Type)) {\n                isMember = (value instanceof Type);\n            }\n        }\n        if(isMember) {\n            return value;\n        }\n        if(createNew !== undefined) {\n            return createNew.call(Type, value);\n        } else if(type === \"function\") {\n            if(typeReflections.isConstructorLike(Type)) {\n                return new Type(value);\n            } else {\n                // call it like a normal function\n                return Type(value);\n            }\n        } else {\n            throw new Error(\"can-reflect: Can not convert values into type. Type must provide `can.new` symbol.\");\n        }\n    }\n};\nmodule.exports = schemaReflections;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/shape/schema/schema.js?");

/***/ }),

/***/ "../../node_modules/can-reflect/reflections/shape/shape.js":
/*!********************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/shape/shape.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar getSetReflections = __webpack_require__(/*! ../get-set/get-set */ \"../../node_modules/can-reflect/reflections/get-set/get-set.js\");\nvar typeReflections = __webpack_require__(/*! ../type/type */ \"../../node_modules/can-reflect/reflections/type/type.js\");\nvar helpers = __webpack_require__(/*! ../helpers */ \"../../node_modules/can-reflect/reflections/helpers.js\");\n\n\n// IE-remove-start\nvar getPrototypeOfWorksWithPrimitives = true;\ntry {\n\tObject.getPrototypeOf(1);\n} catch(e) {\n\tgetPrototypeOfWorksWithPrimitives = false;\n}\n// IE-remove-end\n\nvar ArrayMap;\nif(typeof Map === \"function\") {\n\tArrayMap = Map;\n} else {\n\t// IE-remove-start\n\tfunction isEven(num) {\n\t\treturn !(num % 2);\n\t}\n\n\t// A simple map that stores items in an array.\n\t// like [key, value]\n\t// You can find the value by searching for the key and then +1.\n\tArrayMap = function(){\n\t\tthis.contents = [];\n\t};\n\n\tArrayMap.prototype = {\n\t\t/**\n\t\t * Get an index of a key. Because we store boths keys and values in\n\t\t * a flat array, we ensure we are getting a key by checking that it is an\n\t\t * even number index (all keys are even number indexed).\n\t\t **/\n\t\t_getIndex: function(key) {\n\t\t\tvar idx;\n\t\t\tdo {\n\t\t\t\tidx = this.contents.indexOf(key, idx);\n\t\t\t} while(idx !== -1 && !isEven(idx));\n\t\t\treturn idx;\n\t\t},\n\t\thas: function(key){\n\t\t\treturn this._getIndex(key) !== -1;\n\t\t},\n\t\tget: function(key){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\treturn this.contents[idx + 1];\n\t\t\t}\n\t\t},\n\t\tset: function(key, value){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\t// Key already exists, replace the value.\n\t\t\t\tthis.contents[idx + 1] = value;\n\t\t\t} else {\n\t\t\t\tthis.contents.push(key);\n\t\t\t\tthis.contents.push(value);\n\t\t\t}\n\t\t},\n\t\t\"delete\": function(key){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\t// Key already exists, replace the value.\n\t\t\t\tthis.contents.splice(idx, 2);\n\t\t\t}\n\t\t}\n\t};\n\t// IE-remove-end\n}\n\nvar shapeReflections;\n\nvar shiftFirstArgumentToThis = function(func){\n\treturn function(){\n\t\tvar args = [this];\n\t\targs.push.apply(args, arguments);\n\t\treturn func.apply(null,args);\n\t};\n};\n\nvar getKeyValueSymbol = canSymbol.for(\"can.getKeyValue\");\nvar shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);\nvar setKeyValueSymbol = canSymbol.for(\"can.setKeyValue\");\nvar shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);\n\nvar sizeSymbol = canSymbol.for(\"can.size\");\n\nvar hasUpdateSymbol = helpers.makeGetFirstSymbolValue([\"can.updateDeep\",\"can.assignDeep\",\"can.setKeyValue\"]);\nvar shouldUpdateOrAssign = function(obj){\n\treturn typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);\n};\n\n// is the value itself its serialized value\nfunction isSerializedHelper(obj){\n\tif (typeReflections.isPrimitive(obj)) {\n\t\treturn true;\n\t}\n\tif(hasUpdateSymbol(obj)) {\n\t\treturn false;\n\t}\n\treturn typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj) && !Array.isArray(obj);\n}\n\n// IE11 doesn't support primitives\nvar Object_Keys;\ntry{\n\tObject.keys(1);\n\tObject_Keys = Object.keys;\n} catch(e) {\n\tObject_Keys = function(obj){\n\t\tif(typeReflections.isPrimitive(obj)) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\treturn Object.keys(obj);\n\t\t}\n\t};\n}\n\nfunction makeSerializer(methodName, symbolsToCheck){\n\t// A local variable that is shared with all operations that occur withing a single\n\t// outer call to serialize()\n\tvar serializeMap = null;\n\n\t// Holds the value of running serialize(), preserving the same map for all\n\t// internal instances.\n\tfunction SerializeOperation(MapType) {\n\t\tthis.first = !serializeMap;\n\n\t\tif(this.first) {\n\t\t\tserializeMap = createSerializeMap(MapType);\n\t\t}\n\n\t\tthis.map = serializeMap;\n\t\tthis.result = null;\n\t}\n\n\tSerializeOperation.prototype.end = function(){\n\t\t// If this is the first, outer call, clean up the serializeMap.\n\t\tif(this.first) {\n\t\t\tserializeMap = null;\n\t\t}\n\t\treturn this.result;\n\t};\n\n\tfunction createSerializeMap(Type) {\n\t\tvar MapType = Type || ArrayMap;\n\t\treturn {\n\t\t\tunwrap: new MapType(),\n\t\t\tserialize: new MapType() ,\n\t\t\tisSerializing: {\n\t\t\t\tunwrap: new MapType(),\n\t\t\t\tserialize: new MapType()\n\t\t\t},\n\t\t\tcircularReferenceIsSerializing: {\n\t\t\t\tunwrap: new MapType(),\n\t\t\t\tserialize: new MapType()\n\t\t\t}\n\t\t};\n\t}\n\n\treturn function serializer(value, MapType){\n\t\tif (isSerializedHelper(value)) {\n\t\t\treturn value;\n\t\t}\n\n\t\tvar operation = new SerializeOperation(MapType);\n\n\t\tif(typeReflections.isValueLike(value)) {\n\t\t\toperation.result = this[methodName](getSetReflections.getValue(value));\n\n\t\t} else {\n\t\t\t// Date, RegEx and other Built-ins are handled above\n\t\t\t// only want to do something if it's intended to be serialized\n\t\t\t// or do nothing for a POJO\n\n\t\t\tvar isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);\n\t\t\toperation.result = isListLike ? [] : {};\n\n\t\t\t// handle maping to what is serialized\n\t\t\tif( operation.map[methodName].has(value) ) {\n\t\t\t\t// if we are in the process of serializing the first time, setup circular reference detection.\n\t\t\t\tif(operation.map.isSerializing[methodName].has(value)) {\n\t\t\t\t\toperation.map.circularReferenceIsSerializing[methodName].set(value, true);\n\t\t\t\t}\n\t\t\t\treturn operation.map[methodName].get(value);\n\t\t\t} else {\n\t\t\t\toperation.map[methodName].set(value, operation.result);\n\t\t\t}\n\n\t\t\tfor(var i = 0, len = symbolsToCheck.length ; i< len;i++) {\n\t\t\t\tvar serializer = value[symbolsToCheck[i]];\n\t\t\t\tif(serializer) {\n\t\t\t\t\t// mark that we are serializing\n\t\t\t\t\toperation.map.isSerializing[methodName].set(value, true);\n\t\t\t\t\tvar oldResult = operation.result;\n\t\t\t\t\toperation.result = serializer.call(value, oldResult);\n\t\t\t\t\toperation.map.isSerializing[methodName].delete(value);\n\n\t\t\t\t\t// if the result differs, but this was circular, blow up.\n\t\t\t\t\tif(operation.result !== oldResult) {\n\t\t\t\t\t\t// jshint -W073\n\t\t\t\t\t\tif(operation.map.circularReferenceIsSerializing[methodName].has(value)) {\n\t\t\t\t\t\t\t// Circular references should use a custom serializer\n\t\t\t\t\t\t\t// that sets the serialized value on the object\n\t\t\t\t\t\t\t// passed to it as the first argument e.g.\n\t\t\t\t\t\t\t// function(proto){\n\t\t\t\t\t\t\t//   return proto.a = canReflect.serialize(this.a);\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\toperation.end();\n\t\t\t\t\t\t\tthrow new Error(\"Cannot serialize cirular reference!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\toperation.map[methodName].set(value, operation.result);\n\t\t\t\t\t}\n\t\t\t\t\treturn operation.end();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof obj ==='function') {\n\t\t\t\toperation.map[methodName].set(value, value);\n\n\t\t\t\toperation.result = value;\n\t\t\t} else if( isListLike ) {\n\t\t\t\tthis.eachIndex(value,function(childValue, index){\n\t\t\t\t\toperation.result[index] = this[methodName](childValue);\n\t\t\t\t},this);\n\t\t\t} else {\n\t\t\t\tthis.eachKey(value,function(childValue, prop){\n\t\t\t\t\toperation.result[prop] = this[methodName](childValue);\n\t\t\t\t},this);\n\t\t\t}\n\t\t}\n\n\t\treturn operation.end();\n\t};\n}\n\n// returns a Map type of the keys mapped to true\nvar makeMap;\nif(typeof Map !== \"undefined\") {\n\tmakeMap = function(keys) {\n\t\tvar map = new Map();\n\t\tshapeReflections.eachIndex(keys, function(key){\n\t\t\tmap.set(key, true);\n\t\t});\n\t\treturn map;\n\t};\n} else {\n\tmakeMap = function(keys) {\n\t\tvar map = {};\n\t\tkeys.forEach(function(key){\n\t\t\tmap[key] = true;\n\t\t});\n\n\t\treturn {\n\t\t\tget: function(key){\n\t\t\t\treturn map[key];\n\t\t\t},\n\t\t\tset: function(key, value) {\n\t\t\t\tmap[key] = value;\n\t\t\t},\n\t\t\tkeys: function(){\n\t\t\t\treturn keys;\n\t\t\t}\n\t\t};\n\t};\n}\n\n// creates an optimized hasOwnKey lookup.\n// If the object has hasOwnKey, then we just use that.\n// Otherwise, try to put all keys in a map.\nvar fastHasOwnKey = function(obj){\n\tvar hasOwnKey = obj[canSymbol.for(\"can.hasOwnKey\")];\n\tif(hasOwnKey) {\n\t\treturn hasOwnKey.bind(obj);\n\t} else {\n\t\tvar map = makeMap( shapeReflections.getOwnEnumerableKeys(obj) );\n\t\treturn function(key) {\n\t\t\treturn map.get(key);\n\t\t};\n\t}\n};\n\n\n// combines patches if it makes sense\nfunction addPatch(patches, patch) {\n\tvar lastPatch = patches[patches.length -1];\n\tif(lastPatch) {\n\t\t// same number of deletes and counts as the index is back\n\t\tif(lastPatch.deleteCount === lastPatch.insert.length && (patch.index - lastPatch.index === lastPatch.deleteCount) ) {\n\t\t\tlastPatch.insert.push.apply(lastPatch.insert, patch.insert);\n\t\t\tlastPatch.deleteCount += patch.deleteCount;\n\t\t\treturn;\n\t\t}\n\t}\n\tpatches.push(patch);\n}\n\nfunction updateDeepList(target, source, isAssign) {\n\tvar sourceArray = this.toArray(source);\n\n\tvar patches = [],\n\t\tlastIndex = -1;\n\tthis.eachIndex(target, function(curVal, index){\n\t\tlastIndex = index;\n\t\t// If target has more items than the source.\n\t\tif(index >= sourceArray.length) {\n\t\t\tif(!isAssign) {\n\t\t\t\t// add a patch that removes the last items\n\t\t\t\taddPatch(patches, {index: index, deleteCount: target.length - index + 1, insert: []});\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tvar newVal = sourceArray[index];\n\t\tif( typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\taddPatch(patches, {index: index, deleteCount: 1, insert: [newVal]});\n\t\t} else {\n\t\t\tthis.updateDeep(curVal, newVal);\n\t\t}\n\t}, this);\n\t// add items at the end\n\tif(sourceArray.length > lastIndex) {\n\t\taddPatch(patches, {index: lastIndex+1, deleteCount: 0, insert: sourceArray.slice(lastIndex+1)});\n\t}\n\tfor(var i = 0, patchLen = patches.length; i < patchLen; i++) {\n\t\tvar patch = patches[i];\n\t\tgetSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);\n\t}\n\treturn target;\n}\n\nshapeReflections = {\n\t/**\n\t * @function {Object, function(*), [Object]} can-reflect.each each\n\t * @parent can-reflect/shape\n\t * @description  Iterate a List-like or Map-like, calling `callback` on each keyed or indexed property\n\t *\n\t * @signature `each(obj, callback, context)`\n\t *\n\t * If `obj` is a List-like or an Iterator-like, `each` functions as [can-reflect.eachIndex eachIndex],\n\t * iterating over numeric indexes from 0 to `obj.length - 1` and calling `callback` with each property and\n\t * index, optionally with `context` as `this` (defaulting to `obj`).  If not, `each` functions as\n\t * [can-reflect.eachKey eachKey],\n\t * iterating over every key on `obj` and calling `callback` on each one.\n\t *\n\t * ```\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t * var quux = new DefineList([ \"thud\", \"jeek\" ]);\n\t *\n\t * canReflect.each(foo, console.log, console); // -> logs 'baz bar {foo}'\n\t * canReflect.each(quux, console.log, console); // -> logs 'thud 0 {quux}'; logs 'jeek 1 {quux}'\n\t * ```\n\t *\n\t * @param  {Object}   obj     The object to iterate over\n\t * @param  {Function(*, ValueLike)} callback a function that receives each item in the ListLike or MapLike\n\t * @param  {[Object]}   context  an optional `this` context for calling the callback\n\t * @return {Array} the result of calling [can-reflect.eachIndex `eachIndex`] if `obj` is a ListLike,\n\t * or [can-reflect.eachKey `eachKey`] if a MapLike.\n\t */\n\teach: function(obj, callback, context){\n\n\t\t// if something is more \"list like\" .. use eachIndex\n\t\tif(typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj) ) {\n\t\t\treturn shapeReflections.eachIndex(obj,callback,context);\n\t\t} else {\n\t\t\treturn shapeReflections.eachKey(obj,callback,context);\n\t\t}\n\t},\n\n\t/**\n\t * @function {ListLike, function(*), [Object]} can-reflect.eachIndex eachIndex\n\t * @parent can-reflect/shape\n\t * @description  Iterate a ListLike calling `callback` on each numerically indexed element\n\t *\n\t * @signature `eachIndex(list, callback, context)`\n\t *\n\t * For each numeric index from 0 to `list.length - 1`, call `callback`, passing the current\n\t * property value, the current index, and `list`, and optionally setting `this` as `context`\n\t * if specified (otherwise use the current property value).\n\t *\n\t * ```\n\t * var foo = new DefineList([ \"bar\", \"baz\" ]);\n\t *\n\t * canReflect.eachIndex(foo, console.log, console); // -> logs 'bar 0 {foo}'; logs 'baz 1 {foo}'\n\t * ```\n\t *\n\t * @param  {ListLike}   list     The list to iterate over\n\t * @param  {Function(*, Number)} callback a function that receives each item\n\t * @param  {[Object]}   context  an optional `this` context for calling the callback\n\t * @return {ListLike}   the original list\n\t */\n\teachIndex: function(list, callback, context){\n\t\t// each index in something list-like. Uses iterator if it has it.\n\t\tif(Array.isArray(list)) {\n\t\t\treturn shapeReflections.eachListLike(list, callback, context);\n\t\t} else {\n\t\t\tvar iter, iterator = list[canSymbol.iterator];\n\t\t\tif(typeReflections.isIteratorLike(list)) {\n\t\t\t\t// we are looping through an iterator\n\t\t\t\titer = list;\n\t\t\t} else if(iterator) {\n\t\t\t\titer = iterator.call(list);\n\t\t\t}\n\t\t\t// fast-path arrays\n\t\t\tif(iter) {\n\t\t\t\tvar res, index = 0;\n\n\t\t\t\twhile(!(res = iter.next()).done) {\n\t\t\t\t\tif( callback.call(context || list, res.value, index++, list) === false ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tshapeReflections.eachListLike(list, callback, context);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t},\n\teachListLike: function(list, callback, context){\n\t\tvar index = -1;\n\t\tvar length = list.length;\n\t\tif( length === undefined ) {\n\t\t\tvar size = list[sizeSymbol];\n\t\t\tif(size) {\n\t\t\t\tlength = size.call(list);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"can-reflect: unable to iterate.\");\n\t\t\t}\n\t\t}\n\n\t\twhile (++index < length) {\n\t\t\tvar item = list[index];\n\t\t\tif (callback.call(context || item, item, index, list) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t},\n\t/**\n\t * @function can-reflect.toArray toArray\n\t * @parent can-reflect/shape\n\t * @description  convert the values of any MapLike or ListLike into an array\n\t *\n\t * @signature `toArray(obj)`\n\t *\n\t * Convert the values of any Map-like or List-like into a JavaScript Array.  If a Map-like,\n\t * key data is discarded and only value data is preserved.\n\t *\n\t * ```\n\t * var foo = new DefineList([\"bar\", \"baz\"]);\n\t * var quux = new DefineMap({ thud: \"jeek\" });\n\t * ```\n\t *\n\t * canReflect.toArray(foo); // -> [\"bar\", \"baz\"]\n\t * canReflect.toArray(quux): // -> [\"jeek\"]\n\t *\n\t * @param  {Object} obj Any object, whether MapLike or ListLike\n\t * @return {Array}  an array of the values of `obj`\n\t */\n\ttoArray: function(obj){\n\t\tvar arr = [];\n\t\tshapeReflections.each(obj, function(value){\n\t\t\tarr.push(value);\n\t\t});\n\t\treturn arr;\n\t},\n\t/**\n\t * @function can-reflect.eachKey eachKey\n\t * @parent can-reflect/shape\n\t * @description Iterate over a MapLike, calling `callback` on each enumerable property\n\t *\n\t * @signature `eachKey(obj, callback, context)`\n\t *\n\t * Iterate all own enumerable properties on Map-like `obj`\n\t * (using [can-reflect/shape/getOwnEnumerableKeys canReflect.getOwnEnumerableKeys]), and call\n\t * `callback` with the property value, the property key, and `obj`, and optionally setting\n\t * `this` on the callback as `context` if provided, `obj` otherwise.\n\t *\n\t * ```\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.eachKey(foo, console.log, console); // logs 'baz bar {foo}'\n\t * ```\n\t *\n\t * @param  {Object}   obj   The object to iterate over\n\t * @param  {Function(*, String)} callback The callback to call on each enumerable property value\n\t * @param  {[Object]}   context  an optional `this` context for calling `callback`\n\t * @return {Array}    the enumerable keys of `obj` as an Array\n\t */\n\teachKey: function(obj, callback, context){\n\t\t// each key in something map like\n\t\t// eachOwnEnumerableKey\n\t\tif(obj) {\n\t\t\tvar enumerableKeys = shapeReflections.getOwnEnumerableKeys(obj);\n\n\t\t\t// cache getKeyValue method if we can\n\t\t\tvar getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;\n\n\t\t\treturn shapeReflections.eachIndex(enumerableKeys, function(key){\n\t\t\t\tvar value = getKeyValue.call(obj, key);\n\t\t\t\treturn callback.call(context || obj, value, key, obj);\n\t\t\t});\n\t\t}\n\t\treturn obj;\n\t},\n\t/**\n\t * @function can-reflect.hasOwnKey hasOwnKey\n\t * @parent can-reflect/shape\n\t * @description  Determine whether an object contains a key on itself, not only on its prototype chain\n\t *\n\t * @signature `hasOwnKey(obj, key)`\n\t *\n\t * Return `true` if an object's own properties include the property key `key`, `false` otherwise.\n\t * An object may implement [can-symbol/symbols/hasOwnKey @@@@can.hasOwnKey] to override default behavior.\n\t * By default, `canReflect.hasOwnKey` will first look for\n\t * [can-symbol/symbols/getOwnKey @@@@can.getOwnKey] on `obj`. If present, it will call `@@@@can.getOwnKey` and\n\t * test `key` against the returned Array of keys.  If absent, `Object.prototype.hasOwnKey()` is used.\n\t *\n\t * ```\n\t * var foo = new DefineMap({ \"bar\": \"baz\" });\n\t *\n\t * canReflect.hasOwnKey(foo, \"bar\"); // -> true\n\t * canReflect.hasOwnKey(foo, \"each\"); // -> false\n\t * foo.each // -> function each() {...}\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @param  {String} key The key to look up on `obj`\n\t * @return {Boolean} `true` if `obj`'s key set contains `key`, `false` otherwise\n\t */\n\t\"hasOwnKey\": function(obj, key){\n\t\t// if a key or index\n\t\t// like has own property\n\t\tvar hasOwnKey = obj[canSymbol.for(\"can.hasOwnKey\")];\n\t\tif(hasOwnKey) {\n\t\t\treturn hasOwnKey.call(obj, key);\n\t\t}\n\t\tvar getOwnKeys = obj[canSymbol.for(\"can.getOwnKeys\")];\n\t\tif( getOwnKeys ) {\n\t\t\tvar found = false;\n\t\t\tshapeReflections.eachIndex(getOwnKeys.call(obj), function(objKey){\n\t\t\t\tif(objKey === key) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn found;\n\t\t}\n\t\treturn obj.hasOwnProperty(key);\n\t},\n\t/**\n\t * @function can-reflect.getOwnEnumerableKeys getOwnEnumerableKeys\n\t * @parent can-reflect/shape\n\t * @description Return the list of keys which can be iterated over on an object\n\t *\n\t * @signature `getOwnEnumerableKeys(obj)`\n\t *\n\t * Return all keys on `obj` which have been defined as enumerable, either from explicitly setting\n\t * `enumerable` on the property descriptor, or by using `=` to set the value of the property without\n\t * a key descriptor, but excluding properties that only exist on `obj`'s prototype chain.  The\n\t * default behavior can be overridden by implementing\n\t * [can-symbol/symbols/getOwnEnumerableKeys @@@@can.getOwnEnumerableKeys] on `obj`.  By default,\n\t * `canReflect.getOwnEnumerableKeys` will use [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] to\n\t * retrieve the set of keys and [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]\n\t * to filter for those which are enumerable.  If either symbol is absent from `obj`, `Object.keys`\n\t * is used.\n\t *\n\t * ```\n\t * var foo = new DefineMap({ bar: \"baz\", [canSymbol.for(\"quux\")]: \"thud\" });\n\t * Object.defineProperty(foo, \"jeek\", {\n\t *   enumerable: true,\n\t *   value: \"plonk\"\n\t * });\n\t *\n\t * canReflect.getOwnEnumerableKeys(foo); // -> [\"bar\", \"jeek\"]\n\t * ```\n\t *\n\t * @param  {Object} obj Any Map-like object\n\t * @return {Array} the Array of all enumerable keys from the object, either using\n\t * [can-symbol/symbols/getOwnEnumerableKeys `@@@@can.getOwnEnumerableKeys`] from `obj`, or filtering\n\t * `obj`'s own keys for those which are enumerable.\n\t */\n\tgetOwnEnumerableKeys: function(obj){\n\t\t// own enumerable keys (aliased as keys)\n\t\tvar getOwnEnumerableKeys = obj[canSymbol.for(\"can.getOwnEnumerableKeys\")];\n\t\tif(getOwnEnumerableKeys) {\n\t\t\treturn getOwnEnumerableKeys.call(obj);\n\t\t}\n\t\tif( obj[canSymbol.for(\"can.getOwnKeys\")] && obj[canSymbol.for(\"can.getOwnKeyDescriptor\")] ) {\n\t\t\tvar keys = [];\n\t\t\tshapeReflections.eachIndex(shapeReflections.getOwnKeys(obj), function(key){\n\t\t\t\tvar descriptor =  shapeReflections.getOwnKeyDescriptor(obj, key);\n\t\t\t\tif(descriptor.enumerable) {\n\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\treturn keys;\n\t\t} /*else if(obj[canSymbol.iterator]){\n\t\t\tvar iter = obj[canSymbol.iterator](obj);\n\t\t\tvar index = 0;\n\t\t\tvar keys;\n\t\t\treturn {\n\t\t\t\tnext: function(){\n\t\t\t\t\tvar res = iter.next();\n\t\t\t\t\tif(index++)\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!().done) {\n\n\t\t\t\tif( callback.call(context || list, res.value, index++, list) === false ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/ else {\n\t\t\treturn Object_Keys(obj);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.getOwnKeys getOwnKeys\n\t * @parent can-reflect/shape\n\t * @description Return the list of keys on an object, whether or not they can be iterated over\n\t *\n\t * @signature `getOwnKeys(obj)`\n\t *\n\t * Return the Array of all String (not Symbol) keys from `obj`, whether they are enumerable or not.  If\n\t * [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] exists on `obj`, it is called to return\n\t * the keys; otherwise, `Object.getOwnPropertyNames()` is used.\n\t *\n\t * ```\n\t * var foo = new DefineMap({ bar: \"baz\", [canSymbol.for(\"quux\")]: \"thud\" });\n\t * Object.defineProperty(foo, \"jeek\", {\n\t *   enumerable: false,\n\t *   value: \"plonk\"\n\t * });\n\t *\n\t * canReflect.getOwnKeys(foo); // -> [\"bar\", \"jeek\"]\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @return {Array} the Array of all String keys from the object.\n\t */\n\tgetOwnKeys: function(obj){\n\t\t// own enumerable&non-enumerable keys (Object.getOwnPropertyNames)\n\t\tvar getOwnKeys = obj[canSymbol.for(\"can.getOwnKeys\")];\n\t\tif(getOwnKeys) {\n\t\t\treturn getOwnKeys.call(obj);\n\t\t} else {\n\t\t\treturn Object.getOwnPropertyNames(obj);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.getOwnKeyDescriptor getOwnKeyDescriptor\n\t * @parent can-reflect/shape\n\t * @description Return a property descriptor for a named property on an object.\n\t *\n\t * @signature `getOwnKeyDescriptor(obj, key)`\n\t *\n\t *\tReturn the key descriptor for the property key `key` on the Map-like object `obj`. A key descriptor\n\t *\tis specified in ECMAScript 5 and contains keys for the property's `configurable` and `enumerable` states,\n\t *\tas well as either `value` and `writable` for value properties, or `get` and `set` for getter/setter properties.\n\t *\n\t * The default behavior can be overridden by implementing [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]\n\t * on `obj`; otherwise the default is to call `Object.getOwnKeyDescriptor()`.\n\t *\n\t * ```\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * getOwnKeyDescriptor(foo, \"bar\"); // -> {configurable: true, writable: true, enumerable: true, value: \"baz\"}\n\t * ```\n\t *\n\t * @param  {Object} obj Any object with named properties\n\t * @param  {String} key The property name to look up on `obj`\n\t * @return {Object}   A key descriptor object\n\t */\n\tgetOwnKeyDescriptor: function(obj, key){\n\t\tvar getOwnKeyDescriptor = obj[canSymbol.for(\"can.getOwnKeyDescriptor\")];\n\t\tif(getOwnKeyDescriptor) {\n\t\t\treturn getOwnKeyDescriptor.call(obj, key);\n\t\t} else {\n\t\t\treturn Object.getOwnPropertyDescriptor(obj, key);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.unwrap unwrap\n\t * @parent can-reflect/shape\n\t * @description Unwraps a map-like or array-like value into an object or array.\n\t *\n\t *\n\t * @signature `unwrap(obj)`\n\t *\n\t * Recursively unwraps a map-like or list-like object.\n\t *\n\t * ```js\n\t * import canReflect from \"can-reflect\";\n\t *\n\t * var map = new DefineMap({foo: \"bar\"});\n\t * canReflect.unwrap(map) //-> {foo: \"bar\"}\n\t * ```\n\t *\n\t * `unwrap` is similar to [can-reflect.serialize] except it does not try to provide `JSON.stringify()`-safe\n\t * objects.  For example, an object with a `Date` instance property value will not be expected to\n\t * serialize the date instance:\n\t *\n\t * ```js\n\t * var date = new Date();\n\t * var map = new DefineMap({date: date});\n\t * canReflect.unwrap(map) //-> {date: date}\n\t * ```\n\t *\n\t * @param {Object} obj A map-like or array-like object.\n\t * @return {Object} Returns objects and arrays.\n\t */\n\tunwrap: makeSerializer(\"unwrap\",[canSymbol.for(\"can.unwrap\")]),\n\t/**\n\t * @function can-reflect.serialize serialize\n\t * @parent can-reflect/shape\n\t * @description Serializes an object to a value that can be passed to JSON.stringify.\n\t *\n\t *\n\t * @signature `serialize(obj)`\n\t *\n\t * Recursively serializes a map-like or list-like object.\n\t *\n\t * ```js\n\t * import canReflect from \"can-reflect\";\n\t * canReflect.serialize({foo: \"bar\"}) //-> {foo: \"bar\"}\n\t * ```\n\t *\n\t * It does this by recursively:\n\t *\n\t *  - Checking if `obj` is a primitive, if it is, returns the value.\n\t *  - If `obj` is an object:\n\t *    - calling the `@can.serialize` property on the value if it exists.\n\t *    - If the `@can.serialize` value doesn't exist, walks through every key-value\n\t *      on `obj` and copy to a new object.\n\t *\n\t * @param {Object} obj A map-like or array-like object.\n\t * @return {Object} Returns a plain object or array.\n\t */\n\tserialize: makeSerializer(\"serialize\",[canSymbol.for(\"can.serialize\"), canSymbol.for(\"can.unwrap\")]),\n\n\tassignMap: function(target, source) {\n\t\t// read each key and set it on target\n\t\tvar hasOwnKey = fastHasOwnKey(target);\n\t\tvar getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\t\tshapeReflections.eachKey(source,function(value, key){\n\t\t\t// if the target doesn't have this key or the keys are not the same\n\t\t\tif(!hasOwnKey(key) || getKeyValue.call(target, key) !==  value) {\n\t\t\t\tsetKeyValue.call(target, key, value);\n\t\t\t}\n\t\t});\n\t\treturn target;\n\t},\n\tassignList: function(target, source) {\n\t\tvar inserting = shapeReflections.toArray(source);\n\t\tgetSetReflections.splice(target, 0, inserting, inserting );\n\t\treturn target;\n\t},\n\t/**\n\t * @function can-reflect.assign assign\n\t * @parent can-reflect/shape\n\t * @description Assign one objects values to another\n\t *\n\t * @signature `.assign(target, source)`\n\t *\n\t * Copies the values (and properties if map-like) from `source` onto `target`.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {};\n\t * var source = {key : \"value\"};\n\t * var restult = canReflect.assign(target, source);\n\t * result === target //-> true\n\t * target //-> {key : \"value\"}\n\t * ```\n\t *\n\t * For Arrays, enumerated values are copied over, but the length of the array will not be\n\t * trunkated.  Use [can-reflect.update] for trunkating.\n\t *\n\t * ```js\n\t * var target = [\"a\",\"b\",\"c\"];\n\t * var source = [\"A\",\"B\"];\n\t * canReflect.assign(target, source);\n\t * target //-> [\"A\",\"B\",\"c\"]\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassign: function(target, source) {\n\t\tif(typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// copy to array and add these keys in place\n\t\t\tshapeReflections.assignList(target, source);\n\t\t} else {\n\t\t\tshapeReflections.assignMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tassignDeepMap: function(target, source) {\n\n\t\tvar hasOwnKey = fastHasOwnKey(target);\n\t\tvar getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(source, function(newVal, key){\n\t\t\tif(!hasOwnKey(key)) {\n\t\t\t\t// set no matter what\n\t\t\t\tgetSetReflections.setKeyValue(target, key, newVal);\n\t\t\t} else {\n\t\t\t\tvar curVal = getKeyValue.call(target, key);\n\n\t\t\t\t// if either was primitive, no recursive update possible\n\t\t\t\tif(newVal === curVal) {\n\t\t\t\t\t// do nothing\n\t\t\t\t} else if(typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\t\t\tsetKeyValue.call(target, key, newVal);\n\t\t\t\t} else {\n\t\t\t\t\tshapeReflections.assignDeep(curVal, newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\t\treturn target;\n\t},\n\tassignDeepList: function(target, source) {\n\t\treturn updateDeepList.call(this,target, source, true);\n\t},\n\t/**\n\t * @function can-reflect.assignDeep assignDeep\n\t * @parent can-reflect/shape\n\t * @description Assign one objects values to another, and performs the same action for all child values.\n\t *\n\t * @signature `.assignDeep(target, source)`\n\t *\n\t * Copies the values (and properties if map-like) from `source` onto `target` and repeates for all child\n\t * values.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var restult = canReflect.assignDeep(target, source);\n\t * target //->  {name: {first: \"Justin\", last: \"Meyer\"}}\n\t * ```\n\t *\n\t * An object can control the behavior of `assignDeep` using the [can-symbol/symbols/assignDeep] symbol.\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassignDeep: function(target, source){\n\t\tvar assignDeep = target[canSymbol.for(\"can.assignDeep\")];\n\t\tif(assignDeep) {\n\t\t\tassignDeep.call(target, source);\n\t\t} else if( typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// list-like\n\t\t\tshapeReflections.assignDeepList(target, source);\n\t\t} else {\n\t\t\t// map-like\n\t\t\tshapeReflections.assignDeepMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tupdateMap: function(target, source) {\n\t\tvar sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );\n\n\t\tvar sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(target, function(curVal, key){\n\t\t\tif(!sourceKeyMap.get(key)) {\n\t\t\t\tgetSetReflections.deleteKeyValue(target, key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsourceKeyMap.set(key, false);\n\t\t\tvar newVal = sourceGetKeyValue.call(source, key);\n\n\t\t\t// if either was primitive, no recursive update possible\n\t\t\tif(newVal !== curVal) {\n\t\t\t\ttargetSetKeyValue.call(target, key, newVal);\n\t\t\t}\n\t\t}, this);\n\n\t\tshapeReflections.eachIndex(sourceKeyMap.keys(), function(key){\n\t\t\tif(sourceKeyMap.get(key)) {\n\t\t\t\ttargetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );\n\t\t\t}\n\t\t})\n\n\t\treturn target;\n\t},\n\tupdateList: function(target, source) {\n\t\tvar inserting = shapeReflections.toArray(source);\n\n\t\tgetSetReflections.splice(target, 0, target, inserting );\n\t\treturn target;\n\t},\n\t/**\n\t * @function can-reflect.update update\n\t * @parent can-reflect/shape\n\t * @description Updates the values of an object match the values of an other object.\n\t *\n\t * @signature `.update(target, source)`\n\t *\n\t * Updates the values (and properties if map-like) of `target` to match the values of `source`. This does\n\t * not recursively update.  For that, use [can-reflect.updateDeep].\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}, age: 34};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var restult = canReflect.assignDeep(target, source);\n\t * target //->  {name: {last: \"Meyer\"}}\n\t * ```\n\t *\n\t * With Arrays all items of the source will be replaced with the new items.\n\t *\n\t * ```js\n\t * var target = [\"a\",\"b\",\"c\"];\n\t * var source = [\"A\",\"B\"];\n\t * canReflect.assign(target, source);\n\t * target //-> [\"A\",\"B\"]\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tupdate: function(target, source) {\n\t\tif(typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// copy to array and add these keys in place\n\t\t\tshapeReflections.updateList(target, source);\n\t\t} else {\n\t\t\tshapeReflections.updateMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tupdateDeepMap: function(target, source) {\n\t\tvar sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );\n\n\t\tvar sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(target, function(curVal, key){\n\n\t\t\tif(!sourceKeyMap.get(key)) {\n\t\t\t\tgetSetReflections.deleteKeyValue(target, key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsourceKeyMap.set(key, false);\n\t\t\tvar newVal = sourceGetKeyValue.call(source, key);\n\n\t\t\t// if either was primitive, no recursive update possible\n\t\t\tif(typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\t\ttargetSetKeyValue.call(target, key, newVal);\n\t\t\t} else {\n\t\t\t\tshapeReflections.updateDeep(curVal, newVal);\n\t\t\t}\n\n\t\t}, this);\n\n\t\tshapeReflections.eachIndex(sourceKeyMap.keys(), function(key){\n\t\t\tif(sourceKeyMap.get(key)) {\n\t\t\t\ttargetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );\n\t\t\t}\n\t\t});\n\t\treturn target;\n\t},\n\tupdateDeepList: function(target, source) {\n\t\treturn updateDeepList.call(this,target, source);\n\t},\n\t/**\n\t * @function can-reflect.updateDeep updateDeep\n\t * @parent can-reflect/shape\n\t * @description Makes the values of an object match the values of an other object including all children values.\n\t *\n\t * @signature `.updateDeep(target, source)`\n\t *\n\t * Updates the values (and properties if map-like) of `target` to match the values of `source`.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}, age: 34};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var restult = canReflect.assignDeep(target, source);\n\t * target //->  {name: {last: \"Meyer\"}}\n\t * ```\n\t *\n\t * An object can control the behavior of `assignDeep` using the [can-symbol/symbols/updateDeep] symbol.\n\t *\n\t * For list-like objects, a diff and patch strategy is used.  This attempts to limit the number of changes.\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tupdateDeep: function(target, source){\n\t\tvar updateDeep = target[canSymbol.for(\"can.updateDeep\")];\n\t\tif(updateDeep) {\n\t\t\tupdateDeep.call(target, source);\n\t\t} else if( typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// list-like\n\t\t\tshapeReflections.updateDeepList(target, source);\n\t\t} else {\n\t\t\t// map-like\n\t\t\tshapeReflections.updateDeepMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\t// walks up the whole prototype chain\n\t/**\n\t * @function can-reflect.hasKey hasKey\n\t * @parent can-reflect/shape\n\t * @description Determine whether an object contains a key on itself or its prototype chain\n\t *\n\t * @signature `hasKey(obj, key)`\n\t *\n\t * Return `true` if an object's properties include the property key `key` or an object on its prototype\n\t * chain's properties include the key `key`, `false` otherwise.\n\t * An object may implement [can-symbol/symbols/hasKey @@@@can.hasKey] to override default behavior.\n\t * By default, `canReflect.hasKey` will use [can-reflect.hasOwnKey] and return true if the key is present.\n\t * If `hasOwnKey` returns false, the [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in in Operator] will be used.\n\t *\n\t * ```\n\t * var foo = new DefineMap({ \"bar\": \"baz\" });\n\t *\n\t * canReflect.in(foo, \"bar\"); // -> true\n\t * canReflect.in(foo, \"each\"); // -> true\n\t * foo.each // -> function each() {...}\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @param  {String} key The key to look up on `obj`\n\t * @return {Boolean} `true` if `obj`'s key set contains `key` or an object on its prototype chain's key set contains `key`, `false` otherwise\n\t */\n\thasKey: function(obj, key) {\n\t\tif( obj == null ) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeReflections.isPrimitive(obj)) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tvar proto;\n\t\t\t\tif(getPrototypeOfWorksWithPrimitives) {\n\t\t\t\t\tproto = Object.getPrototypeOf(obj);\n\t\t\t\t} else {\n\t\t\t\t\t// IE-remove-start\n\t\t\t\t\tproto = obj.__proto__;\n\t\t\t\t\t// IE-remove-end\n\t\t\t\t};\n\t\t\t\tif(proto !== undefined) {\n\t\t\t\t\treturn key in proto;\n\t\t\t\t} else {\n\t\t\t\t\t// IE-remove-start\n\t\t\t\t\treturn obj[key] !== undefined;\n\t\t\t\t\t// IE-remove-end\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar hasKey = obj[canSymbol.for(\"can.hasKey\")];\n\t\tif(hasKey) {\n\t\t\treturn hasKey.call(obj, key);\n\t\t}\n\n\t\tvar found = shapeReflections.hasOwnKey(obj, key);\n\n\t\treturn found || key in obj;\n\t},\n\tgetAllEnumerableKeys: function(){},\n\tgetAllKeys: function(){},\n\t/**\n\t * @function can-reflect.assignSymbols assignSymbols\n\t * @parent can-reflect/shape\n\t * @description Assign well known symbols and values to an object.\n\t *\n\t * @signature `.assignSymbols(target, source)`\n\t *\n\t * Converts each property name on the `source` object to a [can-symbol.for well known symbol]\n\t * and uses that symbol to set the corresponding value on target.\n\t *\n\t * This is used to easily set symbols correctly even when symbol isn't natively supported.\n\t *\n\t * ```js\n\t * canReflect.assignSymbols(Map.prototype, {\n\t *   \"can.getKeyValue\": Map.prototype.get\n\t * })\n\t * ```\n\t *\n\t * If a `source` property name matches a symbol on `Symbol` (like `iterator` on `Symbol.iterator`),\n\t * that symbol will be used:\n\t *\n\t * ```js\n\t * canReflect.assignSymbols(ArrayLike.prototype, {\n\t *   \"iterator\": function() { ... }\n\t * })\n\t * ArrayLike.prototype[Symbol.iterator] = function(){ ... }\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s symbols and values.\n\t * @param  {Object<name,value>} source A source of symbol names and values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassignSymbols: function(target, source){\n\t\tshapeReflections.eachKey(source, function(value, key){\n\t\t\tvar symbol = typeReflections.isSymbolLike(canSymbol[key]) ? canSymbol[key] : canSymbol.for(key);\n\t\t\tgetSetReflections.setKeyValue(target, symbol, value);\n\t\t});\n\t\treturn target;\n\t},\n\tisSerialized: isSerializedHelper,\n\t/**\n\t * @function can-reflect.size size\n\t * @parent can-reflect/shape\n\t * @description Return the number of items in the collection.\n\t *\n\t * @signature `.size(target)`\n\t *\n\t * Returns the number of items contained in `target`. Target can\n\t * provide the size using the [can-symbol/symbols/size] symbol.\n\t *\n\t * If the `target` has a numeric `length` property that is greater than or equal to 0, that\n\t * `length` will be returned.\n\t *\n\t * ```js\n\t * canReflect.size([1,2,3]) //-> 3\n\t * ```\n\t *\n\t * If the `target` is [can-reflect.isListLike], the values of the list will be counted.\n\t *\n\t * If the `target` is a plain JS object, the number of enumerable properties will be returned.\n\t *\n\t * ```js\n\t * canReflect.size({foo:\"bar\"}) //-> 1\n\t * ```\n\t *\n\t * If the `target` is anything else, `undefined` is returned.\n\t *\n\t * @param  {Object} target The container object.\n\t * @return {Number} The number of values in the target.\n\t */\n\tsize: function(obj){\n\t\tif(obj == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar size = obj[sizeSymbol];\n\t\tvar count = 0;\n\t\tif(size) {\n\t\t\treturn size.call(obj);\n\t\t}\n\t\telse if(helpers.hasLength(obj)){\n\t\t\treturn obj.length;\n\t\t}\n\t\telse if(typeReflections.isListLike(obj)){\n\n\t\t\tshapeReflections.eachIndex(obj, function(){\n\t\t\t\tcount++;\n\t\t\t});\n\t\t\treturn count;\n\t\t}\n\t\telse if( obj ) {\n\t\t\treturn shapeReflections.getOwnEnumerableKeys(obj).length;\n\t\t}\n\t\telse {\n\t\t\treturn undefined;\n\t\t}\n\t},\n\t/**\n\t * @function {Function, String|Symbol, Object} can-reflect.defineInstanceKey defineInstanceKey\n\t * @parent can-reflect/shape\n\t * @description Create a key for all instances of a constructor.\n\t *\n\t * @signature `defineInstanceKey(cls, key, properties)`\n\t *\n\t * Define the property `key` on the prototype of the constructor `cls` using the symbolic\n\t * property [can-symbol/symbols/defineInstanceKey @@can.defineInstanceKey] if it exists; otherwise\n\t * use `Object.defineProperty()` to define the property.  The property definition\n\t *\n\t * @param  {Function} cls  a Constructor function\n\t * @param  {String} key     the String or Symbol key to set.\n\t * @param  {Object} properties a JavaScript property descriptor\n\t */\n\tdefineInstanceKey: function(cls, key, properties) {\n\t\tvar defineInstanceKey = cls[canSymbol.for(\"can.defineInstanceKey\")];\n\t\tif(defineInstanceKey) {\n\t\t\treturn defineInstanceKey.call(cls, key, properties);\n\t\t}\n\t\tvar proto = cls.prototype;\n\t\tdefineInstanceKey = proto[canSymbol.for(\"can.defineInstanceKey\")];\n\t\tif(defineInstanceKey) {\n\t\t\tdefineInstanceKey.call(proto, key, properties);\n\t\t} else {\n\t\t\tObject.defineProperty(\n\t\t\t\tproto,\n\t\t\t\tkey,\n\t\t\t\tshapeReflections.assign({\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: !typeReflections.isSymbolLike(key),\n\t\t\t\t\twritable: true\n\t\t\t\t}, properties)\n\t\t\t);\n\t\t}\n\t}\n};\n\nshapeReflections.isSerializable = shapeReflections.isSerialized;\nshapeReflections.keys = shapeReflections.getOwnEnumerableKeys;\nmodule.exports = shapeReflections;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/shape/shape.js?");

/***/ }),

/***/ "../../node_modules/can-reflect/reflections/type/type.js":
/*!******************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/type/type.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar helpers = __webpack_require__(/*! ../helpers */ \"../../node_modules/can-reflect/reflections/helpers.js\");\n\nvar plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames((function(){}).prototype);\nvar plainFunctionPrototypeProto = Object.getPrototypeOf( (function(){}).prototype );\n/**\n * @function can-reflect.isConstructorLike isConstructorLike\n * @parent can-reflect/type\n *\n * @description Test if a value looks like a constructor function.\n *\n * @signature `isConstructorLike(func)`\n *\n * Return `true` if `func` is a function and has a non-empty prototype, or implements\n *  [can-symbol/symbols/new `@@@@can.new`]; `false` otherwise.\n *\n * ```\n * canReflect.isConstructorLike(function() {}); // -> false\n *\n * function Construct() {}\n * Construct.prototype = { foo: \"bar\" };\n * canReflect.isConstructorLike(Construct); // -> true\n *\n * canReflect.isConstructorLike({}); // -> false\n * !!canReflect.isConstructorLike({ [canSymbol.for(\"can.new\")]: function() {} }); // -> true\n * ```\n *\n * @param  {*}  func maybe a function\n * @return {Boolean} `true` if a constructor; `false` if otherwise.\n */\nfunction isConstructorLike(func){\n\t/* jshint unused: false */\n\t// if you can new it ... it's a constructor\n\tvar value = func[canSymbol.for(\"can.new\")];\n\tif(value !== undefined) {\n\t\treturn value;\n\t}\n\n\tif(typeof func !== \"function\") {\n\t\treturn false;\n\t}\n\t// If there are any properties on the prototype that don't match\n\t// what is normally there, assume it's a constructor\n\tvar prototype = func.prototype;\n\tif(!prototype) {\n\t\treturn false;\n\t}\n\t// Check if the prototype's proto doesn't point to what it normally would.\n\t// If it does, it means someone is messing with proto chains\n\tif( plainFunctionPrototypeProto !== Object.getPrototypeOf( prototype ) ) {\n\t\treturn true;\n\t}\n\n\tvar propertyNames = Object.getOwnPropertyNames(prototype);\n\tif(propertyNames.length === plainFunctionPrototypePropertyNames.length) {\n\t\tfor(var i = 0, len = propertyNames.length; i < len; i++) {\n\t\t\tif(propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\n/**\n * @function can-reflect.isFunctionLike isFunctionLike\n * @parent can-reflect/type\n * @description Test if a value looks like a function.\n * @signature `isFunctionLike(obj)`\n *\n *  Return `true` if `func` is a function, or implements\n *  [can-symbol/symbols/new `@@@@can.new`] or [can-symbol/symbols/apply `@@@@can.apply`]; `false` otherwise.\n *\n * ```\n * canReflect.isFunctionLike(function() {}); // -> true\n * canReflect.isFunctionLike({}); // -> false\n * canReflect.isFunctionLike({ [canSymbol.for(\"can.apply\")]: function() {} }); // -> true\n * ```\n *\n * @param  {*}  obj maybe a function\n * @return {Boolean}\n */\nvar getNewOrApply = helpers.makeGetFirstSymbolValue([\"can.new\",\"can.apply\"]);\nfunction isFunctionLike(obj){\n\tvar result,\n\t\tsymbolValue = obj[canSymbol.for(\"can.isFunctionLike\")];\n\n\tif (symbolValue !== undefined) {\n\t\treturn symbolValue;\n\t}\n\n\tresult = getNewOrApply(obj);\n\tif(result !== undefined) {\n\t\treturn !!result;\n\t}\n\n\treturn typeof obj === \"function\";\n}\n\n/**\n * @function can-reflect.isPrimitive isPrimitive\n * @parent can-reflect/type\n * @description Test if a value is a JavaScript primitive.\n * @signature `isPrimitive(obj)`\n *\n * Return `true` if `obj` is not a function nor an object via `typeof`, or is null; `false` otherwise.\n *\n * ```\n * canReflect.isPrimitive(null); // -> true\n * canReflect.isPrimitive({}); // -> false\n * canReflect.isPrimitive(undefined); // -> true\n * canReflect.isPrimitive(1); // -> true\n * canReflect.isPrimitive([]); // -> false\n * canReflect.isPrimitive(function() {}); // -> false\n * canReflect.isPrimitive(\"foo\"); // -> true\n *\n * ```\n *\n * @param  {*}  obj maybe a primitive value\n * @return {Boolean}\n */\nfunction isPrimitive(obj){\n\tvar type = typeof obj;\n\tif(obj == null || (type !== \"function\" && type !== \"object\") ) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\n/**\n * @function can-reflect.isBuiltIn isBuiltIn\n * @parent can-reflect/type\n * @description Test if a value is a JavaScript built-in type.\n * @signature `isBuiltIn(obj)`\n *\n * Return `true` if `obj` is some type of JavaScript native built-in; `false` otherwise.\n *\n * ```\n * canReflect.isBuiltIn(null); // -> true\n * canReflect.isBuiltIn({}); // -> true\n * canReflect.isBuiltIn(1); // -> true\n * canReflect.isBuiltIn([]); // -> true\n * canReflect.isBuiltIn(function() {}); // -> true\n * canReflect.isBuiltIn(\"foo\"); // -> true\n * canReflect.isBuiltIn(new Date()); // -> true\n * canReflect.isBuiltIn(/[foo].[bar]/); // -> true\n * canReflect.isBuiltIn(new DefineMap); // -> false\n *\n * ```\n *\n * Not supported in browsers that have implementations of Map/Set where\n * `toString` is not properly implemented to return `[object Map]`/`[object Set]`.\n *\n * @param  {*}  obj maybe a built-in value\n * @return {Boolean}\n */\nfunction isBuiltIn(obj) {\n\n\t// If primitive, array, or POJO return true. Also check if\n\t// it is not a POJO but is some type like [object Date] or\n\t// [object Regex] and return true.\n\tif (isPrimitive(obj) ||\n\t\tArray.isArray(obj) ||\n\t\tisPlainObject(obj) ||\n\t\t(Object.prototype.toString.call(obj) !== '[object Object]' &&\n\t\t\tObject.prototype.toString.call(obj).indexOf('[object ') !== -1)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\n/**\n * @function can-reflect.isValueLike isValueLike\n * @parent can-reflect/type\n * @description Test if a value represents a single value (as opposed to several values).\n *\n * @signature `isValueLike(obj)`\n *\n * Return `true` if `obj` is a primitive or implements [can-symbol/symbols/getValue `@@can.getValue`],\n * `false` otherwise.\n *\n * ```\n * canReflect.isValueLike(null); // -> true\n * canReflect.isValueLike({}); // -> false\n * canReflect.isValueLike(function() {}); // -> false\n * canReflect.isValueLike({ [canSymbol.for(\"can.isValueLike\")]: true}); // -> true\n * canReflect.isValueLike({ [canSymbol.for(\"can.getValue\")]: function() {} }); // -> true\n * canReflect.isValueLike(canCompute()); // -> true\n * canReflect.isValueLike(new DefineMap()); // -> false\n *\n * ```\n *\n * @param  {*}  obj maybe a primitive or an object that yields a value\n * @return {Boolean}\n */\nfunction isValueLike(obj) {\n\tvar symbolValue;\n\tif(isPrimitive(obj)) {\n\t\treturn true;\n\t}\n\tsymbolValue = obj[canSymbol.for(\"can.isValueLike\")];\n\tif( typeof symbolValue !== \"undefined\") {\n\t\treturn symbolValue;\n\t}\n\tvar value = obj[canSymbol.for(\"can.getValue\")];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n}\n\n/**\n * @function can-reflect.isMapLike isMapLike\n * @parent can-reflect/type\n *\n * @description Test if a value represents multiple values.\n *\n * @signature `isMapLike(obj)`\n *\n * Return `true` if `obj` is _not_ a primitive, does _not_ have a falsy value for\n * [can-symbol/symbols/isMapLike `@@@@can.isMapLike`], or alternately implements\n * [can-symbol/symbols/getKeyValue `@@@@can.getKeyValue`]; `false` otherwise.\n *\n * ```\n * canReflect.isMapLike(null); // -> false\n * canReflect.isMapLike(1); // -> false\n * canReflect.isMapLike(\"foo\"); // -> false\n * canReflect.isMapLike({}); // -> true\n * canReflect.isMapLike(function() {}); // -> true\n * canReflect.isMapLike([]); // -> false\n * canReflect.isMapLike({ [canSymbol.for(\"can.isMapLike\")]: false }); // -> false\n * canReflect.isMapLike({ [canSymbol.for(\"can.getKeyValue\")]: null }); // -> false\n * canReflect.isMapLike(canCompute()); // -> false\n * canReflect.isMapLike(new DefineMap()); // -> true\n *\n * ```\n *\n * @param  {*}  obj maybe a Map-like\n * @return {Boolean}\n */\nfunction isMapLike(obj) {\n\tif(isPrimitive(obj)) {\n\t\treturn false;\n\t}\n\tvar isMapLike = obj[canSymbol.for(\"can.isMapLike\")];\n\tif(typeof isMapLike !== \"undefined\") {\n\t\treturn !!isMapLike;\n\t}\n\tvar value = obj[canSymbol.for(\"can.getKeyValue\")];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n\t// everything else in JS is MapLike\n\treturn true;\n}\n\n/**\n * @function can-reflect.isObservableLike isObservableLike\n * @parent can-reflect/type\n * @description Test if a value (or its keys) can be observed for changes.\n *\n * @signature `isObservableLike(obj)`\n *\n * Return  `true` if `obj` is _not_ a primitive and implements any of\n * [can-symbol/symbols/onValue `@@@@can.onValue`], [can-symbol/symbols/onKeyValue `@@@@can.onKeyValue`], or\n * [can-symbol/symbols/onPatches `@@@@can.onKeys`]; `false` otherwise.\n *\n * ```\n * canReflect.isObservableLike(null); // -> false\n * canReflect.isObservableLike({}); // -> false\n * canReflect.isObservableLike([]); // -> false\n * canReflect.isObservableLike(function() {}); // -> false\n * canReflect.isObservableLike({ [canSymbol.for(\"can.onValue\")]: function() {} }); // -> true\n * canReflect.isObservableLike({ [canSymbol.for(\"can.onKeyValue\")]: function() {} }); // -> true\n * canReflect.isObservableLike(canCompute())); // -> true\n * canReflect.isObservableLike(new DefineMap())); // -> true\n * ```\n *\n * @param  {*}  obj maybe an observable\n * @return {Boolean}\n */\n\n// Specially optimized\nvar onValueSymbol = canSymbol.for(\"can.onValue\"),\n\tonKeyValueSymbol = canSymbol.for(\"can.onKeyValue\"),\n\tonPatchesSymbol = canSymbol.for(\"can.onPatches\");\nfunction isObservableLike( obj ) {\n\tif(isPrimitive(obj)) {\n\t\treturn false;\n\t}\n\treturn Boolean(obj[onValueSymbol] || obj[onKeyValueSymbol] || obj[onPatchesSymbol]);\n}\n\n/**\n * @function can-reflect.isListLike isListLike\n * @parent can-reflect/type\n *\n * @description Test if a value looks like a constructor function.\n *\n * @signature `isListLike(list)`\n *\n * Return `true` if `list` is a `String`, <br>OR `list` is _not_ a primitive and implements `@@@@iterator`,\n * <br>OR `list` is _not_ a primitive and returns `true` for `Array.isArray()`, <br>OR `list` is _not_ a primitive and has a\n * numerical length and is either empty (`length === 0`) or has a last element at index `length - 1`; <br>`false` otherwise\n *\n * ```\n * canReflect.isListLike(null); // -> false\n * canReflect.isListLike({}); // -> false\n * canReflect.isListLike([]); // -> true\n * canReflect.isListLike(\"foo\"); // -> true\n * canReflect.isListLike(1); // -> false\n * canReflect.isListLike({ [canSymbol.for(\"can.isListLike\")]: true }); // -> true\n * canReflect.isListLike({ [canSymbol.iterator]: function() {} }); // -> true\n * canReflect.isListLike({ length: 0 }); // -> true\n * canReflect.isListLike({ length: 3 }); // -> false\n * canReflect.isListLike({ length: 3, \"2\": true }); // -> true\n * canReflect.isListLike(new DefineMap()); // -> false\n * canReflect.isListLike(new DefineList()); // -> true\n * ```\n *\n * @param  {*}  list maybe a List-like\n * @return {Boolean}\n */\nfunction isListLike( list ) {\n\tvar symbolValue,\n\t\ttype = typeof list;\n\tif(type === \"string\") {\n\t\treturn true;\n\t}\n\tif( isPrimitive(list) ) {\n\t\treturn false;\n\t}\n\tsymbolValue = list[canSymbol.for(\"can.isListLike\")];\n\tif( typeof symbolValue !== \"undefined\") {\n\t\treturn symbolValue;\n\t}\n\tvar value = list[canSymbol.iterator];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n\tif(Array.isArray(list)) {\n\t\treturn true;\n\t}\n\treturn helpers.hasLength(list);\n}\n\n/**\n * @function can-reflect.isSymbolLike isSymbolLike\n * @parent can-reflect/type\n *\n * @description Test if a value is a symbol or a [can-symbol].\n *\n * @signature `isSymbolLike(symbol)`\n *\n * Return `true` if `symbol` is a native Symbol, or evaluates to a String with a prefix\n * equal to that of CanJS's symbol polyfill; `false` otherwise.\n *\n * ```\n * /* ES6 *\\/ canReflect.isSymbolLike(Symbol.iterator); // -> true\n * canReflect.isSymbolLike(canSymbol.for(\"foo\")); // -> true\n * canReflect.isSymbolLike(\"@@symbol.can.isSymbol\"); // -> true (due to polyfill for non-ES6)\n * canReflect.isSymbolLike(\"foo\"); // -> false\n * canReflect.isSymbolLike(null); // -> false\n * canReflect.isSymbolLike(1); // -> false\n * canReflect.isSymbolLike({}); // -> false\n * canReflect.isSymbolLike({ toString: function() { return \"@@symbol.can.isSymbol\"; } }); // -> true\n * ```\n *\n * @param  {*}  symbol maybe a symbol\n * @return {Boolean}\n */\n\nvar supportsSymbols = typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\";\nvar isSymbolLike;\nif(supportsSymbols) {\n\tisSymbolLike = function(symbol) {\n\t\treturn typeof symbol === \"symbol\";\n\t};\n} else {\n\tvar symbolStart = \"@@symbol\";\n\tisSymbolLike = function(symbol) {\n\t\tif(typeof symbol === \"object\" && !Array.isArray(symbol)){\n\t\t\treturn symbol.toString().substr(0, symbolStart.length) === symbolStart;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n}\n\nvar coreHasOwn = Object.prototype.hasOwnProperty;\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(obj) {\n\t// Must be an Object.\n\t// Because of IE, we also have to check the presence of the constructor property.\n\t// Make sure that DOM nodes and window objects don't pass through, as well\n\tif (!obj || typeof obj !== 'object' ) {\n\t\treturn false;\n\t}\n\tvar proto = Object.getPrototypeOf(obj);\n\tif(proto === Object.prototype || proto === null) {\n\t\treturn true;\n\t}\n\t// partially inspired by lodash: https://github.com/lodash/lodash\n\tvar Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;\n\treturn typeof Constructor === 'function' && Constructor instanceof Constructor &&\n    \tfuncToString.call(Constructor) === objectCtorString;\n}\n\nmodule.exports = {\n\tisConstructorLike: isConstructorLike,\n\tisFunctionLike: isFunctionLike,\n\tisListLike: isListLike,\n\tisMapLike: isMapLike,\n\tisObservableLike: isObservableLike,\n\tisPrimitive: isPrimitive,\n\tisBuiltIn: isBuiltIn,\n\tisValueLike: isValueLike,\n\tisSymbolLike: isSymbolLike,\n\t/**\n\t * @function can-reflect.isMoreListLikeThanMapLike isMoreListLikeThanMapLike\n\t * @parent can-reflect/type\n\t *\n\t * @description Test if a value should be treated as a list instead of a map.\n\t *\n\t * @signature `isMoreListLikeThanMapLike(obj)`\n\t *\n\t * Return  `true` if `obj` is an Array, declares itself to be more ListLike with\n\t * `@@@@can.isMoreListLikeThanMapLike`, or self-reports as ListLike but not as MapLike; `false` otherwise.\n\t *\n\t * ```\n\t * canReflect.isMoreListLikeThanMapLike([]); // -> true\n\t * canReflect.isMoreListLikeThanMapLike(null); // -> false\n\t * canReflect.isMoreListLikeThanMapLike({}); // -> false\n\t * canReflect.isMoreListLikeThanMapLike(new DefineList()); // -> true\n\t * canReflect.isMoreListLikeThanMapLike(new DefineMap()); // -> false\n\t * canReflect.isMoreListLikeThanMapLike(function() {}); // -> false\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test for ListLike against MapLike traits.\n\t * @return {Boolean}\n\t */\n\tisMoreListLikeThanMapLike: function(obj){\n\t\tif(Array.isArray(obj)) {\n\t\t\treturn true;\n\t\t}\n\t\tif(obj instanceof Array) {\n\t\t\treturn true;\n\t\t}\n\t\tif( obj == null ) {\n\t\t\treturn false;\n\t\t}\n\t\tvar value = obj[canSymbol.for(\"can.isMoreListLikeThanMapLike\")];\n\t\tif(value !== undefined) {\n\t\t\treturn value;\n\t\t}\n\t\tvar isListLike = this.isListLike(obj),\n\t\t\tisMapLike = this.isMapLike(obj);\n\t\tif(isListLike && !isMapLike) {\n\t\t\treturn true;\n\t\t} else if(!isListLike && isMapLike) {\n\t\t\treturn false;\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.isIteratorLike isIteratorLike\n\t * @parent can-reflect/type\n\t * @description Test if a value looks like an iterator.\n\t * @signature `isIteratorLike(obj)`\n\t *\n\t * Return `true` if `obj` has a key `\"next\"` pointing to a zero-argument function; `false` otherwise\n\t *\n\t * ```\n\t * canReflect.isIteratorLike([][Symbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(new DefineList()[canSymbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(new DefineMap()[canSymbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(null); // -> false\n\t * canReflect.isIteratorLike({ next: function() {} }); // -> true\n\t * canReflect.isIteratorLike({ next: function(foo) {} }); // -> false (iterator nexts do not take arguments)\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test for Iterator traits\n\t * @return {Boolean}\n\t */\n\tisIteratorLike: function(obj){\n\t\treturn obj &&\n\t\t\ttypeof obj === \"object\" &&\n\t\t\ttypeof obj.next === \"function\" &&\n\t\t\tobj.next.length === 0;\n\t},\n\t/**\n\t * @function can-reflect.isPromise isPromise\n\t * @parent can-reflect/type\n\t * @description Test if a value is a promise.\n\t *\n\t * @signature `isPromise(obj)`\n\t *\n\t * Return `true` if `obj` is an instance of promise or `.toString` returns `\"[object Promise]\"`.\n\t *\n\t * ```\n\t * canReflect.isPromise(Promise.resolve()); // -> true\n\t * ```\n\t *\n\t * @param  {*}  obj the object to test for Promise traits.\n\t * @return {Boolean}\n\t */\n\tisPromise: function(obj){\n\t\treturn (obj instanceof Promise || (Object.prototype.toString.call(obj) === '[object Promise]'));\n\t},\n\t/**\n\t * @function can-reflect.isPlainObject isPlainObject\n\t * @parent can-reflect/type\n\t * @description Test if a value is an object created with `{}` or `new Object()`.\n\t *\n\t * @signature `isPlainObject(obj)`\n\t *\n\t * Attempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:\n\t *\n\t * 1. Objects with prototypes (created using the `new` keyword).\n\t * 2. Booleans.\n\t * 3. Numbers.\n\t * 4. NaN.\n\t *\n\t * ```js\n\t * var isPlainObject = require(\"can-reflect\").isPlainObject;\n\t *\n\t * // Created with {}\n\t * console.log(isPlainObject({})); // -> true\n\t *\n\t * // new Object\n\t * console.log(isPlainObject(new Object())); // -> true\n\t *\n\t * // Custom object\n\t * var Ctr = function(){};\n\t * var obj = new Ctr();\n\t *\n\t * console.log(isPlainObject(obj)); // -> false\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test.\n\t * @return {Boolean}\n\t */\n\tisPlainObject: isPlainObject\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/reflections/type/type.js?");

/***/ }),

/***/ "../../node_modules/can-reflect/types/map.js":
/*!******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/types/map.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar shape = __webpack_require__(/*! ../reflections/shape/shape */ \"../../node_modules/can-reflect/reflections/shape/shape.js\");\nvar CanSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n\nfunction keysPolyfill() {\n  var keys = [];\n  var currentIndex = 0;\n\n  this.forEach(function(val, key) {\n    keys.push(key);\n  });\n\n  return {\n    next: function() {\n      return {\n        value: keys[currentIndex],\n        done: (currentIndex++ === keys.length)\n      };\n    }\n  }\n}\n\nif (typeof Map !== \"undefined\") {\n  shape.assignSymbols(Map.prototype, {\n    \"can.getOwnEnumerableKeys\": Map.prototype.keys,\n    \"can.setKeyValue\": Map.prototype.set,\n    \"can.getKeyValue\": Map.prototype.get,\n    \"can.deleteKeyValue\": Map.prototype[\"delete\"],\n    \"can.hasOwnKey\": Map.prototype.has\n  });\n\n  if (typeof Map.prototype.keys !== \"function\") {\n    Map.prototype.keys = Map.prototype[CanSymbol.for(\"can.getOwnEnumerableKeys\")] = keysPolyfill;\n  }\n}\n\nif (typeof WeakMap !== \"undefined\") {\n  shape.assignSymbols(WeakMap.prototype, {\n    \"can.getOwnEnumerableKeys\": function() {\n      throw new Error(\"can-reflect: WeakMaps do not have enumerable keys.\");\n    },\n    \"can.setKeyValue\": WeakMap.prototype.set,\n    \"can.getKeyValue\": WeakMap.prototype.get,\n    \"can.deleteKeyValue\": WeakMap.prototype[\"delete\"],\n    \"can.hasOwnKey\": WeakMap.prototype.has\n  });\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/types/map.js?");

/***/ }),

/***/ "../../node_modules/can-reflect/types/set.js":
/*!******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/types/set.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar shape = __webpack_require__(/*! ../reflections/shape/shape */ \"../../node_modules/can-reflect/reflections/shape/shape.js\");\nvar CanSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n\nif (typeof Set !== \"undefined\") {\n  shape.assignSymbols(Set.prototype, {\n    \"can.isMoreListLikeThanMapLike\": true,\n    \"can.updateValues\": function(index, removing, adding) {\n      if (removing !== adding) {\n        shape.each(\n          removing,\n          function(value) {\n            this.delete(value);\n          },\n          this\n        );\n      }\n      shape.each(\n        adding,\n        function(value) {\n          this.add(value);\n        },\n        this\n      );\n    },\n    \"can.size\": function() {\n      return this.size;\n    }\n  });\n\n  // IE11 doesn't support Set.prototype[@@iterator]\n  if (typeof Set.prototype[CanSymbol.iterator] !== \"function\") {\n\t  Set.prototype[CanSymbol.iterator] = function() {\n\t\t  var arr = [];\n\t\t  var currentIndex = 0;\n\n\t\t  this.forEach(function(val) {\n\t\t\t  arr.push(val);\n\t\t  });\n\n\t\t  return {\n\t\t\t  next: function() {\n\t\t\t\t  return {\n\t\t\t\t\t  value: arr[currentIndex],\n\t\t\t\t\t  done: (currentIndex++ === arr.length)\n\t\t\t\t  };\n\t\t\t  }\n\t\t  }\n\t  };\n  }\n}\nif (typeof WeakSet !== \"undefined\") {\n  shape.assignSymbols(WeakSet.prototype, {\n    \"can.isListLike\": true,\n    \"can.isMoreListLikeThanMapLike\": true,\n    \"can.updateValues\": function(index, removing, adding) {\n      if (removing !== adding) {\n        shape.each(\n          removing,\n          function(value) {\n            this.delete(value);\n          },\n          this\n        );\n      }\n      shape.each(\n        adding,\n        function(value) {\n          this.add(value);\n        },\n        this\n      );\n    },\n    \"can.size\": function() {\n      throw new Error(\"can-reflect: WeakSets do not have enumerable keys.\");\n    }\n  });\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-reflect/types/set.js?");

/***/ }),

/***/ "../../node_modules/can-simple-map/can-simple-map.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-map/can-simple-map.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Construct = __webpack_require__(/*! can-construct */ \"../../node_modules/can-construct/can-construct.js\");\nvar eventQueue = __webpack_require__(/*! can-event-queue/map/map */ \"../../node_modules/can-event-queue/map/map.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n\n// Ensure the \"obj\" passed as an argument has an object on @@can.meta\nvar ensureMeta = function ensureMeta(obj) {\n\tvar metaSymbol = canSymbol.for(\"can.meta\");\n\tvar meta = obj[metaSymbol];\n\n\tif (!meta) {\n\t\tmeta = {};\n\t\tcanReflect.setKeyValue(obj, metaSymbol, meta);\n\t}\n\n\treturn meta;\n};\n\n// this is a very simple can-map like object\nvar SimpleMap = Construct.extend(\"SimpleMap\",\n\t{\n\t\t// ### setup\n\t\t// A setup function for the instantiation of a simple-map.\n\t\tsetup: function(initialData){\n\t\t\tthis._data = {};\n\t\t\tif(initialData && typeof initialData === \"object\") {\n\t\t\t\tthis.attr(initialData);\n\t\t\t}\n\t\t},\n\t\t// ### attr\n\t\t// The main get/set interface simple-map.\n\t\t// Either sets or gets one or more properties depending on how it is called.\n\t\tattr: function(prop, value) {\n\t\t\tvar self = this;\n\n\t\t\tif(arguments.length === 0 ) {\n\t\t\t\tObservationRecorder.add(this,\"can.keys\");\n\t\t\t\tvar data = {};\n\t\t\t\tcanReflect.eachKey(this._data, function(value, prop){\n\t\t\t\t\tObservationRecorder.add(this, prop);\n\t\t\t\t\tdata[prop] = value;\n\t\t\t\t}, this);\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\telse if(arguments.length > 1) {\n\t\t\t\tvar had = this._data.hasOwnProperty(prop);\n\t\t\t\tvar old = this._data[prop];\n\t\t\t\tthis._data[prop] = value;\n\t\t\t\tif(old !== value) {\n\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\t\t\t\tthis._log(prop, value, old);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\n\t\t\t\t\tvar dispatched = {\n\t\t\t\t\t\tkeyChanged: !had ? prop : undefined,\n\t\t\t\t\t\ttype: prop\n\t\t\t\t\t};\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tdispatched = {\n\t\t\t\t\t\t\tkeyChanged: !had ? prop : undefined,\n\t\t\t\t\t\t\ttype: prop,\n\t\t\t\t\t\t\treasonLog: [ canReflect.getName(this) + \"'s\", prop, \"changed to\", value, \"from\", old ],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tthis.dispatch(dispatched, [value, old]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// 1 argument\n\t\t\telse if(typeof prop === 'object') {\n\t\t\t\tqueues.batch.start();\n\t\t\t\tcanReflect.eachKey(prop, function(value, key) {\n\t\t\t\t\tself.attr(key, value);\n\t\t\t\t});\n\t\t\t\tqueues.batch.stop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(prop !== \"constructor\") {\n\t\t\t\t\tObservationRecorder.add(this, prop);\n\t\t\t\t\treturn this._data[prop];\n\t\t\t\t}\n\n\t\t\t\treturn this.constructor;\n\t\t\t}\n\t\t},\n\t\tserialize: function(){\n\t\t\treturn canReflect.serialize(this, Map);\n\t\t},\n\t\tget: function(){\n\t\t\treturn this.attr.apply(this, arguments);\n\t\t},\n\t\tset: function(){\n\t\t\treturn this.attr.apply(this, arguments);\n\t\t},\n\t\t// call `.log()` to log all property changes\n\t\t// pass a single property to only get logs for said property, e.g: `.log(\"foo\")`\n\t\tlog: function(key) {\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tvar quoteString = function quoteString(x) {\n\t\t\t\t\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n\t\t\t\t};\n\t\t\t}\n\t\t\tvar meta = ensureMeta(this);\n\t\t\tmeta.allowedLogKeysSet = meta.allowedLogKeysSet || new Set();\n\n\t\t\tif (key) {\n\t\t\t\tmeta.allowedLogKeysSet.add(key);\n\t\t\t}\n\n\t\t\tthis._log = function(prop, current, previous, log) {\n\t\t\t\tif (key && !meta.allowedLogKeysSet.has(prop)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdev.log(\n\t\t\t\t\tcanReflect.getName(this),\n\t\t\t\t\t\"\\n key \", quoteString(prop),\n\t\t\t\t\t\"\\n is  \", quoteString(current),\n\t\t\t\t\t\"\\n was \", quoteString(previous)\n\t\t\t\t);\n\t\t\t};\n\t\t\t//!steal-remove-end\n\t\t}\n\t}\n);\n\neventQueue(SimpleMap.prototype);\n\nvar simpleMapProto = {\n\t// -type-\n\t\"can.isMapLike\": true,\n\t\"can.isListLike\": false,\n\t\"can.isValueLike\": false,\n\n\t// -get/set-\n\t\"can.getKeyValue\": SimpleMap.prototype.get,\n\t\"can.setKeyValue\": SimpleMap.prototype.set,\n\t\"can.deleteKeyValue\": function(prop) {\n\t\tvar dispatched;\n\t\tif( this._data.hasOwnProperty(prop) ) {\n\t\t\tvar old = this._data[prop];\n\t\t\tdelete this._data[prop];\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\t\tthis._log(prop, undefined, old);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tdispatched = {\n\t\t\t\tkeyChanged: prop,\n\t\t\t\ttype: prop\n\t\t\t};\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tdispatched = {\n\t\t\t\t\tkeyChanged: prop,\n\t\t\t\t\ttype: prop,\n\t\t\t\t\treasonLog: [ canReflect.getName(this) + \"'s\", prop, \"deleted\", old ]\n\t\t\t\t};\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tthis.dispatch(dispatched, [undefined, old]);\n\t\t}\n\t},\n\n\n\t// -shape\n\t\"can.getOwnEnumerableKeys\": function(){\n\t\tObservationRecorder.add(this, 'can.keys');\n\t\treturn Object.keys(this._data);\n\t},\n\n\t// -shape get/set-\n\t\"can.assignDeep\": function(source){\n\t\tqueues.batch.start();\n\t\t// TODO: we should probably just throw an error instead of cleaning\n\t\tcanReflect.assignMap(this, source);\n\t\tqueues.batch.stop();\n\t},\n\t\"can.updateDeep\": function(source){\n\t\tqueues.batch.start();\n\t\t// TODO: we should probably just throw an error instead of cleaning\n\t\tcanReflect.updateMap(this, source);\n\t\tqueues.batch.stop();\n\t},\n\t\"can.keyHasDependencies\": function(key) {\n\t\treturn false;\n\t},\n\t\"can.getKeyDependencies\": function(key) {\n\t\treturn undefined;\n\t}\t\n};\n\n//!steal-remove-start\nif (true) {\n\tsimpleMapProto[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"{}\";\n\t};\n}\n//!steal-remove-end\ncanReflect.assignSymbols(SimpleMap.prototype,simpleMapProto);\n\n// Setup other symbols\n\n\nmodule.exports = SimpleMap;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-map/can-simple-map.js?");

/***/ }),

/***/ "../../node_modules/can-simple-observable/async/async.js":
/*!******************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/async/async.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar SimpleObservable = __webpack_require__(/*! ../can-simple-observable */ \"../../node_modules/can-simple-observable/can-simple-observable.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar SettableObservable = __webpack_require__(/*! ../settable/settable */ \"../../node_modules/can-simple-observable/settable/settable.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"../../node_modules/can-event-queue/value/value.js\");\n\n// This is an observable that is like `settable`, but passed a `resolve`\n// function that can resolve the value of this observable late.\nfunction AsyncObservable(fn, context, initialValue) {\n\tthis.resolve = this.resolve.bind(this);\n\tthis.lastSetValue = new SimpleObservable(initialValue);\n\tthis.handler = this.handler.bind(this);\n\n\tfunction observe() {\n\t\tthis.resolveCalled = false;\n\n\t\t// set inGetter flag to avoid calling `resolve` redundantly if it is called\n\t\t// synchronously in the getter\n\t\tthis.inGetter = true;\n\t\tvar newVal = fn.call(\n\t\t\tcontext,\n\t\t\tthis.lastSetValue.get(),\n\t\t\tthis.bound === true ? this.resolve : undefined\n\t\t);\n\t\tthis.inGetter = false;\n\n\t\t// if the getter returned a value, resolve with the value\n\t\tif (newVal !== undefined) {\n\t\t\tthis.resolve(newVal);\n\t\t}\n\t\t// otherwise, if `resolve` was called synchronously in the getter,\n\t\t// resolve with the value passed to `resolve`\n\t\telse if (this.resolveCalled) {\n\t\t\tthis.resolve(this.value);\n\t\t}\n\n\t\t// if bound, the handlers will be called by `resolve`\n\t\t// returning here would cause a duplicate event\n\t\tif (this.bound !== true) {\n\t\t\treturn newVal;\n\t\t}\n\t}\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor) +\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(fn) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.handler, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".handler\"\n\t\t});\n\t\tObject.defineProperty(observe, \"name\", {\n\t\t\tvalue: canReflect.getName(fn) + \"::\" + canReflect.getName(this.constructor)\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tthis.observation = new Observation(observe, this);\n}\nAsyncObservable.prototype = Object.create(SettableObservable.prototype);\nAsyncObservable.prototype.constructor = AsyncObservable;\n\nAsyncObservable.prototype.handler = function(newVal) {\n\tif (newVal !== undefined) {\n\t\tSettableObservable.prototype.handler.apply(this, arguments);\n\t}\n};\n\nvar peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));\nAsyncObservable.prototype.activate = function() {\n\tcanReflect.onValue(this.observation, this.handler, \"notify\");\n\tif (!this.resolveCalled) {\n\t\tthis.value = peek(this.observation);\n\t}\n};\n\nAsyncObservable.prototype.resolve = function resolve(newVal) {\n\tthis.resolveCalled = true;\n\tvar old = this.value;\n\tthis.value = newVal;\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tif (typeof this._log === \"function\") {\n\t\t\tthis._log(old, newVal);\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// if resolve was called synchronously from the getter, do not enqueue changes\n\t// the observation will handle calling resolve again if required\n\tif (!this.inGetter) {\n\t\tvar queuesArgs = [\n\t\tthis.handlers.getNode([]),\n\t\t\tthis,\n\t\t\t[newVal, old],\n\t\t\tnull\n\t\t];\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\tthis,\n\t\t\t\t[newVal, old],\n\t\t\t\tnull\n\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t, [canReflect.getName(this), \"resolved with\", newVal]\n\t\t\t\t/* jshint laxcomma: false */\n\t\t\t];\n\t\t}\n\t\t//!steal-remove-end\n\t\t// adds callback handlers to be called w/i their respective queue.\n\t\tqueues.enqueueByQueue.apply(queues, queuesArgs);\n\t}\n};\n\nmodule.exports = AsyncObservable;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/async/async.js?");

/***/ }),

/***/ "../../node_modules/can-simple-observable/can-simple-observable.js":
/*!****************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/can-simple-observable.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar log = __webpack_require__(/*! ./log */ \"../../node_modules/can-simple-observable/log.js\");\nvar ns = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"../../node_modules/can-event-queue/value/value.js\");\n\nvar dispatchSymbol = canSymbol.for(\"can.dispatch\");\n\n/**\n * @module {function} can-simple-observable\n * @parent can-observables\n * @collection can-infrastructure\n * @package ./package.json\n * @description Create an observable value.\n *\n * @signature `new SimpleObservable(initialValue)`\n *\n * Creates an observable value that can be read, written, and observed using [can-reflect].\n *\n * @param {*} initialValue The initial value of the observable.\n *\n * @return {can-simple-observable} An observable instance\n *\n * @body\n *\n * ## Use\n *\n * ```js\n *  var obs = new SimpleObservable('one');\n *\n *  canReflect.getValue(obs); // -> \"one\"\n *\n *  canReflect.setValue(obs, 'two');\n *  canReflect.getValue(obs); // -> \"two\"\n *\n *  function handler(newValue) {\n *    // -> \"three\"\n *  };\n *  canReflect.onValue(obs, handler);\n *  canReflect.setValue(obs, 'three');\n *\n *  canReflect.offValue(obs, handler);\n * ```\n */\nfunction SimpleObservable(initialValue) {\n\tthis.value = initialValue;\n}\n\n// mix in the value-like object event bindings\nvalueEventBindings(SimpleObservable.prototype);\n\nObject.assign(SimpleObservable.prototype, {\n\tlog: log,\n\tget: function(){\n\t\tObservationRecorder.add(this);\n\t\treturn this.value;\n\t},\n\tset: function(value){\n\t\tvar old = this.value;\n\t\tthis.value = value;\n\n\t\tthis[dispatchSymbol](value, old);\n\t}\n});\n\nvar simpleObservableProto = {\n\t\"can.getValue\": SimpleObservable.prototype.get,\n\t\"can.setValue\": SimpleObservable.prototype.set,\n\t\"can.isMapLike\": false,\n\t\"can.valueHasDependencies\": function(){\n\t\treturn true;\n\t}\n};\n\n//!steal-remove-start\nif (true) {\n\tsimpleObservableProto[\"can.getName\"] = function() {\n\t\tvar value = this.value;\n\t\tif (typeof value !== 'object' || value === null) {\n\t\t\tvalue = JSON.stringify(value);\n\t\t}\n\t\telse {\n\t\t\tvalue = '';\n\t\t}\n\n\t\treturn canReflect.getName(this.constructor) + \"<\" + value + \">\";\n\t};\n}\n//!steal-remove-end\n\ncanReflect.assignSymbols(SimpleObservable.prototype, simpleObservableProto);\n\nmodule.exports = ns.SimpleObservable = SimpleObservable;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/can-simple-observable.js?");

/***/ }),

/***/ "../../node_modules/can-simple-observable/log.js":
/*!**********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/log.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\n// when printing out strings to the console, quotes are not included which\n// makes it confusing to tell the actual output from static string messages\nfunction quoteString(x) {\n\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n}\n\n// To add the `.log` function to a observable\n// a.- Add the log function to the propotype:\n//\t   `Observable.propotype.log = log`\n// b.- Make sure `._log` is called by the observable when mutation happens\n//     `_.log` should be passed the current value and the value before the mutation\nmodule.exports = function log() {\n\t//!steal-remove-start\n\tif (true) {\n\t\tthis._log = function(previous, current) {\n\t\t\tdev.log(\n\t\t\t\tcanReflect.getName(this),\n\t\t\t\t\"\\n is  \", quoteString(current),\n\t\t\t\t\"\\n was \", quoteString(previous)\n\t\t\t);\n\t\t};\n\t}\n\t//!steal-remove-end\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/log.js?");

/***/ }),

/***/ "../../node_modules/can-simple-observable/resolver/resolver.js":
/*!************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/resolver/resolver.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar mapEventBindings = __webpack_require__(/*! can-event-queue/map/map */ \"../../node_modules/can-event-queue/map/map.js\");\nvar SettableObservable = __webpack_require__(/*! ../settable/settable */ \"../../node_modules/can-simple-observable/settable/settable.js\");\nvar SimpleObservable = __webpack_require__(/*! ../can-simple-observable */ \"../../node_modules/can-simple-observable/can-simple-observable.js\");\n\nvar getChangesSymbol = canSymbol.for(\"can.getChangesDependencyRecord\");\n\nfunction ResolverObservable(resolver, context) {\n\t// we don't want reads leaking out.  We should be binding to all of this ourselves.\n\tthis.resolver = ObservationRecorder.ignore(resolver);\n\tthis.context = context;\n\tthis.valueOptions = {\n\t\tresolve: this.resolve.bind(this),\n\t\tlistenTo: this.listenTo.bind(this),\n\t\tstopListening: this.stopListening.bind(this),\n\t\tlastSet: new SimpleObservable(undefined)\n\t};\n\n\tthis.update = this.update.bind(this);\n\n\tthis.contextHandlers = new WeakMap();\n\tthis.teardown = null;\n\t// a place holder for remembering where we bind\n\tthis.binder = {};\n\t//!steal-remove-start\n\tif (true) {\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor) +\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(resolver) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.update, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".update\"\n\t\t});\n\n\t\tcanReflect.assignSymbols(this.valueOptions.lastSet, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor)  +\"::lastSet\"+\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(resolver) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\t//!steal-remove-end\n}\nResolverObservable.prototype = Object.create(SettableObservable.prototype);\n\nfunction deleteHandler(bindTarget, event, queue, handler){\n\tmapEventBindings.off.call(bindTarget, event, handler, queue);\n}\n\ncanReflect.assignMap(ResolverObservable.prototype, {\n\tconstructor: ResolverObservable,\n\tlistenTo: function(bindTarget, event, handler, queueName) {\n\t\t//Object.defineProperty(this.handler, \"name\", {\n\t\t//\tvalue: canReflect.getName(this) + \".handler\"\n\t\t//});\n\t\tif(canReflect.isPrimitive(bindTarget)) {\n\t\t\thandler = event;\n\t\t\tevent = bindTarget;\n\t\t\tbindTarget = this.context;\n\t\t}\n\t\tif(typeof event === \"function\") {\n\t\t\thandler = event;\n\t\t\tevent = undefined;\n\t\t}\n\n\t\tvar resolverInstance = this;\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif(!handler.name) {\n\t\t\t\tObject.defineProperty(handler, \"name\", {\n\t\t\t\t\tvalue:\n\t\t\t\t\t\t(bindTarget ?\n\t\t\t\t\t\t\t canReflect.getName(bindTarget) : \"\")+\n\t\t\t\t\t\t (event ? \".on('\"+event+\"',handler)\" : \".on(handler)\")+\n\t\t\t\t\t\t \"::\"+canReflect.getName(this)\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tvar contextHandler = handler.bind(this.context);\n\t\tcontextHandler[getChangesSymbol] = function getChangesDependencyRecord() {\n\t\t\treturn {\n\t\t\t\tvalueDependencies: new Set([ resolverInstance ])\n\t\t\t};\n\t\t};\n\n\t\tthis.contextHandlers.set(handler, contextHandler);\n\t\tmapEventBindings.listenTo.call(this.binder, bindTarget, event, contextHandler, queueName || \"notify\");\n\t},\n\tstopListening: function(){\n\n\t\tvar meta = this.binder[canSymbol.for(\"can.meta\")];\n\t\tvar listenHandlers = meta && meta.listenHandlers;\n\t\tif(listenHandlers) {\n\t\t\tvar keys = mapEventBindings.stopListeningArgumentsToKeys.call({context: this.context, defaultQueue: \"notify\"});\n\n\t\t\tlistenHandlers.delete(keys, deleteHandler);\n\t\t}\n\t\treturn this;\n\t},\n\tresolve: function(newVal) {\n\t\tthis.value = newVal;\n\t\t// if we are setting up the initial binding and we get a resolved value\n\t\t// do not emit events for it.\n\n\t\tif(this.isBinding) {\n\t\t\tthis.lastValue = this.value;\n\t\t\treturn newVal;\n\t\t}\n\n\t\tif(this.value !== this.lastValue) {\n\t\t\tvar enqueueMeta  = {};\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\tenqueueMeta = {\n\t\t\t\t\tlog: [canReflect.getName(this.update)],\n\t\t\t\t\treasonLog: [canReflect.getName(this), \"resolved with\", newVal]\n\t\t\t\t};\n\t\t\t\t/* jshint laxcomma: false */\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t\n\t\t\tqueues.batch.start();\n\t\t\tqueues.deriveQueue.enqueue(\n\t\t\t\tthis.update,\n\t\t\t\tthis,\n\t\t\t\t[],\n\t\t\t\tenqueueMeta\n\t\t\t);\n\t\t\tqueues.batch.stop();\n\t\t}\n\t\treturn newVal;\n\t},\n\tupdate: function(){\n\n\t\tif(this.lastValue !== this.value) {\n\n\t\t\tvar old = this.lastValue;\n\t\t\tthis.lastValue = this.value;\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\t\tthis._log(old, this.value);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\t// adds callback handlers to be called w/i their respective queue.\n\t\t\tqueues.enqueueByQueue(\n\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\tthis,\n\t\t\t\t[this.value, old]\n\t\t\t);\n\t\t}\n\t},\n\tactivate: function() {\n\t\tthis.isBinding = true;\n\t\tthis.teardown = this.resolver.call(this.context, this.valueOptions);\n\t\tthis.isBinding = false;\n\t},\n\tonUnbound: function() {\n\t\tthis.bound = false;\n\t\tmapEventBindings.stopListening.call(this.binder);\n\t\tif(this.teardown != null) {\n\t\t\tthis.teardown();\n\t\t\tthis.teardown = null;\n\t\t}\n\t},\n\tset: function(value) {\n\t\tthis.valueOptions.lastSet.set(value);\n\n\t\t/*if (newVal !== this.lastSetValue.get()) {\n\t\t\tthis.lastSetValue.set(newVal);\n\t\t}*/\n\t},\n\tget: function() {\n\t\tif (ObservationRecorder.isRecording()) {\n\t\t\tObservationRecorder.add(this);\n\t\t\tif (!this.bound) {\n\t\t\t\tthis.onBound();\n\t\t\t}\n\t\t}\n\n\t\tif (this.bound === true) {\n\t\t\treturn this.value;\n\t\t} else {\n\t\t\tvar handler = function(){};\n\t\t\tthis.on(handler);\n\t\t\tvar val = this.value;\n\t\t\tthis.off(handler);\n\t\t\treturn val;\n\t\t}\n\t},\n\thasDependencies: function hasDependencies() {\n\t\tvar hasDependencies = false;\n\n\t\tif (this.bound) {\n\t\t\tvar meta = this.binder[canSymbol.for(\"can.meta\")];\n\t\t\tvar listenHandlers = meta && meta.listenHandlers;\n\t\t\thasDependencies = !!listenHandlers.size();\n\t\t}\n\n\t\treturn hasDependencies;\n\t},\n\tgetValueDependencies: function getValueDependencies() {\n\t\tif (this.bound) {\n\t\t\tvar meta = this.binder[canSymbol.for(\"can.meta\")];\n\t\t\tvar listenHandlers = meta && meta.listenHandlers;\n\n\t\t\tvar keyDeps = new Map();\n\t\t\tvar valueDeps = new Set();\n\n\t\t\tif (listenHandlers) {\n\t\t\t\tcanReflect.each(listenHandlers.root, function(events, obj) {\n\t\t\t\t\tcanReflect.each(events, function(queues, eventName) {\n\t\t\t\t\t\tif (eventName === undefined) {\n\t\t\t\t\t\t\tvalueDeps.add(obj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar entry = keyDeps.get(obj);\n\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\tentry = new Set();\n\t\t\t\t\t\t\t\tkeyDeps.set(obj, entry);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry.add(eventName);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tif (valueDeps.size || keyDeps.size) {\n\t\t\t\t\tvar result = {};\n\n\t\t\t\t\tif (keyDeps.size) {\n\t\t\t\t\t\tresult.keyDependencies = keyDeps;\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDeps.size) {\n\t\t\t\t\t\tresult.valueDependencies = valueDeps;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\ncanReflect.assignSymbols(ResolverObservable.prototype, {\n\t\"can.getValue\": ResolverObservable.prototype.get,\n\t\"can.setValue\": ResolverObservable.prototype.set,\n\t\"can.isMapLike\": false,\n\t\"can.getPriority\": function() {\n\t\t// TODO: the priority should come from any underlying values\n\t\treturn this.priority || 0;\n\t},\n\t\"can.setPriority\": function(newPriority) {\n\t\tthis.priority = newPriority;\n\t},\n\t\"can.valueHasDependencies\": ResolverObservable.prototype.hasDependencies,\n\t\"can.getValueDependencies\": ResolverObservable.prototype.getValueDependencies\n});\n\n\nmodule.exports = ResolverObservable;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/resolver/resolver.js?");

/***/ }),

/***/ "../../node_modules/can-simple-observable/settable/settable.js":
/*!************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/settable/settable.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar SimpleObservable = __webpack_require__(/*! ../can-simple-observable */ \"../../node_modules/can-simple-observable/can-simple-observable.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar log = __webpack_require__(/*! ../log */ \"../../node_modules/can-simple-observable/log.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"../../node_modules/can-event-queue/value/value.js\");\n\nvar peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));\n\n// This supports an \"internal\" settable value that the `fn` can derive its value from.\n// It's useful to `can-define`.\n// ```\n// new SettableObservable(function(lastSet){\n//   return lastSet * 5;\n// }, null, 5)\n// ```\nfunction SettableObservable(fn, context, initialValue) {\n\n\tthis.lastSetValue = new SimpleObservable(initialValue);\n\tfunction observe() {\n\t\treturn fn.call(context, this.lastSetValue.get());\n\t}\n\tthis.handler = this.handler.bind(this);\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor) +\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(fn) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.handler, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".handler\"\n\t\t});\n\t\tObject.defineProperty(observe, \"name\", {\n\t\t\tvalue: canReflect.getName(fn) + \"::\" + canReflect.getName(this.constructor)\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tthis.observation = new Observation(observe, this);\n}\n\nvalueEventBindings(SettableObservable.prototype);\n\nObject.assign(SettableObservable.prototype, {\n\t// call `obs.log()` to log observable changes to the browser console\n\t// The observable has to be bound for `.log` to be called\n\tlog: log,\n\tconstructor: SettableObservable,\n\thandler: function(newVal) {\n\t\tvar old = this.value;\n\t\tthis.value = newVal;\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\tthis._log(old, newVal);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// adds callback handlers to be called w/i their respective queue.\n\t\tqueues.enqueueByQueue(\n\t\t\tthis.handlers.getNode([]),\n\t\t\tthis,\n\t\t\t[newVal, old],\n\t\t\tfunction() {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t);\n\t},\n\tonBound: function() {\n\t\t// onBound can be called by `.get` and then later called through\n\t\t// a keyTree binding.\n\t\tif(!this.bound) {\n\t\t\tthis.bound = true;\n\t\t\tthis.activate();\n\t\t}\n\t},\n\tactivate: function(){\n\t\tcanReflect.onValue(this.observation, this.handler, \"notify\");\n\t\tthis.value = peek(this.observation);\n\t},\n\tonUnbound: function() {\n\t\tthis.bound = false;\n\t\tcanReflect.offValue(this.observation, this.handler, \"notify\");\n\t},\n\tset: function(newVal) {\n\t\tvar oldVal =  this.lastSetValue.get();\n\n\t\tif (\n\t\t\tcanReflect.isObservableLike(oldVal) &&\n\t\t\tcanReflect.isValueLike(oldVal) &&\n\t\t\t!canReflect.isObservableLike(newVal)\n\t\t) {\n\t\t\tcanReflect.setValue(oldVal, newVal);\n\t\t} else {\n\t\t\tif (newVal !== oldVal) {\n\t\t\t\tthis.lastSetValue.set(newVal);\n\t\t\t}\n\t\t}\n\t},\n\tget: function() {\n\t\tif (ObservationRecorder.isRecording()) {\n\t\t\tObservationRecorder.add(this);\n\t\t\tif (!this.bound) {\n\t\t\t\t// proactively setup bindings\n\t\t\t\tthis.onBound();\n\t\t\t}\n\t\t}\n\n\t\tif (this.bound === true) {\n\t\t\treturn this.value;\n\t\t} else {\n\t\t\treturn this.observation.get();\n\t\t}\n\t},\n\thasDependencies: function() {\n\t\treturn canReflect.valueHasDependencies(this.observation);\n\t},\n\tgetValueDependencies: function() {\n\t\treturn canReflect.getValueDependencies(this.observation);\n\t}\n});\n\ncanReflect.assignSymbols(SettableObservable.prototype, {\n\t\"can.getValue\": SettableObservable.prototype.get,\n\t\"can.setValue\": SettableObservable.prototype.set,\n\t\"can.isMapLike\": false,\n\t\"can.getPriority\": function() {\n\t\treturn canReflect.getPriority(this.observation);\n\t},\n\t\"can.setPriority\": function(newPriority) {\n\t\tcanReflect.setPriority(this.observation, newPriority);\n\t},\n\t\"can.valueHasDependencies\": SettableObservable.prototype.hasDependencies,\n\t\"can.getValueDependencies\": SettableObservable.prototype.getValueDependencies\n});\n\nmodule.exports = SettableObservable;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/settable/settable.js?");

/***/ }),

/***/ "../../node_modules/can-simple-observable/setter/setter.js":
/*!********************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/setter/setter.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar SettableObservable = __webpack_require__(/*! ../settable/settable */ \"../../node_modules/can-simple-observable/settable/settable.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"../../node_modules/can-event-queue/value/value.js\");\n\n// SetterObservable's call a function when set. Their getter is backed up by an\n// observation.\nfunction SetterObservable(getter, setter) {\n\tthis.setter = setter;\n\tthis.observation = new Observation(getter);\n\tthis.handler = this.handler.bind(this);\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor) +\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(getter) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.handler, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".handler\"\n\t\t});\n\t}\n\t//!steal-remove-end\n}\n\nSetterObservable.prototype = Object.create(SettableObservable.prototype);\nSetterObservable.prototype.constructor = SetterObservable;\nSetterObservable.prototype.set = function(newVal) {\n\tthis.setter(newVal);\n};\nSetterObservable.prototype.hasDependencies = function() {\n\treturn canReflect.valueHasDependencies(this.observation);\n};\ncanReflect.assignSymbols(SetterObservable.prototype, {\n\t\"can.setValue\": SetterObservable.prototype.set,\n\t\"can.valueHasDependencies\": SetterObservable.prototype.hasDependencies\n});\n\nmodule.exports = SetterObservable;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-simple-observable/setter/setter.js?");

/***/ }),

/***/ "../../node_modules/can-single-reference/can-single-reference.js":
/*!**************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-single-reference/can-single-reference.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar CID = __webpack_require__(/*! can-cid */ \"../../node_modules/can-cid/can-cid.js\");\n\nvar singleReference;\n\nfunction getKeyName(key, extraKey) {\n\tvar keyName = extraKey ? CID(key) + \":\" + extraKey : CID(key);\n\treturn keyName || key;\n}\n\n// weak maps are slow\n/* if(typeof WeakMap !== \"undefined\") {\n\tvar globalMap = new WeakMap();\n\tsingleReference = {\n\t\tset: function(obj, key, value){\n\t\t\tvar localMap = globalMap.get(obj);\n\t\t\tif( !localMap ) {\n\t\t\t\tglobalMap.set(obj, localMap = new WeakMap());\n\t\t\t}\n\t\t\tlocalMap.set(key, value);\n\t\t},\n\t\tgetAndDelete: function(obj, key){\n\t\t\treturn globalMap.get(obj).get(key);\n\t\t},\n\t\treferences: globalMap\n\t};\n} else {*/\nsingleReference = {\n    // obj is a function ... we need to place `value` on it so we can retreive it\n    // we can't use a global map\n    set: function(obj, key, value, extraKey){\n        // check if it has a single reference map\n        obj[getKeyName(key, extraKey)] = value;\n    },\n\n    getAndDelete: function(obj, key, extraKey){\n        var keyName = getKeyName(key, extraKey);\n        var value = obj[keyName];\n        delete obj[keyName];\n        return value;\n    }\n};\n/*}*/\n\nmodule.exports = singleReference;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-single-reference/can-single-reference.js?");

/***/ }),

/***/ "../../node_modules/can-stache-ast/can-stache-ast.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache-ast/can-stache-ast.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var controls = __webpack_require__(/*! ./controls */ \"../../node_modules/can-stache-ast/controls.js\");\nvar parser = __webpack_require__(/*! can-view-parser */ \"../../node_modules/can-view-parser/can-view-parser.js\");\n\nexports.parse = function(filename, source){\n\tif (arguments.length === 1) {\n\t\tsource = arguments[0];\n\t\tfilename = undefined;\n\t}\n\n\tvar template = source;\n\ttemplate = controls.cleanWhitespaceControl(template);\n\ttemplate = controls.cleanLineEndings(template);\n\n\tvar imports = [],\n\t\tdynamicImports = [],\n\t\timportDeclarations = [],\n\t\tases = {},\n\t\tinImport = false,\n\t\tinFrom = false,\n\t\tinAs = false,\n\t\tisUnary = false,\n\t\timportIsDynamic = false,\n\t\tcurrentAs = \"\",\n\t\tcurrentFrom = \"\";\n\n\tfunction processImport(line) {\n\t\tif(currentAs) {\n\t\t\tases[currentAs] = currentFrom;\n\t\t\tcurrentAs = \"\";\n\t\t}\n\t\tif(importIsDynamic) {\n\t\t\tdynamicImports.push(currentFrom);\n\t\t} else {\n\t\t\timports.push(currentFrom);\n\t\t}\n\t\timportDeclarations.push({\n\t\t\tspecifier: currentFrom,\n\t\t\tloc: {\n\t\t\t\tline: line\n\t\t\t}\n\t\t});\n\t}\n\n\tvar program = parser(template, {\n\t\tfilename: filename,\n\t\tstart: function( tagName, unary ){\n\t\t\tif(tagName === \"can-import\") {\n\t\t\t\tisUnary = unary;\n\t\t\t\timportIsDynamic = false; // assume static import unless there is content (chars/tags/special).\n\t\t\t\tinImport = true;\n\t\t\t} else if(tagName === \"can-dynamic-import\") {\n\t\t\t\tisUnary = unary;\n\t\t\t\timportIsDynamic = true;\n\t\t\t\tinImport = true;\n\t\t\t} else if(inImport) {\n\t\t\t\timportIsDynamic = true;  // found content inside can-import tag.\n\t\t\t\tinImport = false;\n\t\t\t}\n\t\t},\n\t\tattrStart: function( attrName ){\n\t\t\tif(attrName === \"from\") {\n\t\t\t\tinFrom = true;\n\t\t\t} else if(attrName === \"as\" || attrName === \"export-as\") {\n\t\t\t\tinAs = true;\n\t\t\t}\n\t\t},\n\t\tattrEnd: function( attrName ){\n\t\t\tif(attrName === \"from\") {\n\t\t\t\tinFrom = false;\n\t\t\t} else if(attrName === \"as\" || attrName === \"export-as\") {\n\t\t\t\tinAs = false;\n\t\t\t}\n\t\t},\n\t\tattrValue: function( value ){\n\t\t\tif(inFrom && inImport) {\n\t\t\t\tcurrentFrom = value;\n\t\t\t} else if(inAs && inImport) {\n\t\t\t\tcurrentAs = value;\n\t\t\t}\n\t\t},\n\t\tend: function(tagName, unary, line){\n\t\t\tif((tagName === \"can-import\" || tagName === \"can-dynamic-import\") && isUnary) {\n\t\t\t\tprocessImport(line);\n\t\t\t}\n\t\t},\n\t\tclose: function(tagName, unary, line){\n\t\t\tif((tagName === \"can-import\" || tagName === \"can-dynamic-import\")) {\n\t\t\t\tprocessImport(line);\n\t\t\t}\n\t\t},\n\t\tchars: function(text) {\n\t\t\tif(text.trim().length > 0) {\n\t\t\t\timportIsDynamic = true;\n\t\t\t}\n\t\t},\n\t\tspecial: function() {\n\t\t\timportIsDynamic = true;\n\t\t}\n\t}, true);\n\n\treturn {\n\t\tintermediate: program,\n\t\tprogram: program,\n\t\timports: imports,\n\t\tdynamicImports: dynamicImports,\n\t\timportDeclarations: importDeclarations,\n\t\tases: ases,\n\t\texports: ases\n\t};\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache-ast/can-stache-ast.js?");

/***/ }),

/***/ "../../node_modules/can-stache-ast/controls.js":
/*!********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache-ast/controls.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var mustacheLineBreakRegExp = /(?:(^|\\r?\\n)(\\s*)(\\{\\{([\\s\\S]*)\\}\\}\\}?)([^\\S\\n\\r]*)($|\\r?\\n))|(\\{\\{([\\s\\S]*)\\}\\}\\}?)/g,\n\tmustacheWhitespaceRegExp = /(\\s*)(\\{\\{\\{?)(-?)([\\s\\S]*?)(-?)(\\}\\}\\}?)(\\s*)/g;\n\nfunction splitModeFromExpression(expression, state){\n\texpression = expression.trim();\n\tvar mode = expression.charAt(0);\n\n\tif( \"#/{&^>!<\".indexOf(mode) >= 0 ) {\n\t\texpression =  expression.substr(1).trim();\n\t} else {\n\t\tmode = null;\n\t}\n\t// Triple braces do nothing within a tag.\n\tif(mode === \"{\" && state.node) {\n\t\tmode = null;\n\t}\n\treturn {\n\t\tmode: mode,\n\t\texpression: expression\n\t};\n}\n\nfunction cleanLineEndings(template) {\n\t\t// Finds mustache tags with space around them or no space around them.\n\t\treturn template.replace( mustacheLineBreakRegExp,\n\t\t\tfunction(whole,\n\t\t\t\treturnBefore,\n\t\t\t\tspaceBefore,\n\t\t\t\tspecial,\n\t\t\t\texpression,\n\t\t\t\tspaceAfter,\n\t\t\t\treturnAfter,\n\t\t\t\t// A mustache magic tag that has no space around it.\n\t\t\t\tspaceLessSpecial,\n\t\t\t\tspaceLessExpression,\n\t\t\t\tmatchIndex){\n\n\t\t\t// IE 8 will provide undefined\n\t\t\tspaceAfter = (spaceAfter || \"\");\n\t\t\treturnBefore = (returnBefore || \"\");\n\t\t\tspaceBefore = (spaceBefore || \"\");\n\n\t\t\tvar modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});\n\n\t\t\t// If it's a partial or tripple stache, leave in place.\n\t\t\tif(spaceLessSpecial || \">{\".indexOf( modeAndExpression.mode) >= 0) {\n\t\t\t\treturn whole;\n\t\t\t}  else if( \"^#!/\".indexOf(  modeAndExpression.mode ) >= 0 ) {\n\t\t\t\t// Return the magic tag and a trailing linebreak if this did not\n\t\t\t\t// start a new line and there was an end line.\n\t\t\t\t// Add a normalized leading space, if there was any leading space, in case this abuts a tag name\n\t\t\t\tspaceBefore = (returnBefore + spaceBefore) && \" \";\n\t\t\t\treturn spaceBefore+special+( matchIndex !== 0 && returnAfter.length ? returnBefore+\"\\n\" :\"\");\n\n\n\t\t\t} else {\n\t\t\t\t// There is no mode, return special with spaces around it.\n\t\t\t\treturn spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+\"\\n\" : \"\");\n\t\t\t}\n\t\t});\n}\n\nfunction whiteSpaceReplacement(\n\twhole,\n\tspaceBefore,\n\tbracketBefore,\n\tcontrolBefore,\n\texpression,\n\tcontrolAfter,\n\tbracketAfter,\n\tspaceAfter\n) {\n\n\tif (controlBefore === '-') {\n\t\tspaceBefore = '';\n\t}\n\n\tif (controlAfter === '-') {\n\t\tspaceAfter = '';\n\t}\n\n\treturn spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;\n}\n\nfunction cleanWhitespaceControl(template) {\n\treturn template.replace(mustacheWhitespaceRegExp, whiteSpaceReplacement);\n}\n\nexports.cleanLineEndings = cleanLineEndings;\nexports.cleanWhitespaceControl = cleanWhitespaceControl;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache-ast/controls.js?");

/***/ }),

/***/ "../../node_modules/can-stache-bindings/can-stache-bindings.js":
/*!************************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache-bindings/can-stache-bindings.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # can-stache-bindings.js\n//\n// This module provides CanJS's default data and event bindings.\n// It's broken up into several parts:\n//\n// - Behaviors - Binding behaviors that run given an attribute or element.\n// - Attribute Syntaxes - Hooks up custom attributes to their behaviors.\n// - getObservableFrom - Methods that return a observable cross bound to the scope, viewModel, or element.\n// - bind - Methods for setting up cross binding\n// - getBindingInfo - A helper that returns the details of a data binding given an attribute.\n// - makeDataBinding - A helper method for setting up a data binding.\n// - initializeValues - A helper that initializes a data binding.\nvar Bind = __webpack_require__(/*! can-bind */ \"../../node_modules/can-bind/can-bind.js\");\nvar expression = __webpack_require__(/*! can-stache/src/expression */ \"../../node_modules/can-stache/src/expression.js\");\nvar viewCallbacks = __webpack_require__(/*! can-view-callbacks */ \"../../node_modules/can-view-callbacks/can-view-callbacks.js\");\nvar canViewModel = __webpack_require__(/*! can-view-model */ \"../../node_modules/can-view-model/can-view-model.js\");\nvar observeReader = __webpack_require__(/*! can-stache-key */ \"../../node_modules/can-stache-key/can-stache-key.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"../../node_modules/can-simple-observable/can-simple-observable.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"../../node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar domData = __webpack_require__(/*! can-dom-data-state */ \"../../node_modules/can-dom-data-state/can-dom-data-state.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"../../node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\nvar encoder = __webpack_require__(/*! can-attribute-encoder */ \"../../node_modules/can-attribute-encoder/can-attribute-encoder.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar SettableObservable = __webpack_require__(/*! can-simple-observable/setter/setter */ \"../../node_modules/can-simple-observable/setter/setter.js\");\nvar AttributeObservable = __webpack_require__(/*! can-attribute-observable */ \"../../node_modules/can-attribute-observable/can-attribute-observable.js\");\nvar makeCompute = __webpack_require__(/*! can-view-scope/make-compute-like */ \"../../node_modules/can-view-scope/make-compute-like.js\");\nvar ViewNodeList = __webpack_require__(/*! can-view-nodelist */ \"../../node_modules/can-view-nodelist/can-view-nodelist.js\");\n\nvar canEvent = __webpack_require__(/*! can-attribute-observable/event */ \"../../node_modules/can-attribute-observable/event.js\");\n\n// Contains all of the stache bindings that will be exported.\nvar bindings = new Map();\n\nvar onMatchStr = \"on:\",\n\tvmMatchStr = \"vm:\",\n\telMatchStr = \"el:\",\n\tbyMatchStr = \":by:\",\n\ttoMatchStr = \":to\",\n\tfromMatchStr = \":from\",\n\tbindMatchStr = \":bind\",\n\tviewModelBindingStr = \"viewModel\",\n\tattributeBindingStr = \"attribute\",\n\tscopeBindingStr = \"scope\",\n\tviewModelOrAttributeBindingStr = \"viewModelOrAttribute\";\n\nvar throwOnlyOneTypeOfBindingError = function() {\n\tthrow new Error(\"can-stache-bindings - you can not have contextual bindings ( this:from='value' ) and key bindings ( prop:from='value' ) on one element.\");\n};\n\n// This function checks if there bindings that are trying\n// to set a property ON the viewModel _conflicting_ with bindings trying to\n// set THE viewModel ITSELF.\n// If there is a conflict, an error is thrown.\nvar checkBindingState = function(bindingState, bindingInfo) {\n\tvar isSettingOnViewModel = bindingInfo.parentToChild && bindingInfo.child === viewModelBindingStr;\n\tif (isSettingOnViewModel) {\n\t\tvar bindingName = bindingInfo.childName;\n\t\tvar isSettingViewModel = isSettingOnViewModel && ( bindingName === 'this' || bindingName === '.' );\n\n\t\tif (isSettingViewModel) {\n\t\t\tif (bindingState.isSettingViewModel || bindingState.isSettingOnViewModel) {\n\t\t\t\tthrowOnlyOneTypeOfBindingError();\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tisSettingViewModel: true,\n\t\t\t\t\tinitialViewModelData: undefined\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\t// just setting on viewModel\n\t\t\tif (bindingState.isSettingViewModel) {\n\t\t\t\tthrowOnlyOneTypeOfBindingError();\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tisSettingOnViewModel: true,\n\t\t\t\t\tinitialViewModelData: bindingState.initialViewModelData\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn bindingState;\n\t}\n};\n\n// ## Behaviors\nvar behaviors = {\n\t// ### bindings.behaviors.viewModel\n\t// Sets up all of an element's data binding attributes to a \"soon-to-be-created\"\n\t// `viewModel`.\n\t// This is primarily used by `can.Component` to ensure that its\n\t// `viewModel` is initialized with values from the data bindings as quickly as possible.\n\t// Component could look up the data binding values itself.  However, that lookup\n\t// would have to be duplicated when the bindings are established.\n\t// Instead, this uses the `makeDataBinding` helper, which allows creation of the `viewModel`\n\t// after scope values have been looked up.\n\t//\n\t// - `makeViewModel(initialViewModelData)` - a function that returns the `viewModel`.\n\t// - `initialViewModelData` any initial data that should already be added to the `viewModel`.\n\t//\n\t// Returns:\n\t// - `function` - a function that tears all the bindings down. Component\n\t// wants all the bindings active so cleanup can be done during a component being removed.\n\tviewModel: function(el, tagData, makeViewModel, initialViewModelData, staticDataBindingsOnly) {\n\n\t\tvar viewModel,\n\t\t\t// Stores callbacks for when the viewModel is created.\n\t\t\tonCompleteBindings = [],\n\t\t\t// Stores what needs to be called when the element is removed\n\t\t\t// to prevent memory leaks.\n\t\t\tonTeardowns = {},\n\t\t\t// Track info about each binding, we need this for binding attributes correctly.\n\t\t\tbindingInfos = {},\n\t\t\tattributeViewModelBindings = assign({}, initialViewModelData),\n\t\t\tbindingsState = {\n\t\t\t\t// if we have a binding like {something}=\"foo\"\n\t\t\t\tisSettingOnViewModel: false,\n\t\t\t\t// if we have binding like {this}=\"bar\"\n\t\t\t\tisSettingViewModel: false,\n\t\t\t\tinitialViewModelData: initialViewModelData || {}\n\t\t\t},\n\t\t\thasDataBinding = false;\n\n\t\t// For each attribute, we start the binding process,\n\t\t// and save what's returned to be used when the `viewModel` is created,\n\t\t// the element is removed, or the attribute changes values.\n\t\tcanReflect.each(el.attributes || [], function(node) {\n\t\t\tvar dataBinding = makeDataBinding(node, el, {\n\t\t\t\ttemplateType: tagData.templateType,\n\t\t\t\tscope: tagData.scope,\n\t\t\t\tgetViewModel: function() {\n\t\t\t\t\treturn viewModel;\n\t\t\t\t},\n\t\t\t\tattributeViewModelBindings: attributeViewModelBindings,\n\t\t\t\talreadyUpdatedChild: true,\n\t\t\t\tnodeList: tagData.parentNodeList,\n\t\t\t\t// force viewModel bindings in cases when it is ambiguous whether you are binding\n\t\t\t\t// on viewModel or an attribute (:to, :from, :bind)\n\t\t\t\tfavorViewModel: true\n\t\t\t});\n\n\t\t\tif (dataBinding) {\n\t\t\t\tvar bindingInfo = dataBinding.bindingInfo;\n\t\t\t\tbindingsState = checkBindingState(bindingsState, bindingInfo);\n\t\t\t\thasDataBinding = true;\n\n\t\t\t\t// For bindings that change the viewModel,\n\t\t\t\t// save the initial value on the viewModel.\n\t\t\t\tif (bindingInfo.parentToChild) {\n\t\t\t\t\tvar parentValue = bindingInfo.stickyParentToChild ? makeCompute(dataBinding.parent) : dataBinding.canBinding.parentValue;\n\n\t\t\t\t\tif (parentValue !== undefined) {\n\n\t\t\t\t\t\tif (bindingsState.isSettingViewModel) {\n\t\t\t\t\t\t\t// the initial data is the context\n\t\t\t\t\t\t\t// TODO: this is covered by can-component’s tests but not can-stache-bindings’ tests\n\t\t\t\t\t\t\tbindingsState.initialViewModelData = parentValue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbindingsState.initialViewModelData[cleanVMName(bindingInfo.childName, tagData.scope)] = parentValue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Save what needs to happen after the `viewModel` is created.\n\t\t\t\tonCompleteBindings.push(dataBinding.canBinding.start.bind(dataBinding.canBinding));\n\n\t\t\t\tonTeardowns[node.name] = dataBinding.canBinding.stop.bind(dataBinding.canBinding);\n\t\t\t}\n\t\t});\n\t\tif (staticDataBindingsOnly && !hasDataBinding) {\n\t\t\treturn;\n\t\t}\n\t\t// Create the `viewModel` and call what needs to happen after `viewModel` is created.\n\t\tviewModel = makeViewModel(bindingsState.initialViewModelData, hasDataBinding);\n\n\t\tfor (var i = 0, len = onCompleteBindings.length; i < len; i++) {\n\t\t\tonCompleteBindings[i]();\n\t\t}\n\n\t\t// Listen to attribute changes and re-initialize\n\t\t// the bindings.\n\t\tvar attributeDisposal;\n\t\tif (!bindingsState.isSettingViewModel) {\n\t\t\tattributeDisposal = domMutate.onNodeAttributeChange(el, function(ev) {\n\t\t\t\tvar attrName = ev.attributeName,\n\t\t\t\t\tvalue = el.getAttribute(attrName);\n\n\t\t\t\tif (onTeardowns[attrName]) {\n\t\t\t\t\tonTeardowns[attrName]();\n\t\t\t\t}\n\t\t\t\t// Parent attribute bindings we always re-setup.\n\t\t\t\tvar parentBindingWasAttribute = bindingInfos[attrName] && bindingInfos[attrName].parent === attributeBindingStr;\n\n\t\t\t\tif (value !== null || parentBindingWasAttribute) {\n\t\t\t\t\tvar dataBinding = makeDataBinding({\n\t\t\t\t\t\tname: attrName,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t}, el, {\n\t\t\t\t\t\ttemplateType: tagData.templateType,\n\t\t\t\t\t\tscope: tagData.scope,\n\t\t\t\t\t\tgetViewModel: function() {\n\t\t\t\t\t\t\treturn viewModel;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tattributeViewModelBindings: attributeViewModelBindings,\n\t\t\t\t\t\t// always update the viewModel accordingly.\n\t\t\t\t\t\tinitializeValues: true,\n\t\t\t\t\t\tnodeList: tagData.parentNodeList\n\t\t\t\t\t});\n\t\t\t\t\tif (dataBinding) {\n\t\t\t\t\t\t// The viewModel is created, so call callback immediately.\n\t\t\t\t\t\tdataBinding.canBinding.start();\n\t\t\t\t\t\tbindingInfos[attrName] = dataBinding.bindingInfo;\n\t\t\t\t\t\tonTeardowns[attrName] = dataBinding.canBinding.stop.bind(dataBinding.canBinding);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn function() {\n\t\t\tif (attributeDisposal) {\n\t\t\t\tattributeDisposal();\n\t\t\t\tattributeDisposal = undefined;\n\t\t\t}\n\t\t\tfor (var attrName in onTeardowns) {\n\t\t\t\tonTeardowns[attrName]();\n\t\t\t}\n\t\t};\n\t},\n\t// ### bindings.behaviors.data\n\t// This is called when an individual data binding attribute is placed on an element.\n\t// For example `{^value}=\"name\"`.\n\tdata: function(el, attrData) {\n\t\tif (domData.get.call(el, \"preventDataBindings\")) {\n\t\t\treturn;\n\t\t}\n\t\tvar viewModel,\n\t\t\tgetViewModel = ObservationRecorder.ignore(function() {\n\t\t\t\treturn viewModel || (viewModel = canViewModel(el));\n\t\t\t}),\n\t\t\tteardown,\n\t\t\tattributeDisposal,\n\t\t\tremovedDisposal;\n\n\t\t// Setup binding\n\t\tvar dataBinding = makeDataBinding({\n\t\t\tname: attrData.attributeName,\n\t\t\tvalue: el.getAttribute(attrData.attributeName),\n\t\t\tnodeList: attrData.nodeList\n\t\t}, el, {\n\t\t\ttemplateType: attrData.templateType,\n\t\t\tscope: attrData.scope,\n\t\t\tgetViewModel: getViewModel,\n\t\t\tsyncChildWithParent: false\n\t\t});\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (dataBinding.bindingInfo.child === \"viewModel\" && !domData.get(el, \"viewModel\")) {\n\t\t\t\tdev.warn('This element does not have a viewModel. (Attempting to bind `' + dataBinding.bindingInfo.bindingAttributeName + '=\"' + dataBinding.bindingInfo.parentName + '\"`)');\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tdataBinding.canBinding.start();\n\n\t\tvar attributeListener = function(ev) {\n\t\t\tvar attrName = ev.attributeName,\n\t\t\t\tvalue = el.getAttribute(attrName);\n\n\t\t\tif (attrName === attrData.attributeName) {\n\t\t\t\tif (teardown) {\n\t\t\t\t\tteardown();\n\t\t\t\t}\n\n\t\t\t\tif(value !== null  ) {\n\t\t\t\t\tvar dataBinding = makeDataBinding({name: attrName, value: value}, el, {\n\t\t\t\t\t\ttemplateType: attrData.templateType,\n\t\t\t\t\t\tscope: attrData.scope,\n\t\t\t\t\t\tgetViewModel: getViewModel,\n\t\t\t\t\t\t// always update the viewModel accordingly.\n\t\t\t\t\t\tinitializeValues: true,\n\t\t\t\t\t\tnodeList: attrData.nodeList,\n\t\t\t\t\t\tsyncChildWithParent: false\n\t\t\t\t\t});\n\t\t\t\t\tif(dataBinding) {\n\t\t\t\t\t\t// The viewModel is created, so call callback immediately.\n\t\t\t\t\t\tdataBinding.canBinding.start();\n\t\t\t\t\t\tteardown = dataBinding.canBinding.stop.bind(dataBinding.canBinding);\n\t\t\t\t\t}\n\t\t\t\t\tteardown = dataBinding.onTeardown;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\tvar tearItAllDown = function() {\n\t\t\tif (teardown) {\n\t\t\t\tteardown();\n\t\t\t\tteardown = undefined;\n\t\t\t}\n\n\t\t\tif (removedDisposal) {\n\t\t\t\tremovedDisposal();\n\t\t\t\tremovedDisposal = undefined;\n\t\t\t}\n\t\t\tif (attributeDisposal) {\n\t\t\t\tattributeDisposal();\n\t\t\t\tattributeDisposal = undefined;\n\t\t\t}\n\t\t};\n\t\tif (attrData.nodeList) {\n\t\t\tViewNodeList.register([], tearItAllDown, attrData.nodeList, false);\n\t\t}\n\n\n\t\t// Listen for changes\n\t\tteardown = dataBinding.canBinding.stop.bind(dataBinding.canBinding);\n\n\t\tattributeDisposal = domMutate.onNodeAttributeChange(el, attributeListener);\n\t\tremovedDisposal = domMutate.onNodeRemoval(el, function() {\n\t\t\tif (el.ownerDocument.contains(el) === false) {\n\t\t\t\ttearItAllDown();\n\t\t\t}\n\t\t});\n\t},\n\t// ### bindings.behaviors.event\n\t// The following section contains code for implementing the can-EVENT attribute.\n\t// This binds on a wildcard attribute name. Whenever a view is being processed\n\t// and can-xxx (anything starting with can-), this callback will be run.  Inside, its setting up an event handler\n\t// that calls a method identified by the value of this attribute.\n\tevent: function(el, data) {\n\n\t\t// Get the `event` name and if we are listening to the element or viewModel.\n\t\t// The attribute name is the name of the event.\n\t\tvar attributeName = encoder.decode(data.attributeName),\n\t\t\t// the name of the event we are binding\n\t\t\tevent,\n\t\t\t// if we are binding on the element or the VM\n\t\t\tbindingContext;\n\n\t\t// check for `on:event:value:to` type things and call data bindings\n\t\tif (attributeName.indexOf(toMatchStr + \":\") !== -1 ||\n\t\t\tattributeName.indexOf(fromMatchStr + \":\") !== -1 ||\n\t\t\tattributeName.indexOf(bindMatchStr + \":\") !== -1\n\t\t) {\n\t\t\treturn this.data(el, data);\n\t\t}\n\n\t\tif (startsWith.call(attributeName, onMatchStr)) {\n\t\t\tevent = attributeName.substr(onMatchStr.length);\n\t\t\tvar viewModel = el[canSymbol.for('can.viewModel')];\n\n\t\t\t// when using on:prop:by:obj\n\t\t\t// bindingContext should be scope.obj\n\t\t\tvar byParent = data.scope;\n\n\t\t\t// get the bindingContext\n\t\t\t// on:el:prop -> bindingContext = element\n\t\t\t// on:vm:prop -> bindingContext = viewModel\n\t\t\t// otherwise,\n\t\t\t// bind on the element if there is not a viewModel\n\t\t\tif (startsWith.call(event, elMatchStr)) {\n\t\t\t\tevent = event.substr(elMatchStr.length);\n\t\t\t\tbindingContext = el;\n\t\t\t} else {\n\t\t\t\tif (startsWith.call(event, vmMatchStr)) {\n\t\t\t\t\tevent = event.substr(vmMatchStr.length);\n\t\t\t\t\tbindingContext = viewModel;\n\n\t\t\t\t\t// when using on:vm:prop:by:obj\n\t\t\t\t\t// bindingContext should be viewModel.obj\n\t\t\t\t\tbyParent = viewModel;\n\t\t\t\t} else {\n\t\t\t\t\tbindingContext = viewModel || el;\n\t\t\t\t}\n\n\t\t\t\t// update the bindingContext and event if using :by:\n\t\t\t\t// on:prop:by:obj\n\t\t\t\t//   -> bindingContext = byParent.get('obj')\n\t\t\t\t//   -> event = 'prop'\n\t\t\t\tvar byIndex = event.indexOf(byMatchStr);\n\t\t\t\tif (byIndex >= 0) {\n\t\t\t\t\tbindingContext = byParent.get(event.substr(byIndex + byMatchStr.length));\n\t\t\t\t\tevent = event.substr(0, byIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"can-stache-bindings - unsupported event bindings \" + attributeName);\n\t\t}\n\n\t\t// This is the method that the event will initially trigger. It will look up the method by the string name\n\t\t// passed in the attribute and call it.\n\t\tvar handler = function(ev) {\n\t\t\tvar attrVal = el.getAttribute(encoder.encode(attributeName));\n\t\t\tif (!attrVal) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar viewModel = canViewModel(el);\n\n\t\t\t// expression.parse will read the attribute\n\t\t\t// value and parse it identically to how mustache helpers\n\t\t\t// get parsed.\n\t\t\tvar expr = expression.parse(attrVal, {\n\t\t\t\tlookupRule: function() {\n\t\t\t\t\treturn expression.Lookup;\n\t\t\t\t},\n\t\t\t\tmethodRule: \"call\"\n\t\t\t});\n\n\n\t\t\tif (!(expr instanceof expression.Call)) {\n\t\t\t\tthrow new Error(\"can-stache-bindings: Event bindings must be a call expression. Make sure you have a () in \" + data.attributeName + \"=\" + JSON.stringify(attrVal));\n\t\t\t}\n\n\t\t\t// create \"special\" values that can be looked up using\n\t\t\t// {{scope.element}}, etc\n\t\t\tvar specialValues = {\n\t\t\t\telement: el,\n\t\t\t\tevent: ev,\n\t\t\t\tviewModel: viewModel,\n\t\t\t\targuments: arguments\n\t\t\t};\n\n\t\t\t// make a scope with these things just under\n\t\t\tvar localScope = data.scope\n\t\t\t\t.add(specialValues, {\n\t\t\t\t\tspecial: true\n\t\t\t\t});\n\n\t\t\tvar updateFn = function() {\n\t\t\t\tvar value = expr.value(localScope, {\n\t\t\t\t\tdoNotWrapInObservation: true\n\t\t\t\t});\n\n\t\t\t\tvalue = canReflect.isValueLike(value) ?\n\t\t\t\t\tcanReflect.getValue(value) :\n\t\t\t\t\tvalue;\n\n\t\t\t\treturn typeof value === 'function' ?\n\t\t\t\t\tvalue(el) :\n\t\t\t\t\tvalue;\n\t\t\t};\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tObject.defineProperty(updateFn, \"name\", {\n\t\t\t\t\tvalue: attributeName + '=\"' + attrVal + '\"'\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tqueues.batch.start();\n\t\t\tvar mutateQueueArgs = [];\n\t\t\tmutateQueueArgs = [\n\t\t\t\tupdateFn,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t{}\n\t\t\t];\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tmutateQueueArgs = [\n\t\t\t\t\tupdateFn,\n\t\t\t\t\tnull,\n\t\t\t\t\tnull, {\n\t\t\t\t\t\treasonLog: [el, ev, attributeName+\"=\"+attrVal]\n\t\t\t\t\t}\n\t\t\t\t];\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tqueues.mutateQueue.enqueue.apply(queues.mutateQueue, mutateQueueArgs);\n\t\t\tqueues.batch.stop();\n\n\t\t};\n\n\t\tvar attributesDisposal,\n\t\t\tremovalDisposal;\n\n\t\t// Unbind the event when the attribute is removed from the DOM\n\t\tvar attributesHandler = function(ev) {\n\t\t\tvar isEventAttribute = ev.attributeName === attributeName;\n\t\t\tvar isRemoved = !el.getAttribute(attributeName);\n\t\t\tvar isEventAttributeRemoved = isEventAttribute && isRemoved;\n\t\t\tif (isEventAttributeRemoved) {\n\t\t\t\tunbindEvent();\n\t\t\t}\n\t\t};\n\t\tvar removalHandler = function() {\n\t\t\tif (!el.ownerDocument.contains(el)) {\n\t\t\t\tunbindEvent();\n\t\t\t}\n\t\t};\n\t\tvar unbindEvent = function() {\n\t\t\tcanEvent.off.call(bindingContext, event, handler);\n\t\t\tif (attributesDisposal) {\n\t\t\t\tattributesDisposal();\n\t\t\t\tattributesDisposal = undefined;\n\t\t\t}\n\t\t\tif (removalDisposal) {\n\t\t\t\tremovalDisposal();\n\t\t\t\tremovalDisposal = undefined;\n\t\t\t}\n\t\t};\n\n\t\t// Bind the handler defined above to the element we're currently processing and the event name provided in this\n\t\t// attribute name (can-click=\"foo\")\n\t\tcanEvent.on.call(bindingContext, event, handler);\n\t\tattributesDisposal = domMutate.onNodeAttributeChange(el, attributesHandler);\n\t\tremovalDisposal = domMutate.onNodeRemoval(el, removalHandler);\n\t}\n};\n\n\n// ## Attribute Syntaxes\n// The following sets up the bindings functions to be called\n// when called in a template.\n\n\n// value:to=\"bar\" data bindings\n// these are separate so that they only capture at the end\n// to avoid (toggle)=\"bar\" which is encoded as :lp:toggle:rp:=\"bar\"\nbindings.set(/[\\w\\.:]+:to$/, behaviors.data);\nbindings.set(/[\\w\\.:]+:from$/, behaviors.data);\nbindings.set(/[\\w\\.:]+:bind$/, behaviors.data);\nbindings.set(/[\\w\\.:]+:raw$/, behaviors.data);\n// value:to:on:input=\"bar\" data bindings\nbindings.set(/[\\w\\.:]+:to:on:[\\w\\.:]+/, behaviors.data);\nbindings.set(/[\\w\\.:]+:from:on:[\\w\\.:]+/, behaviors.data);\nbindings.set(/[\\w\\.:]+:bind:on:[\\w\\.:]+/, behaviors.data);\n\n\n// `(EVENT)` event bindings.\nbindings.set(/on:[\\w\\.:]+/, behaviors.event);\n\n// ## getObservableFrom\n// An object of helper functions that make a getter/setter observable\n// on different types of objects.\nvar getObservableFrom = {\n\t// ### getObservableFrom.viewModelOrAttribute\n\tviewModelOrAttribute: function(el, scope, vmNameOrProp, bindingData, mustBeGettable, stickyCompute, event) {\n\t\tvar viewModel = el[canSymbol.for('can.viewModel')];\n\n\t\t// if we have a viewModel, use it; otherwise, setup attribute binding\n\t\tif (viewModel) {\n\t\t\treturn this.viewModel.apply(this, arguments);\n\t\t} else {\n\t\t\treturn this.attribute.apply(this, arguments);\n\t\t}\n\t},\n\t// ### getObservableFrom.scope\n\t// Returns a compute from the scope.  This handles expressions like `someMethod(.,1)`.\n\tscope: function(el, scope, scopeProp, bindingData, mustBeGettable, stickyCompute) {\n\t\tif (!scopeProp) {\n\t\t\treturn new SimpleObservable();\n\t\t} else {\n\t\t\t// Check if we need to spend time building a scope-key-data\n\t\t\t// If we have a '(', it likely means a call expression.\n\t\t\tif (mustBeGettable || scopeProp.indexOf(\"(\") >= 0 ) {\n\t\t\t\tvar parentExpression = expression.parse(scopeProp,{baseMethodType: \"Call\"});\n\t\t\t\treturn parentExpression.value(scope);\n\t\t\t} else {\n\t\t\t\tvar observation = {};\n\t\t\t\tcanReflect.assignSymbols(observation, {\n\t\t\t\t\t\"can.getValue\": function getValue() {},\n\n\t\t\t\t\t\"can.valueHasDependencies\": function hasValueDependencies() {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\n\t\t\t\t\t\"can.setValue\": function setValue(newVal) {\n\t\t\t\t\t\tscope.set(cleanVMName(scopeProp, scope), newVal);\n\t\t\t\t\t},\n\n\t\t\t\t\t// Register what the custom observation changes\n\t\t\t\t\t\"can.getWhatIChange\": function getWhatIChange() {\n\t\t\t\t\t\tvar data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tmutate: {\n\t\t\t\t\t\t\t\tkeyDependencies: new Map([\n\t\t\t\t\t\t\t\t\t[data.parent, new Set([data.key])]\n\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\n\t\t\t\t\t\"can.getName\": function getName() {\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tvar result = \"ObservableFromScope<>\";\n\t\t\t\t\t\t\tvar data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));\n\n\t\t\t\t\t\t\tif (data.parent && data.key) {\n\t\t\t\t\t\t\t\tresult = \"ObservableFromScope<\" +\n\t\t\t\t\t\t\t\t\tcanReflect.getName(data.parent) +\n\t\t\t\t\t\t\t\t\t\".\" +\n\t\t\t\t\t\t\t\t\tdata.key +\n\t\t\t\t\t\t\t\t\t\">\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tvar data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));\n\t\t\t\tif (data.parent && data.key) {\n\t\t\t\t\t// Register what changes the Scope's parent key\n\t\t\t\t\tcanReflectDeps.addMutatedBy(data.parent, data.key, observation);\n\t\t\t\t}\n\n\t\t\t\treturn observation;\n\t\t\t}\n\t\t}\n\t},\n\t// ### getObservableFrom.viewModel\n\t// Returns a compute that's two-way bound to the `viewModel` returned by\n\t// `options.getViewModel()`.\n\tviewModel: function(el, scope, vmName, bindingData, mustBeGettable, stickyCompute, childEvent) {\n\t\tvar setName = cleanVMName(vmName, scope);\n\t\tvar isBoundToContext = vmName === \".\" || vmName === \"this\";\n\t\tvar keysToRead = isBoundToContext ? [] : observeReader.reads(vmName);\n\n\t\tfunction getViewModelProperty() {\n\t\t\tvar viewModel = bindingData.getViewModel();\n\t\t\treturn observeReader.read(viewModel, keysToRead, {}).value;\n\t\t}\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tObject.defineProperty(getViewModelProperty, \"name\", {\n\t\t\t\tvalue: \"viewModel.\" + vmName\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tvar observation = new SettableObservable(\n\t\t\tgetViewModelProperty,\n\n\t\t\tfunction setViewModelProperty(newVal) {\n\t\t\t\tvar viewModel = bindingData.getViewModel();\n\n\t\t\t\tif (stickyCompute) {\n\t\t\t\t\t// TODO: Review what this is used for.\n\t\t\t\t\tvar oldValue = canReflect.getKeyValue(viewModel, setName);\n\t\t\t\t\tif (canReflect.isObservableLike(oldValue)) {\n\t\t\t\t\t\tcanReflect.setValue(oldValue, newVal);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanReflect.setKeyValue(\n\t\t\t\t\t\t\tviewModel,\n\t\t\t\t\t\t\tsetName,\n\t\t\t\t\t\t\tnew SimpleObservable(canReflect.getValue(stickyCompute))\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isBoundToContext) {\n\t\t\t\t\t\tcanReflect.setValue(viewModel, newVal);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanReflect.setKeyValue(viewModel, setName, newVal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tvar viewModel = bindingData.getViewModel();\n\t\t\tif (viewModel && setName) {\n\t\t\t\tcanReflectDeps.addMutatedBy(viewModel, setName, observation);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn observation;\n\t},\n\t// ### getObservableFrom.attribute\n\t// Returns a compute that is two-way bound to an attribute or property on the element.\n\tattribute: function(el, scope, prop, bindingData, mustBeGettable, stickyCompute, event, bindingInfo) {\n\t\treturn new AttributeObservable(el, prop, bindingData, event);\n\t}\n};\n\nvar startsWith = String.prototype.startsWith || function(text){\n\treturn this.indexOf(text) === 0;\n};\n\n// Gets an event name in the after part.\nfunction getEventName(result) {\n\tif (result.special.on !== undefined) {\n\t\treturn result.tokens[result.special.on + 1];\n\t}\n}\n\nvar bindingRules = {\n\tto: {\n\t\tchildToParent: true,\n\t\tparentToChild: false,\n\t\tsyncChildWithParent: false\n\t},\n\tfrom: {\n\t\tchildToParent: false,\n\t\tparentToChild: true,\n\t\tsyncChildWithParent: false,\n\t},\n\tbind: {\n\t\tchildToParent: true,\n\t\tparentToChild: true,\n\t\tsyncChildWithParent: true,\n\t},\n\traw: {\n\t\tchildToParent: false,\n\t\tparentToChild: true,\n\t\tsyncChildWithParent: false\n\t}\n};\nvar bindingNames = [];\nvar special = {\n\tvm: true,\n\ton: true\n};\ncanReflect.each(bindingRules, function(value, key) {\n\tbindingNames.push(key);\n\tspecial[key] = true;\n});\n\n// \"on:click:value:to\" //-> {tokens: [...], special: {on: 0, to: 3}}\nfunction tokenize(source) {\n\tvar splitByColon = source.split(\":\");\n\t// combine tokens that are not to, from, vm,\n\tvar result = {\n\t\ttokens: [],\n\t\tspecial: {}\n\t};\n\tsplitByColon.forEach(function(token) {\n\t\tif (special[token]) {\n\t\t\tresult.special[token] = result.tokens.push(token) - 1;\n\t\t} else {\n\t\t\tresult.tokens.push(token);\n\t\t}\n\t});\n\n\treturn result;\n}\n\n// ## getChildBindingStr\nvar getChildBindingStr = function(tokens, favorViewModel) {\n\tif (tokens.indexOf('vm') >= 0) {\n\t\treturn viewModelBindingStr;\n\t} else if (tokens.indexOf('el') >= 0) {\n\t\treturn attributeBindingStr;\n\t} else {\n\t\treturn favorViewModel ? viewModelBindingStr : viewModelOrAttributeBindingStr;\n\t}\n};\n\n// ## getBindingInfo\n// takes a node object like {name, value} and returns\n// an object with information about that binding.\n// Properties:\n// - `parent` - where is the parentName read from: \"scope\", \"attribute\", \"viewModel\".\n// - `parentName` - what is the parent property that should be read.\n// - `child` - where is the childName read from: \"scope\", \"attribute\", \"viewModel\".\n//  - `childName` - what is the child property that should be read.\n// - `parentToChild` - should changes in the parent update the child.\n// - `childToParent` - should changes in the child update the parent.\n// - `bindingAttributeName` - the attribute name that created this binding.\n// - `initializeValues` - should parent and child be initialized to their counterpart.\n// If undefined is return, there is no binding.\nvar getBindingInfo = function(node, attributeViewModelBindings, templateType, tagName, favorViewModel) {\n\tvar bindingInfo,\n\t\tattributeName = encoder.decode(node.name),\n\t\tattributeValue = node.value || \"\";\n\n\t// START: check new binding syntaxes ======\n\tvar result = tokenize(attributeName),\n\t\tdataBindingName,\n\t\tspecialIndex;\n\n\n\n\t// check if there's a match of a binding name with at least a value before it\n\tbindingNames.forEach(function(name) {\n\t\tif (result.special[name] !== undefined && result.special[name] > 0) {\n\t\t\tdataBindingName = name;\n\t\t\tspecialIndex = result.special[name];\n\t\t\treturn false;\n\t\t}\n\t});\n\n\tif (dataBindingName) {\n\t\tvar childEventName = getEventName(result);\n\t\tvar initializeValues = childEventName && dataBindingName !== \"bind\" ? false : true;\n\t\tbindingInfo = assign({\n\t\t\tparent: scopeBindingStr,\n\t\t\tchild: getChildBindingStr(result.tokens, favorViewModel),\n\t\t\t// the child is going to be the token before the special location\n\t\t\tchildName: result.tokens[specialIndex - 1],\n\t\t\tchildEvent: childEventName,\n\t\t\tbindingAttributeName: attributeName,\n\t\t\tparentName: result.special.raw ? ('\"' + attributeValue + '\"') : attributeValue,\n\t\t\tinitializeValues: initializeValues,\n\t\t}, bindingRules[dataBindingName]);\n\t\tif (attributeValue.trim().charAt(0) === \"~\") {\n\t\t\tbindingInfo.stickyParentToChild = true;\n\t\t}\n\t\treturn bindingInfo;\n\t}\n\t// END: check new binding syntaxes ======\n\n};\n\n\n\n// ## makeDataBinding\n// Makes a data binding for an attribute `node`.  Returns an object with information\n// about the binding, including an `onTeardown` method that undoes the binding.\n// If the data binding involves a `viewModel`, an `onCompleteBinding` method is returned on\n// the object.  This method must be called after the element has a `viewModel` with the\n// `viewModel` to complete the binding.\n//\n// - `node` - an attribute node or an object with a `name` and `value` property.\n// - `el` - the element this binding belongs on.\n// - `bindingData` - an object with:\n//   - `templateType` - the type of template.\n//   - `scope` - the `Scope`,\n//   - `getViewModel`  - a function that returns the `viewModel` when called.  This function can be passed around (not called) even if the\n//      `viewModel` doesn't exist yet.\n//   - `attributeViewModelBindings` - properties already specified as being a viewModel<->attribute (as opposed to viewModel<->scope) binding.\n//\n// Returns:\n// - `undefined` - If this isn't a data binding.\n// - `object` - An object with information about the binding.\nvar makeDataBinding = function(node, el, bindingData) {\n\t// Get information about the binding.\n\tvar bindingInfo = getBindingInfo(node, bindingData.attributeViewModelBindings,\n\t\tbindingData.templateType, el.nodeName.toLowerCase(), bindingData.favorViewModel);\n\tif (!bindingInfo) {\n\t\treturn;\n\t}\n\n\t// Get computes for the parent and child binding\n\tvar parentObservable = getObservableFrom[bindingInfo.parent](\n\t\tel,\n\t\tbindingData.scope,\n\t\tbindingInfo.parentName,\n\t\tbindingData,\n\t\tbindingInfo.parentToChild,\n\t\tundefined,\n\t\tundefined,\n\t\tbindingInfo\n\t),\n\tchildObservable = getObservableFrom[bindingInfo.child](\n\t\tel,\n\t\tbindingData.scope,\n\t\tbindingInfo.childName,\n\t\tbindingData,\n\t\tbindingInfo.childToParent,\n\t\tbindingInfo.stickyParentToChild && parentObservable,\n\t\tbindingInfo.childEvent,\n\t\tbindingInfo\n\t);\n\n\t// Check for child:bind=\"~parent\" (it’s not supported because it’s unclear\n\t// what the “right” behavior should be)\n\tvar childToParent = !!bindingInfo.childToParent;\n\tvar parentToChild = !!bindingInfo.parentToChild;\n\t//!steal-remove-start\n\tif (true) {\n\t\tif (bindingInfo.stickyParentToChild && childToParent && parentToChild) {\n\t\t\tdev.warn(\"Two-way binding computes is not supported.\");\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\tvar bindingOptions = {\n\t\tchild: childObservable,\n\t\tchildToParent: childToParent,\n\t\tcycles: 0,\n\t\tonInitDoNotUpdateChild: bindingData.alreadyUpdatedChild,\n\t\tonInitSetUndefinedParentIfChildIsDefined: true,\n\t\tparent: parentObservable,\n\t\tparentToChild: parentToChild,\n\t\tpriority: bindingData.nodeList ? bindingData.nodeList.nesting + 1 : undefined,\n\t\tqueue: \"domUI\",\n\t\tsticky: bindingInfo.syncChildWithParent ? \"childSticksToParent\" : undefined\n\t};\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tbindingOptions.updateChildName = \"update \"+bindingInfo.child+\".\"+bindingInfo.childName+\" of <\"+el.nodeName.toLowerCase()+\">\";\n\t\tbindingOptions.updateParentName = \"update \"+bindingInfo.parent+\".\"+bindingInfo.parentName+\" of <\"+el.nodeName.toLowerCase()+\">\";\n\t}\n\t//!steal-remove-end\n\n\t// Create the binding\n\tvar canBinding = new Bind(bindingOptions);\n\n\t// Immediately bind to the parent\n\t// TODO: it doesn’t appear that there are any tests that cover this behavior\n\tcanBinding.startParent();\n\n\treturn {\n\t\tbindingInfo: bindingInfo,\n\t\tcanBinding: canBinding,\n\t\tparent: parentObservable\n\t};\n};\n\nvar cleanVMName = function(name, scope) {\n\t//!steal-remove-start\n\tif (true) {\n\t\tif (name.indexOf(\"@\") >= 0) {\n\t\t\tvar filename = scope.peek('scope.filename');\n\t\t\tvar lineNumber = scope.peek('scope.lineNumber');\n\n\t\t\tdev.warn(\n\t\t\t\t(filename ? filename + ':' : '') +\n\t\t\t\t(lineNumber ? lineNumber + ': ' : '') +\n\t\t\t\t'functions are no longer called by default so @ is unnecessary in \\'' + name + '\\'.');\n\t\t}\n\t}\n\t//!steal-remove-end\n\treturn name.replace(/@/g, \"\");\n};\n\nvar canStacheBindings = {\n\tbehaviors: behaviors,\n\tgetBindingInfo: getBindingInfo,\n\tbindings: bindings\n};\n\ncanStacheBindings[canSymbol.for(\"can.callbackMap\")] = bindings;\nviewCallbacks.attrs(canStacheBindings);\n\nmodule.exports = canStacheBindings;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache-bindings/can-stache-bindings.js?");

/***/ }),

/***/ "../../node_modules/can-stache-helpers/can-stache-helpers.js":
/*!**********************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache-helpers/can-stache-helpers.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\n\nif (namespace.stacheHelpers) {\n\tthrow new Error(\"You can't have two versions of can-stache-helpers, check your dependencies\");\n} else {\n\tmodule.exports = namespace.stacheHelpers = {};\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache-helpers/can-stache-helpers.js?");

/***/ }),

/***/ "../../node_modules/can-stache-key/can-stache-key.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache-key/can-stache-key.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canReflectPromise = __webpack_require__(/*! can-reflect-promise */ \"../../node_modules/can-reflect-promise/can-reflect-promise.js\");\n\nvar getValueSymbol = canSymbol.for(\"can.getValue\");\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\n\nvar isValueLikeSymbol = canSymbol.for(\"can.isValueLike\");\nvar peek = ObservationRecorder.ignore(canReflect.getKeyValue.bind(canReflect));\nvar observeReader;\n\nvar bindName = Function.prototype.bind;\n//!steal-remove-start\nif (true) {\n\tbindName = function(source){\n\t\tvar fn = Function.prototype.bind.call(this, source);\n\t\tObject.defineProperty(fn, \"name\", {\n\t\t\tvalue: canReflect.getName(source) + \".\"+canReflect.getName(this)\n\t\t});\n\t\treturn fn;\n\t};\n}\n//!steal-remove-end\n\nvar isAt = function(index, reads) {\n\tvar prevRead = reads[index-1];\n\treturn prevRead && prevRead.at;\n};\n\nvar readValue = function(value, index, reads, options, state, prev){\n\t// if the previous read is AT false ... we shouldn't be doing this;\n\tvar usedValueReader;\n\tdo {\n\n\t\tusedValueReader = false;\n\t\tfor(var i =0, len = observeReader.valueReaders.length; i < len; i++){\n\t\t\tif( observeReader.valueReaders[i].test(value, index, reads, options) ) {\n\t\t\t\tvalue = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);\n\t\t\t\t//usedValueReader = true;\n\t\t\t}\n\t\t}\n\t} while(usedValueReader);\n\n\treturn value;\n};\n\nvar specialRead = {index: true, key: true, event: true, element: true, viewModel: true};\n\nvar checkForObservableAndNotify = function(options, state, getObserves, value, index){\n\tif(options.foundObservable && !state.foundObservable) {\n\t\tif(ObservationRecorder.trapsCount()) {\n\t\t\tObservationRecorder.addMany( getObserves() );\n\t\t\toptions.foundObservable(value, index);\n\t\t\tstate.foundObservable = true;\n\t\t}\n\t}\n};\n\nvar objHasKeyAtIndex = function(obj, reads, index) {\n\treturn !!(\n\t\treads && reads.length &&\n\t\tcanReflect.hasKey(obj, reads[index].key)\n\t);\n};\n\nobserveReader = {\n\t// there are things that you need to evaluate when you get them back as a property read\n\t// for example a compute or a function you might need to call to get the next value to\n\t// actually check\n\t// - readCompute - can be set to `false` to prevent reading an ending compute.  This is used by component to get a\n\t//   compute as a delegate.  In 3.0, this should be removed and force people to write \"{@prop} change\"\n\t// - callMethodsOnObservables - this is an overwrite ... so normal methods won't be called, but observable ones will.\n\t// - executeAnonymousFunctions - call a function if it's found, defaults to true\n\t// - proxyMethods - if the last read is a method, return a function so `this` will be correct.\n\t// - args - arguments to call functions with.\n\t//\n\t// Callbacks\n\t// - earlyExit - called if a value could not be found\n\t// - foundObservable - called when an observable value is found\n\tread: function (parent, reads, options) {\n\t\toptions = options || {};\n\t\tvar state = {\n\t\t\tfoundObservable: false\n\t\t};\n\t\tvar getObserves;\n\t\tif(options.foundObservable) {\n\t\t\tgetObserves = ObservationRecorder.trap();\n\t\t}\n\n\t\t// `cur` is the current value.\n\t\tvar cur = readValue(parent, 0, reads, options, state),\n\t\t\ttype,\n\t\t\t// `prev` is the object we are reading from.\n\t\t\tprev,\n\t\t\t// `foundObs` did we find an observable.\n\t\t\treadLength = reads.length,\n\t\t\ti = 0,\n\t\t\tlast,\n\t\t\tparentHasKey;\n\n\t\tcheckForObservableAndNotify(options, state, getObserves, parent, 0);\n\n\t\twhile( i < readLength ) {\n\t\t\tprev = cur;\n\t\t\t// try to read the property\n\t\t\tfor(var r=0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {\n\t\t\t\tvar reader = observeReader.propertyReaders[r];\n\t\t\t\tif(reader.test(cur)) {\n\t\t\t\t\tcur = reader.read(cur, reads[i], i, options, state);\n\t\t\t\t\tbreak; // there can be only one reading of a property\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckForObservableAndNotify(options, state, getObserves, prev, i);\n\t\t\tlast = cur;\n\t\t\ti = i+1;\n\t\t\t// read the value if it is a compute or function\n\t\t\tcur = readValue(cur, i, reads, options, state, prev);\n\n\t\t\tcheckForObservableAndNotify(options, state, getObserves, prev, i-1);\n\n\t\t\ttype = typeof cur;\n\t\t\t// early exit if need be\n\t\t\tif (i < reads.length && (cur === null || cur === undefined )) {\n\t\t\t\tparentHasKey = objHasKeyAtIndex(prev, reads, i - 1);\n\t\t\t\tif (options.earlyExit && !parentHasKey) {\n\t\t\t\t\toptions.earlyExit(prev, i - 1, cur);\n\t\t\t\t}\n\t\t\t\t// return undefined so we know this isn't the right value\n\t\t\t\treturn {\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t\tparent: prev,\n\t\t\t\t\tparentHasKey: parentHasKey,\n\t\t\t\t\tfoundLastParent: false\n\t\t\t\t};\n\t\t\t}\n\n\t\t}\n\n\t\tparentHasKey = objHasKeyAtIndex(prev, reads, reads.length - 1);\n\t\t// if we don't have a value, exit early.\n\t\tif (cur === undefined && !parentHasKey) {\n\t\t\tif (options.earlyExit) {\n\t\t\t\toptions.earlyExit(prev, i - 1);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tvalue: cur,\n\t\t\tparent: prev,\n\t\t\tparentHasKey: parentHasKey,\n\t\t\tfoundLastParent: true\n\t\t};\n\t},\n\tget: function(parent, reads, options){\n\t\treturn observeReader.read(parent, observeReader.reads(reads), options || {}).value;\n\t},\n\tvalueReadersMap: {},\n\t// an array of types that might have a value inside them like functions\n\t// value readers check the current value\n\t// and get a new value from it\n\t// ideally they would keep calling until\n\t// none of these passed\n\tvalueReaders: [\n\t\t{\n\t\t\tname: \"function\",\n\t\t\t// if this is a function before the last read and its not a constructor function\n\t\t\ttest: function(value){\n\t\t\t\treturn value && canReflect.isFunctionLike(value) && !canReflect.isConstructorLike(value);\n\t\t\t},\n\t\t\tread: function(value, i, reads, options, state, prev){\n\t\t\t\tif(options.callMethodsOnObservables && canReflect.isObservableLike(prev) && canReflect.isMapLike(prev)) {\n\t\t\t\t\tdev.warn(\"can-stache-key: read() called with `callMethodsOnObservables: true`.\");\n\n\t\t\t\t\treturn value.apply(prev, options.args || []);\n\t\t\t\t}\n\n\t\t\t\treturn options.proxyMethods !== false ? bindName.call(value, prev) : value;\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tname: \"isValueLike\",\n\t\t\t// compute value reader\n\t\t\ttest: function(value, i, reads, options) {\n\t\t\t\treturn value && value[getValueSymbol] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads) );\n\t\t\t},\n\t\t\tread: function(value, i, reads, options){\n\t\t\t\tif(options.readCompute === false && i === reads.length ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\treturn canReflect.getValue(value);\n\t\t\t},\n\t\t\twrite: function(base, newVal){\n\t\t\t\tif(base[setValueSymbol]) {\n\t\t\t\t\tbase[setValueSymbol](newVal);\n\t\t\t\t} else if(base.set) {\n\t\t\t\t\tbase.set(newVal);\n\t\t\t\t} else {\n\t\t\t\t\tbase(newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t}],\n\tpropertyReadersMap: {},\n\t// an array of things that might have a property\n\tpropertyReaders: [\n\t\t{\n\t\t\tname: \"map\",\n\t\t\ttest: function(value){\n\t\t\t\t// the first time we try reading from a promise, set it up for\n\t\t\t\t//  special reflections.\n\t\t\t\tif(canReflect.isPromise(value) || typeof value === \"object\" && value && typeof value.then === \"function\") {\n\t\t\t\t\tcanReflectPromise(value);\n\t\t\t\t}\n\n\t\t\t\treturn canReflect.isObservableLike(value) && canReflect.isMapLike(value);\n\t\t\t},\n\t\t\tread: function(value, prop){\n\t\t\t\tvar res = canReflect.getKeyValue(value, prop.key);\n\t\t\t\tif(res !== undefined) {\n\t\t\t\t\treturn res;\n\t\t\t\t} else {\n\t\t\t\t\treturn value[prop.key];\n\t\t\t\t}\n\t\t\t},\n\t\t\twrite: canReflect.setKeyValue\n\t\t},\n\n\t\t// read a normal object\n\t\t{\n\t\t\tname: \"object\",\n\t\t\t// this is the default\n\t\t\ttest: function(){return true;},\n\t\t\tread: function(value, prop, i, options){\n\t\t\t\tif(value == null) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\tif(typeof value === \"object\") {\n\t\t\t\t\t\tif(prop.key in value) {\n\t\t\t\t\t\t\treturn value[prop.key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: remove in 5.0.\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tif( prop.at && specialRead[prop.key] && ( (\"@\"+prop.key) in value)) {\n\t\t\t\t\t\t\t\toptions.foundAt = true;\n\t\t\t\t\t\t\t\tdev.warn(\"Use %\"+prop.key+\" in place of @\"+prop.key+\".\");\n\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn value[prop.key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\twrite: function(base, prop, newVal){\n\t\t\t\tvar propValue = base[prop];\n\t\t\t\t// if newVal is observable object, lets try to update\n\t\t\t\tif(newVal != null && typeof newVal === \"object\" && canReflect.isMapLike(propValue) ) {\n\t\t\t\t\tdev.warn(\"can-stache-key: Merging data into \\\"\" + prop + \"\\\" because its parent is non-observable\");\n\t\t\t\t\tcanReflect.update(propValue, newVal);\n\t\t\t\t} else if(propValue != null && propValue[setValueSymbol] !== undefined){\n\t\t\t\t\tcanReflect.setValue(propValue, newVal);\n\t\t\t\t} else {\n\t\t\t\t\tbase[prop] = newVal;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t],\n\treads: function(keyArg) {\n\t\tvar key = \"\"+keyArg;\n\t\tvar keys = [];\n\t\tvar last = 0;\n\t\tvar at = false;\n\t\tif( key.charAt(0) === \"@\" ) {\n\t\t\tlast = 1;\n\t\t\tat = true;\n\t\t}\n\t\tvar keyToAdd = \"\";\n\t\tfor(var i = last; i < key.length; i++) {\n\t\t\tvar character = key.charAt(i);\n\t\t\tif(character === \".\" || character === \"@\") {\n\t\t\t\tif( key.charAt(i -1) !== \"\\\\\" ) {\n\t\t\t\t\tkeys.push({\n\t\t\t\t\t\tkey: keyToAdd,\n\t\t\t\t\t\tat: at\n\t\t\t\t\t});\n\t\t\t\t\tat = character === \"@\";\n\t\t\t\t\tkeyToAdd = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tkeyToAdd = keyToAdd.substr(0,keyToAdd.length - 1) + \".\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeyToAdd += character;\n\t\t\t}\n\t\t}\n\t\tkeys.push({\n\t\t\tkey: keyToAdd,\n\t\t\tat: at\n\t\t});\n\n\t\treturn keys;\n\t},\n\t// This should be able to set a property similar to how read works.\n\twrite: function(parent, key, value, options) {\n\t\tvar keys = typeof key === \"string\" ? observeReader.reads(key) : key;\n\t\tvar last;\n\n\t\toptions = options || {};\n\t\tif(keys.length > 1) {\n\t\t\tlast = keys.pop();\n\t\t\tparent = observeReader.read(parent, keys, options).value;\n\t\t\tkeys.push(last);\n\t\t} else {\n\t\t\tlast = keys[0];\n\t\t}\n\t\tif(!parent) {\n\t\t\treturn;\n\t\t}\n\t\tvar keyValue = peek(parent, last.key);\n\t\t// here's where we need to figure out the best way to write\n\n\t\t// if property being set points at a compute, set the compute\n\t\tif( observeReader.valueReadersMap.isValueLike.test(keyValue, keys.length - 1, keys, options) ) {\n\t\t\tobserveReader.valueReadersMap.isValueLike.write(keyValue, value, options);\n\t\t} else {\n\t\t\tif(observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options) ) {\n\t\t\t\tparent = parent[getValueSymbol]();\n\t\t\t}\n\t\t\tif(observeReader.propertyReadersMap.map.test(parent)) {\n\t\t\t\tobserveReader.propertyReadersMap.map.write(parent, last.key, value, options);\n\t\t\t}\n\t\t\telse if(observeReader.propertyReadersMap.object.test(parent)) {\n\t\t\t\tobserveReader.propertyReadersMap.object.write(parent, last.key, value, options);\n\t\t\t\tif(options.observation) {\n\t\t\t\t\toptions.observation.update();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nobserveReader.propertyReaders.forEach(function(reader){\n\tobserveReader.propertyReadersMap[reader.name] = reader;\n});\nobserveReader.valueReaders.forEach(function(reader){\n\tobserveReader.valueReadersMap[reader.name] = reader;\n});\nobserveReader.set = observeReader.write;\n\nmodule.exports = observeReader;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache-key/can-stache-key.js?");

/***/ }),

/***/ "../../node_modules/can-stache/can-stache.js":
/*!******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/can-stache.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint undef: false */\n\nvar parser = __webpack_require__(/*! can-view-parser */ \"../../node_modules/can-view-parser/can-view-parser.js\");\nvar viewCallbacks = __webpack_require__(/*! can-view-callbacks */ \"../../node_modules/can-view-callbacks/can-view-callbacks.js\");\n\nvar HTMLSectionBuilder = __webpack_require__(/*! ./src/html_section */ \"../../node_modules/can-stache/src/html_section.js\");\nvar TextSectionBuilder = __webpack_require__(/*! ./src/text_section */ \"../../node_modules/can-stache/src/text_section.js\");\nvar mustacheCore = __webpack_require__(/*! ./src/mustache_core */ \"../../node_modules/can-stache/src/mustache_core.js\");\nvar mustacheHelpers = __webpack_require__(/*! ./helpers/core */ \"../../node_modules/can-stache/helpers/core.js\");\n__webpack_require__(/*! ./helpers/converter */ \"../../node_modules/can-stache/helpers/converter.js\");\nvar getIntermediateAndImports = __webpack_require__(/*! can-stache-ast */ \"../../node_modules/can-stache-ast/can-stache-ast.js\").parse;\nvar utils = __webpack_require__(/*! ./src/utils */ \"../../node_modules/can-stache/src/utils.js\");\nvar makeRendererConvertScopes = utils.makeRendererConvertScopes;\nvar last = utils.last;\n\nvar attributeEncoder = __webpack_require__(/*! can-attribute-encoder */ \"../../node_modules/can-attribute-encoder/can-attribute-encoder.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar DOCUMENT = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\nvar importer = __webpack_require__(/*! can-import-module */ \"../../node_modules/can-import-module/can-import-module.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n// Make sure that we can also use our modules with Stache as a plugin\n\n__webpack_require__(/*! can-view-target */ \"../../node_modules/can-view-target/can-view-target.js\");\n__webpack_require__(/*! can-view-nodelist */ \"../../node_modules/can-view-nodelist/can-view-nodelist.js\");\n\nif(!viewCallbacks.tag(\"content\")) {\n\t// This was moved from the legacy view/scanner.js to here.\n\t// This makes sure content elements will be able to have a callback.\n\tviewCallbacks.tag(\"content\", function(el, tagData) {\n\t\treturn tagData.scope;\n\t});\n}\n\nvar wrappedAttrPattern = /[{(].*[)}]/;\nvar colonWrappedAttrPattern = /^on:|(:to|:from|:bind)$|.*:to:on:.*/;\nvar svgNamespace = \"http://www.w3.org/2000/svg\";\nvar namespaces = {\n\t\"svg\": svgNamespace,\n\t// this allows a partial to start with g.\n\t\"g\": svgNamespace\n},\n\ttextContentOnlyTag = {style: true, script: true};\n\nfunction stache (filename, template) {\n\tif (arguments.length === 1) {\n\t\ttemplate = arguments[0];\n\t\tfilename = undefined;\n\t}\n\n\tvar inlinePartials = {};\n\n\t// Remove line breaks according to mustache's specs.\n\tif(typeof template === \"string\") {\n\t\ttemplate = mustacheCore.cleanWhitespaceControl(template);\n\t\ttemplate = mustacheCore.cleanLineEndings(template);\n\t}\n\n\t// The HTML section that is the root section for the entire template.\n\tvar section = new HTMLSectionBuilder(filename),\n\t\t// Tracks the state of the parser.\n\t\tstate = {\n\t\t\tnode: null,\n\t\t\tattr: null,\n\t\t\t// A stack of which node / section we are in.\n\t\t\t// There is probably a better way of doing this.\n\t\t\tsectionElementStack: [],\n\t\t\t// If text should be inserted and HTML escaped\n\t\t\ttext: false,\n\t\t\t// which namespace we are in\n\t\t\tnamespaceStack: [],\n\t\t\t// for style and script tags\n\t\t\t// we create a special TextSectionBuilder and add things to that\n\t\t\t// when the element is done, we compile the text section and\n\t\t\t// add it as a callback to `section`.\n\t\t\ttextContentOnly: null\n\n\t\t},\n\n\t\t// This function is a catch all for taking a section and figuring out\n\t\t// how to create a \"renderer\" that handles the functionality for a\n\t\t// given section and modify the section to use that renderer.\n\t\t// For example, if an HTMLSection is passed with mode `#` it knows to\n\t\t// create a liveBindingBranchRenderer and pass that to section.add.\n\t\t// jshint maxdepth:5\n\t\tmakeRendererAndUpdateSection = function(section, mode, stache, lineNo){\n\n\t\t\tif(mode === \">\") {\n\t\t\t\t// Partials use liveBindingPartialRenderers\n\t\t\t\tsection.add(mustacheCore.makeLiveBindingPartialRenderer(stache, copyState({ filename: section.filename, lineNo: lineNo })));\n\n\t\t\t} else if(mode === \"/\") {\n\n\t\t\t\tvar createdSection = section.last();\n\t\t\t\tif ( createdSection.startedWith === \"<\" ) {\n\t\t\t\t\tinlinePartials[ stache ] = section.endSubSectionAndReturnRenderer();\n\t\t\t\t\tsection.removeCurrentNode();\n\t\t\t\t} else {\n\t\t\t\t\tsection.endSection();\n\t\t\t\t}\n\n\t\t\t\t// to avoid \"Blocks are nested too deeply\" when linting\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tif(section instanceof HTMLSectionBuilder) {\n\t\t\t\t\t\tvar last = state.sectionElementStack[state.sectionElementStack.length - 1];\n\t\t\t\t\t\tif (last.tag && last.type === \"section\" && stache !== \"\" && stache !== last.tag) {\n\t\t\t\t\t\t\tif (filename) {\n\t\t\t\t\t\t\t\tdev.warn(filename + \":\" + lineNo + \": unexpected closing tag {{/\" + stache + \"}} expected {{/\" + last.tag + \"}}\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdev.warn(lineNo + \": unexpected closing tag {{/\" + stache + \"}} expected {{/\" + last.tag + \"}}\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\tif(section instanceof HTMLSectionBuilder) {\n\t\t\t\t\tstate.sectionElementStack.pop();\n\t\t\t\t}\n\t\t\t} else if(mode === \"else\") {\n\n\t\t\t\tsection.inverse();\n\n\t\t\t} else {\n\n\t\t\t\t// If we are an HTMLSection, we will generate a\n\t\t\t\t// a LiveBindingBranchRenderer; otherwise, a StringBranchRenderer.\n\t\t\t\t// A LiveBindingBranchRenderer function processes\n\t\t\t\t// the mustache text, and sets up live binding if an observable is read.\n\t\t\t\t// A StringBranchRenderer function processes the mustache text and returns a\n\t\t\t\t// text value.\n\t\t\t\tvar makeRenderer = section instanceof HTMLSectionBuilder ?\n\t\t\t\t\tmustacheCore.makeLiveBindingBranchRenderer:\n\t\t\t\t\tmustacheCore.makeStringBranchRenderer;\n\n\t\t\t\tif(mode === \"{\" || mode === \"&\") {\n\n\t\t\t\t\t// Adds a renderer function that just reads a value or calls a helper.\n\t\t\t\t\tsection.add(makeRenderer(null,stache, copyState({ filename: section.filename, lineNo: lineNo })));\n\n\t\t\t\t} else if(mode === \"#\" || mode === \"^\" || mode === \"<\") {\n\t\t\t\t\t// Adds a renderer function and starts a section.\n\t\t\t\t\tvar renderer = makeRenderer(mode, stache, copyState({ filename: section.filename, lineNo: lineNo }));\n\t\t\t\t\tvar sectionItem = {\n\t\t\t\t\t\ttype: \"section\"\n\t\t\t\t\t};\n\t\t\t\t\tsection.startSection(renderer);\n\t\t\t\t\tsection.last().startedWith = mode;\n\n\t\t\t\t\t// If we are a directly nested section, count how many we are within\n\t\t\t\t\tif(section instanceof HTMLSectionBuilder) {\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tvar tag = typeof renderer.exprData.closingTag === 'function' ?\n\t\t\t\t\t\t\t\trenderer.exprData.closingTag() : '';\n\t\t\t\t\t\t\tsectionItem.tag = tag;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\t\tstate.sectionElementStack.push(sectionItem);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Adds a renderer function that only updates text.\n\t\t\t\t\tsection.add(makeRenderer(null, stache, copyState({text: true, filename: section.filename, lineNo: lineNo })));\n\t\t\t\t}\n\n\t\t\t}\n\t\t},\n\t\tisDirectlyNested = function() {\n\t\t\tvar lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];\n\t\t\treturn state.sectionElementStack.length ?\n\t\t\t\tlastElement.type === \"section\" || lastElement.type === \"custom\": true;\n\t\t},\n\t\t// Copys the state object for use in renderers.\n\t\tcopyState = function(overwrites){\n\n\t\t\tvar cur = {\n\t\t\t\ttag: state.node && state.node.tag,\n\t\t\t\tattr: state.attr && state.attr.name,\n\t\t\t\t// <content> elements should be considered direclty nested\n\t\t\t\tdirectlyNested: isDirectlyNested(),\n\t\t\t\ttextContentOnly: !!state.textContentOnly\n\t\t\t};\n\t\t\treturn overwrites ? assign(cur, overwrites) : cur;\n\t\t},\n\t\taddAttributesCallback = function(node, callback){\n\t\t\tif( !node.attributes ) {\n\t\t\t\tnode.attributes = [];\n\t\t\t}\n\t\t\tnode.attributes.unshift(callback);\n\t\t};\n\n\tparser(template, {\n\t\tfilename: filename,\n\t\tstart: function(tagName, unary, lineNo){\n\t\t\tvar matchedNamespace = namespaces[tagName];\n\n\t\t\tif (matchedNamespace && !unary ) {\n\t\t\t\tstate.namespaceStack.push(matchedNamespace);\n\t\t\t}\n\n\t\t\t// either add templates: {} here or check below and decorate\n\t\t\t// walk up the stack/targetStack until you find the first node\n\t\t\t// with a templates property, and add the popped renderer\n\t\t\tstate.node = {\n\t\t\t\ttag: tagName,\n\t\t\t\tchildren: [],\n\t\t\t\tnamespace: matchedNamespace || last(state.namespaceStack)\n\t\t\t};\n\t\t},\n\t\tend: function(tagName, unary, lineNo){\n\t\t\tvar isCustomTag =  viewCallbacks.tag(tagName);\n\t\t\tvar directlyNested = isDirectlyNested();\n\t\t\tif(unary){\n\t\t\t\t// If it's a custom tag with content, we need a section renderer.\n\t\t\t\tsection.add(state.node);\n\t\t\t\tif(isCustomTag) {\n\t\t\t\t\t// Call directlyNested now as it's stateful.\n\t\t\t\t\taddAttributesCallback(state.node, function(scope, parentNodeList){\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tscope.set('scope.lineNumber', lineNo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\tviewCallbacks.tagHandler(this,tagName, {\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\tsubtemplate: null,\n\t\t\t\t\t\t\ttemplateType: \"stache\",\n\t\t\t\t\t\t\tparentNodeList: parentNodeList,\n\t\t\t\t\t\t\tdirectlyNested: directlyNested\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsection.push(state.node);\n\n\t\t\t\tstate.sectionElementStack.push({\n\t\t\t\t\ttype: isCustomTag ? \"custom\" : null,\n\t\t\t\t\ttag: isCustomTag ? null : tagName,\n\t\t\t\t\ttemplates: {},\n\t\t\t\t\tdirectlyNested: directlyNested\n\t\t\t\t});\n\n\t\t\t\t// If it's a custom tag with content, we need a section renderer.\n\t\t\t\tif( isCustomTag ) {\n\t\t\t\t\tsection.startSubSection();\n\t\t\t\t} else if(textContentOnlyTag[tagName]) {\n\t\t\t\t\tstate.textContentOnly = new TextSectionBuilder();\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tstate.node =null;\n\n\t\t},\n\t\tclose: function(tagName, lineNo) {\n\t\t\tvar matchedNamespace = namespaces[tagName];\n\n\t\t\tif (matchedNamespace  ) {\n\t\t\t\tstate.namespaceStack.pop();\n\t\t\t}\n\n\t\t\tvar isCustomTag = viewCallbacks.tag(tagName),\n\t\t\t\trenderer;\n\n\t\t\tif( isCustomTag ) {\n\t\t\t\trenderer = section.endSubSectionAndReturnRenderer();\n\t\t\t}\n\n\t\t\tif(textContentOnlyTag[tagName]) {\n\t\t\t\tsection.last().add(state.textContentOnly.compile(copyState()));\n\t\t\t\tstate.textContentOnly = null;\n\t\t\t}\n\n\t\t\tvar oldNode = section.pop();\n\t\t\tif( isCustomTag ) {\n\t\t\t\tif (tagName === \"can-template\") {\n\t\t\t\t\t// If we find a can-template we want to go back 2 in the stack to get it's inner content\n\t\t\t\t\t// rather than the <can-template> element itself\n\t\t\t\t\tvar parent = state.sectionElementStack[state.sectionElementStack.length - 2];\n\t\t\t\t\tif (renderer) {// Only add the renderer if the template has content\n\t\t\t\t\t\tparent.templates[oldNode.attrs.name] = makeRendererConvertScopes(renderer);\n\t\t\t\t\t}\n\t\t\t\t\tsection.removeCurrentNode();\n\t\t\t\t} else {\n\t\t\t\t\t// Get the last element in the stack\n\t\t\t\t\tvar current = state.sectionElementStack[state.sectionElementStack.length - 1];\n\t\t\t\t\taddAttributesCallback(oldNode, function(scope, parentNodeList){\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tscope.set('scope.lineNumber', lineNo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\tviewCallbacks.tagHandler(this,tagName, {\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\tsubtemplate: renderer  ? makeRendererConvertScopes(renderer) : renderer,\n\t\t\t\t\t\t\ttemplateType: \"stache\",\n\t\t\t\t\t\t\tparentNodeList: parentNodeList,\n\t\t\t\t\t\t\ttemplates: current.templates,\n\t\t\t\t\t\t\tdirectlyNested: current.directlyNested\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate.sectionElementStack.pop();\n\t\t},\n\t\tattrStart: function(attrName, lineNo){\n\t\t\tif(state.node.section) {\n\t\t\t\tstate.node.section.add(attrName+\"=\\\"\");\n\t\t\t} else {\n\t\t\t\tstate.attr = {\n\t\t\t\t\tname: attrName,\n\t\t\t\t\tvalue: \"\"\n\t\t\t\t};\n\t\t\t}\n\n\t\t},\n\t\tattrEnd: function(attrName, lineNo){\n\t\t\tif(state.node.section) {\n\t\t\t\tstate.node.section.add(\"\\\" \");\n\t\t\t} else {\n\t\t\t\tif(!state.node.attrs) {\n\t\t\t\t\tstate.node.attrs = {};\n\t\t\t\t}\n\n\t\t\t\tstate.node.attrs[state.attr.name] =\n\t\t\t\t\tstate.attr.section ? state.attr.section.compile(copyState()) : state.attr.value;\n\n\t\t\t\tvar attrCallback = viewCallbacks.attr(attrName);\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tvar decodedAttrName = attributeEncoder.decode(attrName);\n\t\t\t\t\tvar weirdAttribute = !!wrappedAttrPattern.test(decodedAttrName) || !!colonWrappedAttrPattern.test(decodedAttrName);\n\t\t\t\t\tif (weirdAttribute && !attrCallback) {\n\t\t\t\t\t\tdev.warn(\"unknown attribute binding \" + decodedAttrName + \". Is can-stache-bindings imported?\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\tif(attrCallback) {\n\t\t\t\t\tif( !state.node.attributes ) {\n\t\t\t\t\t\tstate.node.attributes = [];\n\t\t\t\t\t}\n\t\t\t\t\tstate.node.attributes.push(function(scope, nodeList){\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tscope.set('scope.lineNumber', lineNo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\tattrCallback(this,{\n\t\t\t\t\t\t\tattributeName: attrName,\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\tnodeList: nodeList\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tstate.attr = null;\n\t\t\t}\n\t\t},\n\t\tattrValue: function(value, lineNo){\n\t\t\tvar section = state.node.section || state.attr.section;\n\t\t\tif(section){\n\t\t\t\tsection.add(value);\n\t\t\t} else {\n\t\t\t\tstate.attr.value += value;\n\t\t\t}\n\t\t},\n\t\tchars: function(text, lineNo) {\n\t\t\t(state.textContentOnly || section).add(text);\n\t\t},\n\t\tspecial: function(text, lineNo){\n\t\t\tvar firstAndText = mustacheCore.splitModeFromExpression(text, state),\n\t\t\t\tmode = firstAndText.mode,\n\t\t\t\texpression = firstAndText.expression;\n\n\n\t\t\tif(expression === \"else\") {\n\t\t\t\tvar inverseSection;\n\t\t\t\tif(state.attr && state.attr.section) {\n\t\t\t\t\tinverseSection = state.attr.section;\n\t\t\t\t} else if(state.node && state.node.section ) {\n\t\t\t\t\tinverseSection = state.node.section;\n\t\t\t\t} else {\n\t\t\t\t\tinverseSection = state.textContentOnly || section;\n\t\t\t\t}\n\t\t\t\tinverseSection.inverse();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(mode === \"!\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(state.node && state.node.section) {\n\n\t\t\t\tmakeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);\n\n\t\t\t\tif(state.node.section.subSectionDepth() === 0){\n\t\t\t\t\tstate.node.attributes.push( state.node.section.compile(copyState()) );\n\t\t\t\t\tdelete state.node.section;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// `{{}}` in an attribute like `class=\"{{}}\"`\n\t\t\telse if(state.attr) {\n\n\t\t\t\tif(!state.attr.section) {\n\t\t\t\t\tstate.attr.section = new TextSectionBuilder();\n\t\t\t\t\tif(state.attr.value) {\n\t\t\t\t\t\tstate.attr.section.add(state.attr.value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmakeRendererAndUpdateSection(state.attr.section, mode, expression, lineNo);\n\n\t\t\t}\n\t\t\t// `{{}}` in a tag like `<div {{}}>`\n\t\t\telse if(state.node) {\n\n\t\t\t\tif(!state.node.attributes) {\n\t\t\t\t\tstate.node.attributes = [];\n\t\t\t\t}\n\t\t\t\tif(!mode) {\n\t\t\t\t\tstate.node.attributes.push(mustacheCore.makeLiveBindingBranchRenderer(null, expression, copyState({ filename: section.filename, lineNo: lineNo })));\n\t\t\t\t} else if( mode === \"#\" || mode === \"^\" ) {\n\t\t\t\t\tif(!state.node.section) {\n\t\t\t\t\t\tstate.node.section = new TextSectionBuilder();\n\t\t\t\t\t}\n\t\t\t\t\tmakeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(mode+\" is currently not supported within a tag.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmakeRendererAndUpdateSection(state.textContentOnly || section, mode, expression, lineNo);\n\t\t\t}\n\t\t},\n\t\tcomment: function(text) {\n\t\t\t// create comment node\n\t\t\tsection.add({\n\t\t\t\tcomment: text\n\t\t\t});\n\t\t},\n\t\tdone: function(lineNo){}\n\t});\n\n\tvar renderer = section.compile();\n\tvar scopifiedRenderer = HTMLSectionBuilder.scopify(function( scope, nodeList ) {\n\t\tvar templateContext = scope.templateContext;\n\n\t\tcanReflect.eachKey(inlinePartials, function(partial, partialName) {\n\t\t\tcanReflect.setKeyValue(templateContext.partials, partialName, partial);\n\t\t});\n\n\t\t// allow the current renderer to be called with {{>scope.view}}\n\t\tcanReflect.setKeyValue(templateContext, 'view', scopifiedRenderer);\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tcanReflect.setKeyValue(templateContext, 'filename', section.filename);\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn renderer.apply( this, arguments );\n\t});\n\treturn scopifiedRenderer;\n}\n\n// At this point, can.stache has been created\nassign(stache, mustacheHelpers);\n\nstache.safeString = function(text){\n\treturn {\n\t\ttoString: function () {\n\t\t\treturn text;\n\t\t}\n\t};\n};\nstache.async = function(source){\n\tvar iAi = getIntermediateAndImports(source);\n\tvar importPromises = iAi.imports.map(function(moduleName){\n\t\treturn importer(moduleName);\n\t});\n\treturn Promise.all(importPromises).then(function(){\n\t\treturn stache(iAi.intermediate);\n\t});\n};\nvar templates = {};\nstache.from = mustacheCore.getTemplateById = function(id){\n\tif(!templates[id]) {\n\t\tvar el = DOCUMENT().getElementById(id);\n\t\tif(el) {\n\t\t\ttemplates[id] = stache(\"#\" + id, el.innerHTML);\n\t\t}\n\t}\n\treturn templates[id];\n};\n\nstache.registerPartial = function(id, partial) {\n\ttemplates[id] = (typeof partial === \"string\" ? stache(partial) : partial);\n};\n\nstache.addBindings = viewCallbacks.attrs;\n\nmodule.exports = namespace.stache = stache;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/can-stache.js?");

/***/ }),

/***/ "../../node_modules/can-stache/expressions/arg.js":
/*!***********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/arg.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ### Arg\n// `new Arg(Expression [,modifierOptions] )`\n// Used to identify an expression that should return a value.\nvar Arg = function(expression, modifiers){\n\tthis.expr = expression;\n\tthis.modifiers = modifiers || {};\n\tthis.isCompute = false;\n};\nArg.prototype.value = function(){\n\treturn this.expr.value.apply(this.expr, arguments);\n};\n//!steal-remove-start\nif (true) {\n\tArg.prototype.sourceText = function(){\n\t\treturn (this.modifiers.compute ? \"~\" : \"\")+ this.expr.sourceText();\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Arg;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/arg.js?");

/***/ }),

/***/ "../../node_modules/can-stache/expressions/bracket.js":
/*!***************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/bracket.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n//!steal-remove-start\nif (true) {\n\tvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n}\n//!steal-remove-end\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"../../node_modules/can-stache/src/expression-helpers.js\");\n\n// ### Bracket\n// For accessing properties using bracket notation like `foo[bar]`\nvar Bracket = function (key, root, originalKey) {\n\tthis.root = root;\n\tthis.key = key;\n\t//!steal-remove-start\n\tif (true) {\n\t\tthis[canSymbol.for(\"can-stache.originalKey\")] = originalKey;\n\t}\n\t//!steal-remove-end\n};\nBracket.prototype.value = function (scope, helpers) {\n\tvar root = this.root ? this.root.value(scope, helpers) : scope.peek(\"this\");\n\treturn expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key.value(scope, helpers), root, scope, helpers, {});\n};\n//!steal-remove-start\nif (true) {\n\tBracket.prototype.sourceText = function(){\n\t\tif(this.rootExpr) {\n\t\t\treturn this.rootExpr.sourceText()+\"[\"+this.key+\"]\";\n\t\t} else {\n\t\t\treturn \"[\"+this.key+\"]\";\n\t\t}\n\t};\n}\n//!steal-remove-end\n\nBracket.prototype.closingTag = function() {\n\t//!steal-remove-start\n\tif (true) {\n\t\treturn this[canSymbol.for('can-stache.originalKey')] || '';\n\t}\n\t//!steal-remove-end\n};\n\nmodule.exports = Bracket;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/bracket.js?");

/***/ }),

/***/ "../../node_modules/can-stache/expressions/call.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/call.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Hashes = __webpack_require__(/*! ./hashes */ \"../../node_modules/can-stache/expressions/hashes.js\");\nvar SetIdentifier = __webpack_require__(/*! ../src/set-identifier */ \"../../node_modules/can-stache/src/set-identifier.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar sourceTextSymbol = canSymbol.for(\"can-stache.sourceText\");\nvar SetterObservable = __webpack_require__(/*! can-simple-observable/setter/setter */ \"../../node_modules/can-simple-observable/setter/setter.js\");\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"../../node_modules/can-stache/src/expression-helpers.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\n\n// ### Call\n// `new Call( new Lookup(\"method\"), [new ScopeExpr(\"name\")], {})`\n// A call expression like `method(arg1, arg2)` that, by default,\n// calls `method` with non compute values.\nvar Call = function(methodExpression, argExpressions){\n\tthis.methodExpr = methodExpression;\n\tthis.argExprs = argExpressions.map(expressionHelpers.convertToArgExpression);\n};\nCall.prototype.args = function(scope, ignoreArgLookup) {\n\tvar hashExprs = {};\n\tvar args = [];\n\tvar gotIgnoreFunction = typeof ignoreArgLookup === \"function\";\n\n\tfor (var i = 0, len = this.argExprs.length; i < len; i++) {\n\t\tvar arg = this.argExprs[i];\n\t\tif(arg.expr instanceof Hashes){\n\t\t\tassign(hashExprs, arg.expr.hashExprs);\n\t\t}\n\t\tif (!gotIgnoreFunction || !ignoreArgLookup(i)) {\n\t\t\tvar value = arg.value.apply(arg, arguments);\n\t\t\targs.push({\n\t\t\t\t// always do getValue unless compute is false\n\t\t\t\tcall: !arg.modifiers || !arg.modifiers.compute,\n\t\t\t\tvalue: value\n\t\t\t});\n\t\t}\n\t}\n\treturn function(doNotWrapArguments){\n\t\tvar finalArgs = [];\n\t\tif(canReflect.size(hashExprs) > 0){\n\t\t\tfinalArgs.hashExprs = hashExprs;\n\t\t}\n\t\tfor(var i = 0, len = args.length; i < len; i++) {\n\t\t\tif (doNotWrapArguments) {\n\t\t\t\tfinalArgs[i] = args[i].value;\n\t\t\t} else {\n\t\t\t\tfinalArgs[i] = args[i].call ?\n\t\t\t\t\tcanReflect.getValue( args[i].value ) :\n\t\t\t\t\texpressionHelpers.toCompute( args[i].value );\n\t\t\t}\n\t\t}\n\t\treturn finalArgs;\n\t};\n};\n\nCall.prototype.value = function(scope, helperOptions){\n\tvar callExpression = this;\n\n\t// proxyMethods must be false so that the `requiresOptionsArgument` and any\n\t// other flags stored on the function are preserved\n\tvar method = this.methodExpr.value(scope, { proxyMethods: false }),\n\t\tfunc = canReflect.getValue( method );\n\n\tvar getArgs = callExpression.args(scope , func && func.ignoreArgLookup);\n\n\tvar computeFn = function(newVal){\n\t\tvar func = canReflect.getValue( method );\n\n\t\tif(typeof func === \"function\") {\n\t\t\tvar args = getArgs(\n\t\t\t\tfunc.isLiveBound\n\t\t\t);\n\n\t\t\tif (func.requiresOptionsArgument) {\n\t\t\t\tif(args.hashExprs && helperOptions && helperOptions.exprData){\n\t\t\t\t\thelperOptions.exprData.hashExprs = args.hashExprs;\n\t\t\t\t}\n\t\t\t\targs.push(helperOptions);\n\t\t\t}\n\t\t\tif(arguments.length) {\n\t\t\t\targs.unshift(new SetIdentifier(newVal));\n\t\t\t}\n\n\t\t\t// if this is a call like `foo.bar()` the method.thisArg will be set to `foo`\n\t\t\t// for a call like `foo()`, method.thisArg will not be set and we will default\n\t\t\t// to setting the scope as the context of the function\n\t\t\treturn func.apply(method.thisArg || scope.peek(\"this\"), args);\n\t\t}\n\t};\n\t//!steal-remove-start\n\tif (true) {\n\t\tObject.defineProperty(computeFn, \"name\", {\n\t\t\tvalue: \"{{\" + this.sourceText() + \"}}\"\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tif (helperOptions && helperOptions.doNotWrapInObservation) {\n\t\treturn computeFn();\n\t} else {\n\t\tvar computeValue = new SetterObservable(computeFn, computeFn);\n\n\t\treturn computeValue;\n\t}\n};\n//!steal-remove-start\nif (true) {\n\tCall.prototype.sourceText = function(){\n\t\tvar args = this.argExprs.map(function(arg){\n\t\t\treturn arg.sourceText();\n\t\t});\n\t\treturn this.methodExpr.sourceText()+\"(\"+args.join(\",\")+\")\";\n\t};\n}\n//!steal-remove-end\nCall.prototype.closingTag = function() {\n\t//!steal-remove-start\n\tif (true) {\n\t\tif(this.methodExpr[sourceTextSymbol]) {\n\t\t\treturn this.methodExpr[sourceTextSymbol];\n\t\t}\n\t}\n\t//!steal-remove-end\n\treturn this.methodExpr.key;\n};\n\nmodule.exports = Call;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/call.js?");

/***/ }),

/***/ "../../node_modules/can-stache/expressions/hashes.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/hashes.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"../../node_modules/can-stache/src/expression-helpers.js\");\n\nvar Hashes = function(hashes){\n\tthis.hashExprs = hashes;\n};\nHashes.prototype.value = function(scope, helperOptions){\n\tvar hash = {};\n\tfor(var prop in this.hashExprs) {\n\t\tvar val = expressionHelpers.convertToArgExpression(this.hashExprs[prop]),\n\t\t\tvalue = val.value.apply(val, arguments);\n\n\t\thash[prop] = {\n\t\t\tcall: !val.modifiers || !val.modifiers.compute,\n\t\t\tvalue: value\n\t\t};\n\t}\n\treturn new Observation(function(){\n\t\tvar finalHash = {};\n\t\tfor(var prop in hash) {\n\t\t\tfinalHash[prop] = hash[prop].call ? canReflect.getValue( hash[prop].value ) : expressionHelpers.toComputeOrValue( hash[prop].value );\n\t\t}\n\t\treturn finalHash;\n\t});\n};\n//!steal-remove-start\nif (true) {\n\tHashes.prototype.sourceText = function(){\n\t\tvar hashes = [];\n\t\tcanReflect.eachKey(this.hashExprs, function(expr, prop){\n\t\t\thashes.push( prop+\"=\"+expr.sourceText() );\n\t\t});\n\t\treturn hashes.join(\" \");\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Hashes;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/hashes.js?");

/***/ }),

/***/ "../../node_modules/can-stache/expressions/helper.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/helper.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Literal = __webpack_require__(/*! ./literal */ \"../../node_modules/can-stache/expressions/literal.js\");\nvar Hashes = __webpack_require__(/*! ./hashes */ \"../../node_modules/can-stache/expressions/hashes.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"../../node_modules/can-stache/src/expression-helpers.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nvar Helper = function(methodExpression, argExpressions, hashExpressions){\n\tthis.methodExpr = methodExpression;\n\tthis.argExprs = argExpressions;\n\tthis.hashExprs = hashExpressions;\n\tthis.mode = null;\n};\nHelper.prototype.args = function(scope){\n\tvar args = [];\n\tfor(var i = 0, len = this.argExprs.length; i < len; i++) {\n\t\tvar arg = this.argExprs[i];\n\t\t// TODO: once we know the helper, we should be able to avoid compute conversion\n\t\targs.push( expressionHelpers.toComputeOrValue( arg.value.apply(arg, arguments) ) );\n\t}\n\treturn args;\n};\nHelper.prototype.hash = function(scope){\n\tvar hash = {};\n\tfor(var prop in this.hashExprs) {\n\t\tvar val = this.hashExprs[prop];\n\t\t// TODO: once we know the helper, we should be able to avoid compute conversion\n\t\thash[prop] = expressionHelpers.toComputeOrValue( val.value.apply(val, arguments) );\n\t}\n\treturn hash;\n};\n\nHelper.prototype.value = function(scope, helperOptions){\n\t// If a literal, this means it should be treated as a key. But helpers work this way for some reason.\n\t// TODO: fix parsing so numbers will also be assumed to be keys.\n\tvar methodKey = this.methodExpr instanceof Literal ?\n\t\t\"\" + this.methodExpr._value :\n\t\tthis.methodExpr.key,\n\t\thelperInstance = this,\n\t\t// proxyMethods must be false so that the `requiresOptionsArgument` and any\n\t\t// other flags stored on the function are preserved\n\t\thelperFn = expressionHelpers.getObservableValue_fromKey(methodKey, scope, { proxyMethods: false }),\n\t\tinitialValue = helperFn && helperFn.initialValue,\n\t\tthisArg = helperFn && helperFn.thisArg;\n\n\tif (typeof initialValue === \"function\") {\n\t\thelperFn = function helperFn() {\n\t\t\tvar args = helperInstance.args(scope),\n\t\t\t\thelperOptionArg = assign(assign({}, helperOptions), {\n\t\t\t\t\thash: helperInstance.hash(scope),\n\t\t\t\t\texprData: helperInstance\n\t\t\t\t});\n\n\t\t\targs.push(helperOptionArg);\n\n\t\t\treturn initialValue.apply(thisArg || scope.peek(\"this\"), args);\n\t\t};\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tObject.defineProperty(helperFn, \"name\", {\n\t\t\t\tvalue: canReflect.getName(this)\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\t}\n\t//!steal-remove-start\n\telse if (true) {\n\t\tvar filename = scope.peek('scope.filename');\n\t\t\tvar lineNumber = scope.peek('scope.lineNumber');\n\t\t\tdev.warn(\n\t\t\t\t(filename ? filename + ':' : '') +\n\t\t\t\t(lineNumber ? lineNumber + ': ' : '') +\n\t\t\t\t'Unable to find helper \"' + methodKey + '\".');\n\t}\n\t//!steal-remove-end\n\n\treturn  helperFn;\n};\n\nHelper.prototype.closingTag = function() {\n\treturn this.methodExpr.key;\n};\n\n//!steal-remove-start\nif (true) {\n\tHelper.prototype.sourceText = function(){\n\t\tvar text = [this.methodExpr.sourceText()];\n\t\tif(this.argExprs.length) {\n\t\t\ttext.push( this.argExprs.map(function(arg){\n\t\t\t\treturn arg.sourceText();\n\t\t\t}).join(\" \") );\n\t\t}\n\t\tif(canReflect.size(this.hashExprs) > 0){\n\t\t\ttext.push( Hashes.prototype.sourceText.call(this) );\n\t\t}\n\t\treturn text.join(\" \");\n\t};\n}\n//!steal-remove-end\nif (true) {\n\tcanReflect.assignSymbols(Helper.prototype,{\n\t\t\"can.getName\": function() {\n\t\t\treturn canReflect.getName(this.constructor) + \"{{\" + (this.sourceText()) + \"}}\";\n\t\t}\n\t});\n}\n//!steal-remove-end\n\nmodule.exports = Helper;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/helper.js?");

/***/ }),

/***/ "../../node_modules/can-stache/expressions/literal.js":
/*!***************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/literal.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ### Literal\n// For inline static values like `{{\"Hello World\"}}`\nvar Literal = function(value){\n\tthis._value = value;\n};\nLiteral.prototype.value = function(){\n\treturn this._value;\n};\n//!steal-remove-start\nif (true) {\n\tLiteral.prototype.sourceText = function(){\n\t\treturn JSON.stringify(this._value);\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Literal;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/literal.js?");

/***/ }),

/***/ "../../node_modules/can-stache/expressions/lookup.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/lookup.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"../../node_modules/can-stache/src/expression-helpers.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar sourceTextSymbol = canSymbol.for(\"can-stache.sourceText\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar observeReader = __webpack_require__(/*! can-stache-key */ \"../../node_modules/can-stache-key/can-stache-key.js\");\n\n// ### Lookup\n// `new Lookup(String, [Expression])`\n// Finds a value in the scope or a helper.\nvar Lookup = function(key, root, sourceText) {\n\tthis.key = key;\n\tthis.rootExpr = root;\n\tcanReflect.setKeyValue(this, sourceTextSymbol, sourceText);\n};\nLookup.prototype.value = function(scope, readOptions){\n\tvar value;\n\n\tif (this.rootExpr) {\n\t\tvalue = expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope), scope, {}, {});\n\t} else {\n\t\tvalue = expressionHelpers.getObservableValue_fromKey(this.key, scope, readOptions);\n\t}\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tif (typeof value.initialValue === 'undefined' && this.key !== \"debugger\" && !value.parentHasKey) {\n\t\t\tvar filename = scope.peek('scope.filename');\n\t\t\tvar lineNumber = scope.peek('scope.lineNumber');\n\n\t\t\tvar reads = observeReader.reads(this.key);\n\t\t\tvar firstKey = reads[0].key;\n\t\t\tvar key = reads.map(function(read) {\n\t\t\t\treturn read.key + (read.at ? \"()\" : \"\");\n\t\t\t}).join(\".\");\n\t\t\tvar pathsForKey = scope.getPathsForKey(firstKey);\n\t\t\tvar paths = Object.keys( pathsForKey );\n\n\t\t\tvar includeSuggestions = paths.length && !paths.includes(firstKey);\n\n\t\t\tvar warning = [\n\t\t\t\t(filename ? filename + ':' : '') +\n\t\t\t\t\t(lineNumber ? lineNumber + ': ' : '') +\n\t\t\t\t\t'Unable to find key \"' + key + '\".' +\n\t\t\t\t\t(\n\t\t\t\t\t\tincludeSuggestions ?\n\t\t\t\t\t\t\t\" Did you mean\" + (paths.length > 1 ? \" one of these\" : \"\") + \"?\\n\" :\n\t\t\t\t\t\t\t\"\\n\"\n\t\t\t\t\t)\n\t\t\t];\n\n\t\t\tif (includeSuggestions) {\n\t\t\t\tpaths.forEach(function(path) {\n\t\t\t\t\twarning.push('\\t\"' + path + '\" which will read from');\n\t\t\t\t\twarning.push(pathsForKey[path]);\n\t\t\t\t\twarning.push(\"\\n\");\n\t\t\t\t});\n\t\t\t}\n\n\t\t\twarning.push(\"\\n\");\n\n\t\t\tdev.warn.apply(dev,\n\t\t\t\twarning\n\t\t\t);\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\treturn value;\n};\n//!steal-remove-start\nif (true) {\n\tLookup.prototype.sourceText = function(){\n\t\tif(this[sourceTextSymbol]) {\n\t\t\treturn this[sourceTextSymbol];\n\t\t} else if(this.rootExpr) {\n\t\t\treturn this.rootExpr.sourceText()+\".\"+this.key;\n\t\t} else {\n\t\t\treturn this.key;\n\t\t}\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Lookup;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/expressions/lookup.js?");

/***/ }),

/***/ "../../node_modules/can-stache/helpers/-debugger.js":
/*!*************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/helpers/-debugger.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar canLog = __webpack_require__(/*! can-log */ \"../../node_modules/can-log/dist/cjs/can-log.js\");\nfunction noop () {}\nvar resolveValue = noop;\nvar evaluateArgs = noop;\nvar __testing = {};\n\n//!steal-remove-start\nif (true) {\n\tvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\n\tvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n\n\t__testing = {\n\t\tallowDebugger: true\n\t};\n\n\tresolveValue = function (value) {\n\t\tif (value && value[canSymbol.for(\"can.getValue\")]) {\n\t\t\treturn canReflect.getValue(value);\n\t\t}\n\t\treturn value;\n\t};\n\n\tevaluateArgs = function (left, right) {\n\t\tswitch (arguments.length) {\n\t\t\tcase 0: return true;\n\t\t\tcase 1: return !!resolveValue(left);\n\t\t\tcase 2: return resolveValue(left) === resolveValue(right);\n\t\t\tdefault:\n\t\t\t\tcanLog.log([\n\t\t\t\t\t'Usage:',\n\t\t\t\t\t'  {{debugger}}: break any time this helper is evaluated',\n\t\t\t\t\t'  {{debugger condition}}: break when `condition` is truthy',\n\t\t\t\t\t'  {{debugger left right}}: break when `left` === `right`'\n\t\t\t\t].join('\\n'));\n\t\t\t\tthrow new Error('{{debugger}} must have less than three arguments');\n\t\t}\n\t};\n}\n//!steal-remove-end\n\nfunction debuggerHelper (left, right) {\n\t//!steal-remove-start\n\tif (true) {\n\t\tvar shouldBreak = evaluateArgs.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n\t\tif (!shouldBreak) {\n\t\t\treturn;\n\t\t}\n\n\t\t// jshint +W098\n\t\tvar options = arguments[arguments.length - 1];\n\t\tvar get = function (path) {\n\t\t\treturn options.scope.get(path);\n\t\t};\n\t\t// jshint -W098\n\n\t\tcanLog.log('Use `get(<path>)` to debug this template');\n\n\t\tvar allowDebugger = __testing.allowDebugger;\n\t\t// forgotten debugger\n\t\t// jshint -W087\n\t\tif (allowDebugger) {\n\t\t\tdebugger;\n\t\t\treturn;\n\t\t}\n\t\t// jshint +W087\n\t}\n\t//!steal-remove-end\n\n\tcanLog.warn('Forgotten {{debugger}} helper');\n}\ndebuggerHelper.requiresOptionsArgument = true;\n\nmodule.exports = {\n\thelper: debuggerHelper,\n\tevaluateArgs: evaluateArgs,\n\tresolveValue: resolveValue,\n\n\t// used only for testing purposes\n\t__testing: __testing\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/helpers/-debugger.js?");

/***/ }),

/***/ "../../node_modules/can-stache/helpers/converter.js":
/*!*************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/helpers/converter.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar helpers = __webpack_require__(/*! ./core */ \"../../node_modules/can-stache/helpers/core.js\");\nvar SetIdentifier = __webpack_require__(/*! ../src/set-identifier */ \"../../node_modules/can-stache/src/set-identifier.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\n\nfunction makeConverter(getterSetter){\n\tgetterSetter = getterSetter || {};\n\treturn function(newVal, source) {\n\t\tvar args = canReflect.toArray(arguments);\n\t\tif(newVal instanceof SetIdentifier) {\n\t\t\treturn typeof getterSetter.set === \"function\" ?\n\t\t\t\tgetterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) :\n\t\t\t\tsource(newVal.value);\n\t\t} else {\n\t\t\treturn typeof getterSetter.get === \"function\" ?\n\t\t\t\tgetterSetter.get.apply(this, args) :\n\t\t\t\targs[0];\n\t\t}\n\t};\n}\n\nvar converterPackages = new WeakMap();\nhelpers.addConverter = function(name, getterSetter) {\n\tif(typeof name === \"object\") {\n\t\tif(!converterPackages.has(name)) {\n\t\t\tconverterPackages.set(name, true);\n\t\t\tcanReflect.eachKey(name, function(getterSetter, name) {\n\t\t\t\thelpers.addConverter(name, getterSetter);\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tvar helper = makeConverter(getterSetter);\n\thelper.isLiveBound = true;\n\thelpers.registerHelper(name, helper );\n};\n\nhelpers.registerConverter = function(name, getterSetter) {\n\thelpers.registerHelper(name, makeConverter(getterSetter) );\n};\n\n\nmodule.exports = helpers;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/helpers/converter.js?");

/***/ }),

/***/ "../../node_modules/can-stache/helpers/core.js":
/*!********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/helpers/core.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(System) {\nvar live = __webpack_require__(/*! can-view-live */ \"../../node_modules/can-view-live/can-view-live.js\");\nvar nodeLists = __webpack_require__(/*! can-view-nodelist */ \"../../node_modules/can-view-nodelist/can-view-nodelist.js\");\nvar utils = __webpack_require__(/*! ../src/utils */ \"../../node_modules/can-stache/src/utils.js\");\nvar getBaseURL = __webpack_require__(/*! can-globals/base-url/base-url */ \"../../node_modules/can-globals/base-url/base-url.js\");\nvar joinURIs = __webpack_require__(/*! can-join-uris */ \"../../node_modules/can-join-uris/can-join-uris.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar debuggerHelper = __webpack_require__(/*! ./-debugger */ \"../../node_modules/can-stache/helpers/-debugger.js\").helper;\nvar KeyObservable = __webpack_require__(/*! ../src/key-observable */ \"../../node_modules/can-stache/src/key-observable.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar TruthyObservable = __webpack_require__(/*! ../src/truthy-observable */ \"../../node_modules/can-stache/src/truthy-observable.js\");\nvar helpers = __webpack_require__(/*! can-stache-helpers */ \"../../node_modules/can-stache-helpers/can-stache-helpers.js\");\n\nvar domData = __webpack_require__(/*! can-dom-data */ \"../../node_modules/can-dom-data/can-dom-data.js\");\nvar domDataState = __webpack_require__(/*! can-dom-data-state */ \"../../node_modules/can-dom-data-state/can-dom-data-state.js\");\nvar looksLikeOptions = function(options){\n\treturn options && typeof options.fn === \"function\" && typeof options.inverse === \"function\";\n};\n\nvar resolve = function (value) {\n\tif (value && canReflect.isValueLike(value)) {\n\t\treturn canReflect.getValue(value);\n\t} else {\n\t\treturn value;\n\t}\n};\n\nvar resolveHash = function(hash){\n\tvar params = {};\n\tfor(var prop in hash) {\n\t\tparams[prop] = resolve(hash[prop]);\n\t}\n\treturn params;\n};\nvar bindAndRead = function (value) {\n\tif ( value && canReflect.isValueLike(value) ) {\n\t\tObservation.temporarilyBind(value);\n\t\treturn canReflect.getValue(value);\n\t} else {\n\t\treturn value;\n\t}\n};\n\nvar eachHelper = function(items) {\n\tvar args = [].slice.call(arguments),\n\t\toptions = args.pop(),\n\t\thashExprs = options.exprData.hashExprs,\n\t\tresolved = bindAndRead(items),\n\t\thashOptions,\n\t\taliases;\n\n\t// Check if using hash\n\tif (canReflect.size(hashExprs) > 0) {\n\t\thashOptions = {};\n\t\tcanReflect.eachKey(hashExprs, function (exprs, key) {\n\t\t\thashOptions[exprs.key] = key;\n\t\t});\n\t}\n\n\n\n\tif ((\n\t\tcanReflect.isObservableLike(resolved) && canReflect.isListLike(resolved) ||\n\t\t\t( canReflect.isListLike(resolved) && canReflect.isValueLike(items) )\n\t) && !options.stringOnly) {\n\t\t// Tells that a helper has been called, this function should be returned through\n\t\t// checking its value.\n\t\toptions.metadata.rendered = true;\n\t\treturn function(el){\n\t\t\t// make a child nodeList inside the can.view.live.html nodeList\n\t\t\t// so that if the html is re\n\t\t\tvar nodeList = [el];\n\t\t\tnodeList.expression = \"live.list\";\n\t\t\tnodeLists.register(nodeList, null, options.nodeList, true);\n\t\t\t// runs nest replacements\n\t\t\tnodeLists.update(options.nodeList, [el]);\n\n\t\t\tvar cb = function (item, index, parentNodeList) {\n\t\t\t\tvar aliases = {};\n\n\t\t\t\tif (canReflect.size(hashOptions) > 0) {\n\t\t\t\t\tif (hashOptions.value) {\n\t\t\t\t\t\taliases[hashOptions.value] = item;\n\t\t\t\t\t}\n\t\t\t\t\tif (hashOptions.index) {\n\t\t\t\t\t\taliases[hashOptions.index] = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn options.fn(\n\t\t\t\t\toptions.scope\n\t\t\t\t\t.add(aliases, { notContext: true })\n\t\t\t\t\t.add({ index: index }, { special: true })\n\t\t\t\t\t.add(item),\n\t\t\t\toptions.options,\n\t\t\t\tparentNodeList\n\t\t\t\t);\n\t\t\t};\n\n\t\t\tlive.list(el, items, cb, options.context, el.parentNode, nodeList, function(list, parentNodeList){\n\t\t\t\treturn options.inverse(options.scope.add(list), options.options, parentNodeList);\n\t\t\t});\n\t\t};\n\t}\n\n\tvar expr = resolve(items),\n\t\tresult;\n\n\tif (!!expr && canReflect.isListLike(expr)) {\n\t\tresult = utils.getItemsFragContent(expr, options, options.scope);\n\t\treturn options.stringOnly ? result.join('') : result;\n\t} else if (canReflect.isObservableLike(expr) && canReflect.isMapLike(expr) || expr instanceof Object) {\n\t\tresult = [];\n\t\tcanReflect.each(expr, function(val, key){\n\t\t\tvar value = new KeyObservable(expr, key);\n\t\t\taliases = {};\n\n\t\t\tif (canReflect.size(hashOptions) > 0) {\n\t\t\t\tif (hashOptions.value) {\n\t\t\t\t\taliases[hashOptions.value] = value;\n\t\t\t\t}\n\t\t\t\tif (hashOptions.key) {\n\t\t\t\t\taliases[hashOptions.key] = key;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.push(options.fn(\n\t\t\t\toptions.scope\n\t\t\t\t.add(aliases, { notContext: true })\n\t\t\t\t.add({ key: key }, { special: true })\n\t\t\t\t.add(value)\n\t\t\t));\n\t\t});\n\n\t\treturn options.stringOnly ? result.join('') : result;\n\t}\n};\neachHelper.isLiveBound = true;\neachHelper.requiresOptionsArgument = true;\neachHelper.ignoreArgLookup = function ignoreArgLookup(index) {\n\treturn index === 1;\n};\n\nvar indexHelper = function(offset, options) {\n\tif (!options) {\n\t\toptions = offset;\n\t\toffset = 0;\n\t}\n\tvar index = options.scope.peek(\"scope.index\");\n\treturn \"\"+((typeof(index) === \"function\" ? index() : index) + offset);\n};\nindexHelper.requiresOptionsArgument = true;\n\nvar ifHelper = function (expr, options) {\n\tvar value;\n\t// if it's a function, wrap its value in a compute\n\t// that will only change values from true to false\n\tif (expr && canReflect.isValueLike(expr)) {\n\t\tvalue = canReflect.getValue(new TruthyObservable(expr));\n\t} else {\n\t\tvalue = !! resolve(expr);\n\t}\n\n\tif (value) {\n\t\treturn options.fn(options.scope || this);\n\t} else {\n\t\treturn options.inverse(options.scope || this);\n\t}\n};\nifHelper.requiresOptionsArgument = true;\n\nvar isHelper = function() {\n\tvar lastValue, curValue,\n\t\toptions = arguments[arguments.length - 1];\n\n\tif (arguments.length  <= 2) {\n\t\treturn options.inverse();\n\t}\n\n\tvar args = arguments;\n\n\tfunction isHelper(){\n\t\tfor (var i = 0; i < args.length - 1; i++) {\n\t\t\tcurValue = resolve(args[i]);\n\t\t\tcurValue = typeof curValue === \"function\" ? curValue() : curValue;\n\n\t\t\tif (i > 0) {\n\t\t\t\tif (curValue !== lastValue) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastValue = curValue;\n\t\t}\n\t\treturn true;\n\t}\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tObject.defineProperty(isHelper, \"name\", {\n\t\t\tvalue: \"is(\"+[].slice.call(args,0,2).map(function(arg){\n\t\t\t\treturn canReflect.getName(arg);\n\t\t\t}).join(\",\")+\")\"\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tvar callFn = new Observation(isHelper);\n\n\treturn callFn.get() ? options.fn() : options.inverse();\n};\nisHelper.requiresOptionsArgument = true;\n\nvar unlessHelper = function (expr, options) {\n\treturn ifHelper.apply(this, [expr, assign(assign({}, options), {\n\t\tfn: options.inverse,\n\t\tinverse: options.fn\n\t})]);\n};\nunlessHelper.requiresOptionsArgument = true;\n\nvar withHelper = function (expr, options) {\n\tvar ctx = expr;\n\tif(!options) {\n\t\t// hash-only case if no current context expression\n\t\toptions = expr;\n\t\texpr = true;\n\t\tctx = options.hash;\n\t} else {\n\t\texpr = resolve(expr);\n\t\tif(options.hash && canReflect.size(options.hash) > 0) {\n\t\t\t// presumably rare case of both a context object AND hash keys\n\t\t\t// Leaving it undocumented for now, but no reason not to support it.\n\t\t\tctx = options.scope.add(options.hash, { notContext: true }).add(ctx);\n\t\t}\n\t}\n\treturn options.fn(ctx || {});\n};\nwithHelper.requiresOptionsArgument = true;\n\nvar dataHelper = function(attr, value) {\n\tvar data = (looksLikeOptions(value) ? value.context : value) || this;\n\treturn function setData(el) {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tdev.warn('The {{data}} helper has been deprecated; use {{domData}} instead: https://canjs.com/doc/can-stache.helpers.domData.html');\n\t\t}\n\t\t//!steal-remove-end\n\t\tdomDataState.set.call( el, attr, data );\n\t};\n};\n\nvar domDataHelper = function(attr, value) {\n\tvar data = (looksLikeOptions(value) ? value.context : value) || this;\n\treturn function setDomData(el) {\n\t\tdomData.set( el, attr, data );\n\t};\n};\n\nvar switchHelper = function(expression, options){\n\tresolve(expression);\n\tvar found = false;\n\n\tvar caseHelper = function(value, options) {\n\t\tif(!found && resolve(expression) === resolve(value)) {\n\t\t\tfound = true;\n\t\t\treturn options.fn(options.scope.peek('this') || this);\n\t\t}\n\t};\n\tcaseHelper.requiresOptionsArgument = true;\n\n\t// create default helper as a value-like function\n\t// so that either {{#default}} or {{#default()}} will work\n\tvar defaultHelper = function(options) {\n\t\tif (!found) {\n\t\t\treturn options ? options.scope.peek('this') : true;\n\t\t}\n\t};\n\tdefaultHelper.requiresOptionsArgument = true;\n\tcanReflect.assignSymbols(defaultHelper, {\n\t\t\"can.isValueLike\": true,\n\t\t\"can.isFunctionLike\": false,\n\t\t\"can.getValue\": function() {\n\t\t\t// pass the helperOptions passed to {{#switch}}\n\t\t\treturn this(options);\n\t\t}\n\t});\n\n\tvar newScope = options.scope.add({\n\t\tcase: caseHelper,\n\t\tdefault: defaultHelper\n\t}, { notContext: true });\n\n\treturn options.fn(newScope, options);\n};\nswitchHelper.requiresOptionsArgument = true;\n\nvar joinBaseHelper = function(firstExpr/* , expr... */){\n\tvar args = [].slice.call(arguments);\n\tvar options = args.pop();\n\n\tvar moduleReference = args.map( function(expr){\n\t\tvar value = resolve(expr);\n\t\treturn typeof value === \"function\" ? value() : value;\n\t}).join(\"\");\n\n\tvar templateModule = canReflect.getKeyValue(options.scope.templateContext.helpers, 'module');\n\tvar parentAddress = templateModule ? templateModule.uri: undefined;\n\n\tvar isRelative = moduleReference[0] === \".\";\n\n\tif(isRelative && parentAddress) {\n\t\treturn joinURIs(parentAddress, moduleReference);\n\t} else {\n\t\tvar baseURL = (\"object\" !== \"undefined\" &&\n\t\t\t(System.renderingBaseURL || System.baseURL)) ||\tgetBaseURL();\n\n\t\t// Make sure one of them has a needed /\n\t\tif(moduleReference[0] !== \"/\" && baseURL[baseURL.length - 1] !== \"/\") {\n\t\t\tbaseURL += \"/\";\n\t\t}\n\n\t\treturn joinURIs(baseURL, moduleReference);\n\t}\n};\njoinBaseHelper.requiresOptionsArgument = true;\n\nvar builtInHelpers = {\n\t'debugger': debuggerHelper,\n\teach: eachHelper,\n\teachOf: eachHelper,\n\tindex: indexHelper,\n\t'if': ifHelper,\n\tis: isHelper,\n\teq: isHelper,\n\tunless: unlessHelper,\n\t'with': withHelper,\n\tconsole: console,\n\tdata: dataHelper,\n\tdomData: domDataHelper,\n\t'switch': switchHelper,\n\tjoinBase: joinBaseHelper,\n\n};\n\nvar addBuiltInHelpers = function() {\n\tcanReflect.each(builtInHelpers, function(helper, helperName) {\n\t\thelpers[helperName] = helper;\n\t});\n};\n\n// add all the built-in helpers when stache is loaded\naddBuiltInHelpers();\n\nvar registerHelper = function(name, callback){\n\t//!steal-remove-start\n\tif (true) {\n\t\tif (helpers[name]) {\n\t\t\tdev.warn('The helper ' + name + ' has already been registered.');\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// mark passed in helper so it will be automatically passed\n\t// helperOptions (.fn, .inverse, etc) when called as Call Expressions\n\tcallback.requiresOptionsArgument = true;\n\n\t// store on global helpers list\n\thelpers[name] = callback;\n};\n\nvar registerHelpers = function(helpers) {\n\tvar name, callback;\n\tfor(name in helpers) {\n\t\tcallback = helpers[name];\n\t\tregisterHelper(name, makeSimpleHelper(callback));\n\t}\n};\n\nvar makeSimpleHelper = function(fn) {\n\treturn function() {\n\t\tvar realArgs = [];\n\t\tcanReflect.eachIndex(arguments, function(val) {\n\t\t\twhile (val && val.isComputed) {\n\t\t\t\tval = val();\n\t\t\t}\n\t\t\trealArgs.push(val);\n\t\t});\n\t\treturn fn.apply(this, realArgs);\n\t};\n};\n\nmodule.exports = {\n\tregisterHelper: registerHelper,\n\n\taddHelper: function(name, callback) {\n\t\tif(typeof name === \"object\") {\n\t\t\treturn registerHelpers(name);\n\t\t}\n\t\treturn registerHelper(name, makeSimpleHelper(callback));\n\t},\n\n\t// add helpers that set up their own internal live-binding\n\t// these helpers will not be wrapped in computes and will\n\t// receive observable arguments when called with Call Expressions\n\taddLiveHelper: function(name, callback) {\n\t\tcallback.isLiveBound = true;\n\t\treturn registerHelper(name, callback);\n\t},\n\n\tgetHelper: function(name, scope) {\n\t\tvar helper = scope && scope.getHelper(name);\n\n\t\tif (!helper) {\n\t\t\thelper = helpers[name];\n\t\t}\n\n\t\treturn helper;\n\t},\n\n\tresolve: resolve,\n\tresolveHash: resolveHash,\n\tlooksLikeOptions: looksLikeOptions,\n\t__resetHelpers: function() {\n\t\t// remove all helpers from can-stache-helpers object\n\t\tfor (var helper in helpers) {\n\t\t\tdelete helpers[helper];\n\t\t}\n\n\t\taddBuiltInHelpers();\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/system.js */ \"../../node_modules/webpack/buildin/system.js\")))\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/helpers/core.js?");

/***/ }),

/***/ "../../node_modules/can-stache/src/expression-helpers.js":
/*!******************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/expression-helpers.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Arg = __webpack_require__(/*! ../expressions/arg */ \"../../node_modules/can-stache/expressions/arg.js\");\nvar Literal = __webpack_require__(/*! ../expressions/literal */ \"../../node_modules/can-stache/expressions/literal.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar stacheKey = __webpack_require__(/*! can-stache-key */ \"../../node_modules/can-stache-key/can-stache-key.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar makeComputeLike = __webpack_require__(/*! can-view-scope/make-compute-like */ \"../../node_modules/can-view-scope/make-compute-like.js\");\nvar SetterObservable = __webpack_require__(/*! can-simple-observable/setter/setter */ \"../../node_modules/can-simple-observable/setter/setter.js\");\n\n// ## Helpers\n// Helper for getting a bound compute in the scope.\nfunction getObservableValue_fromKey(key, scope, readOptions) {\n\tvar data = scope.computeData(key, readOptions);\n\n\tObservation.temporarilyBind(data);\n\n\treturn data;\n}\n\nfunction computeHasDependencies(compute){\n\treturn compute[canSymbol.for(\"can.valueHasDependencies\")] ?\n\t\tcanReflect.valueHasDependencies(compute) : compute.computeInstance.hasDependencies;\n}\n\nfunction getObservableValue_fromDynamicKey_fromObservable(key, root, helperOptions, readOptions) {\n\t// This needs to return something similar to a ScopeKeyData with intialValue and parentHasKey\n\tvar getKeys = function(){\n\t\treturn stacheKey.reads((\"\" + canReflect.getValue(key)).replace(\".\", \"\\\\.\"));\n\t};\n\tvar parentHasKey;\n\tvar computeValue = new SetterObservable(function getDynamicKey() {\n\t\tvar readData = stacheKey.read( canReflect.getValue(root) , getKeys());\n\t\tparentHasKey = readData.parentHasKey;\n\t\treturn readData.value;\n\t}, function setDynamicKey(newVal){\n\t\tstacheKey.write(canReflect.getValue(root), getKeys(), newVal);\n\t});\n\tObservation.temporarilyBind(computeValue);\n\tcomputeValue.initialValue = canReflect.getValue(computeValue);\n\tcomputeValue.parentHasKey = parentHasKey;\n\treturn computeValue;\n}\n\n// If not a Literal or an Arg, convert to an arg for caching.\nfunction convertToArgExpression(expr) {\n\tif(!(expr instanceof Arg) && !(expr instanceof Literal)) {\n\t\treturn new Arg(expr);\n\t} else {\n\t\treturn expr;\n\t}\n}\n\nfunction toComputeOrValue(value) {\n\t// convert to non observable value\n\tif(canReflect.isObservableLike(value)) {\n\t\t// we only want to do this for things that `should` have dependencies, but dont.\n\t\tif(canReflect.isValueLike(value) && canReflect.valueHasDependencies(value) === false) {\n\t\t\treturn canReflect.getValue(value);\n\t\t}\n\t\t// if compute data\n\t\tif(value.compute) {\n\t\t\treturn value.compute;\n\t\t} else {\n\t\t\treturn makeComputeLike(value);\n\t\t}\n\t}\n\treturn value;\n}\n\n// try to make it a compute no matter what.  This is useful for\n// ~ operator.\nfunction toCompute(value) {\n\tif(value) {\n\n\t\tif(value.isComputed) {\n\t\t\treturn value;\n\t\t}\n\t\tif(value.compute) {\n\t\t\treturn value.compute;\n\t\t} else {\n\t\t\treturn makeComputeLike(value);\n\t\t}\n\t}\n\treturn value;\n}\n\nmodule.exports = {\n\tgetObservableValue_fromKey: getObservableValue_fromKey,\n\tcomputeHasDependencies: computeHasDependencies,\n\tgetObservableValue_fromDynamicKey_fromObservable: getObservableValue_fromDynamicKey_fromObservable,\n\tconvertToArgExpression: convertToArgExpression,\n\ttoComputeOrValue: toComputeOrValue,\n\ttoCompute: toCompute\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/expression-helpers.js?");

/***/ }),

/***/ "../../node_modules/can-stache/src/expression.js":
/*!**********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/expression.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ## Expression Types\n//\n// These expression types return a value. They are assembled by `expression.parse`.\nvar Arg = __webpack_require__(/*! ../expressions/arg */ \"../../node_modules/can-stache/expressions/arg.js\");\nvar Literal = __webpack_require__(/*! ../expressions/literal */ \"../../node_modules/can-stache/expressions/literal.js\");\nvar Hashes = __webpack_require__(/*! ../expressions/hashes */ \"../../node_modules/can-stache/expressions/hashes.js\");\nvar Bracket = __webpack_require__(/*! ../expressions/bracket */ \"../../node_modules/can-stache/expressions/bracket.js\");\nvar Call = __webpack_require__(/*! ../expressions/call */ \"../../node_modules/can-stache/expressions/call.js\");\nvar Helper = __webpack_require__(/*! ../expressions/helper */ \"../../node_modules/can-stache/expressions/helper.js\");\nvar Lookup = __webpack_require__(/*! ../expressions/lookup */ \"../../node_modules/can-stache/expressions/lookup.js\");\n\nvar SetIdentifier = __webpack_require__(/*! ./set-identifier */ \"../../node_modules/can-stache/src/set-identifier.js\");\nvar expressionHelpers = __webpack_require__(/*! ../src/expression-helpers */ \"../../node_modules/can-stache/src/expression-helpers.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"../../node_modules/can-stache/src/utils.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\nvar last = utils.last;\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n\nvar sourceTextSymbol = canSymbol.for(\"can-stache.sourceText\");\n\n// ### Hash\n// A placeholder. This isn't actually used.\nvar Hash = function(){ }; // jshint ignore:line\n\n// NAME - \\w\n// KEY - foo, foo.bar, foo@bar, %foo (special), &foo (references), ../foo, ./foo\n// ARG - ~KEY, KEY, CALLEXPRESSION, PRIMITIVE\n// CALLEXPRESSION = KEY(ARG,ARG, NAME=ARG)\n// HELPEREXPRESSION = KEY ARG ARG NAME=ARG\n// DOT .NAME\n// AT @NAME\n//\nvar keyRegExp = /[\\w\\.\\\\\\-_@\\/\\&%]+/,\n\ttokensRegExp = /('.*?'|\".*?\"|=|[\\w\\.\\\\\\-_@\\/*%\\$]+|[\\(\\)]|,|\\~|\\[|\\]\\s*|\\s*(?=\\[))/g,\n\tbracketSpaceRegExp = /\\]\\s+/,\n\tliteralRegExp = /^('.*?'|\".*?\"|-?[0-9]+\\.?[0-9]*|true|false|null|undefined)$/;\n\nvar isTokenKey = function(token){\n\treturn keyRegExp.test(token);\n};\n\nvar testDot = /^[\\.@]\\w/;\nvar isAddingToExpression = function(token) {\n\n\treturn isTokenKey(token) && testDot.test(token);\n};\n\nvar ensureChildren = function(type) {\n\tif(!type.children) {\n\t\ttype.children = [];\n\t}\n\treturn type;\n};\n\nvar Stack = function(){\n\n\tthis.root = {children: [], type: \"Root\"};\n\tthis.current = this.root;\n\tthis.stack = [this.root];\n};\nassign(Stack.prototype,{\n\ttop: function(){\n\t\treturn last(this.stack);\n\t},\n\tisRootTop: function(){\n\t\treturn this.top() === this.root;\n\t},\n\tpopTo: function(types){\n\t\tthis.popUntil(types);\n\t\tthis.pop();\n\t},\n\tpop: function() {\n\t\tif(!this.isRootTop()) {\n\t\t\tthis.stack.pop();\n\t\t}\n\t},\n\tfirst: function(types){\n\t\tvar curIndex = this.stack.length - 1;\n\t\twhile( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {\n\t\t\tcurIndex--;\n\t\t}\n\t\treturn this.stack[curIndex];\n\t},\n\tfirstParent: function(types){\n\t\tvar curIndex = this.stack.length - 2;\n\t\twhile( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {\n\t\t\tcurIndex--;\n\t\t}\n\t\treturn this.stack[curIndex];\n\t},\n\tpopUntil: function(types){\n\t\twhile( types.indexOf(this.top().type) === -1 && !this.isRootTop() ) {\n\t\t\tthis.stack.pop();\n\t\t}\n\t\treturn this.top();\n\t},\n\taddTo: function(types, type){\n\t\tvar cur = this.popUntil(types);\n\t\tensureChildren(cur).children.push(type);\n\t},\n\taddToAndPush: function(types, type){\n\t\tthis.addTo(types, type);\n\t\tthis.stack.push(type);\n\t},\n\tpush: function(type) {\n\t\tthis.stack.push(type);\n\t},\n\ttopLastChild: function(){\n\t\treturn last(this.top().children);\n\t},\n\treplaceTopLastChild: function(type){\n\t\tvar children = ensureChildren(this.top()).children;\n\t\tchildren.pop();\n\t\tchildren.push(type);\n\t\treturn type;\n\t},\n\treplaceTopLastChildAndPush: function(type) {\n\t\tthis.replaceTopLastChild(type);\n\t\tthis.stack.push(type);\n\t},\n\treplaceTopAndPush: function(type){\n\t\tvar children;\n\t\tif(this.top() === this.root) {\n\t\t\tchildren = ensureChildren(this.top()).children;\n\t\t} else {\n\t\t\tthis.stack.pop();\n\t\t\t// get parent and clean\n\t\t\tchildren = ensureChildren(this.top()).children;\n\t\t}\n\n\t\tchildren.pop();\n\t\tchildren.push(type);\n\t\tthis.stack.push(type);\n\t\treturn type;\n\t}\n});\n\n// converts\n// - \"../foo\" -> \"../@foo\",\n// - \"foo\" -> \"@foo\",\n// - \".foo\" -> \"@foo\",\n// - \"./foo\" -> \"./@foo\"\n// - \"foo.bar\" -> \"foo@bar\"\nvar convertKeyToLookup = function(key){\n\tvar lastPath = key.lastIndexOf(\"./\");\n\tvar lastDot = key.lastIndexOf(\".\");\n\tif(lastDot > lastPath) {\n\t\treturn key.substr(0, lastDot)+\"@\"+key.substr(lastDot+1);\n\t}\n\tvar firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath+2;\n\tvar firstNonPathChar = key.charAt(firstNonPathCharIndex);\n\tif(firstNonPathChar === \".\" || firstNonPathChar === \"@\" ) {\n\t\treturn key.substr(0, firstNonPathCharIndex)+\"@\"+key.substr(firstNonPathCharIndex+1);\n\t} else {\n\t\treturn key.substr(0, firstNonPathCharIndex)+\"@\"+key.substr(firstNonPathCharIndex);\n\t}\n};\nvar convertToAtLookup = function(ast){\n\tif(ast.type === \"Lookup\") {\n\t\tcanReflect.setKeyValue(ast, sourceTextSymbol, ast.key);\n\t\tast.key = convertKeyToLookup(ast.key);\n\t}\n\treturn ast;\n};\n\nvar convertToHelperIfTopIsLookup = function(stack){\n\tvar top = stack.top();\n\t// if two scopes, that means a helper\n\tif(top && top.type === \"Lookup\") {\n\n\t\tvar base = stack.stack[stack.stack.length - 2];\n\t\t// That lookup shouldn't be part of a Helper already or\n\t\tif(base.type !== \"Helper\" && base) {\n\t\t\tstack.replaceTopAndPush({\n\t\t\t\ttype: \"Helper\",\n\t\t\t\tmethod: top\n\t\t\t});\n\t\t}\n\t}\n};\n\nvar expression = {\n\ttoComputeOrValue: expressionHelpers.toComputeOrValue,\n\tconvertKeyToLookup: convertKeyToLookup,\n\n\tLiteral: Literal,\n\tLookup: Lookup,\n\tArg: Arg,\n\tHash: Hash,\n\tHashes: Hashes,\n\tCall: Call,\n\tHelper: Helper,\n\tBracket: Bracket,\n\n\tSetIdentifier: SetIdentifier,\n\ttokenize: function(expression){\n\t\tvar tokens = [];\n\t\t(expression.trim() + ' ').replace(tokensRegExp, function (whole, arg) {\n\t\t\tif (bracketSpaceRegExp.test(arg)) {\n\t\t\t\ttokens.push(arg[0]);\n\t\t\t\ttokens.push(arg.slice(1));\n\t\t\t} else {\n\t\t\t\ttokens.push(arg);\n\t\t\t}\n\t\t});\n\t\treturn tokens;\n\t},\n\tlookupRules: {\n\t\t\"default\": function(ast, methodType, isArg){\n\t\t\treturn ast.type === \"Helper\" ? Helper : Lookup;\n\t\t},\n\t\t\"method\": function(ast, methodType, isArg){\n\t\t\treturn Lookup;\n\t\t}\n\t},\n\tmethodRules: {\n\t\t\"default\": function(ast){\n\t\t\treturn ast.type === \"Call\" ? Call : Helper;\n\t\t},\n\t\t\"call\": function(ast){\n\t\t\treturn Call;\n\t\t}\n\t},\n\t// ## expression.parse\n\t//\n\t// - {String} expressionString - A stache expression like \"abc foo()\"\n\t// - {Object} options\n\t//   - baseMethodType - Treat this like a Helper or Call.  Default to \"Helper\"\n\t//   - lookupRule - \"default\" or \"method\"\n\t//   - methodRule - \"default\" or \"call\"\n\tparse: function(expressionString, options){\n\t\toptions =  options || {};\n\t\tvar ast = this.ast(expressionString);\n\n\t\tif(!options.lookupRule) {\n\t\t\toptions.lookupRule = \"default\";\n\t\t}\n\t\tif(typeof options.lookupRule === \"string\") {\n\t\t\toptions.lookupRule = expression.lookupRules[options.lookupRule];\n\t\t}\n\t\tif(!options.methodRule) {\n\t\t\toptions.methodRule = \"default\";\n\t\t}\n\t\tif(typeof options.methodRule === \"string\") {\n\t\t\toptions.methodRule = expression.methodRules[options.methodRule];\n\t\t}\n\n\t\tvar expr = this.hydrateAst(ast, options, options.baseMethodType || \"Helper\");\n\n\t\treturn expr;\n\t},\n\thydrateAst: function(ast, options, methodType, isArg){\n\t\tvar hashes;\n\t\tif(ast.type === \"Lookup\") {\n\t\t\tvar LookupRule = options.lookupRule(ast, methodType, isArg);\n\t\t\tvar lookup = new LookupRule(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType), ast[sourceTextSymbol] );\n\t\t\treturn lookup;\n\t\t}\n\t\telse if(ast.type === \"Literal\") {\n\t\t\treturn new Literal(ast.value);\n\t\t}\n\t\telse if(ast.type === \"Arg\") {\n\t\t\treturn new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg),{compute: true});\n\t\t}\n\t\telse if(ast.type === \"Hash\") {\n\t\t\tthrow new Error(\"\");\n\t\t}\n\t\telse if(ast.type === \"Hashes\") {\n\t\t\thashes = {};\n\t\t\tast.children.forEach(function(hash){\n\t\t\t\thashes[hash.prop] = this.hydrateAst( hash.children[0], options, methodType, true );\n\t\t\t}, this);\n\t\t\treturn new Hashes(hashes);\n\t\t}\n\t\telse if(ast.type === \"Call\" || ast.type === \"Helper\") {\n\t\t\t//get all arguments and hashes\n\t\t\thashes = {};\n\t\t\tvar args = [],\n\t\t\t\tchildren = ast.children,\n\t\t\t\tExpressionType = options.methodRule(ast);\n\t\t\tif(children) {\n\t\t\t\tfor(var i = 0 ; i <children.length; i++) {\n\t\t\t\t\tvar child = children[i];\n\t\t\t\t\tif(child.type === \"Hashes\" && ast.type === \"Helper\" &&\n\t\t\t\t\t\t(ExpressionType !== Call)) {\n\n\t\t\t\t\t\tchild.children.forEach(function(hash){\n\t\t\t\t\t\t\thashes[hash.prop] = this.hydrateAst( hash.children[0], options, ast.type, true );\n\t\t\t\t\t\t}, this);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push( this.hydrateAst(child, options, ast.type, true) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\treturn new ExpressionType(this.hydrateAst(ast.method, options, ast.type),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\targs, hashes);\n\t\t} else if (ast.type === \"Bracket\") {\n\t\t\tvar originalKey;\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\toriginalKey = ast[canSymbol.for(\"can-stache.originalKey\")];\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\treturn new Bracket(\n\t\t\t\tthis.hydrateAst(ast.children[0], options),\n\t\t\t\tast.root ? this.hydrateAst(ast.root, options) : undefined,\n\t\t\t\toriginalKey\n\t\t\t);\n\t\t}\n\t},\n\tast: function(expression){\n\t\tvar tokens = this.tokenize(expression);\n\t\treturn this.parseAst(tokens, {\n\t\t\tindex: 0\n\t\t});\n\t},\n\tparseAst: function(tokens, cursor) {\n\t\t// jshint maxdepth: 6\n\t\tvar stack = new Stack(),\n\t\t\ttop,\n\t\t\tfirstParent,\n\t\t\tlastToken;\n\n\t\twhile(cursor.index < tokens.length) {\n\t\t\tvar token = tokens[cursor.index],\n\t\t\t\tnextToken = tokens[cursor.index+1];\n\n\t\t\tcursor.index++;\n\n\t\t\t// Hash\n\t\t\tif(nextToken === \"=\") {\n\t\t\t\t//convertToHelperIfTopIsLookup(stack);\n\t\t\t\ttop = stack.top();\n\n\t\t\t\t// If top is a Lookup, we might need to convert to a helper.\n\t\t\t\tif(top && top.type === \"Lookup\") {\n\t\t\t\t\t// Check if current Lookup is part of a Call, Helper, or Hash\n\t\t\t\t\t// If it happens to be first within a Call or Root, that means\n\t\t\t\t\t// this is helper syntax.\n\t\t\t\t\tfirstParent = stack.firstParent([\"Call\",\"Helper\",\"Hash\"]);\n\t\t\t\t\tif(firstParent.type === \"Call\" || firstParent.type === \"Root\") {\n\n\t\t\t\t\t\tstack.popUntil([\"Call\"]);\n\t\t\t\t\t\ttop = stack.top();\n\t\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\t\ttype: \"Helper\",\n\t\t\t\t\t\t\tmethod: top.type === \"Root\" ? last(top.children) : top\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfirstParent = stack.firstParent([\"Call\",\"Helper\",\"Hashes\"]);\n\t\t\t\t// makes sure we are adding to Hashes if there already is one\n\t\t\t\t// otherwise we create one.\n\t\t\t\tvar hash = {type: \"Hash\", prop: token};\n\t\t\t\tif(firstParent.type === \"Hashes\") {\n\t\t\t\t\tstack.addToAndPush([\"Hashes\"], hash);\n\t\t\t\t} else {\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\"], {\n\t\t\t\t\t\ttype: \"Hashes\",\n\t\t\t\t\t\tchildren: [hash]\n\t\t\t\t\t});\n\t\t\t\t\tstack.push(hash);\n\t\t\t\t}\n\t\t\t\tcursor.index++;\n\n\t\t\t}\n\t\t\t// Literal\n\t\t\telse if(literalRegExp.test( token )) {\n\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\t// only add to hash if there's not already a child.\n\t\t\t\tfirstParent = stack.first([\"Helper\", \"Call\", \"Hash\", \"Bracket\"]);\n\t\t\t\tif(firstParent.type === \"Hash\" && (firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Bracket\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t} else if(firstParent.type === \"Bracket\" && (firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Hash\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t} else {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Hash\", \"Bracket\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// Lookup\n\t\t\telse if(keyRegExp.test(token)) {\n\t\t\t\tlastToken = stack.topLastChild();\n\t\t\t\tfirstParent = stack.first([\"Helper\", \"Call\", \"Hash\", \"Bracket\"]);\n\n\t\t\t\t// if we had `foo().bar`, we need to change to a Lookup that looks up from lastToken.\n\t\t\t\tif(lastToken && (lastToken.type === \"Call\" || lastToken.type === \"Bracket\" ) && isAddingToExpression(token)) {\n\t\t\t\t\tstack.replaceTopLastChildAndPush({\n\t\t\t\t\t\ttype: \"Lookup\",\n\t\t\t\t\t\troot: lastToken,\n\t\t\t\t\t\tkey: token.slice(1) // remove leading `.`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if(firstParent.type === 'Bracket') {\n\t\t\t\t\t// a Bracket expression without children means we have\n\t\t\t\t\t// parsed `foo[` of an expression like `foo[bar]`\n\t\t\t\t\t// so we know to add the Lookup as a child of the Bracket expression\n\t\t\t\t\tif (!(firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\t\tstack.addToAndPush([\"Bracket\"], {type: \"Lookup\", key: token});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// check if we are adding to a helper like `eq foo[bar] baz`\n\t\t\t\t\t\t// but not at the `.baz` of `eq foo[bar].baz xyz`\n\t\t\t\t\t\tif(stack.first([\"Helper\", \"Call\", \"Hash\", \"Arg\"]).type === 'Helper' && token[0] !== '.') {\n\t\t\t\t\t\t\tstack.addToAndPush([\"Helper\"], {type: \"Lookup\", key: token});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// otherwise, handle the `.baz` in expressions like `foo[bar].baz`\n\t\t\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\t\t\ttype: \"Lookup\",\n\t\t\t\t\t\t\t\tkey: token.slice(1),\n\t\t\t\t\t\t\t\troot: firstParent\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// if two scopes, that means a helper\n\t\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\", \"Arg\", \"Bracket\"], {type: \"Lookup\", key: token});\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// Arg\n\t\t\telse if(token === \"~\") {\n\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\"], {type: \"Arg\", key: token});\n\t\t\t}\n\t\t\t// Call\n\t\t\t// foo[bar()]\n\t\t\telse if(token === \"(\") {\n\t\t\t\ttop = stack.top();\n\t\t\t\tif(top.type === \"Lookup\") {\n\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\ttype: \"Call\",\n\t\t\t\t\t\tmethod: convertToAtLookup(top)\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Unable to understand expression \"+tokens.join(''));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// End Call\n\t\t\telse if(token === \")\") {\n\t\t\t\tstack.popTo([\"Call\"]);\n\t\t\t}\n\t\t\t// End Call argument\n\t\t\telse if(token === \",\") {\n\t\t\t\tstack.popUntil([\"Call\"]);\n\t\t\t}\n\t\t\t// Bracket\n\t\t\telse if(token === \"[\") {\n\t\t\t\ttop = stack.top();\n\t\t\t\tlastToken = stack.topLastChild();\n\n\t\t\t\tif (lastToken && (lastToken.type === \"Call\" || lastToken.type === \"Bracket\"  )  ) {\n\t\t\t\t\tstack.replaceTopAndPush({type: \"Bracket\", root: lastToken});\n\t\t\t\t} else if (top.type === \"Lookup\" || top.type === \"Bracket\") {\n\t\t\t\t\tvar bracket = {type: \"Bracket\", root: top};\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tcanReflect.setKeyValue(bracket, canSymbol.for(\"can-stache.originalKey\"), top.key);\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tstack.replaceTopAndPush(bracket);\n\t\t\t\t} else if (top.type === \"Call\") {\n\t\t\t\t\tstack.addToAndPush([\"Call\"], { type: \"Bracket\" });\n\t\t\t\t} else if (top === \" \") {\n\t\t\t\t\tstack.popUntil([\"Lookup\"]);\n\t\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\"], {type: \"Bracket\"});\n\t\t\t\t} else {\n\t\t\t\t\tstack.replaceTopAndPush({type: \"Bracket\"});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// End Bracket\n\t\t\telse if(token === \"]\") {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\telse if(token === \" \") {\n\t\t\t\tstack.push(token);\n\t\t\t}\n\t\t}\n\t\treturn stack.root.children[0];\n\t}\n};\n\nmodule.exports = expression;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/expression.js?");

/***/ }),

/***/ "../../node_modules/can-stache/src/html_section.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/html_section.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar target = __webpack_require__(/*! can-view-target */ \"../../node_modules/can-view-target/can-view-target.js\");\nvar Scope = __webpack_require__(/*! can-view-scope */ \"../../node_modules/can-view-scope/can-view-scope.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"../../node_modules/can-stache/src/utils.js\");\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\nvar last = utils.last;\n\nvar decodeHTML = typeof document !== \"undefined\" && (function(){\n\tvar el = getDocument().createElement('div');\n\treturn function(html){\n\t\tif(html.indexOf(\"&\") === -1) {\n\t\t\treturn html.replace(/\\r\\n/g,\"\\n\");\n\t\t}\n\t\tel.innerHTML = html;\n\t\treturn el.childNodes.length === 0 ? \"\" : el.childNodes.item(0).nodeValue;\n\t};\n})();\n// ## HTMLSectionBuilder\n//\n// Contains a stack of HTMLSections.\n// An HTMLSection is created everytime a subsection is found. For example:\n//\n//     {{#if(items)}} {{#items}} X\n//\n// At the point X was being processed, there would be 2 HTMLSections in the\n// stack.  One for the content of `{{#if(items)}}` and the other for the\n// content of `{{#items}}`\nvar HTMLSectionBuilder = function(filename){\n\tif (filename) {\n\t\tthis.filename = filename;\n\t}\n\tthis.stack = [new HTMLSection()];\n};\n\nHTMLSectionBuilder.scopify = function(renderer) {\n\treturn ObservationRecorder.ignore(function(scope, options, nodeList){\n\t\tif ( !(scope instanceof Scope) ) {\n\t\t\tscope = new Scope(scope || {});\n\t\t}\n\n\t\t// Support passing nodeList as the second argument\n\t\tif (nodeList === undefined && canReflect.isListLike(options)) {\n\t\t\tnodeList = options;\n\t\t\toptions = undefined;\n\t\t}\n\n\t\t// if an object is passed to options, assume it is the helpers object\n\t\tif (options && !options.helpers && !options.partials && !options.tags) {\n\t\t\toptions = {\n\t\t\t\thelpers: options\n\t\t\t};\n\t\t}\n\n\t\t// mark passed in helper so they will be automatically passed\n\t\t// helperOptions (.fn, .inverse, etc) when called as Call Expressions\n\t\tcanReflect.eachKey(options && options.helpers, function(helperValue) {\n\t\t\thelperValue.requiresOptionsArgument = true;\n\t\t});\n\n\t\tvar templateContext = scope.templateContext;\n\n\t\t// loop through each option category - helpers, partials, etc\n\t\tcanReflect.eachKey(options, function(optionValues, optionKey) {\n\t\t\tvar container = templateContext[optionKey];\n\n\t\t\tif (container) {\n\t\t\t\t// loop through each helper/partial\n\t\t\t\tcanReflect.eachKey(optionValues, function(optionValue, optionValueKey) {\n\t\t\t\t\tcanReflect.setKeyValue(container, optionValueKey, optionValue);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn renderer(scope, nodeList);\n\t});\n};\n\nassign(HTMLSectionBuilder.prototype,utils.mixins);\n\nassign(HTMLSectionBuilder.prototype,{\n\tstartSubSection: function(process){\n\t\tvar newSection = new HTMLSection(process);\n\t\tthis.stack.push(newSection);\n\t\treturn newSection;\n\t},\n\t// Ends the current section and returns a renderer.\n\t// But only returns a renderer if there is a template.\n\tendSubSectionAndReturnRenderer: function(){\n\t\tif(this.last().isEmpty()) {\n\t\t\tthis.stack.pop();\n\t\t\treturn null;\n\t\t} else {\n\t\t\tvar htmlSection = this.endSection();\n\t\t\treturn htmlSection.compiled.hydrate.bind(htmlSection.compiled);\n\t\t}\n\t},\n\tstartSection: function( process ) {\n\t\tvar newSection = new HTMLSection(process);\n\t\tthis.last().add(newSection.targetCallback);\n\t\t// adding a section within a section ...\n\t\t// the stack has section ...\n\t\tthis.stack.push(newSection);\n\t},\n\tendSection: function(){\n\t\tthis.last().compile();\n\t\treturn this.stack.pop();\n\t},\n\tinverse: function(){\n\t\tthis.last().inverse();\n\t},\n\tcompile: function(){\n\t\tvar compiled = this.stack.pop().compile();\n\t\t// ignore observations here.  the render fn\n\t\t//  itself doesn't need to be observable.\n\t\treturn ObservationRecorder.ignore(function(scope, nodeList){\n\t\t\tif ( !(scope instanceof Scope) ) {\n\t\t\t\tscope = new Scope(scope || {});\n\t\t\t}\n\n\t\t\treturn compiled.hydrate(scope, nodeList);\n\t\t});\n\t},\n\tpush: function(chars){\n\t\tthis.last().push(chars);\n\t},\n\tpop: function(){\n\t\treturn this.last().pop();\n\t},\n\tremoveCurrentNode: function() {\n\t\tthis.last().removeCurrentNode();\n\t}\n});\n\nvar HTMLSection = function(process){\n\tthis.data = \"targetData\";\n\tthis.targetData = [];\n\t// A record of what targetData element we are within.\n\tthis.targetStack = [];\n\tvar self = this;\n\tthis.targetCallback = function(scope, sectionNode){\n\t\tprocess.call(this,\n\t\t\tscope,\n\t\t\tsectionNode,\n\t\t\tself.compiled.hydrate.bind(self.compiled),\n\t\t\tself.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled)  ) ;\n\t};\n};\nassign(HTMLSection.prototype,{\n\tinverse: function(){\n\t\tthis.inverseData = [];\n\t\tthis.data = \"inverseData\";\n\t},\n\t// Adds a DOM node.\n\tpush: function(data){\n\t\tthis.add(data);\n\t\tthis.targetStack.push(data);\n\t},\n\tpop: function(){\n\t\treturn this.targetStack.pop();\n\t},\n\tadd: function(data){\n\t\tif(typeof data === \"string\"){\n\t\t\tdata = decodeHTML(data);\n\t\t}\n\t\tif(this.targetStack.length) {\n\t\t\tlast(this.targetStack).children.push(data);\n\t\t} else {\n\t\t\tthis[this.data].push(data);\n\t\t}\n\t},\n\tcompile: function(){\n\t\tthis.compiled = target(this.targetData, getDocument());\n\t\tif(this.inverseData) {\n\t\t\tthis.inverseCompiled = target(this.inverseData, getDocument());\n\t\t\tdelete this.inverseData;\n\t\t}\n\t\tthis.targetStack = this.targetData = null;\n\t\treturn this.compiled;\n\t},\n\tremoveCurrentNode: function() {\n\t\tvar children = this.children();\n\t\treturn children.pop();\n\t},\n\tchildren: function(){\n\t\tif(this.targetStack.length) {\n\t\t\treturn last(this.targetStack).children;\n\t\t} else {\n\t\t\treturn this[this.data];\n\t\t}\n\t},\n\t// Returns if a section is empty\n\tisEmpty: function(){\n\t\treturn !this.targetData.length;\n\t}\n});\nHTMLSectionBuilder.HTMLSection = HTMLSection;\n\nmodule.exports = HTMLSectionBuilder;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/html_section.js?");

/***/ }),

/***/ "../../node_modules/can-stache/src/key-observable.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/key-observable.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar SettableObservable = __webpack_require__(/*! can-simple-observable/settable/settable */ \"../../node_modules/can-simple-observable/settable/settable.js\");\nvar stacheKey = __webpack_require__(/*! can-stache-key */ \"../../node_modules/can-stache-key/can-stache-key.js\");\n\n\nfunction KeyObservable(root, key){\n    key = \"\"+key;\n    this.key = key;\n    this.root = root;\n    SettableObservable.call(this, function(){\n        return stacheKey.get(this,key);\n    }, root);\n}\n\nKeyObservable.prototype = Object.create(SettableObservable.prototype);\n\nKeyObservable.prototype.set = function(newVal) {\n    stacheKey.set(this.root,this.key, newVal);\n};\n\n\nmodule.exports = KeyObservable;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/key-observable.js?");

/***/ }),

/***/ "../../node_modules/can-stache/src/mustache_core.js":
/*!*************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/mustache_core.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n//\n// This provides helper utilities for Mustache processing. Currently,\n// only stache uses these helpers.  Ideally, these utilities could be used\n// in other libraries implementing Mustache-like features.\nvar live = __webpack_require__(/*! can-view-live */ \"../../node_modules/can-view-live/can-view-live.js\");\nvar nodeLists = __webpack_require__(/*! can-view-nodelist */ \"../../node_modules/can-view-nodelist/can-view-nodelist.js\");\n\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"../../node_modules/can-stache/src/utils.js\");\nvar expression = __webpack_require__(/*! ./expression */ \"../../node_modules/can-stache/src/expression.js\");\nvar frag = __webpack_require__(/*! can-fragment */ \"../../node_modules/can-fragment/can-fragment.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"../../node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"../../node_modules/can-define-lazy-value/define-lazy-value.js\");\n\n// Lazily lookup the context only if it's needed.\nfunction HelperOptions(scope, nodeList, exprData, stringOnly) {\n\tthis.metadata = { rendered: false };\n\tthis.stringOnly = stringOnly;\n\tthis.scope = scope;\n\tthis.nodeList = nodeList;\n\tthis.exprData = exprData;\n}\ndefineLazyValue(HelperOptions.prototype,\"context\", function(){\n\treturn this.scope.peek(\"this\");\n});\n\n// ## Types\n\n// A lookup is an object that is used to identify a lookup in the scope.\n/**\n * @hide\n * @typedef {{get: String}} can.stache.Lookup\n * @option {String} get A value in the scope to look up.\n */\n\n\n// ## Helpers\n\nvar mustacheLineBreakRegExp = /(?:(^|\\r?\\n)(\\s*)(\\{\\{([\\s\\S]*)\\}\\}\\}?)([^\\S\\n\\r]*)($|\\r?\\n))|(\\{\\{([\\s\\S]*)\\}\\}\\}?)/g,\n\tmustacheWhitespaceRegExp = /(\\s*)(\\{\\{\\{?)(-?)([\\s\\S]*?)(-?)(\\}\\}\\}?)(\\s*)/g,\n\tk = function(){};\nvar viewInsertSymbol = canSymbol.for(\"can.viewInsert\");\n\n\nvar core = {\n\texpression: expression,\n\t// ## mustacheCore.makeEvaluator\n\t// Given a scope and expression, returns a function that evaluates that expression in the scope.\n\t//\n\t// This function first reads lookup values in the args and hash.  Then it tries to figure out\n\t// if a helper is being called or a value is being read.  Finally, depending on\n\t// if it's a helper, or not, and which mode the expression is in, it returns\n\t// a function that can quickly evaluate the expression.\n\t/**\n\t * @hide\n\t * Given a mode and expression data, returns a function that evaluates that expression.\n\t * @param {can-view-scope} The scope in which the expression is evaluated.\n\t * @param {can.view.Options} The option helpers in which the expression is evaluated.\n\t * @param {String} mode Either null, #, ^. > is handled elsewhere\n\t * @param {Object} exprData Data about what was in the mustache expression\n\t * @param {renderer} [truthyRenderer] Used to render a subsection\n\t * @param {renderer} [falseyRenderer] Used to render the inverse subsection\n\t * @param {String} [stringOnly] A flag to indicate that only strings will be returned by subsections.\n\t * @return {Function} An 'evaluator' function that evaluates the expression.\n\t */\n\tmakeEvaluator: function (scope, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {\n\n\t\tif(mode === \"^\") {\n\t\t\tvar temp = truthyRenderer;\n\t\t\ttruthyRenderer = falseyRenderer;\n\t\t\tfalseyRenderer = temp;\n\t\t}\n\n\t\tvar value,\n\t\t\thelperOptions = new HelperOptions(scope, nodeList, exprData, stringOnly);\n\t\t\t// set up renderers\n\t\t\tutils.createRenderers(helperOptions, scope, nodeList, truthyRenderer, falseyRenderer, stringOnly);\n\n\t\tif(exprData instanceof expression.Call) {\n\t\t\tvalue = exprData.value(scope, helperOptions);\n\t\t} else if (exprData instanceof expression.Bracket) {\n\t\t\tvalue = exprData.value(scope);\n\t\t} else if (exprData instanceof expression.Lookup) {\n\t\t\tvalue = exprData.value(scope);\n\t\t} else if (exprData instanceof expression.Helper && exprData.methodExpr instanceof expression.Bracket) {\n\t\t\t// Brackets get wrapped in Helpers when used in attributes\n\t\t\t// like `<p class=\"{{ foo[bar] }}\" />`\n\t\t\tvalue = exprData.methodExpr.value(scope, helperOptions);\n\t\t} else {\n\t\t\tvalue = exprData.value(scope, helperOptions);\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\t// {{#something()}}foo{{/something}}\n\t\t// return evaluator for no mode or rendered value if a renderer was called\n\t\tif(!mode || helperOptions.metadata.rendered) {\n\t\t\treturn value;\n\t\t} else if( mode === \"#\" || mode === \"^\" ) {\n\n\t\t\treturn function(){\n\t\t\t\t// Get the value\n\t\t\t\tvar finalValue = canReflect.getValue(value);\n\t\t\t\tvar result;\n\n\t\t\t\t// if options.fn or options.inverse was called, we take the observable's return value\n\t\t\t\t// as what should be put in the DOM.\n\t\t\t\tif(helperOptions.metadata.rendered) {\n\t\t\t\t\tresult = finalValue;\n\t\t\t\t}\n\t\t\t\t// If it's an array, render.\n\t\t\t\telse if ( typeof finalValue !== \"string\" && canReflect.isListLike(finalValue) ) {\n\t\t\t\t\tvar isObserveList = canReflect.isObservableLike(finalValue) &&\n\t\t\t\t\t\tcanReflect.isListLike(finalValue);\n\n\t\t\t\t\tif(canReflect.getKeyValue(finalValue, \"length\")) {\n\t\t\t\t\t\tif (stringOnly) {\n\t\t\t\t\t\t\tresult = utils.getItemsStringContent(finalValue, isObserveList, helperOptions);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult = frag(utils.getItemsFragContent(finalValue, helperOptions, scope));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = helperOptions.inverse(scope);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = finalValue ? helperOptions.fn(finalValue || scope) : helperOptions.inverse(scope);\n\t\t\t\t}\n\t\t\t\t// We always set the rendered result back to false.\n\t\t\t\t// - Future calls might change from returning a value to calling `.fn`\n\t\t\t\t// - We are calling `.fn` and `.inverse` ourselves.\n\t\t\t\thelperOptions.metadata.rendered = false;\n\t\t\t\treturn result;\n\t\t\t};\n\t\t} else {\n\t\t\t// not supported!\n\t\t}\n\t},\n\t// ## mustacheCore.makeLiveBindingPartialRenderer\n\t// Returns a renderer function that live binds a partial.\n\t/**\n\t * @hide\n\t * Returns a renderer function that live binds a partial.\n\t * @param {String} expressionString\n\t * @param {Object} state The html state of where the expression was found.\n\t * @return {function(this:HTMLElement,can-view-scope,can.view.Options)} A renderer function\n\t * live binds a partial.\n\t */\n\tmakeLiveBindingPartialRenderer: function(expressionString, state){\n\t\texpressionString = expressionString.trim();\n\t\tvar exprData,\n\t\t\t\tpartialName = expressionString.split(/\\s+/).shift();\n\n\t\tif(partialName !== expressionString) {\n\t\t\texprData = core.expression.parse(expressionString);\n\t\t}\n\n\t\treturn function(scope, parentSectionNodeList){\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tscope.set('scope.filename', state.filename);\n\t\t\t\tscope.set('scope.lineNumber', state.lineNo);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar nodeList = [this];\n\t\t\tnodeList.expression = \">\" + partialName;\n\t\t\tnodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);\n\n\t\t\tvar partialFrag = new Observation(function(){\n\t\t\t\tvar localPartialName = partialName;\n\t\t\t\t// If the second parameter of a partial is a custom context\n\t\t\t\tif(exprData && exprData.argExprs.length === 1) {\n\t\t\t\t\tvar newContext = canReflect.getValue( exprData.argExprs[0].value(scope) );\n\t\t\t\t\tif(typeof newContext === \"undefined\") {\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (true) {\n\t\t\t\t\t\t\tdev.warn('The context ('+ exprData.argExprs[0].key +') you passed into the' +\n\t\t\t\t\t\t\t\t'partial ('+ partialName +') is not defined in the scope!');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t}else{\n\t\t\t\t\t\tscope = scope.add(newContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Look up partials in templateContext first\n\t\t\t\tvar partial = canReflect.getKeyValue(scope.templateContext.partials, localPartialName);\n\t\t\t\tvar renderer;\n\n\t\t\t\tif (partial) {\n\t\t\t\t\trenderer = function() {\n\t\t\t\t\t\treturn partial.render ? partial.render(scope, nodeList)\n\t\t\t\t\t\t\t: partial(scope);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Use can.view to get and render the partial.\n\t\t\t\telse {\n\t\t\t\t\tvar scopePartialName = scope.read(localPartialName, {\n\t\t\t\t\t\tisArgument: true\n\t\t\t\t\t}).value;\n\n\t\t\t\t\tif (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {\n\t\t\t\t\t\treturn frag(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tif (scopePartialName) {\n\t\t\t\t\t\tlocalPartialName = scopePartialName;\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer = function() {\n\t\t\t\t\t\tif(typeof localPartialName === \"function\"){\n\t\t\t\t\t\t\treturn localPartialName(scope, {}, nodeList);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar domRenderer = core.getTemplateById(localPartialName);\n\t\t\t\t\t\t\treturn domRenderer ? domRenderer(scope, {}, nodeList) : getDocument().createDocumentFragment();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar res = ObservationRecorder.ignore(renderer)();\n\t\t\t\treturn frag(res);\n\t\t\t});\n\t\t\tcanReflect.setPriority(partialFrag,nodeList.nesting );\n\n\t\t\tlive.html(this, partialFrag, this.parentNode, nodeList);\n\t\t};\n\t},\n\t// ## mustacheCore.makeStringBranchRenderer\n\t// Return a renderer function that evalutes to a string and caches\n\t// the evaluator on the scope.\n\t/**\n\t * @hide\n\t * Return a renderer function that evaluates to a string.\n\t * @param {String} mode\n\t * @param {can.stache.Expression} expression\n\t * @param {Object} state The html state of where the expression was found.\n\t * @return {function(can.view.Scope,can.view.Options, can-stache.renderer, can.view.renderer)}\n\t */\n\tmakeStringBranchRenderer: function(mode, expressionString, state){\n\t\tvar exprData = core.expression.parse(expressionString),\n\t\t\t// Use the full mustache expression as the cache key.\n\t\t\tfullExpression = mode+expressionString;\n\n\t\t// A branching renderer takes truthy and falsey renderer.\n\t\tvar branchRenderer = function branchRenderer(scope, truthyRenderer, falseyRenderer){\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tscope.set('scope.filename', state.filename);\n\t\t\t\tscope.set('scope.lineNumber', state.lineNo);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t// Check the scope's cache if the evaluator already exists for performance.\n\t\t\tvar evaluator = scope.__cache[fullExpression];\n\t\t\tif(mode || !evaluator) {\n\t\t\t\tevaluator = makeEvaluator( scope, null, mode, exprData, truthyRenderer, falseyRenderer, true);\n\t\t\t\tif(!mode) {\n\t\t\t\t\tscope.__cache[fullExpression] = evaluator;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar gotObservableValue = evaluator[canSymbol.for(\"can.onValue\")],\n\t\t\t\tres;\n\n\t\t\t// Run the evaluator and return the result.\n\t\t\tif(gotObservableValue) {\n\t\t\t\tres = canReflect.getValue(evaluator);\n\t\t\t} else {\n\t\t\t\tres = evaluator();\n\t\t\t}\n\n\n\t\t\treturn res == null ? \"\" : \"\"+res;\n\t\t};\n\n\t\tbranchRenderer.exprData = exprData;\n\n\t\treturn branchRenderer;\n\t},\n\t// ## mustacheCore.makeLiveBindingBranchRenderer\n\t// Return a renderer function that evaluates the mustache expression and\n\t// sets up live binding if a compute with dependencies is found. Otherwise,\n\t// the element's value is set.\n\t//\n\t// This function works by creating a `can.compute` from the mustache expression.\n\t// If the compute has dependent observables, it passes the compute to `can.view.live`; otherwise,\n\t// it updates the element's property based on the compute's value.\n\t/**\n\t * @hide\n\t * Returns a renderer function that evaluates the mustache expression.\n\t * @param {String} mode\n\t * @param {can.stache.Expression} expression\n\t * @param {Object} state The html state of where the expression was found.\n\t */\n\tmakeLiveBindingBranchRenderer: function(mode, expressionString, state){\n\t\t// Pre-process the expression.\n\t\tvar exprData = core.expression.parse(expressionString);\n\t\tif(!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call) && !(exprData instanceof expression.Bracket) && !(exprData instanceof expression.Lookup)) {\n\t\t\texprData = new expression.Helper(exprData,[],{});\n\t\t}\n\t\t// A branching renderer takes truthy and falsey renderer.\n\t\tvar branchRenderer = function branchRenderer(scope, parentSectionNodeList, truthyRenderer, falseyRenderer){\n\t\t\t// If this is within a tag, make sure we only get string values.\n\t\t\tvar stringOnly = state.tag;\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tscope.set('scope.filename', state.filename);\n\t\t\t\tscope.set('scope.lineNumber', state.lineNo);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar nodeList = [this];\n\t\t\tnodeList.expression = expressionString;\n\t\t\t// register this nodeList.\n\t\t\t// Register it with its parent ONLY if this is directly nested.  Otherwise, it's unnecessary.\n\t\t\tnodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);\n\n\t\t\t// Get the evaluator. This does not need to be cached (probably) because if there\n\t\t\t// an observable value, it will be handled by `can.view.live`.\n\t\t\tvar evaluator = makeEvaluator( scope, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly );\n\n\t\t\t// Create a compute that can not be observed by other\n\t\t\t// computes. This is important because this renderer is likely called by\n\t\t\t// parent expressions.  If this value changes, the parent expressions should\n\t\t\t// not re-evaluate. We prevent that by making sure this compute is ignored by\n\t\t\t// everyone else.\n\t\t\t//var compute = can.compute(evaluator, null, false);\n\t\t\tvar gotObservableValue = evaluator[canSymbol.for(\"can.onValue\")];\n\t\t\tvar observable;\n\t\t\tif(gotObservableValue) {\n\t\t\t\tobservable = evaluator;\n\t\t\t} else {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tObject.defineProperty(evaluator,\"name\",{\n\t\t\t\t\t\tvalue: \"{{\"+(mode || \"\")+expressionString+\"}}\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\tobservable = new Observation(evaluator,null,{isObservable: false});\n\t\t\t}\n\n\t\t\tif(canReflect.setPriority(observable, nodeList.nesting) === false) {\n\t\t\t\tthrow new Error(\"can-stache unable to set priority on observable\");\n\t\t\t}\n\n\t\t\t// Bind on the computeValue to set the cached value. This helps performance\n\t\t\t// so live binding can read a cached value instead of re-calculating.\n\t\t\tcanReflect.onValue(observable, k);\n\n\t\t\tvar value = canReflect.getValue(observable);\n\n\t\t\t// If value is a function and not a Lookup ({{foo}}),\n\t\t\t// it's a helper that returned a function and should be called.\n\t\t\tif(typeof value === \"function\" && !(exprData instanceof expression.Lookup)) {\n\n\t\t\t\t// A helper function should do it's own binding.  Similar to how\n\t\t\t\t// we prevented this function's compute from being noticed by parent expressions,\n\t\t\t\t// we hide any observables read in the function by saving any observables that\n\t\t\t\t// have been read and then setting them back which overwrites any `can.__observe` calls\n\t\t\t\t// performed in value.\n\t\t\t\tObservationRecorder.ignore(value)(this);\n\n\t\t\t}\n\t\t\t// If the computeValue has observable dependencies, setup live binding.\n\t\t\telse if( canReflect.valueHasDependencies(observable) ) {\n\n\t\t\t\t// Depending on where the template is, setup live-binding differently.\n\t\t\t\tif(state.attr) {\n\t\t\t\t\tlive.attr(this, state.attr, observable);\n\t\t\t\t}\n\t\t\t\telse if( state.tag )  {\n\t\t\t\t\tlive.attrs( this, observable );\n\t\t\t\t}\n\t\t\t\telse if(state.text && typeof value !== \"object\"){\n\t\t\t\t\tlive.text(this, observable, this.parentNode, nodeList);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlive.html(this, observable, this.parentNode, {\n\t\t\t\t\t\tnodeList: nodeList\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If the computeValue has no observable dependencies, just set the value on the element.\n\t\t\telse {\n\n\t\t\t\tif(state.attr) {\n\t\t\t\t\tdomMutate.setAttribute(this, state.attr, value);\n\t\t\t\t}\n\t\t\t\telse if(state.tag) {\n\t\t\t\t\tlive.attrs(this, value);\n\t\t\t\t}\n\t\t\t\telse if(state.text && typeof value === \"string\") {\n\t\t\t\t\tthis.nodeValue = value;\n\t\t\t\t}\n\t\t\t\telse if( value != null ){\n\t\t\t\t\tif (typeof value[viewInsertSymbol] === \"function\") {\n\t\t\t\t\t\tnodeLists.replace([this], value[viewInsertSymbol]({\n\t\t\t\t\t\t\tnodeList: nodeList\n\t\t\t\t\t\t}));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnodeLists.replace([this], frag(value, this.ownerDocument));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Unbind the compute.\n\t\t\tcanReflect.offValue(observable, k);\n\t\t};\n\n\t\tbranchRenderer.exprData = exprData;\n\n\t\treturn branchRenderer;\n\t},\n\t// ## mustacheCore.splitModeFromExpression\n\t// Returns the mustache mode split from the rest of the expression.\n\t/**\n\t * @hide\n\t * Returns the mustache mode split from the rest of the expression.\n\t * @param {can.stache.Expression} expression\n\t * @param {Object} state The state of HTML where the expression was found.\n\t */\n\tsplitModeFromExpression: function(expression, state){\n\t\texpression = expression.trim();\n\t\tvar mode = expression.charAt(0);\n\n\t\tif( \"#/{&^>!<\".indexOf(mode) >= 0 ) {\n\t\t\texpression =  expression.substr(1).trim();\n\t\t} else {\n\t\t\tmode = null;\n\t\t}\n\t\t// Triple braces do nothing within a tag.\n\t\tif(mode === \"{\" && state.node) {\n\t\t\tmode = null;\n\t\t}\n\t\treturn {\n\t\t\tmode: mode,\n\t\t\texpression: expression\n\t\t};\n\t},\n\t// ## mustacheCore.cleanLineEndings\n\t// Removes line breaks accoding to the mustache specification.\n\t/**\n\t * @hide\n\t * Prunes line breaks accoding to the mustache specification.\n\t * @param {String} template\n\t * @return {String}\n\t */\n\tcleanLineEndings: function(template){\n\n\t\t// Finds mustache tags with space around them or no space around them.\n\t\treturn template.replace( mustacheLineBreakRegExp,\n\t\t\tfunction(whole,\n\t\t\t\treturnBefore,\n\t\t\t\tspaceBefore,\n\t\t\t\tspecial,\n\t\t\t\texpression,\n\t\t\t\tspaceAfter,\n\t\t\t\treturnAfter,\n\t\t\t\t// A mustache magic tag that has no space around it.\n\t\t\t\tspaceLessSpecial,\n\t\t\t\tspaceLessExpression,\n\t\t\t\tmatchIndex){\n\n\t\t\t// IE 8 will provide undefined\n\t\t\tspaceAfter = (spaceAfter || \"\");\n\t\t\treturnBefore = (returnBefore || \"\");\n\t\t\tspaceBefore = (spaceBefore || \"\");\n\n\t\t\tvar modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});\n\n\t\t\t// If it's a partial or tripple stache, leave in place.\n\t\t\tif(spaceLessSpecial || \">{\".indexOf( modeAndExpression.mode) >= 0) {\n\t\t\t\treturn whole;\n\t\t\t}  else if( \"^#!/\".indexOf(  modeAndExpression.mode ) >= 0 ) {\n\t\t\t\t// Return the magic tag and a trailing linebreak if this did not\n\t\t\t\t// start a new line and there was an end line.\n\t\t\t\t// Add a normalized leading space, if there was any leading space, in case this abuts a tag name\n\t\t\t\tspaceBefore = (returnBefore + spaceBefore) && \" \";\n\t\t\t\treturn spaceBefore+special+( matchIndex !== 0 && returnAfter.length ? returnBefore+\"\\n\" :\"\");\n\n\n\t\t\t} else {\n\t\t\t\t// There is no mode, return special with spaces around it.\n\t\t\t\treturn spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+\"\\n\" : \"\");\n\t\t\t}\n\n\t\t});\n\t},\n\t// ## mustacheCore.cleanWhitespaceControl\n\t// Removes whitespace according to the whitespace control.\n\t/**\n\t * @hide\n\t * Prunes whitespace according to the whitespace control.\n\t * @param {String} template\n\t * @return {String}\n\t */\n\tcleanWhitespaceControl: function(template) {\n\t\treturn template.replace(mustacheWhitespaceRegExp, function(\n\t\t\twhole,\n\t\t\tspaceBefore,\n\t\t\tbracketBefore,\n\t\t\tcontrolBefore,\n\t\t\texpression,\n\t\t\tcontrolAfter,\n\t\t\tbracketAfter,\n\t\t\tspaceAfter,\n\t\t\tmatchIndex\n\t\t) {\n\n\t\t\tif (controlBefore === '-') {\n\t\t\t\tspaceBefore = '';\n\t\t\t}\n\n\t\t\tif (controlAfter === '-') {\n\t\t\t\tspaceAfter = '';\n\t\t\t}\n\n\t\t\treturn spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;\n\n\t\t});\n\t},\n\tgetTemplateById: function(){}\n};\n\n// ## Local Variable Cache\n//\n// The following creates slightly more quickly accessible references of the following\n// core functions.\nvar makeEvaluator = core.makeEvaluator,\n\tsplitModeFromExpression = core.splitModeFromExpression;\n\nmodule.exports = core;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/mustache_core.js?");

/***/ }),

/***/ "../../node_modules/can-stache/src/set-identifier.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/set-identifier.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function SetIdentifier(value){\n\tthis.value = value;\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/set-identifier.js?");

/***/ }),

/***/ "../../node_modules/can-stache/src/text_section.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/text_section.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar live = __webpack_require__(/*! can-view-live */ \"../../node_modules/can-view-live/can-view-live.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"../../node_modules/can-stache/src/utils.js\");\n\nvar domMutate = __webpack_require__(/*! can-dom-mutate/node */ \"../../node_modules/can-dom-mutate/node.js\");\n\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\n\nvar noop = function(){};\n\nvar TextSectionBuilder = function(){\n\tthis.stack = [new TextSection()];\n};\n\nassign(TextSectionBuilder.prototype,utils.mixins);\n\nassign(TextSectionBuilder.prototype,{\n\t// Adds a subsection.\n\tstartSection: function(process){\n\t\tvar subSection = new TextSection();\n\t\tthis.last().add({process: process, truthy: subSection});\n\t\tthis.stack.push(subSection);\n\t},\n\tendSection: function(){\n\t\tthis.stack.pop();\n\t},\n\tinverse: function(){\n\t\tthis.stack.pop();\n\t\tvar falseySection = new TextSection();\n\t\tthis.last().last().falsey = falseySection;\n\t\tthis.stack.push(falseySection);\n\t},\n\tcompile: function(state){\n\n\t\tvar renderer = this.stack[0].compile();\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tObject.defineProperty(renderer,\"name\",{\n\t\t\t\tvalue: \"textSectionRenderer<\"+state.tag+\".\"+state.attr+\">\"\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn function(scope){\n\t\t\tfunction textSectionRender(){\n\t\t\t\treturn renderer(scope);\n\t\t\t}\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tObject.defineProperty(textSectionRender,\"name\",{\n\t\t\t\t\tvalue: \"textSectionRender<\"+state.tag+\".\"+state.attr+\">\"\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar observation = new Observation(textSectionRender, null, {isObservable: false});\n\n\t\t\tcanReflect.onValue(observation, noop);\n\n\t\t\tvar value = canReflect.getValue(observation);\n\t\t\tif( canReflect.valueHasDependencies( observation ) ) {\n\t\t\t\tif(state.textContentOnly) {\n\t\t\t\t\tlive.text(this, observation);\n\t\t\t\t}\n\t\t\t\telse if(state.attr) {\n\t\t\t\t\tlive.attr(this, state.attr, observation);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlive.attrs(this, observation, scope);\n\t\t\t\t}\n\t\t\t\tcanReflect.offValue(observation, noop);\n\t\t\t} else {\n\t\t\t\tif(state.textContentOnly) {\n\t\t\t\t\tthis.nodeValue = value;\n\t\t\t\t}\n\t\t\t\telse if(state.attr) {\n\t\t\t\t\tdomMutate.setAttribute.call(this, state.attr, value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlive.attrs(this, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\nvar passTruthyFalsey = function(process, truthy, falsey){\n\treturn function(scope){\n\t\treturn process.call(this, scope, truthy, falsey);\n\t};\n};\n\nvar TextSection = function(){\n\tthis.values = [];\n};\n\nassign( TextSection.prototype, {\n\tadd: function(data){\n\t\tthis.values.push(data);\n\t},\n\tlast: function(){\n\t\treturn this.values[this.values.length - 1];\n\t},\n\tcompile: function(){\n\t\tvar values = this.values,\n\t\t\tlen = values.length;\n\n\t\tfor(var i = 0 ; i < len; i++) {\n\t\t\tvar value = this.values[i];\n\t\t\tif(typeof value === \"object\") {\n\t\t\t\tvalues[i] = passTruthyFalsey( value.process,\n\t\t\t\t    value.truthy && value.truthy.compile(),\n\t\t\t\t    value.falsey && value.falsey.compile());\n\t\t\t}\n\t\t}\n\n\t\treturn function(scope){\n\t\t\tvar txt = \"\",\n\t\t\t\tvalue;\n\t\t\tfor(var i = 0; i < len; i++){\n\t\t\t\tvalue = values[i];\n\t\t\t\ttxt += typeof value === \"string\" ? value : value.call(this, scope);\n\t\t\t}\n\t\t\treturn txt;\n\t\t};\n\t}\n});\n\nmodule.exports = TextSectionBuilder;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/text_section.js?");

/***/ }),

/***/ "../../node_modules/can-stache/src/truthy-observable.js":
/*!*****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/truthy-observable.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nmodule.exports = function(observable){\n    return new Observation(function truthyObservation(){\n        var val = canReflect.getValue(observable);\n\n        return !!val;\n    });\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/truthy-observable.js?");

/***/ }),

/***/ "../../node_modules/can-stache/src/utils.js":
/*!*****************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/utils.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Scope = __webpack_require__(/*! can-view-scope */ \"../../node_modules/can-view-scope/can-view-scope.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar observationReader = __webpack_require__(/*! can-stache-key */ \"../../node_modules/can-stache-key/can-stache-key.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar KeyObservable = __webpack_require__(/*! ./key-observable */ \"../../node_modules/can-stache/src/key-observable.js\");\n\n// this creates a noop that marks that a renderer was called\n// this is for situations where a helper function calls a renderer\n// that was not provided such as\n// {{#if false}} ... {{/if}}\n// with no {{else}}\nvar createNoOpRenderer = function (metadata) {\n\treturn function noop() {\n\t\tif (metadata) {\n\t\t\tmetadata.rendered = true;\n\t\t}\n\t};\n};\n\nmodule.exports = {\n\tlast: function(arr){\n\t\treturn arr !=null && arr[arr.length-1];\n\t},\n\t// A generic empty function\n\temptyHandler: function(){},\n\t// Converts a string like \"1\" into 1. \"null\" into null, etc.\n\t// This doesn't have to do full JSON, so removing eval would be good.\n\tjsonParse: function(str){\n\t\t// if it starts with a quote, assume a string.\n\t\tif(str[0] === \"'\") {\n\t\t\treturn str.substr(1, str.length -2);\n\t\t} else if(str === \"undefined\") {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\treturn JSON.parse(str);\n\t\t}\n\t},\n\tmixins: {\n\t\tlast: function(){\n\t\t\treturn this.stack[this.stack.length - 1];\n\t\t},\n\t\tadd: function(chars){\n\t\t\tthis.last().add(chars);\n\t\t},\n\t\tsubSectionDepth: function(){\n\t\t\treturn this.stack.length - 1;\n\t\t}\n\t},\n\t// Sets .fn and .inverse on a helperOptions object and makes sure\n\t// they can reference the current scope and options.\n\tcreateRenderers: function(helperOptions, scope, nodeList, truthyRenderer, falseyRenderer, isStringOnly){\n\t\thelperOptions.fn = truthyRenderer ? this.makeRendererConvertScopes(truthyRenderer, scope, nodeList, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);\n\t\thelperOptions.inverse = falseyRenderer ? this.makeRendererConvertScopes(falseyRenderer, scope, nodeList, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);\n\t\thelperOptions.isSection = !!(truthyRenderer || falseyRenderer);\n\t},\n\t// Returns a new renderer function that makes sure any data or helpers passed\n\t// to it are converted to a can.view.Scope and a can.view.Options.\n\tmakeRendererConvertScopes: function (renderer, parentScope, nodeList, observeObservables, metadata) {\n\t\tvar convertedRenderer = function (newScope, newOptions, parentNodeList) {\n\t\t\t// prevent binding on fn.\n\t\t\t// If a non-scope value is passed, add that to the parent scope.\n\t\t\tif (newScope !== undefined && !(newScope instanceof Scope)) {\n\t\t\t\tif (parentScope) {\n\t\t\t\t\tnewScope = parentScope.add(newScope);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewScope = new Scope(newScope || {});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (metadata) {\n\t\t\t\tmetadata.rendered = true;\n\t\t\t}\n\n\t\t\tvar result = renderer(newScope || parentScope, parentNodeList || nodeList );\n\t\t\treturn result;\n\t\t};\n\t\treturn observeObservables ? convertedRenderer :\n\t\t\tObservationRecorder.ignore(convertedRenderer);\n\t},\n\t// Calls the truthy subsection for each item in a list and returning them in a string.\n\tgetItemsStringContent: function(items, isObserveList, helperOptions){\n\t\tvar txt = \"\",\n\t\t\tlen = observationReader.get(items, 'length'),\n\t\t\tisObservable = canReflect.isObservableLike(items);\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar item = isObservable ? new KeyObservable(items, i) :items[i];\n\t\t\ttxt += helperOptions.fn(item);\n\t\t}\n\t\treturn txt;\n\t},\n\t// Calls the truthy subsection for each item in a list and returns them in a document Fragment.\n\tgetItemsFragContent: function(items, helperOptions, scope) {\n\t\tvar result = [],\n\t\t\tlen = observationReader.get(items, 'length'),\n\t\t\tisObservable = canReflect.isObservableLike(items),\n\t\t\thashExprs = helperOptions.exprData && helperOptions.exprData.hashExprs,\n\t\t\thashOptions;\n\n\t\t// Check if using hash\n\t\tif (canReflect.size(hashExprs) > 0) {\n\t\t\thashOptions = {};\n\t\t\tcanReflect.eachKey(hashExprs, function (exprs, key) {\n\t\t\t\thashOptions[exprs.key] = key;\n\t\t\t});\n\t\t}\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar aliases = {};\n\n\t\t\tvar item = isObservable ? new KeyObservable(items, i) :items[i];\n\n\t\t\tif (canReflect.size(hashOptions) > 0) {\n\t\t\t\tif (hashOptions.value) {\n\t\t\t\t\taliases[hashOptions.value] = item;\n\t\t\t\t}\n\t\t\t\tif (hashOptions.index) {\n\t\t\t\t\taliases[hashOptions.index] = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult.push(helperOptions.fn(\n\t\t\t\tscope\n\t\t\t\t.add(aliases, { notContext: true })\n\t\t\t\t.add({ index: i }, { special: true })\n\t\t\t\t.add(item))\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-stache/src/utils.js?");

/***/ }),

/***/ "../../node_modules/can-string-to-any/can-string-to-any.js":
/*!********************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-string-to-any/can-string-to-any.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function(str){\n\tswitch(str) {\n\t\tcase \"NaN\":\n\t\tcase \"Infinity\":\n\t\t\treturn +str;\n\t\tcase \"null\":\n\t\t\treturn null;\n\t\tcase \"undefined\":\n\t\t\treturn undefined;\n\t\tcase \"true\":\n\t\tcase \"false\":\n\t\t\treturn str === \"true\";\n\t\tdefault:\n\t\t\tvar val = +str;\n\t\t\tif(!isNaN(val)) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn str;\n\t\t\t}\n\t}\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-string-to-any/can-string-to-any.js?");

/***/ }),

/***/ "../../node_modules/can-string/can-string.js":
/*!******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-string/can-string.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ##string.js\n// _Miscellaneous string utility functions._\n// Several of the methods in this plugin use code adapted from Prototype\n// Prototype JavaScript framework, version 1.6.0.1.\n// © 2005-2007 Sam Stephenson\nvar strUndHash = /_|-/,\n\tstrColons = /\\=\\=/,\n\tstrWords = /([A-Z]+)([A-Z][a-z])/g,\n\tstrLowUp = /([a-z\\d])([A-Z])/g,\n\tstrDash = /([a-z\\d])([A-Z])/g,\n\tstrQuote = /\"/g,\n\tstrSingleQuote = /'/g,\n\tstrHyphenMatch = /-+(.)?/g,\n\tstrCamelMatch = /[a-z][A-Z]/g,\n\tconvertBadValues = function (content) {\n\t\t// Convert bad values into empty strings\n\t\tvar isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';\n\t\treturn '' + (isInvalid ? '' : content);\n\t};\n\nvar string = {\n\t/**\n\t * @function can-string.esc esc\n\t * @signature `string.esc(content)`\n\t * @param  {String} content a string\n\t * @return {String}         the string safely HTML-escaped\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * string.esc(\"<div>&nbsp;</div>\"); //-> \"&lt;div&gt;&amp;nbsp;&lt;/div&gt;\"\n\t * ```\n\t */\n\tesc: function (content) {\n\t\treturn convertBadValues(content)\n\t\t\t.replace(/&/g, '&amp;')\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t.replace(strQuote, '&#34;')\n\t\t\t.replace(strSingleQuote, '&#39;');\n\t},\n\t/**\n\t * @function can-string.capitalize capitalize\n\t * @signature `string.capitalize(s)`\n\t * @param  {String} s     the string to capitalize\n\t * @return {String}       the supplied string with the first character uppercased if it is a letter\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.capitalize(\"foo\")); // -> \"Foo\"\n\t * console.log(string.capitalize(\"123\")); // -> \"123\"\n\t * ```\n\t */\n\tcapitalize: function (s) {\n\t\t// Used to make newId.\n\t\treturn s.charAt(0)\n\t\t\t.toUpperCase() + s.slice(1);\n\t},\n\t/**\n\t * @function can-string.camelize camelize\n\t * @signature `string.camelize(s)`\n\t * @param  {String} str   the string to camelCase\n\t * @return {String}       the supplied string with hyphens removed and following letters capitalized.\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\n\t * console.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n\t * ```\n\t */\n\tcamelize: function (str) {\n\t\treturn convertBadValues(str)\n\t\t\t.replace(strHyphenMatch, function (match, chr) {\n\t\t\t\treturn chr ? chr.toUpperCase() : '';\n\t\t\t});\n\t},\n\t/**\n\t * @function can-string.hyphenate hyphenate\n\t * @signature `string.hyphenate(s)`\n\t * @param  {String} str   a string in camelCase\n\t * @return {String}       the supplied string with camelCase converted to hyphen-lowercase digraphs\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\n\t * console.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n\t * ```\n\t */\n\thyphenate: function (str) {\n\t\treturn convertBadValues(str)\n\t\t\t.replace(strCamelMatch, function (str) {\n\t\t\t\treturn str.charAt(0) + '-' + str.charAt(1)\n\t\t\t\t\t.toLowerCase();\n\t\t\t});\n\t},\n\t/**\n\t * @function can-string.underscore underscore\n\t * @signature `string.underscore(s)`\n\t * @param  {String} str   a string in camelCase\n\t * @return {String}       the supplied string with camelCase converted to underscore-lowercase digraphs\n\t *\n\t * ```js\n\t * var string = require(\"can-string\");\n\t *\n\t * console.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\n\t * console.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n\t * ```\n\t */\n\tunderscore: function (s) {\n\t\treturn s.replace(strColons, '/')\n\t\t\t.replace(strWords, '$1_$2')\n\t\t\t.replace(strLowUp, '$1_$2')\n\t\t\t.replace(strDash, '_')\n\t\t\t.toLowerCase();\n\t},\n\t/**\n\t * @property {RegExp} can-string.strUndHash strUndHash\n\t *\n\t * A regex which matches an underscore or hyphen character\n\t */\n\tundHash: strUndHash\n};\nmodule.exports = string;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-string/can-string.js?");

/***/ }),

/***/ "../../node_modules/can-symbol/can-symbol.js":
/*!******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-symbol/can-symbol.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\n\nvar CanSymbol;\nif(typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\") {\n\tCanSymbol = Symbol;\n} else {\n\n\tvar symbolNum = 0;\n\tCanSymbol = function CanSymbolPolyfill(description){\n\t\tvar symbolValue = \"@@symbol\"+(symbolNum++)+(description);\n\n\t\tvar symbol = {}; // make it object type\n\n\t\tObject.defineProperties(symbol, {\n\t\t\ttoString: {\n\t\t\t\tvalue: function(){\n\t\t\t\t\treturn symbolValue;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn symbol;\n\t};\n\n\tvar descriptionToSymbol = {};\n\tvar symbolToDescription = {};\n\n\t/**\n\t * @function can-symbol.for for\n\t * @parent  can-symbol/methods\n\t * @description  Get a symbol based on a known string identifier, or create it if it doesn't exist.\n\t *\n\t * @signature `canSymbol.for(String)`\n\t *\n\t * @param { String } description  The string value of the symbol\n\t * @return { CanSymbol } The globally unique and consistent symbol with the given string value.\n\t */\n\tCanSymbol.for = function(description){\n\t\tvar symbol = descriptionToSymbol[description];\n\t\tif(!symbol) {\n\t\t\tsymbol = descriptionToSymbol[description] = CanSymbol(description);\n\t\t\tsymbolToDescription[symbol] = description;\n\t\t}\n\t\treturn symbol;\n\t};\n\t/**\n\t * @function can-symbol.keyFor keyFor\n\t * @parent  can-symbol\n\t * @description  Get the description for a symbol.\n\t *\n\t * @signature `canSymbol.keyFor(CanSymbol)`\n\t *\n\t * @param { String } description  The string value of the symbol\n\t * @return { CanSymbol } The globally unique and consistent symbol with the given string value.\n\t */\n\tCanSymbol.keyFor = function(symbol) {\n\t\treturn symbolToDescription[symbol];\n\t};\n\t[\"hasInstance\",\"isConcatSpreadable\",\n\t\t\"iterator\",\"match\",\"prototype\",\"replace\",\"search\",\"species\",\"split\",\n\t\"toPrimitive\",\"toStringTag\",\"unscopables\"].forEach(function(name){\n\t\tCanSymbol[name] = CanSymbol(\"Symbol.\"+name);\n\t});\n}\n\n// Generate can. symbols.\n[\n\t// ======= Type detection ==========\n\t\"isMapLike\",\n\t\"isListLike\",\n\t\"isValueLike\",\n\t\"isFunctionLike\",\n\t// ======= Shape detection =========\n\t\"getOwnKeys\",\n\t\"getOwnKeyDescriptor\",\n\t\"proto\",\n\t// optional\n\t\"getOwnEnumerableKeys\",\n\t\"hasOwnKey\",\n\t\"hasKey\",\n\t\"size\",\n\t\"getName\",\n\t\"getIdentity\",\n\n\t// shape manipulation\n\t\"assignDeep\",\n\t\"updateDeep\",\n\n\t// ======= GET / SET\n\t\"getValue\",\n\t\"setValue\",\n\t\"getKeyValue\",\n\t\"setKeyValue\",\n\t\"updateValues\",\n\t\"addValue\",\n\t\"removeValues\",\n\t// ======= Call =========\n\t\"apply\",\n\t\"new\",\n\t// ======= Observe =========\n\t\"onValue\",\n\t\"offValue\",\n\t\"onKeyValue\",\n\t\"offKeyValue\",\n\t\"getKeyDependencies\",\n\t\"getValueDependencies\",\n\t\"keyHasDependencies\",\n\t\"valueHasDependencies\",\n\t\"onKeys\",\n\t\"onKeysAdded\",\n\t\"onKeysRemoved\",\n\t\"onPatches\"\n\t].forEach(function(name){\n\tCanSymbol.for(\"can.\"+name);\n});\n\nmodule.exports = namespace.Symbol = CanSymbol;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-symbol/can-symbol.js?");

/***/ }),

/***/ "../../node_modules/can-view-callbacks/can-view-callbacks.js":
/*!**********************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-callbacks/can-view-callbacks.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\n\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar getGlobal = __webpack_require__(/*! can-globals/global/global */ \"../../node_modules/can-globals/global/global.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate/node */ \"../../node_modules/can-dom-mutate/node.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar nodeLists = __webpack_require__(/*! can-view-nodelist */ \"../../node_modules/can-view-nodelist/can-view-nodelist.js\");\nvar makeFrag = __webpack_require__(/*! can-fragment */ \"../../node_modules/can-fragment/can-fragment.js\");\nvar globals = __webpack_require__(/*! can-globals */ \"../../node_modules/can-globals/can-globals.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nvar callbackMapSymbol = canSymbol.for('can.callbackMap');\n\n//!steal-remove-start\nif (true) {\n\tvar requestedAttributes = {};\n}\n//!steal-remove-end\n\nvar tags = {};\n\n// WeakSet containing elements that have been rendered already\n// and therefore do not need to be rendered again\n\nvar automountEnabled = function(){\n\treturn globals.getKeyValue(\"document\").documentElement.getAttribute(\"data-can-automount\") !== \"false\";\n};\n\nvar renderedElements = new WeakMap();\n\nvar renderNodeAndChildren = function(node) {\n\tvar tagName = node.tagName && node.tagName.toLowerCase();\n\tvar tagHandler = tags[tagName];\n\tvar children;\n\n\t// skip elements that already have a viewmodel or elements whose tags don't match a registered tag\n\t// or elements that have already been rendered\n\tif (tagHandler && !renderedElements.has(node)) {\n\t\ttagHandler(node, {});\n\t}\n\n\tif (node.getElementsByTagName) {\n\t\tchildren = node.getElementsByTagName(\"*\");\n\t\tfor (var k=0, child; (child = children[k]) !== undefined; k++) {\n\t\t\trenderNodeAndChildren(child);\n\t\t}\n\t}\n};\n\nvar mutationObserverEnabled = false;\nvar globalMutationObserver;\nvar enableMutationObserver = function() {\n\tif (mutationObserverEnabled) {\n\t\treturn;\n\t}\n\n\tvar mutationHandler = function(mutationsList) {\n\t\tvar addedNodes;\n\n\t\tfor (var i=0, mutation; (mutation = mutationsList[i]) !== undefined; i++) {\n\t\t\tif (mutation.type === \"childList\") {\n\t\t\t\taddedNodes = mutation.addedNodes;\n\n\t\t\t\tfor (var j=0, addedNode; (addedNode = addedNodes[j]) !== undefined; j++) {\n\t\t\t\t\t// skip elements that have already been rendered\n\t\t\t\t\tif (!renderedElements.has(addedNode)) {\n\t\t\t\t\t\trenderNodeAndChildren(addedNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar MutationObserver = globals.getKeyValue(\"MutationObserver\");\n\tif(MutationObserver) {\n\t\tglobalMutationObserver = new MutationObserver(mutationHandler);\n\t\tglobalMutationObserver.observe(getGlobal().document.documentElement, {\n\t\t\tchildList: true,\n\t\t\tsubtree: true\n\t\t});\n\n\t\tmutationObserverEnabled = true;\n\t}\n};\n\nvar renderTagsInDocument = function(tagName) {\n\tvar nodes = getGlobal().document.getElementsByTagName(tagName);\n\n\tfor (var i=0, node; (node = nodes[i]) !== undefined; i++) {\n\t\trenderNodeAndChildren(node);\n\t}\n};\n\nvar attr = function (attributeName, attrHandler) {\n\tif(attrHandler) {\n\t\tif (typeof attributeName === \"string\") {\n\t\t\tattributes[attributeName] = attrHandler;\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tif(requestedAttributes[attributeName]) {\n\t\t\t\t\tdev.warn(\"can-view-callbacks: \" + attributeName+ \" custom attribute behavior requested before it was defined.  Make sure \"+attributeName+\" is defined before it is needed.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t} else {\n\t\t\tregExpAttributes.push({\n\t\t\t\tmatch: attributeName,\n\t\t\t\thandler: attrHandler\n\t\t\t});\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tObject.keys(requestedAttributes).forEach(function(requested){\n\t\t\t\t\tif(attributeName.test(requested)) {\n\t\t\t\t\t\tdev.warn(\"can-view-callbacks: \" + requested+ \" custom attribute behavior requested before it was defined.  Make sure \"+requested+\" is defined before it is needed.\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\t} else {\n\t\tvar cb = attributes[attributeName];\n\t\tif( !cb ) {\n\n\t\t\tfor( var i = 0, len = regExpAttributes.length; i < len; i++) {\n\t\t\t\tvar attrMatcher = regExpAttributes[i];\n\t\t\t\tif(attrMatcher.match.test(attributeName)) {\n\t\t\t\t\treturn attrMatcher.handler;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\trequestedAttributes[attributeName] = true;\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn cb;\n\t}\n};\n\nvar attrs = function(attrMap) {\n\tvar map = canReflect.getKeyValue(attrMap, callbackMapSymbol) || attrMap;\n\n\t// Only add bindings once.\n\tif(attrMaps.has(map)) {\n\t\treturn;\n\t} else {\n\t\t// Would prefer to use WeakSet but IE11 doesn't support it.\n\t\tattrMaps.set(map, true);\n\t}\n\n\tcanReflect.eachKey(map, function(callback, exp){\n\t\tattr(exp, callback);\n\t});\n};\n\nvar attributes = {},\n\tregExpAttributes = [],\n\tattrMaps = new WeakMap(),\n\tautomaticCustomElementCharacters = /[-\\:]/;\nvar defaultCallback = function () {};\n\nvar tag = function (tagName, tagHandler) {\n\tif(tagHandler) {\n\t\tvar GLOBAL = getGlobal();\n\n\t\tvar validCustomElementName = automaticCustomElementCharacters.test(tagName),\n\t\t\ttagExists = typeof tags[tagName.toLowerCase()] !== 'undefined',\n\t\t\tcustomElementExists;\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (tagExists) {\n\t\t\t\tdev.warn(\"Custom tag: \" + tagName.toLowerCase() + \" is already defined\");\n\t\t\t}\n\n\t\t\tif (!validCustomElementName && tagName !== \"content\") {\n\t\t\t\tdev.warn(\"Custom tag: \" + tagName.toLowerCase() + \" hyphen missed\");\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// if we have html5shiv ... re-generate\n\t\tif (GLOBAL.html5) {\n\t\t\tGLOBAL.html5.elements += \" \" + tagName;\n\t\t\tGLOBAL.html5.shivDocument();\n\t\t}\n\n\t\ttags[tagName.toLowerCase()] = tagHandler;\n\n\t\tif(automountEnabled()) {\n\t\t\tvar customElements = globals.getKeyValue(\"customElements\");\n\n\t\t\t// automatically render elements that have tagHandlers\n\t\t\t// If browser supports customElements, register the tag as a custom element\n\t\t\tif (customElements) {\n\t\t\t\tcustomElementExists = customElements.get(tagName.toLowerCase());\n\n\t\t\t\tif (validCustomElementName && !customElementExists) {\n\t\t\t\t\tvar CustomElement = function() {\n\t\t\t\t\t\treturn Reflect.construct(HTMLElement, [], CustomElement);\n\t\t\t\t\t};\n\n\t\t\t\t\tCustomElement.prototype = Object.create(HTMLElement.prototype);\n\n\t\t\t\t\tCustomElement.prototype.connectedCallback = function() {\n\t\t\t\t\t\t// don't re-render an element that has been rendered already\n\t\t\t\t\t\tif (!renderedElements.has(this)) {\n\t\t\t\t\t\t\ttags[tagName.toLowerCase()](this, {});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tcustomElements.define(tagName, CustomElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If browser doesn't support customElements, set up MutationObserver for\n\t\t\t// rendering elements when they are inserted in the page\n\t\t\t// and rendering elements that are already in the page\n\t\t\telse {\n\t\t\t\tenableMutationObserver();\n\t\t\t\trenderTagsInDocument(tagName);\n\t\t\t}\n\t\t} else if(mutationObserverEnabled) {\n\t\t\tglobalMutationObserver.disconnect();\n\t\t}\n\t} else {\n\t\tvar cb;\n\n\t\t// if null is passed as tagHandler, remove tag\n\t\tif (tagHandler === null) {\n\t\t\tdelete tags[tagName.toLowerCase()];\n\t\t} else {\n\t\t\tcb = tags[tagName.toLowerCase()];\n\t\t}\n\n\t\tif(!cb && automaticCustomElementCharacters.test(tagName)) {\n\t\t\t// empty callback for things that look like special tags\n\t\t\tcb = defaultCallback;\n\t\t}\n\t\treturn cb;\n\t}\n\n};\n\nvar callbacks = {\n\t_tags: tags,\n\t_attributes: attributes,\n\t_regExpAttributes: regExpAttributes,\n\tdefaultCallback: defaultCallback,\n\ttag: tag,\n\tattr: attr,\n\tattrs: attrs,\n\t// handles calling back a tag callback\n\ttagHandler: function(el, tagName, tagData){\n\t\tvar scope = tagData.scope,\n\t\t\thelperTagCallback = scope && scope.templateContext.tags.get(tagName),\n\t\t\ttagCallback = helperTagCallback || tags[tagName],\n\t\t\tres;\n\n\t\t// If this was an element like <foo-bar> that doesn't have a component, just render its content\n\t\tif(tagCallback) {\n\t\t\tres = ObservationRecorder.ignore(tagCallback)(el, tagData);\n\n\t\t\t// add the element to the Set of elements that have had their handlers called\n\t\t\t// this will prevent the handler from being called again when the element is inserted\n\t\t\trenderedElements.set(el, true);\n\t\t} else {\n\t\t\tres = scope;\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (!tagCallback) {\n\t\t\t\tvar GLOBAL = getGlobal();\n\t\t\t\tvar ceConstructor = GLOBAL.document.createElement(tagName).constructor;\n\t\t\t\t// If not registered as a custom element, the browser will use default constructors\n\t\t\t\tif (ceConstructor === GLOBAL.HTMLElement || ceConstructor === GLOBAL.HTMLUnknownElement) {\n\t\t\t\t\tdev.warn('can-view-callbacks: No custom element found for ' + tagName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// If the tagCallback gave us something to render with, and there is content within that element\n\t\t// render it!\n\t\tif (res && tagData.subtemplate) {\n\t\t\tif (scope !== res) {\n\t\t\t\tscope = scope.add(res);\n\t\t\t}\n\n\t\t\tvar nodeList = nodeLists.register([], undefined, tagData.parentNodeList || true, false);\n\t\t\tnodeList.expression = \"<\" + el.tagName + \">\";\n\n\t\t\tvar result = tagData.subtemplate(scope, tagData.options, nodeList);\n\t\t\tvar frag = typeof result === \"string\" ? makeFrag(result) : result;\n\t\t\tdomMutate.appendChild.call(el, frag);\n\t\t}\n\t}\n};\n\nnamespace.view = namespace.view || {};\n\nif (namespace.view.callbacks) {\n\tthrow new Error(\"You can't have two versions of can-view-callbacks, check your dependencies\");\n} else {\n\tmodule.exports = namespace.view.callbacks = callbacks;\n}\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-callbacks/can-view-callbacks.js?");

/***/ }),

/***/ "../../node_modules/can-view-import/can-view-import.js":
/*!****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-import/can-view-import.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\nvar canData = __webpack_require__(/*! can-dom-data-state */ \"../../node_modules/can-dom-data-state/can-dom-data-state.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar DOCUMENT = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\nvar getChildNodes = __webpack_require__(/*! can-child-nodes */ \"../../node_modules/can-child-nodes/can-child-nodes.js\");\nvar importer = __webpack_require__(/*! can-import-module */ \"../../node_modules/can-import-module/can-import-module.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"../../node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"../../node_modules/can-dom-mutate/node.js\");\nvar nodeLists = __webpack_require__(/*! can-view-nodelist */ \"../../node_modules/can-view-nodelist/can-view-nodelist.js\");\nvar viewCallbacks = __webpack_require__(/*! can-view-callbacks */ \"../../node_modules/can-view-callbacks/can-view-callbacks.js\");\nvar tag = viewCallbacks.tag;\nvar canLog = __webpack_require__(/*! can-log/ */ \"../../node_modules/can-log/dist/cjs/can-log.js\");\nvar dev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\n\nfunction setViewModel (element, viewModel) {\n\telement[canSymbol.for('can.viewModel')] = viewModel;\n}\n\nfunction processImport(el, tagData) {\n\n\tvar moduleName = el.getAttribute(\"from\");\n\t// If the module is part of the helpers pass that into can.import\n\t// as the parentName\n\tvar templateModule = tagData.scope.get(\"scope.helpers.module\");\n\tvar parentName = templateModule ? templateModule.id : undefined;\n\n\tif(!moduleName) {\n\t\treturn Promise.reject(\"No module name provided\");\n\t}\n\n\tvar importPromise = importer(moduleName, parentName);\n\timportPromise.catch(function(err) {\n\t\tcanLog.error(err);\n\t});\n\n\t// Set the viewModel to the promise\n\tsetViewModel(el, importPromise);\n\tcanData.set.call(el, \"scope\", importPromise);\n\n\t// Set the scope\n\tvar scope = tagData.scope.add(importPromise, { notContext: true });\n\n\t// If there is a can-tag present we will hand-off rendering to that tag.\n\tvar handOffTag = el.getAttribute(\"can-tag\");\n\n\tif(handOffTag) {\n\t\tvar callback = tag(handOffTag);\n\n\t\t// Verify hand off tag has been registered. Callback can be undefined or noop.\n\t\tif (!callback || callback === viewCallbacks.defaultCallback) {\n\t\t\t//!steal-remove-start\n\t\t\tdev.error(new Error(\"The tag '\" + handOffTag + \"' has not been properly registered.\"));\n\t\t\t//!steal-remove-end\n\t\t} else {\n\t\t\tcanData.set.call(el, \"preventDataBindings\", true);\n\t\t\tcallback(el, assign(tagData, {\n\t\t\t\tscope: scope\n\t\t\t}));\n\t\t\tcanData.set.call(el, \"preventDataBindings\", false);\n\n\t\t\tsetViewModel(el, importPromise);\n\t\t\tcanData.set.call(el, \"scope\", importPromise);\n\t\t}\n\t}\n\t// Render the subtemplate and register nodeLists\n\telse {\n\t\tvar nodeList = nodeLists.register([], undefined, tagData.parentNodeList || true, false);\n\t\tnodeList.expression = \"<\" + this.tagName + \">\";\n\n\t\tvar frag = tagData.subtemplate ?\n\t\t\ttagData.subtemplate(scope, tagData.options, nodeList) :\n\t\t\tDOCUMENT().createDocumentFragment();\n\n\t\tvar removalDisposal = domMutate.onNodeRemoval(el, function () {\n\t\t\tif (!el.ownerDocument.contains(el)) {\n\t\t\t\tremovalDisposal();\n\t\t\t\tnodeLists.unregister(nodeList);\n\t\t\t}\n\t\t});\n\n\t\tdomMutateNode.appendChild.call(el, frag);\n\t\tnodeLists.update(nodeList, getChildNodes(el));\n\t}\n}\n\n[\"can-import\", \"can-dynamic-import\"].forEach(function(tagName) {\n\ttag(tagName, processImport.bind({ tagName: tagName }));\n});\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-import/can-view-import.js?");

/***/ }),

/***/ "../../node_modules/can-view-live/can-view-live.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/can-view-live.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar live = __webpack_require__(/*! ./lib/core */ \"../../node_modules/can-view-live/lib/core.js\");\n__webpack_require__(/*! ./lib/attr */ \"../../node_modules/can-view-live/lib/attr.js\");\n__webpack_require__(/*! ./lib/attrs */ \"../../node_modules/can-view-live/lib/attrs.js\");\n__webpack_require__(/*! ./lib/html */ \"../../node_modules/can-view-live/lib/html.js\");\n__webpack_require__(/*! ./lib/list */ \"../../node_modules/can-view-live/lib/list.js\");\n__webpack_require__(/*! ./lib/text */ \"../../node_modules/can-view-live/lib/text.js\");\n\n\nmodule.exports = live;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/can-view-live.js?");

/***/ }),

/***/ "../../node_modules/can-view-live/lib/attr.js":
/*!*******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/attr.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar live = __webpack_require__(/*! ./core */ \"../../node_modules/can-view-live/lib/core.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar attr = __webpack_require__(/*! can-attribute-observable/behaviors */ \"../../node_modules/can-attribute-observable/behaviors.js\");\n\n/**\n * @function can-view-live.attr attr\n * @parent can-view-live\n *\n * @signature `live.attr(el, attributeName, observable)`\n *\n * Keep an attribute live to a [can-reflect]-ed observable.\n *\n * ```js\n * var div = document.createElement('div');\n * var value = new SimpleObservable(\"foo bar\");\n * live.attr(div,\"class\", value);\n * ```\n *\n * @param {HTMLElement} el The element whos attribute will be kept live.\n * @param {String} attributeName The attribute name.\n * @param {Object} observable An observable value.\n *\n * @body\n *\n * ## How it works\n *\n * This listens for the changes in the observable and uses those changes to\n * set the specified attribute.\n */\nlive.attr = function(el, attributeName, compute) {\n\tfunction liveUpdateAttr(newVal) {\n\t\tqueues.domUIQueue.enqueue(attr.set, attr, [el, attributeName, newVal]);\n\t}\n\t//!steal-remove-start\n\tif(true) {\n\t\t// register that the handler changes the parent element\n\t\tcanReflect.assignSymbols(liveUpdateAttr, {\n\t\t\t\"can.getChangesDependencyRecord\": function() {\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: new Set( [ el ] )\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(liveUpdateAttr, \"name\", {\n\t\t\tvalue: \"live.attr update::\"+canReflect.getName(compute),\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\t// Bind a single attribute on an element to a compute\n\tlive.listen(el, compute, liveUpdateAttr);\n\n\t// do initial set of attribute as well\n\tattr.set(el, attributeName, canReflect.getValue(compute));\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/attr.js?");

/***/ }),

/***/ "../../node_modules/can-view-live/lib/attrs.js":
/*!********************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/attrs.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// This provides live binding for stache attributes.\nvar live = __webpack_require__(/*! ./core */ \"../../node_modules/can-view-live/lib/core.js\");\nvar viewCallbacks = __webpack_require__(/*! can-view-callbacks */ \"../../node_modules/can-view-callbacks/can-view-callbacks.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"../../node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"../../node_modules/can-dom-mutate/node.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"../../node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\n\nlive.attrs = function(el, compute, scope, options) {\n\n\tif (!canReflect.isObservableLike(compute)) {\n\t\t// Non-live case (`compute` was not a compute):\n\t\t//  set all attributes on the element and don't\n\t\t//  worry about setting up live binding since there\n\t\t//  is not compute to bind on.\n\t\tvar attrs = live.getAttributeParts(compute);\n\t\tfor (var name in attrs) {\n\t\t\tdomMutateNode.setAttribute.call(el, name, attrs[name]);\n\t\t}\n\t\treturn;\n\t}\n\n\t// last set of attributes\n\tvar oldAttrs = {};\n\n\t// set up a callback for handling changes when the compute\n\t// changes\n\tfunction liveAttrsUpdate(newVal) {\n\t\tvar newAttrs = live.getAttributeParts(newVal),\n\t\t\tname;\n\t\tfor (name in newAttrs) {\n\t\t\tvar newValue = newAttrs[name],\n\t\t\t\t// `oldAttrs` was set on the last run of setAttrs in this context\n\t\t\t\t//  (for this element and compute)\n\t\t\t\toldValue = oldAttrs[name];\n\t\t\t// Only fire a callback\n\t\t\t//  if the value of the attribute has changed\n\t\t\tif (newValue !== oldValue) {\n\t\t\t\t// set on DOM attributes (dispatches an \"attributes\" event as well)\n\t\t\t\tdomMutateNode.setAttribute.call(el, name, newValue);\n\t\t\t\t// get registered callback for attribute name and fire\n\t\t\t\tvar callback = viewCallbacks.attr(name);\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(el, {\n\t\t\t\t\t\tattributeName: name,\n\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\toptions: options\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// remove key found in new attrs from old attrs\n\t\t\tdelete oldAttrs[name];\n\t\t}\n\t\t// any attrs left at this point are not set on the element now,\n\t\t// so remove them.\n\t\tfor (name in oldAttrs) {\n\t\t\tdomMutateNode.removeAttribute.call(el, name);\n\t\t}\n\t\toldAttrs = newAttrs;\n\t}\n\n\t//!steal-remove-start\n\tif(true) {\n\t\t// register that the handler changes the parent element\n\t\tcanReflect.assignSymbols(liveAttrsUpdate, {\n\t\t\t\"can.getChangesDependencyRecord\": function() {\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: new Set( [ el ] )\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\t\n\t\tObject.defineProperty(liveAttrsUpdate, \"name\", {\n\t\t\tvalue: \"live.attrs update::\"+canReflect.getName(compute),\n\t\t});\n\t\tcanReflectDeps.addMutatedBy(el, compute);\n\t}\n\t//!steal-remove-end\n\n\t// set attributes on any change to the compute\n\tcanReflect.onValue(compute, liveAttrsUpdate,\"domUI\");\n\n\tvar removalDisposal;\n\tvar teardownHandler = function() {\n\t\tcanReflect.offValue(compute, liveAttrsUpdate,\"domUI\");\n\t\tif (removalDisposal) {\n\t\t\tremovalDisposal();\n\t\t\tremovalDisposal = undefined;\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tcanReflectDeps.deleteMutatedBy(el, compute);\n\t\t}\n\t\t//!steal-remove-end\n\t};\n\t// unbind on element removal\n\tremovalDisposal = domMutate.onNodeRemoval(el, function () {\n\t\tif (!el.ownerDocument.contains(el)) {\n\t\t\tteardownHandler();\n\t\t}\n\t});\n\n\t// set up a current attribute set and assign to oldAttrs\n\tliveAttrsUpdate(canReflect.getValue(compute));\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/attrs.js?");

/***/ }),

/***/ "../../node_modules/can-view-live/lib/core.js":
/*!*******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/core.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar parser = __webpack_require__(/*! can-view-parser */ \"../../node_modules/can-view-parser/can-view-parser.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate */ \"../../node_modules/can-dom-mutate/can-dom-mutate.js\");\nvar nodeLists = __webpack_require__(/*! can-view-nodelist */ \"../../node_modules/can-view-nodelist/can-view-nodelist.js\");\nvar makeFrag = __webpack_require__(/*! can-fragment */ \"../../node_modules/can-fragment/can-fragment.js\");\nvar childNodes = __webpack_require__(/*! can-child-nodes */ \"../../node_modules/can-child-nodes/can-child-nodes.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"../../node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\n\n/**\n * @module {{}} can-view-live can-view-live\n * @parent can-views\n * @collection can-infrastructure\n * @package ../package.json\n *\n * Setup live-binding between the DOM and a compute manually.\n *\n * @option {Object} An object with the live-binding methods:\n * [can-view-live.html], [can-view-live.list], [can-view-live.text], and\n * [can-view-live.attr].\n *\n * @release 2.0.4\n *\n * @body\n *\n * ## Use\n *\n *  [can-view-live] is an object with utility methods for setting up\n *  live-binding in relation to different parts of the DOM and DOM elements.  For\n *  example, to make an `<h2>`'s text stay live with\n *  a compute:\n *\n *  ```js\n *  var live = require(\"can-view-live\");\n *  var text = canCompute(\"Hello World\");\n *  var textNode = $(\"h2\").text(\" \")[0].childNodes[0];\n *  live.text(textNode, text);\n *  ```\n *\n */\nvar live = {\n\tsetup: function(el, bind, unbind) {\n\t\t// #### setup\n\t\t// Setup a live listener on an element that binds now,\n\t\t//  but unbinds when an element is no longer in the DOM\n\t\tvar tornDown = false,\n\t\t\tremovalDisposal,\n\t\t\tdata,\n\t\t\tteardown = function() {\n\t\t\t\t// Removing an element can call teardown which\n\t\t\t\t// unregister the nodeList which calls teardown\n\t\t\t\tif (!tornDown) {\n\t\t\t\t\ttornDown = true;\n\t\t\t\t\tunbind(data);\n\t\t\t\t\tif (removalDisposal) {\n\t\t\t\t\t\tremovalDisposal();\n\t\t\t\t\t\tremovalDisposal = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t};\n\t\tdata = {\n\t\t\tteardownCheck: function(parent) {\n\t\t\t\treturn parent ? false : teardown();\n\t\t\t}\n\t\t};\n\t\tremovalDisposal = domMutate.onNodeRemoval(el, function () {\n\t\t\tif (!el.ownerDocument.contains(el)) {\n\t\t\t\tteardown();\n\t\t\t}\n\t\t});\n\t\tbind(data);\n\t\treturn data;\n\t},\n\t// #### listen\n\t// Calls setup, but presets bind and unbind to\n\t// operate on a compute\n\tlisten: function(el, compute, change, queueName) {\n\t\treturn live.setup(\n\t\t\tel,\n\t\t\tfunction bind() {\n\t\t\t\t// listen to notify, so on a change, this can\n\t\t\t\t// teardown all children quickly.\n\t\t\t\tcanReflect.onValue(compute, change, queueName || \"notify\");\n\t\t\t\t//compute.computeInstance.addEventListener('change', change);\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tcanReflectDeps.addMutatedBy(el, compute);\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t},\n\t\t\tfunction unbind(data) {\n\t\t\t\tcanReflect.offValue(compute, change, queueName || \"notify\");\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(true) {\n\t\t\t\t\tcanReflectDeps.deleteMutatedBy(el, compute);\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\t//compute.computeInstance.removeEventListener('change', change);\n\t\t\t\tif (data.nodeList) {\n\t\t\t\t\tnodeLists.unregister(data.nodeList);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t},\n\t// #### getAttributeParts\n\t// Breaks up a string like foo='bar' into an object of {\"foo\": \"bar\"} pairs\n\t// See can-view-parser for more about attrStart/attrEnd/attrValue\n\tgetAttributeParts: function(newVal) {\n\t\tvar attrs = {},\n\t\t\tattr;\n\t\tparser.parseAttrs(newVal, {\n\t\t\tattrStart: function(name) {\n\t\t\t\tattrs[name] = \"\";\n\t\t\t\tattr = name;\n\t\t\t},\n\t\t\tattrValue: function(value) {\n\t\t\t\tattrs[attr] += value;\n\t\t\t},\n\t\t\tattrEnd: function() {}\n\t\t});\n\t\treturn attrs;\n\t},\n\t// #### isNode\n\t// Checks a possible node object for the nodeType property\n\tisNode: function(obj) {\n\t\treturn obj && obj.nodeType;\n\t},\n\t// #### addTextNodeIfNoChildren\n\t// Append an empty text node to a parent with no children;\n\t//  do nothing if the parent already has children.\n\taddTextNodeIfNoChildren: function(frag) {\n\t\tif (!frag.firstChild) {\n\t\t\tfrag.appendChild(frag.ownerDocument.createTextNode(\"\"));\n\t\t}\n\t},\n\n\n\t/**\n\t * @function can.view.live.replace\n\t * @parent can.view.live\n\t * @release 2.0.4\n\t * @hide\n\t *\n\t * Replaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\n\t * correct.\n\t *\n\t * @param {Array.<HTMLElement>} nodes An array of elements.  There should typically be one element.\n\t * @param {String|HTMLElement|DocumentFragment} val The content that should replace\n\t * `nodes`.  If a string is passed, it will be [can.view.hookup hookedup].\n\t *\n\t * @param {function} [teardown] A callback if these elements are torn down.\n\t */\n\treplace: function(nodes, val, teardown) {\n\t\t// #### replace\n\t\t// Replaces one element with some content while keeping nodeLists data\n\t\t// correct.\n\t\t//\n\t\t// Take a copy of old nodeList\n\t\tvar oldNodes = nodes.slice(0),\n\t\t\tfrag = makeFrag(val);\n\t\t// Register a teardown callback\n\t\tnodeLists.register(nodes, teardown);\n\t\t// Mark each node as belonging to the node list.\n\t\tnodeLists.update(nodes, childNodes(frag));\n\t\t// Replace old nodes with new on the DOM\n\t\tnodeLists.replace(oldNodes, frag);\n\t\treturn nodes;\n\t},\n\t// #### getParentNode\n\t// Return default parent if el is a fragment, el's parent otherwise\n\tgetParentNode: function(el, defaultParentNode) {\n\t\treturn defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;\n\t},\n\t// #### makeString\n\t// any -> string converter (including nullish)\n\tmakeString: function(txt) {\n\t\treturn txt == null ? \"\" : \"\" + txt;\n\t}\n};\n\nmodule.exports = live;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/core.js?");

/***/ }),

/***/ "../../node_modules/can-view-live/lib/html.js":
/*!*******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/html.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar live = __webpack_require__(/*! ./core */ \"../../node_modules/can-view-live/lib/core.js\");\nvar nodeLists = __webpack_require__(/*! can-view-nodelist */ \"../../node_modules/can-view-nodelist/can-view-nodelist.js\");\nvar makeFrag = __webpack_require__(/*! can-fragment */ \"../../node_modules/can-fragment/can-fragment.js\");\nvar childNodes = __webpack_require__(/*! can-child-nodes */ \"../../node_modules/can-child-nodes/can-child-nodes.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar queues = __webpack_require__(/*! can-queues */ \"../../node_modules/can-queues/can-queues.js\");\nvar viewInsertSymbol = canSymbol.for(\"can.viewInsert\");\n\n\nfunction updateNodeList(oldNodes, nodes, frag, nodeListUpdatedByFn) {\n\tif(nodes.isUnregistered !== true) {\n\t\tif(!nodeListUpdatedByFn) {\n\t\t\tnodeLists.update(nodes, childNodes(frag), oldNodes);\n\t\t}\n\t\tnodeLists.replace(oldNodes, frag);\n\t}\n}\n\n/**\n * @function can-view-live.html html\n * @parent can-view-live\n * @release 2.0.4\n *\n * Live binds a compute's value to a collection of elements.\n *\n * @signature `live.html(el, compute, [parentNode])`\n *\n * `live.html` is used to setup incremental live-binding on a block of html.\n *\n * ```js\n * // a compute that changes its list\n * var greeting = compute(function(){\n *   return \"Welcome <i>\"+me.attr(\"name\")+\"</i>\"\n * });\n *\n * var placeholder = document.createTextNode(\" \");\n * $(\"#greeting\").append(placeholder);\n *\n * live.html(placeholder, greeting);\n * ```\n *\n * @param {HTMLElement} el An html element to replace with the live-section.\n *\n * @param {can.compute} compute A [can.compute] whose value is HTML.\n *\n * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is\n * a documentFragment.\n *\n *\n */\nlive.html = function(el, compute, parentNode, nodeListOrOptions) {\n\tvar data;\n\tvar makeAndPut;\n\tvar nodeList;\n\tvar nodes;\n\tvar options;\n\n\t// nodeListOrOptions can either be a NodeList or an object with a nodeList property\n\tif (nodeListOrOptions !== undefined) {\n\t\tif (Array.isArray(nodeListOrOptions)) {\n\t\t\tnodeList = nodeListOrOptions;\n\t\t} else {\n\t\t\tnodeList = nodeListOrOptions.nodeList;\n\t\t\toptions = nodeListOrOptions;\n\t\t}\n\t}\n\n\tvar meta = {reasonLog: \"live.html replace::\"+canReflect.getName(compute)};\n\t// prefer to manipulate el's actual parent over the supplied parent\n\tparentNode = live.getParentNode(el, parentNode);\n\n\tfunction liveHTMLUpdateHTML(newVal) {\n\t\t// the attachment point for the nodelist\n\t\tvar attached = nodeLists.first(nodes).parentNode;\n\t\t// update the nodes in the DOM with the new rendered value\n\t\tif (attached) {\n\t\t\tmakeAndPut(newVal, true);\n\t\t}\n\t\tvar pn = nodeLists.first(nodes).parentNode;\n\t\tdata.teardownCheck(pn);\n\t}\n\n\n\t//!steal-remove-start\n\tif(true) {\n\t\t// register that the handler changes the parent element\n\t\tcanReflect.assignSymbols(liveHTMLUpdateHTML, {\n\t\t\t\"can.getChangesDependencyRecord\": function() {\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: new Set( [ parentNode ] )\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(liveHTMLUpdateHTML, \"name\", {\n\t\t\tvalue: \"live.html update::\"+canReflect.getName(compute),\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\n\tdata = live.listen(parentNode, compute, liveHTMLUpdateHTML);\n\n\t// Nodes registered to the live operation, either a list of nodes or a single element\n\tnodes = nodeList || [el];\n\tmakeAndPut = function(val, useQueue) {\n\t\t// ##### makeandput\n\t\t// Receives the compute output (must be some DOM representation, a function,\n\t\t// or an object with the can.viewInsert symbol)\n\n\t\t// If val has the can.viewInsert symbol, call it and get something usable for val back\n\t\tif (val && typeof val[viewInsertSymbol] === \"function\") {\n\t\t\tval = val[viewInsertSymbol](options);\n\t\t}\n\n\t\tvar isFunction = typeof val === \"function\";\n\n\t\t// translate val into a document fragment if it's DOM-like\n\t\tvar frag = makeFrag(isFunction ? \"\" : val);\n\n\t\t// Add a placeholder textNode if necessary.\n\t\tlive.addTextNodeIfNoChildren(frag);\n\n\t\t// Mark each node as belonging to the node list.\n\n\t\tvar oldNodes;\n\t\t// DOM replace old nodes with new frag (which might contain some old nodes)\n\t\tif(useQueue === true) {\n\t\t\t// unregister all children immediately\n\t\t\toldNodes = nodeLists.unregisterChildren(nodes, true);\n\n\t\t\tvar nodeListUpdatedByFn = false;\n\t\t\t// allow\n\t\t\tif (isFunction) {\n\t\t\t\tval(frag.firstChild);\n\t\t\t\t// see if nodes has already been updated\n\t\t\t\tnodeListUpdatedByFn = nodeLists.first(nodes) === frag.firstChild;\n\t\t\t}\n\t\t\tqueues.domUIQueue.enqueue(updateNodeList, null, [oldNodes, nodes, frag, nodeListUpdatedByFn], meta);\n\t\t} else {\n\t\t\t// this is initialization, update right away.\n\t\t\toldNodes = nodeLists.update(nodes, childNodes(frag));\n\t\t\tif (isFunction) {\n\t\t\t\tval(frag.firstChild);\n\t\t\t}\n\t\t\tnodeLists.replace(oldNodes, frag);\n\t\t}\n\n\t};\n\n\tdata.nodeList = nodes;\n\n\t// register the span so nodeLists knows the parentNodeList\n\tif (!nodeList) {\n\t\tnodeLists.register(nodes, data.teardownCheck);\n\t} else {\n\t\tnodeList.unregistered = data.teardownCheck;\n\t}\n\t// Finally give the subtree an initial value\n\tmakeAndPut(canReflect.getValue(compute));\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/html.js?");

/***/ }),

/***/ "../../node_modules/can-view-live/lib/list.js":
/*!*******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/list.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar live = __webpack_require__(/*! ./core */ \"../../node_modules/can-view-live/lib/core.js\");\n\nvar nodeLists = __webpack_require__(/*! can-view-nodelist */ \"../../node_modules/can-view-nodelist/can-view-nodelist.js\");\n\nvar frag = __webpack_require__(/*! can-fragment */ \"../../node_modules/can-fragment/can-fragment.js\");\nvar childNodes = __webpack_require__(/*! can-child-nodes */ \"../../node_modules/can-child-nodes/can-child-nodes.js\");\nvar domMutateNode = __webpack_require__(/*! can-dom-mutate/node */ \"../../node_modules/can-dom-mutate/node.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\n\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n\nvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"../../node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\n\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"../../node_modules/can-simple-observable/can-simple-observable.js\");\nvar SetObservable = __webpack_require__(/*! ./set-observable */ \"../../node_modules/can-view-live/lib/set-observable.js\");\nvar Patcher = __webpack_require__(/*! can-diff/patcher/patcher */ \"../../node_modules/can-diff/patcher/patcher.js\");\n\nvar splice = [].splice;\n\n// #### renderAndAddToNodeLists\n// a helper function that renders something and adds its nodeLists to newNodeLists\n// in the right way for stache.\nvar renderAndAddToNodeLists = function(newNodeLists, parentNodeList, render, context, args) {\n\t\tvar itemNodeList = [];\n\n\t\tif (parentNodeList) {\n\t\t\t// With a supplied parent list, \"directly\" register the new nodeList\n\t\t\t//  as a child.\n\t\t\tnodeLists.register(itemNodeList, null, true, true);\n\t\t\titemNodeList.parentList = parentNodeList;\n\t\t\titemNodeList.expression = \"#each SUBEXPRESSION\";\n\t\t}\n\n\t\t// call the renderer, passing in the new nodeList as the last argument\n\t\tvar itemHTML = render.apply(context, args.concat([itemNodeList])),\n\t\t\t// and put the output into a document fragment\n\t\t\titemFrag = frag(itemHTML);\n\n\t\t// get all the direct children of the frag\n\t\tvar children = canReflect.toArray(childNodes(itemFrag));\n\t\tif (parentNodeList) {\n\t\t\t// if a parent list was supplied, children of the frag become the\n\t\t\t//  child nodeList items.\n\t\t\tnodeLists.update(itemNodeList, children);\n\t\t\tnewNodeLists.push(itemNodeList);\n\t\t} else {\n\t\t\t// If no parent nodeList, register the new array of frag children as a nodeList\n\t\t\t//  and push into the nodeLists\n\t\t\tnewNodeLists.push(nodeLists.register(children));\n\t\t}\n\t\treturn itemFrag;\n\t},\n\t// #### removeFromNodeList\n\t// a splicing helper for nodeLists, which removes sublists, including unregistering,\n\t//  for a contiguous slice of the master list.\n\tremoveFromNodeList = function(masterNodeList, index, length) {\n\t\tvar removedMappings = masterNodeList.splice(index + 1, length),\n\t\t\titemsToRemove = [];\n\t\tremovedMappings.forEach( function(nodeList) {\n\n\t\t\t// Unregister to free up event bindings.\n\t\t\tvar nodesToRemove = nodeLists.unregister(nodeList);\n\n\t\t\t// add items that we will remove all at once\n\t\t\t[].push.apply(itemsToRemove, nodesToRemove);\n\t\t});\n\t\treturn itemsToRemove;\n\t};\n\n\n\n\nvar onPatchesSymbol = canSymbol.for(\"can.onPatches\");\nvar offPatchesSymbol = canSymbol.for(\"can.offPatches\");\n\nfunction ListDOMPatcher(el, compute, render, context, parentNode, nodeList, falseyRender) {\n\tthis.patcher = new Patcher(compute);\n\n\t// argument cleanup\n\tparentNode = live.getParentNode(el, parentNode);\n\n\t// function callback binding\n\n\t// argument saving -----\n\tthis.value = compute;\n\tthis.render = render;\n\tthis.context = context;\n\tthis.parentNode = parentNode;\n\tthis.falseyRender = falseyRender;\n\t// A nodeList of all elements this live-list manages.\n\t// This is here so that if this live list is within another section\n\t// that section is able to remove the items in this list.\n\tthis.masterNodeList = nodeList || nodeLists.register([el], null, true);\n\tthis.placeholder = el;\n\n\t// A mapping of items to their indices\n\tthis.indexMap = [];\n\n\tthis.isValueLike = canReflect.isValueLike(this.value);\n\tthis.isObservableLike = canReflect.isObservableLike(this.value);\n\n\t// Setup binding and teardown to add and remove events\n\tthis.onPatches = this.onPatches.bind(this);\n\tvar data = this.data = live.setup(\n\t\tparentNode,\n\t\tthis.setupValueBinding.bind(this),\n\t\tthis.teardownValueBinding.bind(this)\n\t);\n\n\tthis.masterNodeList.unregistered = function() {\n\t\tdata.teardownCheck();\n\t\t//isTornDown = true;\n\t};\n\n\t//!steal-remove-start\n\tif(true) {\n\t\tObject.defineProperty(this.onPatches, \"name\", {\n\t\t\tvalue: \"live.list update::\"+canReflect.getName(compute),\n\t\t});\n\t}\n\t//!steal-remove-end\n}\n\nvar onPatchesSymbol = canSymbol.for(\"can.onPatches\");\nvar offPatchesSymbol = canSymbol.for(\"can.offPatches\");\n\nListDOMPatcher.prototype = {\n\tsetupValueBinding: function() {\n\t\tthis.patcher[onPatchesSymbol](this.onPatches, \"domUI\");\n\t\tif (this.patcher.currentList && this.patcher.currentList.length) {\n\t\t\tthis.onPatches([{\n\t\t\t\tinsert: this.patcher.currentList,\n\t\t\t\tindex: 0,\n\t\t\t\tdeleteCount: 0\n\t\t\t}]);\n\t\t} else {\n\t\t\tthis.addFalseyIfEmpty();\n\t\t}\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tcanReflectDeps.addMutatedBy(this.parentNode, this.patcher.observableOrList);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\tteardownValueBinding: function() {\n\t\tthis.patcher[offPatchesSymbol](this.onPatches, \"domUI\");\n\t\tthis.exit = true;\n\t\tthis.remove({\n\t\t\tlength: this.patcher.currentList.length\n\t\t}, 0, true);\n\t\t//!steal-remove-start\n\t\tif(true) {\n\t\t\tcanReflectDeps.deleteMutatedBy(this.parentNode, this.patcher.observableOrList);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\tonPatches: function ListDOMPatcher_onPatches(patches) {\n\t\tif (this.exit) {\n\t\t\treturn;\n\t\t}\n\t\tfor (var i = 0, patchLen = patches.length; i < patchLen; i++) {\n\t\t\tvar patch = patches[i];\n\t\t\tif (patch.type === \"move\") {\n\t\t\t\tthis.move(patch.toIndex, patch.fromIndex);\n\t\t\t} else {\n\t\t\t\tif (patch.deleteCount) {\n\t\t\t\t\t// Remove any items scheduled for deletion from the patch.\n\t\t\t\t\tthis.remove({\n\t\t\t\t\t\tlength: patch.deleteCount\n\t\t\t\t\t}, patch.index, true);\n\t\t\t\t}\n\t\t\t\tif (patch.insert && patch.insert.length) {\n\t\t\t\t\t// Insert any new items at the index\n\t\t\t\t\tthis.add(patch.insert, patch.index);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\tadd: function(items, index) {\n\t\t//if (!afterPreviousEvents) {\n\t\t//\treturn;\n\t\t//}\n\t\t// Collect new html and mappings\n\t\tvar frag = this.placeholder.ownerDocument.createDocumentFragment(),\n\t\t\tnewNodeLists = [],\n\t\t\tnewIndicies = [],\n\t\t\tmasterNodeList = this.masterNodeList,\n\t\t\trender = this.render,\n\t\t\tcontext = this.context;\n\t\t// For each new item,\n\t\titems.forEach( function(item, key) {\n\n\t\t\tvar itemIndex = new SimpleObservable(key + index),\n\t\t\t\titemCompute = new SetObservable(item, function(newVal) {\n\t\t\t\t\tcanReflect.setKeyValue(this.patcher.currentList, itemIndex.get(), newVal );\n\t\t\t\t}.bind(this)),\n\t\t\t\titemFrag = renderAndAddToNodeLists(newNodeLists, masterNodeList, render, context, [itemCompute, itemIndex]);\n\n\t\t\t// Hookup the fragment (which sets up child live-bindings) and\n\t\t\t// add it to the collection of all added elements.\n\t\t\tfrag.appendChild(itemFrag);\n\t\t\t// track indicies;\n\t\t\tnewIndicies.push(itemIndex);\n\t\t}, this);\n\t\t// The position of elements is always after the initial text placeholder node\n\t\tvar masterListIndex = index + 1;\n\n\t\t// remove falsey if there's something there\n\t\tif (!this.indexMap.length) {\n\t\t\t// remove all leftover things\n\t\t\tvar falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);\n\t\t\tnodeLists.remove(falseyItemsToRemove);\n\t\t}\n\n\t\t// Check if we are adding items at the end\n\t\tif (!masterNodeList[masterListIndex]) {\n\t\t\tnodeLists.after(masterListIndex === 1 ? [this.placeholder] : [nodeLists.last(this.masterNodeList[masterListIndex - 1])], frag);\n\t\t} else {\n\t\t\t// Add elements before the next index's first element.\n\t\t\tvar el = nodeLists.first(masterNodeList[masterListIndex]);\n\t\t\tdomMutateNode.insertBefore.call(el.parentNode, frag, el);\n\t\t}\n\t\tsplice.apply(this.masterNodeList, [\n\t\t\tmasterListIndex,\n\t\t\t0\n\t\t].concat(newNodeLists));\n\n\t\t// update indices after insert point\n\t\tsplice.apply(this.indexMap, [\n\t\t\tindex,\n\t\t\t0\n\t\t].concat(newIndicies));\n\n\t\tfor (var i = index + newIndicies.length, len = this.indexMap.length; i < len; i++) {\n\t\t\tthis.indexMap[i].set(i);\n\t\t}\n\t},\n\tremove: function(items, index) {\n\t\t//if (!afterPreviousEvents) {\n\t\t//\treturn;\n\t\t//}\n\n\t\t// If this is because an element was removed, we should\n\t\t// check to make sure the live elements are still in the page.\n\t\t// If we did this during a teardown, it would cause an infinite loop.\n\t\t//if (!duringTeardown && this.data.teardownCheck(this.placeholder.parentNode)) {\n\t\t//\treturn;\n\t\t//}\n\t\tif (index < 0) {\n\t\t\tindex = this.indexMap.length + index;\n\t\t}\n\t\tvar itemsToRemove = removeFromNodeList(this.masterNodeList, index, items.length);\n\t\tvar indexMap = this.indexMap;\n\t\t// update indices after remove point\n\t\tindexMap.splice(index, items.length);\n\t\tfor (var i = index, len = indexMap.length; i < len; i++) {\n\t\t\tindexMap[i].set(i);\n\t\t}\n\n\t\t// don't remove elements during teardown.  Something else will probably be doing that.\n\t\tif (!this.exit) {\n\t\t\t// adds the falsey section if the list is empty\n\t\t\tthis.addFalseyIfEmpty();\n\t\t\tnodeLists.remove(itemsToRemove);\n\t\t} else {\n\t\t\tnodeLists.unregister(this.masterNodeList);\n\t\t}\n\t},\n\t// #### addFalseyIfEmpty\n\t// Add the results of redering the \"falsey\" or inverse case render to the\n\t// master nodeList and the DOM if the live list is empty\n\taddFalseyIfEmpty: function() {\n\t\tif (this.falseyRender && this.indexMap.length === 0) {\n\t\t\t// If there are no items ... we should render the falsey template\n\t\t\tvar falseyNodeLists = [];\n\t\t\tvar falseyFrag = renderAndAddToNodeLists(falseyNodeLists, this.masterNodeList, this.falseyRender, this.currentList, [this.currentList]);\n\n\t\t\t// put the frag after the reference element in the associated nodeList\n\t\t\tnodeLists.after([this.masterNodeList[0]], falseyFrag);\n\t\t\t// and push the first element onto the master list\n\t\t\tthis.masterNodeList.push(falseyNodeLists[0]);\n\t\t}\n\t},\n\tmove: function move(newIndex, currentIndex) {\n\t\t//if (!afterPreviousEvents) {\n\t\t//\treturn;\n\t\t//}\n\t\t// The position of elements is always after the initial text\n\t\t// placeholder node\n\t\tnewIndex = newIndex + 1;\n\t\tcurrentIndex = currentIndex + 1;\n\t\tvar masterNodeList = this.masterNodeList,\n\t\t\tindexMap = this.indexMap;\n\t\tvar referenceNodeList = masterNodeList[newIndex];\n\t\tvar movedElements = frag(nodeLists.flatten(masterNodeList[currentIndex]));\n\t\tvar referenceElement;\n\n\t\t// If we're moving forward in the list, we want to be placed before\n\t\t// the item AFTER the target index since removing the item from\n\t\t// the currentIndex drops the referenceItem's index. If there is no\n\t\t// nextSibling, insertBefore acts like appendChild.\n\t\tif (currentIndex < newIndex) {\n\t\t\treferenceElement = nodeLists.last(referenceNodeList).nextSibling;\n\t\t} else {\n\t\t\treferenceElement = nodeLists.first(referenceNodeList);\n\t\t}\n\n\t\tvar parentNode = masterNodeList[0].parentNode;\n\n\t\t// Move the DOM nodes into the proper location\n\t\tparentNode.insertBefore(movedElements, referenceElement);\n\n\t\t// Now, do the same for the masterNodeList. We need to keep it\n\t\t// in sync with the DOM.\n\n\t\t// Save a reference to the \"node\" that we're manually moving\n\t\tvar temp = masterNodeList[currentIndex];\n\n\t\t// Remove the movedItem from the masterNodeList\n\t\t[].splice.apply(masterNodeList, [currentIndex, 1]);\n\n\t\t// Move the movedItem to the correct index in the masterNodeList\n\t\t[].splice.apply(masterNodeList, [newIndex, 0, temp]);\n\n\t\t// Convert back to a zero-based array index\n\t\tnewIndex = newIndex - 1;\n\t\tcurrentIndex = currentIndex - 1;\n\n\t\t// Grab the index compute from the `indexMap`\n\t\tvar indexCompute = indexMap[currentIndex];\n\n\t\t// Remove the index compute from the `indexMap`\n\t\t[].splice.apply(indexMap, [currentIndex, 1]);\n\n\t\t// Move the index compute to the correct index in the `indexMap`\n\t\t[].splice.apply(indexMap, [newIndex, 0, indexCompute]);\n\n\t\tvar i = Math.min(currentIndex, newIndex);\n\t\tvar len = indexMap.length;\n\n\t\tfor (i, len; i < len; i++) {\n\t\t\t// set each compute to have its current index in the map as its value\n\t\t\tindexMap[i].set(i);\n\t\t}\n\t},\n\tset: function(newVal, index) {\n\t\tthis.remove({\n\t\t\tlength: 1\n\t\t}, index, true);\n\t\tthis.add([newVal], index);\n\t}\n};\n\n\n\n/**\n * @function can-view-live.list list\n * @parent can-view-live\n * @release 2.0.4\n *\n * @signature `live.list(el, list, render, context, [parentNode])`\n *\n * Live binds a compute's list incrementally.\n *\n * ```js\n * // a compute that change's it's list\n * var todos = compute(function(){\n *   return new Todo.List({page: can.route.attr(\"page\")})\n * })\n *\n * var placeholder = document.createTextNode(\" \");\n * $(\"ul#todos\").append(placeholder);\n *\n * can.view.live.list(\n *   placeholder,\n *   todos,\n *   function(todo, index){\n *     return \"<li>\"+todo.attr(\"name\")+\"</li>\"\n *   });\n * ```\n *\n * @param {HTMLElement} el An html element to replace with the live-section.\n *\n * @param {Object} list An observable value or list type. If an observable value, it should contain\n * a falsey value or a list type.\n *\n * @param {function(this:*,*,index):String} render(index, index) A function that when called with\n * the incremental item to render and the index of the item in the list.\n *\n * @param {Object} context The `this` the `render` function will be called with.\n *\n * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is\n * a documentFragment.\n *\n * @body\n *\n * ## How it works\n *\n * If `list` is an observable value, `live.list` listens to changes in in that\n * observable value.  It will generally change from one list type (often a list type that implements `onPatches`)\n * to another.  When the value changes, a diff will be performed and the DOM updated.  Also, `live.list`\n * will listen to `.onPatches` on the new list and apply any patches emitted from it.\n *\n *\n */\nlive.list = function(el, list, render, context, parentNode, nodeList, falseyRender) {\n\tif (el.nodeType !== Node.TEXT_NODE) {\n\t\tvar textNode;\n\t\tif (!nodeList) {\n\t\t\ttextNode = document.createTextNode(\"\");\n\t\t\tel.parentNode.replaceChild(textNode, el);\n\t\t\tel = textNode;\n\t\t} else {\n\t\t\ttextNode = document.createTextNode(\"\");\n\t\t\tnodeLists.replace(nodeList, textNode);\n\t\t\tnodeLists.update(nodeList, [textNode]);\n\t\t\tel = textNode;\n\t\t}\n\t}\n\tnew ListDOMPatcher(el, list, render, context, parentNode, nodeList, falseyRender);\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/list.js?");

/***/ }),

/***/ "../../node_modules/can-view-live/lib/set-observable.js":
/*!*****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/set-observable.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar SimpleObservable = __webpack_require__(/*! can-simple-observable */ \"../../node_modules/can-simple-observable/can-simple-observable.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nfunction SetObservable(initialValue, setter) {\n\tthis.setter = setter;\n\n\tSimpleObservable.call(this, initialValue);\n}\n\nSetObservable.prototype = Object.create(SimpleObservable.prototype);\nSetObservable.prototype.constructor = SetObservable;\nSetObservable.prototype.set = function(newVal) {\n\tthis.setter(newVal);\n};\n\n\ncanReflect.assignSymbols(SetObservable.prototype, {\n\t\"can.setValue\": SetObservable.prototype.set\n});\n\nmodule.exports = SetObservable;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/set-observable.js?");

/***/ }),

/***/ "../../node_modules/can-view-live/lib/text.js":
/*!*******************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/text.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar live = __webpack_require__(/*! ./core */ \"../../node_modules/can-view-live/lib/core.js\");\nvar nodeLists = __webpack_require__(/*! can-view-nodelist */ \"../../node_modules/can-view-nodelist/can-view-nodelist.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\n/**\n * @function can-view-live.text text\n * @parent can-view-live\n * @release 2.0.4\n *\n * @signature `live.text(el, compute, [parentNode], [nodeList])`\n *\n * Replaces one element with some content while keeping [can-view-live.nodeLists nodeLists] data correct.\n */\nlive.text = function(el, compute, parentNode, nodeList) {\n\t// TODO: we can remove this at some point\n\tif (el.nodeType !== Node.TEXT_NODE) {\n\t\tvar textNode;\n\t\tif (!nodeList) {\n\t\t\ttextNode = document.createTextNode(\"\");\n\t\t\tel.parentNode.replaceChild(textNode, el);\n\t\t\tel = textNode;\n\t\t} else {\n\t\t\ttextNode = document.createTextNode(\"\");\n\t\t\tnodeLists.replace(nodeList, textNode);\n\t\t\tnodeLists.update(nodeList, [textNode]);\n\t\t\tel = textNode;\n\t\t}\n\t}\n\n\tvar parent = live.getParentNode(el, parentNode);\n\t// setup listening right away so we don't have to re-calculate value\n\n\t// Create a new text node from the compute value\n\tel.nodeValue = live.makeString(canReflect.getValue(compute));\n\n\tfunction liveTextUpdateTextNode(newVal) {\n\t\tel.nodeValue = live.makeString(newVal);\n\t}\n\n\t//!steal-remove-start\n\tif(true) {\n\t\t// register that the handler changes the parent element\n\t\tcanReflect.assignSymbols(liveTextUpdateTextNode, {\n\t\t\t\"can.getChangesDependencyRecord\": function() {\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: new Set( [ parent ] )\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(liveTextUpdateTextNode, \"name\", {\n\t\t\tvalue: \"live.text update::\"+canReflect.getName(compute),\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tvar data = live.listen(parent, compute, liveTextUpdateTextNode,\"domUI\");\n\n\tif(!nodeList) {\n\t\tnodeList = nodeLists.register([el], null, true);\n\t}\n\n\tnodeList.unregistered = data.teardownCheck;\n\tdata.nodeList = nodeList;\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-live/lib/text.js?");

/***/ }),

/***/ "../../node_modules/can-view-model/can-view-model.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-model/can-view-model.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar SimpleMap = __webpack_require__(/*! can-simple-map */ \"../../node_modules/can-simple-map/can-simple-map.js\");\nvar ns = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\n\nvar viewModelSymbol = canSymbol.for('can.viewModel');\n\nmodule.exports = ns.viewModel = function (el, attr, val) {\n\tif (typeof el === \"string\") {\n\t\tel = getDocument().querySelector(el);\n\t} else if (canReflect.isListLike(el) && !el.nodeType) {\n\t\tel = el[0];\n\t}\n\n\tif (canReflect.isObservableLike(attr) && canReflect.isMapLike(attr)) {\n\t\tel[viewModelSymbol] = attr;\n\t\treturn;\n\t}\n\n\tvar scope = el[viewModelSymbol];\n\tif(!scope) {\n\t\tscope = new SimpleMap();\n\t\tel[viewModelSymbol] = scope;\n\t}\n\tswitch (arguments.length) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\treturn scope;\n\t\tcase 2:\n\t\t\treturn canReflect.getKeyValue(scope, attr);\n\t\tdefault:\n\t\t\tcanReflect.setKeyValue(scope, attr, val);\n\t\t\treturn el;\n\t}\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-model/can-view-model.js?");

/***/ }),

/***/ "../../node_modules/can-view-nodelist/can-view-nodelist.js":
/*!********************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-nodelist/can-view-nodelist.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate/node */ \"../../node_modules/can-dom-mutate/node.js\");\n\n// # can/view/node_lists/node_list.js\n//\n\n// ### What's a nodeList?\n//\n// A nodelist is an array of DOM nodes (elements text nodes and DOM elements) and/or other\n// nodeLists, along with non-array-indexed properties that manage relationships between lists.\n// These properties are:\n//\n// * deepChildren   children that couldn't be found by iterating over the nodeList when nesting\n// * nesting          nested level of a nodelist (parent's nesting plus 1)\n// * newDeepChildren  same as deepChildren but stored before registering with update()\n// * parentList   the direct parent nodeList of this nodeList\n// * replacements   an array of nodeLists meant to replace virtual nodes\n// * unregistered   a callback to call when unregistering a nodeList\n\n// ## Helpers\n// A mapping of element ids to nodeList id allowing us to quickly find an element\n// that needs to be replaced when updated.\nvar nodeMap = new Map(),\n\tsplice = [].splice,\n\tpush = [].push,\n\n\t// ## nodeLists.itemsInChildListTree\n\t// Given a nodeList return the number of child items in the provided\n\t// list and any child lists.\n\titemsInChildListTree = function(list){\n\t\tvar count = 0;\n\t\tfor(var i = 0, len = list.length ; i < len; i++){\n\t\t\tvar item = list[i];\n\t\t\t// If the item is an HTMLElement then increment the count by 1.\n\t\t\tif(item.nodeType) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\t// If the item is not an HTMLElement it is a list, so\n\t\t\t\t// increment the count by the number of items in the child\n\t\t\t\t// list.\n\t\t\t\tcount += itemsInChildListTree(item);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t},\n\t// replacements is an array of nodeLists\n\t// makes a map of the first node in the replacement to the nodeList\n\treplacementMap = function(replacements){\n\t\tvar map = new Map();\n\t\tfor(var i = 0, len = replacements.length; i < len; i++){\n\t\t\tvar node = nodeLists.first(replacements[i]);\n\t\t\tmap.set(node, replacements[i]);\n\t\t}\n\t\treturn map;\n\t},\n\taddUnfoundAsDeepChildren = function(list, rMap){\n\t\trMap.forEach(function(replacement){\n\t\t\tlist.newDeepChildren.push(replacement);\n\t\t});\n\t};\n\n// ## Registering & Updating\n//\n// To keep all live-bound sections knowing which elements they are managing,\n// all live-bound elments are registered and updated when they change.\n//\n// For example, here's a template:\n//\n//     <div>\n//     \t{{#if items.length}}\n//     \t\tItems:\n//     \t\t{{#each items}}\n//     \t\t\t<label>{{.}}</label>\n//     \t\t{{/each}}\n//     \t{{/if}}\n//     </div>\n//\n//\n// the above template, when rendered with data like:\n//\n//     data = new can.Map({\n//         items: [\"first\",\"second\"]\n//     })\n//\n// This will first render the following content:\n//\n//     <div>\n//         <#text \"\">\n//     </div>\n//\n// The empty text node has a callback which, when called, will register it like:\n//\n//     var ifsNodes = [<#text \"\">]\n//     nodeLists.register(ifsNodes);\n//\n// And then render `{{if}}`'s contents and update `ifsNodes` with it:\n//\n//     nodeLists.update( ifsNodes, [<#text \"\\nItems:\\n\">, <#text \"\">] );\n//\n// Next, that final text node's callback is called which will regsiter it like:\n//\n//     var eachsNodes = [<#text \"\">];\n//     nodeLists.register(eachsNodes);\n//\n// And then it will render `{{#each}}`'s content and update `eachsNodes` with it:\n//\n//     nodeLists.update(eachsNodes, [<label>,<label>]);\n//\n// As `nodeLists` knows that `eachsNodes` is inside `ifsNodes`, it also updates\n// `ifsNodes`'s nodes to look like:\n//\n//     [<#text \"\\nItems:\\n\">,<label>,<label>]\n//\n// Now, if all items were removed, `{{#if}}` would be able to remove\n// all the `<label>` elements.\n//\n// When you regsiter a nodeList, you can also provide a callback to know when\n// that nodeList has been replaced by a parent nodeList.  This is\n// useful for tearing down live-binding.\nvar nodeLists = {\n\n   /**\n\t* @function can-view-nodelist.update update\n\t* @parent can-view-nodelist/methods\n\t*\n\t* @signature `nodeLists.update(nodeList, newNodes)`\n\t*\n\t* Updates a nodeList with new items, i.e. when values for the template have changed.\n\t*\n\t*   @param {can-view-nodelist/types/NodeList} nodeList The list to update with the new nodes.\n\t*   @param {can-view-nodelist/types/NodeList} newNodes The new nodes to update with.\n\t*\n\t*   @return {Array<Node>} The nodes that were removed from `nodeList`.\n\t*/\n\tupdate: function (nodeList, newNodes, oldNodes) {\n\t\t// Unregister all childNodeLists.\n\t\tif(!oldNodes) {\n\t\t\t// if oldNodes has been passed, we assume everything has already been unregistered.\n\t\t\toldNodes = nodeLists.unregisterChildren(nodeList);\n\t\t}\n\n\t\tvar arr = [];\n\t\tfor (var i = 0, ref = arr.length = newNodes.length; i < ref; i++) {\n \t\t\tarr[i] = newNodes[i];\n\t\t} // see https://jsperf.com/nodelist-to-array\n\t\tnewNodes = arr;\n\n\t\tvar oldListLength = nodeList.length;\n\n\t\t// Replace oldNodeLists's contents.\n\t\tsplice.apply(nodeList, [\n\t\t\t0,\n\t\t\toldListLength\n\t\t].concat(newNodes));\n\n\t\t// Replacements are nodes that have replaced the original element this is on.\n\t\t// We can't simply insert elements because stache does children before parents.\n\t\tif(nodeList.replacements){\n\t\t\tnodeLists.nestReplacements(nodeList);\n\t\t\tnodeList.deepChildren = nodeList.newDeepChildren;\n\t\t\tnodeList.newDeepChildren = [];\n\t\t} else {\n\t\t\tnodeLists.nestList(nodeList);\n\t\t}\n\n\t\treturn oldNodes;\n\t},\n   /**\n\t* @function can-view-nodelist.nestReplacements nestReplacements\n\t* @parent can-view-nodelist/methods\n\t* @signature `nodeLists.nestReplacements(list)`\n\t*\n\t* Goes through each node in the list. `[el1, el2, el3, ...]`\n\t* Finds the nodeList for that node in replacements.  el1's nodeList might look like `[el1, [el2]]`.\n\t* Replaces that element and any other elements in the node list with the\n\t* nodelist itself. resulting in `[ [el1, [el2]], el3, ...]`\n\t* If a replacement is not found, it was improperly added, so we add it as a deepChild.\n\t*\n\t* @param {can-view-nodelist/types/NodeList} list  The nodeList of nodes to go over\n\t*\n\t*/\n\tnestReplacements: function(list){\n\t\tvar index = 0,\n\t\t\t// replacements are in reverse order in the DOM\n\t\t\trMap = replacementMap(list.replacements),\n\t\t\trCount = list.replacements.length;\n\n\t\twhile(index < list.length && rCount) {\n\t\t\tvar node = list[index],\n\t\t\t\treplacement = rMap.get(node);\n\t\t\tif( replacement ) {\n\t\t\t\trMap[\"delete\"](node);\n\t\t\t\tlist.splice( index, itemsInChildListTree(replacement), replacement );\n\t\t\t\trCount--;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\t// Only do this if\n\t\tif(rCount) {\n\t\t\taddUnfoundAsDeepChildren(list, rMap );\n\t\t}\n\n\t\tlist.replacements = [];\n\t},\n\t/**\n\t * @function can-view-nodelist.nestList nestList\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.nestList(list)`\n\t *\n\t * If a given list does not exist in the nodeMap then create an lookup\n\t * id for it in the nodeMap and assign the list to it.\n\t * If the the provided does happen to exist in the nodeMap update the\n\t * elements in the list.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} list The nodeList being nested.\n\t *\n\t */\n\tnestList: function(list){\n\t\tvar index = 0;\n\t\twhile(index < list.length) {\n\t\t\tvar node = list[index],\n\t\t\t\tchildNodeList = nodeMap.get(node);\n\n\n\t\t\tif(childNodeList) {\n\t\t\t\t// if this node is in another nodelist\n\t\t\t\tif(childNodeList !== list) {\n\t\t\t\t\t// update this nodeList to point to the childNodeList\n\t\t\t\t\tlist.splice( index, itemsInChildListTree(childNodeList), childNodeList );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Indicate the new nodes belong to this list.\n\t\t\t\tnodeMap.set(node, list);\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t},\n\n\t/**\n\t * @function can-view-nodelist.last last\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.last(nodeList)`\n\t *\n\t * Return the last HTMLElement in a nodeList; if the last\n\t * element is a nodeList, returns the last HTMLElement of\n\t * the child list, etc.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} nodeList A nodeList.\n\t * @return {HTMLElement} The last element of the last list nested in this list.\n\t *\n\t */\n\tlast: function(nodeList){\n\t\tvar last = nodeList[nodeList.length - 1];\n\t\t// If the last node in the list is not an HTMLElement\n\t\t// it is a nodeList so call `last` again.\n\t\tif(last.nodeType) {\n\t\t\treturn last;\n\t\t} else {\n\t\t\treturn nodeLists.last(last);\n\t\t}\n\t},\n\n\t/**\n\t * @function can-view-nodelist.first first\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.first(nodeList)`\n\t *\n\t * Return the first HTMLElement in a nodeList; if the first\n\t * element is a nodeList, returns the first HTMLElement of\n\t * the child list, etc.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} nodeList A nodeList.\n\t * @return {HTMLElement} The first element of the first list nested in this list.\n\t *\n\t *\n\t */\n\tfirst: function(nodeList) {\n\t\tvar first = nodeList[0];\n\t\t// If the first node in the list is not an HTMLElement\n\t\t// it is a nodeList so call `first` again.\n\t\tif(first.nodeType) {\n\t\t\treturn first;\n\t\t} else {\n\t\t\treturn nodeLists.first(first);\n\t\t}\n\t},\n\tflatten: function(nodeList){\n\t\tvar items = [];\n\t\tfor(var i = 0 ; i < nodeList.length; i++) {\n\t\t\tvar item = nodeList[i];\n\t\t\tif(item.nodeType) {\n\t\t\t\titems.push(item);\n\t\t\t} else {\n\t\t\t\titems.push.apply(items, nodeLists.flatten(item));\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t},\n\t/**\n\t * @function can-view-nodelist.register register\n\t * @parent can-view-nodelist/methods\n\t *\n\t * @signature `nodeLists.register(nodeList, unregistered, parent, directlyNested)`\n\t *\n\t * Registers a nodeList and returns the nodeList passed to register.\n\t *\n\t *   @param {can-view-nodelist/types/NodeList} nodeList A nodeList.\n\t *   @param {function()} unregistered A callback to call when the nodeList is unregistered.\n\t *   @param {can-view-nodelist/types/NodeList} parent The parent nodeList of this nodeList.\n\t *   @param {Boolean} directlyNested `true` if nodes in the nodeList are direct children of the parent.\n\t *   @return {can-view-nodelist/types/NodeList} The passed in nodeList.\n\t *\n\t */\n\tregister: function (nodeList, unregistered, parent, directlyNested) {\n\t\t// If a unregistered callback has been provided assign it to the nodeList\n\t\t// as a property to be called when the nodeList is unregistred.\n\t\tnodeList.unregistered = unregistered;\n\t\tnodeList.parentList = parent;\n\t\tnodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;\n\n\t\tif(parent) {\n\t\t\tnodeList.deepChildren = [];\n\t\t\tnodeList.newDeepChildren = [];\n\t\t\tnodeList.replacements = [];\n\t\t\tif(parent !== true) {\n\t\t\t\tif(directlyNested) {\n\t\t\t\t\tparent.replacements.push(nodeList);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent.newDeepChildren.push(nodeList);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tnodeLists.nestList(nodeList);\n\t\t}\n\n\n\t\treturn nodeList;\n\t},\n\n\t/**\n\t * @function can-view-nodelist.unregisterChildren unregisterChildren\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.unregisterChildren(nodeList)`\n\t *\n\t * Unregister all childen within the provided list and return the\n\t * unregistred nodes.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} nodeList The nodeList of child nodes to unregister.\n\t * @return {Array} The list of all nodes that were unregistered.\n\t */\n\tunregisterChildren: function(nodeList){\n\t\tvar nodes = [];\n\t\t// For each node in the nodeList we want to compute it's id\n\t\t// and delete it from the nodeList's internal map.\n\t\tfor (var n = 0; n < nodeList.length; n++) {\n\t\t\tvar node = nodeList[n];\n\t\t\t// If the node does not have a nodeType it is an array of\n\t\t\t// nodes.\n\t\t\tif(node.nodeType) {\n\t\t\t\tif(!nodeList.replacements) {\n\t\t\t\t\tnodeMap[\"delete\"](node);\n\t\t\t\t}\n\n\t\t\t\tnodes.push(node);\n\t\t\t} else {\n\t\t\t\t// Recursively unregister each of the child lists in\n\t\t\t\t// the nodeList.\n\t\t\t\tpush.apply(nodes, nodeLists.unregister(node, true));\n\t\t\t}\n\t\t}\n\n\t\tvar deepChildren = nodeList.deepChildren;\n\t\tif (deepChildren) {\n\t\t\tfor (var l = 0; l < deepChildren.length; l++) {\n\t\t\t\tnodeLists.unregister(deepChildren[l], true);\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t},\n\n\t/**\n\t\t@function can-view-nodelist.unregister unregister\n\t\t@parent can-view-nodelist/methods\n\t\t@signature `nodeLists.unregister(nodeList, isChild)`\n\t\t@param {ArrayLike} nodeList a nodeList to unregister from its parent\n\t\t@param {isChild}  true if the nodeList is a direct child, false if a deep child\n\t\t@return {Array}   a list of all nodes that were unregistered\n\n\t\tUnregister's a nodeList and returns the unregistered nodes.\n\t\tCall if the nodeList is no longer being updated. This will\n\t\talso unregister all child nodeLists.\n\t*/\n\tunregister: function (nodeList, isChild) {\n\t\tvar nodes = nodeLists.unregisterChildren(nodeList, true);\n\t\tnodeList.isUnregistered = true;\n\n\t\t// If an 'unregisted' function was provided during registration, remove\n\t\t// it from the list, and call the function provided.\n\t\tif (nodeList.unregistered) {\n\t\t\tvar unregisteredCallback = nodeList.unregistered;\n\t\t\tnodeList.replacements = nodeList.unregistered = null;\n\t\t\tif(!isChild) {\n\t\t\t\tvar deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;\n\t\t\t\tif(deepChildren) {\n\t\t\t\t\tvar index = deepChildren.indexOf(nodeList);\n\t\t\t\t\tif(index !== -1) {\n\t\t\t\t\t\tdeepChildren.splice(index,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tunregisteredCallback();\n\t\t}\n\t\treturn nodes;\n\t},\n\t/**\n\t * @function can-view-nodelist.after after\n\t * @parent can-view-nodelist/methods\n\t * @hide\n\t * @signature `nodeLists.after(oldElements, newFrag)`\n\t *\n\t *   Inserts `newFrag` after `oldElements`.\n\t *\n\t *   @param {ArrayLike<Node>} oldElements The elements to use as reference.\n\t *   @param {DocumentFragment} newFrag The fragment to insert.\n\t *\n\t */\n\tafter: function (oldElements, newFrag) {\n\t\tvar last = oldElements[oldElements.length - 1];\n\t\t// Insert it in the `document` or `documentFragment`\n\t\tif (last.nextSibling) {\n\t\t\tdomMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);\n\t\t} else {\n\t\t\tdomMutate.appendChild.call(last.parentNode, newFrag );\n\t\t}\n\t},\n\t/**\n\t * @function can-view-nodelist.replace replace\n\t * @hide\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.replace(oldElements, newFrag)`\n\t *\n\t * Replaces `oldElements` with `newFrag`.\n\t *\n\t * @param {Array<Node>} oldElements the list elements to remove\n\t * @param {DocumentFragment} newFrag the fragment to replace the old elements\n\t *\n\t */\n\treplace: function (oldElements, newFrag) {\n\t\t// The following helps make sure that a selected <option> remains\n\t\t// the same by removing `selected` from the currently selected option\n\t\t// and adding selected to an option that has the same value.\n\t\tvar selectedValue,\n\t\t\tparentNode = oldElements[0].parentNode;\n\n\t\tif(parentNode.nodeName.toUpperCase() === \"SELECT\" && parentNode.selectedIndex >= 0) {\n\t\t\tselectedValue = parentNode.value;\n\t\t}\n\t\tif(oldElements.length === 1) {\n\t\t\tdomMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);\n\t\t} else {\n\t\t\tnodeLists.after(oldElements, newFrag);\n\t\t\tnodeLists.remove(oldElements);\n\t\t}\n\n\t\tif(selectedValue !== undefined) {\n\t\t\tparentNode.value = selectedValue;\n\t\t}\n\t},\n\t/**\n\t * @function can-view-nodelist.remove remove\n\t * @parent can-view-nodelist/methods\n\t * @hide\n\t * @signature `nodeLists.remove(elementsToBeRemoved)`\n\t *\n\t * Remove all Nodes in `oldElements` from the DOM.\n\t *\n\t * @param {ArrayLike<Node>} oldElements the list of Elements to remove (must have a common parent)\n\t *\n\t */\n\tremove: function(elementsToBeRemoved){\n\t\tvar parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;\n\t\tfor (var i = 0; i < elementsToBeRemoved.length; i++) {\n\t\t\tdomMutate.removeChild.call(parent, elementsToBeRemoved[i]);\n\t\t}\n\t},\n\tnodeMap: nodeMap\n};\nmodule.exports = namespace.nodeLists = nodeLists;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-nodelist/can-view-nodelist.js?");

/***/ }),

/***/ "../../node_modules/can-view-parser/can-view-parser.js":
/*!****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-parser/can-view-parser.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint maxdepth:7,node:true, latedef:false */\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\"),\n\tdev = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\"),\n\tencoder = __webpack_require__(/*! can-attribute-encoder */ \"../../node_modules/can-attribute-encoder/can-attribute-encoder.js\");\n\nfunction each(items, callback){\n\tfor ( var i = 0; i < items.length; i++ ) {\n\t\tcallback(items[i], i);\n\t}\n}\n\nfunction makeMap(str){\n\tvar obj = {}, items = str.split(\",\");\n\teach(items, function(name){\n\t\tobj[name] = true;\n\t});\n\treturn obj;\n}\n\nfunction handleIntermediate(intermediate, handler){\n\tfor(var i = 0, len = intermediate.length; i < len; i++) {\n\t\tvar item = intermediate[i];\n\t\thandler[item.tokenType].apply(handler, item.args);\n\t}\n\treturn intermediate;\n}\n\n//!steal-remove-start\nif (true) {\n\t//assign the function to a var to avoid jshint\n\t//\"Function declarations should not be placed in blocks\"\n\tvar countLines = function countLines(input) {\n\t\t// TODO: optimize?\n\t\treturn input.split('\\n').length - 1;\n\t};\n}\n//!steal-remove-end\n\nvar alphaNumeric = \"A-Za-z0-9\",\n\talphaNumericHU = \"-:_\"+alphaNumeric,\n\tmagicStart = \"{{\",\n\tendTag = new RegExp(\"^<\\\\/([\"+alphaNumericHU+\"]+)[^>]*>\"),\n\tmagicMatch = new RegExp(\"\\\\{\\\\{(![\\\\s\\\\S]*?!|[\\\\s\\\\S]*?)\\\\}\\\\}\\\\}?\",\"g\"),\n\tspace = /\\s/,\n\talphaRegex = new RegExp('['+ alphaNumeric + ']'),\n\tattributeRegexp = new RegExp(\"[\"+alphaNumericHU+\"]+\\s*=\\s*(\\\"[^\\\"]*\\\"|'[^']*')\");\n\n// Empty Elements - HTML 5\nvar empty = makeMap(\"area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed\");\n\n// Elements for which tag case matters - shouldn't be lowercased.\nvar caseMattersElements = makeMap(\"altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath\");\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar closeSelf = makeMap(\"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr\");\n\n// Special Elements (can contain anything)\nvar special = makeMap(\"script\");\n\n// Callback names on `handler`.\nvar tokenTypes = \"start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done\".split(\",\");\n\n//maps end characters to start characters\nvar startOppositesMap = {\"{\": \"}\", \"(\":\")\"};\n\nvar fn = function(){};\n\nvar HTMLParser = function (html, handler, returnIntermediate) {\n\tif(typeof html === \"object\") {\n\t\treturn handleIntermediate(html, handler);\n\t}\n\n\tvar intermediate = [];\n\thandler = handler || {};\n\tif(returnIntermediate) {\n\t\t// overwrite handlers so they add to intermediate\n\t\teach(tokenTypes, function(name){\n\t\t\tvar callback = handler[name] || fn;\n\t\t\thandler[name] = function(){\n\t\t\t\tif( callback.apply(this, arguments) !== false ) {\n\t\t\t\t\tvar end = arguments.length;\n\n\t\t\t\t\t// the intermediate is stringified in the compiled stache templates\n\t\t\t\t\t// so we want to trim the last item if it is the line number\n\t\t\t\t\tif (arguments[end - 1] === undefined) {\n\t\t\t\t\t\tend = arguments.length - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\t// but restore line number in dev mode\n\t\t\t\t\t\tend = arguments.length;\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tintermediate.push({\n\t\t\t\t\t\ttokenType: name,\n\t\t\t\t\t\targs: [].slice.call(arguments, 0, end),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tfunction parseStartTag(tag, tagName, rest, unary) {\n\t\ttagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();\n\n\t\tif (closeSelf[tagName] && stack.last() === tagName) {\n\t\t\tparseEndTag(\"\", tagName);\n\t\t}\n\n\t\tunary = empty[tagName] || !!unary;\n\t\thandler.start(tagName, unary, lineNo);\n\t\tif (!unary) {\n\t\t\tstack.push(tagName);\n\t\t}\n\n\t\t// find attribute or special\n\t\tHTMLParser.parseAttrs(rest, handler, lineNo);\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tlineNo += countLines(tag);\n\t\t}\n\t\t//!steal-remove-end\n\n\n\t\thandler.end(tagName, unary, lineNo);\n\n\t}\n\n\tfunction parseEndTag(tag, tagName) {\n\t\t// If no tag name is provided, clean shop\n\t\tvar pos;\n\t\tif (!tagName) {\n\t\t\tpos = 0;\n\t\t}\n\t\t// Find the closest opened tag of the same type\n\t\telse {\n\t\t\ttagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();\n\t\t\tfor (pos = stack.length - 1; pos >= 0; pos--) {\n\t\t\t\tif (stack[pos] === tagName) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (typeof tag === 'undefined') {\n\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\tif (handler.filename) {\n\t\t\t\t\t\tdev.warn(handler.filename + \": expected closing tag </\" + stack[pos] + \">\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdev.warn(\"expected closing tag </\" + stack[pos] + \">\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (pos < 0 || pos !== stack.length - 1) {\n\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\tif (handler.filename) {\n\t\t\t\t\t\tdev.warn(handler.filename + \":\" + lineNo + \": unexpected closing tag \" + tag + \" expected </\" + stack[stack.length - 1] + \">\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdev.warn(lineNo + \": unexpected closing tag \" + tag + \" expected </\" + stack[stack.length - 1] + \">\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (handler.filename) {\n\t\t\t\t\t\tdev.warn(handler.filename + \":\" + lineNo + \": unexpected closing tag \" + tag);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdev.warn(lineNo + \": unexpected closing tag \" + tag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif (pos >= 0) {\n\t\t\t// Close all the open elements, up the stack\n\t\t\tfor (var i = stack.length - 1; i >= pos; i--) {\n\t\t\t\tif (handler.close) {\n\t\t\t\t\thandler.close(stack[i], lineNo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the open elements from the stack\n\t\t\tstack.length = pos;\n\t\t}\n\t}\n\n\tfunction parseMustache(mustache, inside){\n\t\tif(handler.special){\n\t\t\thandler.special(inside, lineNo);\n\t\t}\n\t}\n\n\tvar callChars = function(){\n\t\tif(charsText) {\n\t\t\tif(handler.chars) {\n\t\t\t\thandler.chars(charsText, lineNo);\n\t\t\t}\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tlineNo += countLines(charsText);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\n\t\tcharsText = \"\";\n\t};\n\n\tvar index,\n\t\tchars,\n\t\tmatch,\n\t\tlineNo,\n\t\tstack = [],\n\t\tlast = html,\n\t\t// an accumulating text for the next .chars callback\n\t\tcharsText = \"\";\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tlineNo = 1;\n\t}\n\t//!steal-remove-end\n\n\tstack.last = function () {\n\t\treturn this[this.length - 1];\n\t};\n\n\twhile (html) {\n\n\t\tchars = true;\n\n\t\t// Make sure we're not in a script or style element\n\t\tif (!stack.last() || !special[stack.last()]) {\n\n\t\t\t// Comment\n\t\t\tif (html.indexOf(\"<!--\") === 0) {\n\t\t\t\tindex = html.indexOf(\"-->\");\n\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tif (handler.comment) {\n\t\t\t\t\t\thandler.comment(html.substring(4, index), lineNo);\n\t\t\t\t\t}\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tlineNo += countLines(html.substring(0, index + 3));\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\thtml = html.substring(index + 3);\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t} else if (html.indexOf(\"</\") === 0) {\n\t\t\t\tmatch = html.match(endTag);\n\n\t\t\t\tif (match) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tmatch[0].replace(endTag, parseEndTag);\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tlineNo += countLines(html.substring(0, match[0].length));\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\thtml = html.substring(match[0].length);\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t\t// start tag\n\t\t\t} else if (html.indexOf(\"<\") === 0) {\n\t\t\t\tvar res = HTMLParser.searchStartTag(html);\n\n\t\t\t\tif(res) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tparseStartTag.apply(null, res.match);\n\n\t\t\t\t\thtml = res.html;\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t\t// magic tag\n\t\t\t} else if (html.indexOf(magicStart) === 0 ) {\n\t\t\t\tmatch = html.match(magicMatch);\n\n\t\t\t\tif (match) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tmatch[0].replace(magicMatch, parseMustache);\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (true) {\n\t\t\t\t\t\tlineNo += countLines(html.substring(0, match[0].length));\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\thtml = html.substring(match[0].length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (chars) {\n\t\t\t\tindex = findBreak(html, magicStart);\n\t\t\t\tif(index === 0 && html === last) {\n\t\t\t\t\tcharsText += html.charAt(0);\n\t\t\t\t\thtml = html.substr(1);\n\t\t\t\t\tindex = findBreak(html, magicStart);\n\t\t\t\t}\n\n\t\t\t\tvar text = index < 0 ? html : html.substring(0, index);\n\t\t\t\thtml = index < 0 ? \"\" : html.substring(index);\n\n\t\t\t\tif (text) {\n\t\t\t\t\tcharsText += text;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\thtml = html.replace(new RegExp(\"([\\\\s\\\\S]*?)<\\/\" + stack.last() + \"[^>]*>\"), function (all, text) {\n\t\t\t\ttext = text.replace(/<!--([\\s\\S]*?)-->|<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1$2\");\n\t\t\t\tif (handler.chars) {\n\t\t\t\t\thandler.chars(text, lineNo);\n\t\t\t\t}\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (true) {\n\t\t\t\t\tlineNo += countLines(text);\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\treturn \"\";\n\t\t\t});\n\n\t\t\tparseEndTag(\"\", stack.last());\n\t\t}\n\n\t\tif (html === last) {\n\t\t\tthrow new Error(\"Parse Error: \" + html);\n\t\t}\n\n\t\tlast = html;\n\t}\n\tcallChars();\n\t// Clean up any remaining tags\n\tparseEndTag();\n\n\n\thandler.done(lineNo);\n\treturn intermediate;\n};\n\nvar callAttrStart = function(state, curIndex, handler, rest, lineNo){\n\tvar attrName = rest.substring(typeof state.nameStart === \"number\" ? state.nameStart : curIndex, curIndex),\n\t\tnewAttrName = encoder.encode(attrName);\n\n\tstate.attrStart = newAttrName;\n\thandler.attrStart(state.attrStart, lineNo);\n\tstate.inName = false;\n};\n\nvar callAttrEnd = function(state, curIndex, handler, rest, lineNo){\n\tif(state.valueStart !== undefined && state.valueStart < curIndex) {\n\t\tvar val = rest.substring(state.valueStart, curIndex);\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tvar quotedVal, closedQuote;\n\t\t\tquotedVal = rest.substring(state.valueStart - 1, curIndex + 1);\n\t\t\tquotedVal = quotedVal.trim();\n\t\t\tclosedQuote = quotedVal.charAt(quotedVal.length - 1);\n\t\t\t\n\t\t\tif (state.inQuote !== closedQuote) {\n\t\t\t\tif (handler.filename) {\n\t\t\t\t\tdev.warn(handler.filename + \":\" + lineNo + \": End quote is missing for \" + val);\n\t\t\t\t} else {\n\t\t\t\t\tdev.warn(lineNo + \": End quote is missing for \" + val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t\thandler.attrValue(val, lineNo);\n\t}\n\t// if this never got to be inValue, like `DISABLED` then send a attrValue\n\t// else if(!state.inValue){\n\t// \thandler.attrValue(state.attrStart, lineNo);\n\t// }\n\n\thandler.attrEnd(state.attrStart, lineNo);\n\tstate.attrStart = undefined;\n\tstate.valueStart = undefined;\n\tstate.inValue = false;\n\tstate.inName = false;\n\tstate.lookingForEq = false;\n\tstate.inQuote = false;\n\tstate.lookingForName = true;\n};\n\nvar findBreak = function(str, magicStart) {\n\tvar magicLength = magicStart.length;\n\tfor(var i = 0, len = str.length; i < len; i++) {\n\t\tif(str[i] === \"<\" || str.substr(i, magicLength) === magicStart) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\nHTMLParser.parseAttrs = function(rest, handler, lineNo){\n\tif(!rest) {\n\t\treturn;\n\t}\n\n\tvar i = 0;\n\tvar curIndex;\n\tvar state = {\n\t\tinName: false,\n\t\tnameStart: undefined,\n\t\tinValue: false,\n\t\tvalueStart: undefined,\n\t\tinQuote: false,\n\t\tattrStart: undefined,\n\t\tlookingForName: true,\n\t\tlookingForValue: false,\n\t\tlookingForEq : false\n\t};\n\n\twhile(i < rest.length) {\n\t\tcurIndex = i;\n\t\tvar cur = rest.charAt(i);\n\t\ti++;\n\n\t\tif(magicStart === rest.substr(curIndex, magicStart.length) ) {\n\t\t\tif(state.inValue && curIndex > state.valueStart) {\n\t\t\t\thandler.attrValue(rest.substring(state.valueStart, curIndex), lineNo);\n\t\t\t}\n\t\t\t// `{{#foo}}DISABLED{{/foo}}`\n\t\t\telse if(state.inName && state.nameStart < curIndex) {\n\t\t\t\tcallAttrStart(state, curIndex, handler, rest, lineNo);\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t\t// foo={{bar}}\n\t\t\telse if(state.lookingForValue){\n\t\t\t\tstate.inValue = true;\n\t\t\t}\n\t\t\t// a {{bar}}\n\t\t\telse if(state.lookingForEq && state.attrStart) {\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\n\t\t\tmagicMatch.lastIndex = curIndex;\n\t\t\tvar match = magicMatch.exec(rest);\n\t\t\tif(match) {\n\t\t\t\thandler.special(match[1], lineNo);\n\t\t\t\t// i is already incremented\n\t\t\t\ti = curIndex + (match[0].length);\n\t\t\t\tif(state.inValue) {\n\t\t\t\t\tstate.valueStart = curIndex+match[0].length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(state.inValue) {\n\t\t\tif(state.inQuote) {\n\t\t\t\tif(cur === state.inQuote) {\n\t\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(space.test(cur)) {\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t}\n\t\t// if we hit an = outside a value\n\t\telse if(cur === \"=\" && (state.lookingForEq || state.lookingForName || state.inName)) {\n\t\t\t// if we haven't yet started this attribute `{{}}=foo` case:\n\t\t\tif(!state.attrStart) {\n\t\t\t\tcallAttrStart(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t\tstate.lookingForValue = true;\n\t\t\tstate.lookingForEq = false;\n\t\t\tstate.lookingForName = false;\n\t\t}\n\t\t// if we are currently in a name:\n\t\t//  when the name starts with `{` or `(`\n\t\t//  it isn't finished until the matching end character is found\n\t\t//  otherwise, a space finishes the name\n\t\telse if(state.inName) {\n\t\t\tvar started = rest[ state.nameStart ],\n\t\t\t\t\totherStart, otherOpposite;\n\t\t\tif(startOppositesMap[started] === cur) {\n\t\t\t\t//handle mismatched brackets: `{(})` or `({)}`\n\t\t\t\totherStart = started === \"{\" ? \"(\" : \"{\";\n\t\t\t\totherOpposite = startOppositesMap[otherStart];\n\n\t\t\t\tif(rest[curIndex+1] === otherOpposite){\n\t\t\t\t\tcallAttrStart(state, curIndex+2, handler, rest, lineNo);\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tcallAttrStart(state, curIndex+1, handler, rest, lineNo);\n\t\t\t\t}\n\n\t\t\t\tstate.lookingForEq = true;\n\t\t\t}\n\t\t\telse if(space.test(cur) && started !== \"{\" && started !== \"(\") {\n\t\t\t\t\tcallAttrStart(state, curIndex, handler, rest, lineNo);\n\t\t\t\t\tstate.lookingForEq = true;\n\t\t\t}\n\t\t}\n\t\telse if(state.lookingForName) {\n\t\t\tif(!space.test(cur)) {\n\t\t\t\t// might have just started a name, we need to close it\n\t\t\t\tif(state.attrStart) {\n\t\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t\t}\n\t\t\t\tstate.nameStart = curIndex;\n\t\t\t\tstate.inName = true;\n\t\t\t}\n\t\t}\n\t\telse if(state.lookingForValue) {\n\t\t\tif(!space.test(cur)) {\n\t\t\t\tstate.lookingForValue = false;\n\t\t\t\tstate.inValue = true;\n\t\t\t\tif(cur === \"'\" || cur === '\"') {\n\t\t\t\t\tstate.inQuote = cur;\n\t\t\t\t\tstate.valueStart = curIndex+1;\n\t\t\t\t} else {\n\t\t\t\t\tstate.valueStart = curIndex;\n\t\t\t\t}\n\t\t\t\t// if we are looking for a value\n\t\t\t\t// at the end of the loop we need callAttrEnd\n\t\t\t} else if (i === rest.length){\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(state.inName) {\n\t\tcallAttrStart(state, curIndex+1, handler, rest, lineNo);\n\t\tcallAttrEnd(state, curIndex+1, handler, rest, lineNo);\n\t} else if(state.lookingForEq || state.lookingForValue || state.inValue) {\n\t\tcallAttrEnd(state, curIndex+1, handler, rest, lineNo);\n\t}\n\tmagicMatch.lastIndex = 0;\n};\n\nHTMLParser.searchStartTag = function (html) {\n\tvar closingIndex = html.indexOf('>');\n\n\t// The first closing bracket we find might be in an attribute value.\n\t// Move through the attributes by regexp.\n\tvar attributeRange = attributeRegexp.exec(html.substring(1));\n\tvar afterAttributeOffset = 1;\n\t// if the closing index is after the next attribute...\n\twhile(attributeRange && closingIndex >= afterAttributeOffset + attributeRange.index) {\n\n\t\t// prepare to move to the attribute after this one by increasing the offset\n\t\tafterAttributeOffset += attributeRange.index + attributeRange[0].length;\n\t\t// if the closing index is before the new offset, then this closing index is inside\n\t\t//  an attribute value and should be ignored.  Find the *next* closing character.\n\t\twhile(closingIndex < afterAttributeOffset) {\n\t\t\tclosingIndex += html.substring(closingIndex + 1).indexOf('>') + 1;\n\t\t}\n\n\t\t// find the next attribute by starting from the new offset.\n\t\tattributeRange = attributeRegexp.exec(html.substring(afterAttributeOffset));\n\t}\n\n\t// if there is no closing bracket\n\t// <input class=\n\t// or if the tagName does not start with alphaNumer character\n\t// <_iaois>\n\t// it is not a startTag\n\tif(closingIndex === -1 || !(alphaRegex.test(html[1]))){\n\t\treturn null;\n\t}\n\n\tvar tagName, tagContent, match, rest = '', unary = '';\n\tvar startTag = html.substring(0, closingIndex + 1);\n\tvar isUnary = startTag[startTag.length-2] === '/';\n\tvar spaceIndex = startTag.search(space);\n\n\tif(isUnary){\n\t\tunary = '/';\n\t\ttagContent = startTag.substring(1, startTag.length-2).trim();\n\t} else {\n\t\ttagContent = startTag.substring(1, startTag.length-1).trim();\n\t}\n\n\tif(spaceIndex === -1){\n\t\ttagName = tagContent;\n\t} else {\n\t\t//spaceIndex needs to shift one to the left\n\t\tspaceIndex--;\n\t\ttagName = tagContent.substring(0, spaceIndex);\n\t\trest = tagContent.substring(spaceIndex);\n\t}\n\n\tmatch = [startTag, tagName, rest, unary];\n\n\treturn {\n\t\tmatch: match,\n\t\thtml: html.substring(startTag.length),\n\t};\n\n\n};\n\nmodule.exports = namespace.HTMLParser = HTMLParser;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-parser/can-view-parser.js?");

/***/ }),

/***/ "../../node_modules/can-view-scope/can-view-scope.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-scope/can-view-scope.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// # can/view/scope/scope.js\n//\n// This allows you to define a lookup context and parent contexts that a key's value can be retrieved from.\n// If no parent scope is provided, only the scope's context will be explored for values.\nvar observeReader = __webpack_require__(/*! can-stache-key */ \"../../node_modules/can-stache-key/can-stache-key.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar TemplateContext = __webpack_require__(/*! ./template-context */ \"../../node_modules/can-view-scope/template-context.js\");\nvar makeComputeData = __webpack_require__(/*! ./compute_data */ \"../../node_modules/can-view-scope/compute_data.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canLog = __webpack_require__(/*! can-log/dev/dev */ \"../../node_modules/can-log/dev/dev.js\");\nvar defineLazyValue = __webpack_require__(/*! can-define-lazy-value */ \"../../node_modules/can-define-lazy-value/define-lazy-value.js\");\nvar stacheHelpers = __webpack_require__(/*! can-stache-helpers */ \"../../node_modules/can-stache-helpers/can-stache-helpers.js\");\n\nfunction Scope(context, parent, meta) {\n\t// The obj that will be looked on for values.\n\tthis._context = context;\n\t// The next Scope object whose context should be looked on for values.\n\tthis._parent = parent;\n\t// If this is a special context, it can be labeled here.\n\t// Options are:\n\t// - viewModel - This is a viewModel\n\t// - notContext - This can't be looked within using `./` and `../`. It will be skipped.\n\t//   This is for virtual contexts like those used by `%index`.\n\t// - special - This can't be looked within using `./` and `../`. It will be skipped.\n\t//   This is for reading properties like {{scope.index}}.\n\tthis._meta = meta || {};\n\n\t// A cache that can be used to store computes used to look up within this scope.\n\t// For example if someone creates a compute to lookup `name`, another compute does not\n\t// need to be created.\n\tthis.__cache = {};\n}\n\nassign(Scope, {\n\t// ## Scope.read\n\t// Scope.read was moved to can.compute.read\n\t// can.compute.read reads properties from a parent. A much more complex version of getObject.\n\tread: observeReader.read,\n\n\tkeyInfo: function(attr){\n\t\tvar info = {};\n\t\tinfo.isDotSlash = attr.substr(0, 2) === './';\n\t\tinfo.isThisDot = attr.substr(0,5) === \"this.\";\n\t\tinfo.isThisAt = attr.substr(0,5) === \"this@\";\n\t\tinfo.isInCurrentContext = info.isDotSlash || info.isThisDot || info.isThisAt;\n\t\tinfo.isInParentContext = attr.substr(0, 3) === \"../\";\n\t\tinfo.isCurrentContext = attr === \".\" || attr === \"this\";\n\t\tinfo.isParentContext = attr === \"..\";\n\t\tinfo.isScope = attr === \"scope\";\n\t\tinfo.isInScope =\n\t\t\tattr.substr(0, 6) === \"scope.\" ||\n\t\t\tattr.substr(0, 6) === \"scope@\";\n\t\tinfo.isContextBased = info.isInCurrentContext ||\n\t\t\tinfo.isInParentContext ||\n\t\t\tinfo.isCurrentContext ||\n\t\t\tinfo.isParentContext;\n\t\treturn info;\n\t}\n});\n\nassign(Scope.prototype, {\n\n\t// ## Scope.prototype.add\n\t// Creates a new scope and sets the current scope to be the parent.\n\t// ```\n\t// var scope = new can.view.Scope([\n\t//   {name:\"Chris\"},\n\t//   {name: \"Justin\"}\n\t// ]).add({name: \"Brian\"});\n\t// scope.attr(\"name\") //-> \"Brian\"\n\t// ```\n\tadd: function(context, meta) {\n\t\tif (context !== this._context) {\n\t\t\treturn new this.constructor(context, this, meta);\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t},\n\n\t// ## Scope.prototype.find\n\tfind: function(attr, options) {\n\t\treturn this.get(attr, assign({ currentScopeOnly: false }, options));\n\t},\n\n\t// ## Scope.prototype.read\n\t// Reads from the scope chain and returns the first non-`undefined` value.\n\t// `read` deals mostly with setting up \"context based\" keys to start reading\n\t// from the right scope. Once the right scope is located, `_read` is called.\n\t/**\n\t * @hide\n\t * @param {can.stache.key} attr A dot-separated path. Use `\"\\.\"` if you have a property name that includes a dot.\n\t * @param {can.view.Scope.readOptions} options that configure how this gets read.\n\t * @return {{}}\n\t *   @option {Object} parent the value's immediate parent\n\t *   @option {can.Map|can.compute} rootObserve the first observable to read from.\n\t *   @option {Array<String>} reads An array of properties that can be used to read from the rootObserve to get the value.\n\t *   @option {*} value the found value\n\t */\n\tread: function(attr, options) {\n\t\toptions = options || {};\n\n\t\t// make `{{./}}` an alias for `{{.}}`\n\t\tif (attr === \"./\") {\n\t\t\tattr = \".\";\n\t\t}\n\n\t\t// Identify context based keys. Context based keys try to\n\t\t// specify a particular context a key should be within.\n\t\tvar keyInfo = Scope.keyInfo(attr);\n\n\t\t// `notContext` contexts should be skipped if the key is \"context based\".\n\t\t// For example, the context that holds `%index`.\n\t\tif (keyInfo.isContextBased && (this._meta.notContext || this._meta.special)) {\n\t\t\treturn this._parent.read(attr, options);\n\t\t}\n\n\t\t// If true, lookup stops after the current context.\n\t\tvar currentScopeOnly = \"currentScopeOnly\" in options ? options.currentScopeOnly : true;\n\n\t\tif (keyInfo.isInCurrentContext) {\n\t\t\t// Stop lookup from checking parent scopes.\n\t\t\t// Set flag to halt lookup from walking up scope.\n\t\t\tcurrentScopeOnly = true;\n\t\t\tattr = keyInfo.isDotSlash ? attr.substr(2) : attr.substr(5);\n\t\t} else if ((keyInfo.isInParentContext || keyInfo.isParentContext) && this._parent) {\n\t\t\t// walk up until we find a parent that can have context.\n\t\t\t// the `isContextBased` check above won't catch it when you go from\n\t\t\t// `../foo` to `foo` because `foo` isn't context based.\n\t\t\tvar parent = this._parent;\n\t\t\twhile (parent._meta.notContext || parent._meta.special) {\n\t\t\t\tparent = parent._parent;\n\t\t\t}\n\n\t\t\tif (keyInfo.isParentContext) {\n\t\t\t\treturn observeReader.read(parent._context, [], options);\n\t\t\t}\n\n\t\t\tvar parentValue = parent.read(attr.substr(3) || \".\", options);\n\n\t\t\treturn assign( parentValue, {\n\t\t\t\tthisArg: parentValue.thisArg || parent._context\n\t\t\t});\n\t\t} else if (keyInfo.isCurrentContext) {\n\t\t\treturn observeReader.read(this._context, [], options);\n\t\t} else if (keyInfo.isScope) {\n\t\t\treturn { value: this };\n\t\t}\n\n\t\tvar keyReads = observeReader.reads(attr);\n\t\tvar readValue;\n\n\t\tif (keyInfo.isInScope) {\n\t\t\t// check for a value on Scope.prototype\n\t\t\treadValue = observeReader.read(this, keyReads.slice(1), options);\n\n\t\t\t// otherwise, check the templateContext\n\t\t\tif (typeof readValue.value === 'undefined' && !readValue.parentHasKey) {\n\t\t\t\treadValue = this.readFromTemplateContext(attr.slice(6), options);\n\t\t\t}\n\n\t\t\treturn assign(readValue, {\n\t\t\t\tthisArg: keyReads.length > 1 ? readValue.parent : undefined\n\t\t\t});\n\t\t}\n\n\t\treturn this._read(keyReads, options, currentScopeOnly);\n\t},\n\n\t// ## Scope.prototype.readFromSpecialContext\n\treadFromSpecialContext: function(key) {\n\t\treturn this._read(\n\t\t\t[{key: key, at: false }],\n\t\t\t{ special: true }\n\t\t);\n\t},\n\n\t// ## Scope.prototype.readFromTemplateContext\n\treadFromTemplateContext: function(key, readOptions) {\n\t\tvar keyReads = observeReader.reads(key);\n\t\treturn observeReader.read(this.templateContext, keyReads, readOptions);\n\t},\n\n\t// ## Scope.prototype._read\n\t//\n\t_read: function(keyReads, options, currentScopeOnly) {\n\t\t// The current scope and context we are trying to find \"keyReads\" within.\n\t\tvar currentScope = this,\n\t\t\tcurrentContext,\n\n\t\t\t// If no value can be found, this is a list of of every observed\n\t\t\t// object and property name to observe.\n\t\t\tundefinedObserves = [],\n\n\t\t\t// Tracks the first found observe.\n\t\t\tcurrentObserve,\n\t\t\t// Tracks the reads to get the value from `currentObserve`.\n\t\t\tcurrentReads,\n\n\t\t\t// Tracks the most likely observable to use as a setter.\n\t\t\tsetObserveDepth = -1,\n\t\t\tcurrentSetReads,\n\t\t\tcurrentSetObserve,\n\n\t\t\treadOptions = assign({\n\t\t\t\t/* Store found observable, incase we want to set it as the rootObserve. */\n\t\t\t\tfoundObservable: function(observe, nameIndex) {\n\t\t\t\t\tcurrentObserve = observe;\n\t\t\t\t\tcurrentReads = keyReads.slice(nameIndex);\n\t\t\t\t},\n\t\t\t\tearlyExit: function(parentValue, nameIndex) {\n\t\t\t\t\tif (nameIndex > setObserveDepth || (nameIndex === setObserveDepth && (typeof parentValue === \"object\" && keyReads[nameIndex].key in parentValue))) {\n\t\t\t\t\t\tcurrentSetObserve = currentObserve;\n\t\t\t\t\t\tcurrentSetReads = currentReads;\n\t\t\t\t\t\tsetObserveDepth = nameIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, options);\n\n\t\tvar isRecording = ObservationRecorder.isRecording();\n\n\t\t// Goes through each scope context provided until it finds the key (attr). Once the key is found\n\t\t// then it's value is returned along with an observe, the current scope and reads.\n\t\t// While going through each scope context searching for the key, each observable found is returned and\n\t\t// saved so that either the observable the key is found in can be returned, or in the case the key is not\n\t\t// found in an observable the closest observable can be returned.\n\t\twhile (currentScope) {\n\t\t\tcurrentContext = currentScope._context;\n\n\t\t\t// skip this if it _is_ a special context and we aren't explicitly reading special contexts\n\t\t\tif ((!options || options.special !== true) && currentScope._meta.special) {\n\t\t\t\tcurrentScope = currentScope._parent;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// skip this if we _are_ explicitly reading special contexts and this context is _not_ special\n\t\t\tif (options && options.special && !currentScope._meta.special) {\n\t\t\t\tcurrentScope = currentScope._parent;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currentContext !== null &&\n\t\t\t\t// if its a primitive type, keep looking up the scope, since there won't be any properties\n\t\t\t\t(typeof currentContext === \"object\" || typeof currentContext === \"function\")\n\t\t\t) {\n\t\t\t\t// Prevent computes from temporarily observing the reading of observables.\n\t\t\t\tvar getObserves = ObservationRecorder.trap();\n\n\t\t\t\tvar data = observeReader.read(currentContext, keyReads, readOptions);\n\n\t\t\t\t// Retrieve the observes that were read.\n\t\t\t\tvar observes = getObserves();\n\t\t\t\t// If a **value was was found**, return value and location data.\n\t\t\t\tif (data.value !== undefined || data.parentHasKey) {\n\n\t\t\t\t\tif(!observes.length && isRecording) {\n\t\t\t\t\t\t// if we didn't actually observe anything\n\t\t\t\t\t\t// the reads and currentObserve don't mean anything\n\t\t\t\t\t\t// we just point to the current object so setting is fast\n\t\t\t\t\t\tcurrentObserve = data.parent;\n\t\t\t\t\t\tcurrentReads = keyReads.slice(keyReads.length - 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObservationRecorder.addMany(observes);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tscope: currentScope,\n\t\t\t\t\t\trootObserve: currentObserve,\n\t\t\t\t\t\tvalue: data.value,\n\t\t\t\t\t\treads: currentReads,\n\t\t\t\t\t\tthisArg: keyReads.length > 1 ? data.parent : undefined,\n\t\t\t\t\t\tparentHasKey: data.parentHasKey\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Otherwise, save all observables that were read. If no value\n\t\t\t\t// is found, we will observe on all of them.\n\t\t\t\telse {\n\t\t\t\t\tundefinedObserves.push.apply(undefinedObserves, observes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar parentIsNormalContext = currentScope._parent && currentScope._parent._meta &&\n\t\t\t\t!currentScope._parent._meta.notContext && !currentScope._parent._meta.special;\n\n\t\t\tif (currentScopeOnly && parentIsNormalContext) {\n\t\t\t\tcurrentScope = null;\n\t\t\t} else {\n\t\t\t\t// Move up to the next scope.\n\t\t\t\tcurrentScope = currentScope._parent;\n\t\t\t}\n\t\t}\n\n\t\t// The **value was not found** in the scope\n\t\t// if not looking for a \"special\" key, check in can-stache-helpers\n\t\tif (!(options && options.special)) {\n\t\t\tvar helper = this.getHelper(keyReads);\n\n\t\t\tif (helper && helper.value) {\n\t\t\t\treturn helper;\n\t\t\t}\n\t\t}\n\n\t\t// The **value was not found**, return `undefined` for the value.\n\t\t// Make sure we listen to everything we checked for when the value becomes defined.\n\t\t// Once it becomes defined, we won't have to listen to so many things.\n\t\tObservationRecorder.addMany(undefinedObserves);\n\t\treturn {\n\t\t\tsetRoot: currentSetObserve,\n\t\t\treads: currentSetReads,\n\t\t\tvalue: undefined\n\t\t};\n\t},\n\n\t// ## Scope.prototype.getHelper\n\t// read a helper from the templateContext or global helpers list\n\tgetHelper: function(keyReads) {\n\t\tvar helper = observeReader.read(this.templateContext.helpers, keyReads, { proxyMethods: false });\n\n\t\tif (!helper || !helper.value) {\n\t\t\thelper = observeReader.read(stacheHelpers, keyReads, { proxyMethods: false });\n\t\t}\n\n\t\treturn helper;\n\t},\n\n\t// ## Scope.prototype.get\n\t// Gets a value from the scope without being observable.\n\tget: function(key, options) {\n\n\t\toptions = assign({\n\t\t\tisArgument: true\n\t\t}, options);\n\n\t\tvar res = this.read(key, options);\n\t\treturn res.value;\n\t},\n\tpeek: ObservationRecorder.ignore(function(key, options) {\n\t\treturn this.get(key, options);\n\t}),\n\tpeak: ObservationRecorder.ignore(function(key, options) {\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tcanLog.warn('peak is deprecated, please use peek instead');\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn this.peek(key, options);\n\t}),\n\t// ## Scope.prototype.getScope\n\t// Returns the first scope that passes the `tester` function.\n\tgetScope: function(tester) {\n\t\tvar scope = this;\n\t\twhile (scope) {\n\t\t\tif (tester(scope)) {\n\t\t\t\treturn scope;\n\t\t\t}\n\t\t\tscope = scope._parent;\n\t\t}\n\t},\n\t// ## Scope.prototype.getContext\n\t// Returns the first context whose scope passes the `tester` function.\n\tgetContext: function(tester) {\n\t\tvar res = this.getScope(tester);\n\t\treturn res && res._context;\n\t},\n\t// ## Scope.prototype.getTemplateContext\n\t// Returns the template context\n\tgetTemplateContext: function() {\n\t\tvar lastScope;\n\n\t\t// find the first reference scope\n\t\tvar templateContext = this.getScope(function(scope) {\n\t\t\tlastScope = scope;\n\t\t\treturn scope._context instanceof TemplateContext;\n\t\t});\n\n\t\t// if there is no reference scope, add one as the root\n\t\tif(!templateContext) {\n\t\t\ttemplateContext = new Scope(new TemplateContext());\n\n\t\t\t// add templateContext to root of the scope chain so it\n\t\t\t// can be found using `getScope` next time it is looked up\n\t\t\tlastScope._parent = templateContext;\n\t\t}\n\t\treturn templateContext;\n\t},\n\t// ## Scope.prototype.getRoot\n\t// Returns the top most context that is not a references scope.\n\t// Used by `.read` to provide `%root`.\n\tgetRoot: function() {\n\t\tvar cur = this,\n\t\t\tchild = this;\n\n\t\twhile (cur._parent) {\n\t\t\tchild = cur;\n\t\t\tcur = cur._parent;\n\t\t}\n\n\t\tif (cur._context instanceof TemplateContext) {\n\t\t\tcur = child;\n\t\t}\n\t\treturn cur._context;\n\t},\n\n\t// first viewModel scope\n\tgetViewModel: function() {\n\t\tvar vmScope = this.getScope(function(scope) {\n\t\t\treturn scope._meta.viewModel;\n\t\t});\n\n\t\treturn vmScope && vmScope._context;\n\t},\n\n\t// _top_ viewModel scope\n\tgetTop: function() {\n\t\tvar top;\n\n\t\tthis.getScope(function(scope) {\n\t\t\tif (scope._meta.viewModel) {\n\t\t\t\ttop = scope;\n\t\t\t}\n\n\t\t\t// walk entire scope tree\n\t\t\treturn false;\n\t\t});\n\n\t\treturn top && top._context;\n\t},\n\n\t// ## Scope.prototype.getPathsForKey\n\t// Finds all paths that will return a value for a specific key\n\t// NOTE: this is for development purposes only and is removed in production\n\tgetPathsForKey: function getPathsForKey(key) {\n\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\tvar paths = {};\n\n\t\t\tvar getKeyDefinition = function(obj, key) {\n\t\t\t\tif (!obj || typeof obj !== \"object\") {\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\n\t\t\t\tvar keyExistsOnObj = key in obj;\n\t\t\t\tvar objHasKey = canReflect.hasKey(obj, key);\n\n\t\t\t\treturn {\n\t\t\t\t\tisDefined: keyExistsOnObj || objHasKey,\n\t\t\t\t\tisFunction: keyExistsOnObj && typeof obj[key] === \"function\"\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// scope.foo@bar -> bar\n\t\t\tvar reads = observeReader.reads(key);\n\t\t\tvar keyParts = reads.map(function(read) {\n\t\t\t\treturn read.key;\n\t\t\t});\n\t\t\tvar scopeIndex = keyParts.indexOf(\"scope\");\n\n\t\t\tif (scopeIndex > -1) {\n\t\t\t\tkeyParts.splice(scopeIndex, 2);\n\t\t\t}\n\t\t\tvar normalizedKey = keyParts.join(\".\");\n\n\t\t\t// check scope.vm.<key>\n\t\t\tvar vm = this.getViewModel();\n\t\t\tvar vmKeyDefinition = getKeyDefinition(vm, normalizedKey);\n\n\t\t\tif (vmKeyDefinition.isDefined) {\n\t\t\t\tpaths[\"scope.vm.\" + normalizedKey + (vmKeyDefinition.isFunction ? \"()\" : \"\")] = vm;\n\t\t\t}\n\n\t\t\t// check scope.top.<key>\n\t\t\tvar top = this.getTop();\n\t\t\tvar topKeyDefinition = getKeyDefinition(top, normalizedKey);\n\n\t\t\tif (topKeyDefinition.isDefined) {\n\t\t\t\tpaths[\"scope.top.\" + normalizedKey + (topKeyDefinition.isFunction ? \"()\" : \"\")] = top;\n\t\t\t}\n\n\t\t\t// find specific paths (like ../key)\n\t\t\tvar cur = \"\";\n\n\t\t\tthis.getScope(function(scope) {\n\t\t\t\t// `notContext` and `special` contexts can't be read using `../`\n\t\t\t\tvar canBeRead = !scope._meta.special &&  !scope._meta.notContext;\n\n\t\t\t\tif (canBeRead) {\n\t\t\t\t\tvar contextKeyDefinition = getKeyDefinition(scope._context, normalizedKey);\n\t\t\t\t\tif (contextKeyDefinition.isDefined) {\n\t\t\t\t\t\tpaths[cur + normalizedKey + (contextKeyDefinition.isFunction ? \"()\" : \"\")] = scope._context;\n\t\t\t\t\t}\n\n\t\t\t\t\tcur += \"../\";\n\t\t\t\t}\n\n\t\t\t\t// walk entire scope tree\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\t\treturn paths;\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\n\t// ## Scope.prototype.hasKey\n\t// returns whether or not this scope has the key\n\thasKey: function hasKey(key) {\n\t\tvar reads = observeReader.reads(key);\n\t\tvar readValue;\n\n\t\tif (reads[0].key === \"scope\") {\n\t\t\t// read properties like `scope.vm.foo` directly from the scope\n\t\t\treadValue = observeReader.read(this, reads.slice(1), key);\n\t\t} else {\n\t\t\t// read normal properties from the scope's context\n\t\t\treadValue = observeReader.read(this._context, reads, key);\n\t\t}\n\n\t\treturn readValue.foundLastParent && readValue.parentHasKey;\n\t},\n\n\t// ## Scope.prototype.getDataForScopeSet\n\t// Returns an object with data needed by `.set` to figure out what to set,\n\t// and how.\n\tgetDataForScopeSet: function getDataForScopeSet(key, options) {\n\t\tvar keyInfo = Scope.keyInfo(key),\n\t\t\tparent;\n\n\t\t// Use `.read` to read everything upto, but not including the last property\n\t\t// name to find the object we want to set some property on.\n\t\t// For example:\n\t\t//  - `foo.bar` -> `foo`\n\t\t//  - `../foo.bar` -> `../foo`\n\t\t//  - `../foo` -> `..`\n\t\t//  - `foo` -> `.`\n\t\tif (keyInfo.isCurrentContext) {\n\t\t\treturn { parent: this._context, how: \"setValue\" };\n\t\t} else if (keyInfo.isInParentContext || keyInfo.isParentContext) {\n\t\t\t// walk up until we find a parent that can have context.\n\t\t\t// the `isContextBased` check above won't catch it when you go from\n\t\t\t// `../foo` to `foo` because `foo` isn't context based.\n\t\t\tparent = this._parent;\n\t\t\twhile (parent._meta.notContext) {\n\t\t\t\tparent = parent._parent;\n\t\t\t}\n\n\t\t\tif (keyInfo.isParentContext) {\n\t\t\t\treturn { parent: parent._context, how: \"setValue\" };\n\t\t\t}\n\t\t\t// key starts with \"../\" or is \".\"\n\t\t\treturn { how: \"set\", parent: parent, passOptions: true, key: key.substr(3) || \".\" };\n\t\t}\n\n\t\tvar dotIndex = key.lastIndexOf('.'),\n\t\t\tslashIndex = key.lastIndexOf('/'),\n\t\t\tcontextPath,\n\t\t\tpropName;\n\n\t\tif (slashIndex > dotIndex) {\n\t\t\t// ../foo\n\t\t\tcontextPath = key.substring(0, slashIndex);\n\t\t\tpropName = key.substring(slashIndex + 1, key.length);\n\t\t} else {\n\t\t\tif (dotIndex !== -1) {\n\t\t\t\t// ./foo\n\t\t\t\tcontextPath = key.substring(0, dotIndex);\n\t\t\t\tpropName = key.substring(dotIndex + 1, key.length);\n\t\t\t} else {\n\t\t\t\t// foo.bar\n\t\t\t\tcontextPath = \".\";\n\t\t\t\tpropName = key;\n\t\t\t}\n\t\t}\n\n\t\tvar context = this.read(contextPath, options).value;\n\t\tif (context === undefined) {\n\t\t\treturn {\n\t\t\t\terror: \"Attempting to set a value at \" +\n\t\t\t\t\tkey + \" where \" + contextPath + \" is undefined.\"\n\t\t\t};\n\t\t}\n\n\t\tif(!canReflect.isObservableLike(context) && canReflect.isObservableLike(context[propName])) {\n\t\t\tif(canReflect.isMapLike(context[propName])) {\n\t\t\t\treturn {\n\t\t\t\t\tparent: context,\n\t\t\t\t\tkey: propName,\n\t\t\t\t\thow: \"updateDeep\",\n\t\t\t\t\twarn: \"can-view-scope: Merging data into \\\"\" +\n\t\t\t\t\t\tpropName + \"\\\" because its parent is non-observable\"\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if(canReflect.isValueLike(context[propName])){\n\t\t\t\treturn { parent: context, key: propName, how: \"setValue\" };\n\t\t\t} else {\n\t\t\t\treturn { parent: context, how: \"write\", key: propName, passOptions: true };\n\t\t\t}\n\t\t} else {\n\t\t\treturn { parent: context, how: \"write\", key: propName, passOptions: true };\n\t\t}\n\t},\n\n\tset: function(key, value, options) {\n\t\toptions = options || {};\n\n\t\tvar data = this.getDataForScopeSet(key, options);\n\t\tvar parent = data.parent;\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (data.error) {\n\t\t\t\treturn canLog.error(data.error);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif (data.warn) {\n\t\t\tcanLog.warn(data.warn);\n\t\t}\n\n\t\tswitch (data.how) {\n\t\t\tcase \"set\":\n\t\t\t\tparent.set(data.key, value, data.passOptions ? options : undefined);\n\t\t\t\tbreak;\n\n\t\t\tcase \"write\":\n\t\t\t\tobserveReader.write(parent, data.key, value, options);\n\t\t\t\tbreak;\n\n\t\t\tcase \"setValue\":\n\t\t\t\tcanReflect.setValue(\"key\" in data ? parent[data.key] : parent, value);\n\t\t\t\tbreak;\n\n\t\t\tcase \"setKeyValue\":\n\t\t\t\tcanReflect.setKeyValue(parent, data.key, value);\n\t\t\t\tbreak;\n\n\t\t\tcase \"updateDeep\":\n\t\t\t\tcanReflect.updateDeep(parent[data.key], value);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\t// ## Scope.prototype.attr\n\t// Gets or sets a value in the scope without being observable.\n\tattr: ObservationRecorder.ignore(function(key, value, options) {\n\t\tcanLog.warn(\"can-view-scope::attr is deprecated, please use peek, get or set\");\n\n\t\toptions = assign({\n\t\t\tisArgument: true\n\t\t}, options);\n\n\t\t// Allow setting a value on the context\n\t\tif (arguments.length === 2) {\n\t\t\treturn this.set(key, value, options);\n\n\t\t} else {\n\t\t\treturn this.get(key, options);\n\t\t}\n\t}),\n\n\t// ## Scope.prototype.computeData\n\t// Finds the first location of the key in the scope and then provides a get-set compute that represents the key's value\n\t// and other information about where the value was found.\n\tcomputeData: function(key, options) {\n\t\treturn makeComputeData(this, key, options);\n\t},\n\n\t// ## Scope.prototype.compute\n\t// Provides a get-set compute that represents a key's value.\n\tcompute: function(key, options) {\n\t\treturn this.computeData(key, options)\n\t\t\t.compute;\n\t},\n\t// ## Scope.prototype.cloneFromRef\n\t//\n\t// This takes a scope and essentially copies its chain from\n\t// right before the last TemplateContext. And it does not include the ref.\n\t// this is a helper function to provide lexical semantics for refs.\n\t// This will not be needed for leakScope: false.\n\tcloneFromRef: function() {\n\t\tvar contexts = [];\n\t\tvar scope = this,\n\t\t\tcontext,\n\t\t\tparent;\n\t\twhile (scope) {\n\t\t\tcontext = scope._context;\n\t\t\tif (context instanceof TemplateContext) {\n\t\t\t\tparent = scope._parent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontexts.unshift(context);\n\t\t\tscope = scope._parent;\n\t\t}\n\t\tif (parent) {\n\t\t\tcontexts.forEach(function(context) {\n\t\t\t\tparent = parent.add(context);\n\t\t\t});\n\t\t\treturn parent;\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t}\n});\n\ncanReflect.assignSymbols(Scope.prototype, {\n\t\"can.hasKey\": Scope.prototype.hasKey\n});\n\nvar templateContextPrimitives = [\n\t\"filename\", \"lineNumber\"\n];\n\n// create getters/setters for primitives on the templateContext\n// scope.filename -> scope.readFromTemplateContext(\"filename\")\ntemplateContextPrimitives.forEach(function(key) {\n\tObject.defineProperty(Scope.prototype, key, {\n\t\tget: function() {\n\t\t\treturn this.readFromTemplateContext(key).value;\n\t\t},\n\t\tset: function(val) {\n\t\t\tthis.templateContext[key] = val;\n\t\t}\n\t});\n});\n\ndefineLazyValue(Scope.prototype, 'templateContext', function() {\n\treturn this.getTemplateContext()._context;\n});\n\ndefineLazyValue(Scope.prototype, 'root', function() {\n\tcanLog.warn('`scope.root` is deprecated. Use either `scope.top` or `scope.vm` instead.');\n\treturn this.getRoot();\n});\n\ndefineLazyValue(Scope.prototype, 'vm', function() {\n\treturn this.getViewModel();\n});\n\ndefineLazyValue(Scope.prototype, 'top', function() {\n\treturn this.getTop();\n});\n\ndefineLazyValue(Scope.prototype, 'helpers', function() {\n\treturn stacheHelpers;\n});\n\nvar specialKeywords = [\n\t'index', 'key', 'element',\n\t'event', 'viewModel','arguments',\n\t'helperOptions'\n];\n\n// create getters for \"special\" keys\n// scope.index -> scope.readFromSpecialContext(\"index\")\nspecialKeywords.forEach(function(key) {\n\tObject.defineProperty(Scope.prototype, key, {\n\t\tget: function() {\n\t\t\treturn this.readFromSpecialContext(key).value;\n\t\t}\n\t});\n});\n\nnamespace.view = namespace.view || {};\nmodule.exports = namespace.view.Scope = Scope;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-scope/can-view-scope.js?");

/***/ }),

/***/ "../../node_modules/can-view-scope/compute_data.js":
/*!************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-scope/compute_data.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ScopeKeyData = __webpack_require__(/*! ./scope-key-data */ \"../../node_modules/can-view-scope/scope-key-data.js\");\n\nmodule.exports = function(scope, key, options){\n\treturn new ScopeKeyData(scope, key, options || {\n\t\targs: []\n\t});\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-scope/compute_data.js?");

/***/ }),

/***/ "../../node_modules/can-view-scope/make-compute-like.js":
/*!*****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-scope/make-compute-like.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar singleReference = __webpack_require__(/*! can-single-reference */ \"../../node_modules/can-single-reference/can-single-reference.js\");\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\n\nvar Compute = function(newVal){\n\tif(arguments.length) {\n\t\treturn canReflect.setValue(this, newVal);\n\t} else {\n\t\treturn canReflect.getValue(this);\n\t}\n};\n\nmodule.exports = function(observable) {\n    var compute = Compute.bind(observable);\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tObject.defineProperty(compute, \"name\", {\n\t\t\tvalue: \"Compute<\"+canReflect.getName(observable) + \">\",\n\t\t});\n\t}\n\t//!steal-remove-end\n\n    compute.on = compute.bind = compute.addEventListener = function(event, handler) {\n        var translationHandler = function(newVal, oldVal) {\n            handler.call(compute, {type:'change'}, newVal, oldVal);\n        };\n        singleReference.set(handler, this, translationHandler);\n        observable.on(translationHandler);\n    };\n    compute.off = compute.unbind = compute.removeEventListener = function(event, handler) {\n        observable.off( singleReference.getAndDelete(handler, this) );\n    };\n\n    canReflect.assignSymbols(compute, {\n        \"can.getValue\": function(){\n            return canReflect.getValue(observable);\n        },\n        \"can.setValue\": function(newVal){\n            return canReflect.setValue(observable, newVal);\n        },\n        \"can.onValue\": function(handler, queue){\n            return canReflect.onValue(observable, handler, queue);\n        },\n        \"can.offValue\": function(handler, queue){\n            return canReflect.offValue(observable, handler, queue);\n        },\n        \"can.valueHasDependencies\": function(){\n            return canReflect.valueHasDependencies(observable);\n        },\n        \"can.getPriority\": function(){\n    \t\treturn canReflect.getPriority( observable );\n    \t},\n    \t\"can.setPriority\": function(newPriority){\n    \t\tcanReflect.setPriority( observable, newPriority );\n    \t},\n\t\t\"can.isValueLike\": true,\n\t\t\"can.isFunctionLike\": false\n    });\n    compute.isComputed = true;\n    return compute;\n};\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-scope/make-compute-like.js?");

/***/ }),

/***/ "../../node_modules/can-view-scope/scope-key-data.js":
/*!**************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-scope/scope-key-data.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observation = __webpack_require__(/*! can-observation */ \"../../node_modules/can-observation/can-observation.js\");\nvar observeReader = __webpack_require__(/*! can-stache-key */ \"../../node_modules/can-stache-key/can-stache-key.js\");\nvar assign = __webpack_require__(/*! can-assign */ \"../../node_modules/can-assign/dist/cjs/can-assign.js\");\n\nvar canReflect = __webpack_require__(/*! can-reflect */ \"../../node_modules/can-reflect/can-reflect.js\");\nvar canSymbol = __webpack_require__(/*! can-symbol */ \"../../node_modules/can-symbol/can-symbol.js\");\nvar ObservationRecorder = __webpack_require__(/*! can-observation-recorder */ \"../../node_modules/can-observation-recorder/can-observation-recorder.js\");\nvar makeComputeLike = __webpack_require__(/*! ./make-compute-like */ \"../../node_modules/can-view-scope/make-compute-like.js\");\nvar canReflectDeps = __webpack_require__(/*! can-reflect-dependencies */ \"../../node_modules/can-reflect-dependencies/can-reflect-dependencies.js\");\nvar valueEventBindings = __webpack_require__(/*! can-event-queue/value/value */ \"../../node_modules/can-event-queue/value/value.js\");\nvar stacheHelpers = __webpack_require__(/*! can-stache-helpers */ \"../../node_modules/can-stache-helpers/can-stache-helpers.js\");\n\nvar dispatchSymbol = canSymbol.for(\"can.dispatch\");\n\n// The goal of this is to create a high-performance compute that represents a key value from can.view.Scope.\n// If the key value is something like {{name}} and the context is a can.Map, a faster\n// binding path will be used where new rebindings don't need to be looked for with every change of\n// the observable property.\n// However, if the property changes to a compute, then the slower `can.compute.read` method of\n// observing values will be used.\n\n// ideally, we would know the order things were read.  If the last thing read\n// was something we can observe, and the value of it matched the value of the observation,\n// and the key matched the key of the observation\n// it's a fair bet that we can just listen to that last object.\n// If the `this` is not that object ... freak out.  Though `this` is not necessarily part of it.  can-observation could make\n// this work.\n\nvar peekValue = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));\n\nvar getFastPathRoot = ObservationRecorder.ignore(function(computeData){\n\tif( computeData.reads &&\n\t\t\t\t// a single property read\n\t\t\t\tcomputeData.reads.length === 1 ) {\n\t\tvar root = computeData.root;\n\t\tif( root && root[canSymbol.for(\"can.getValue\")] ) {\n\t\t\troot = canReflect.getValue(root);\n\t\t}\n\t\t// on a map\n\t\treturn root && canReflect.isObservableLike(root) && canReflect.isMapLike(root) &&\n\t\t\t// that isn't calling a function\n\t\t\ttypeof root[computeData.reads[0].key] !== \"function\" && root;\n\t}\n\treturn;\n});\n\nvar isEventObject = function(obj){\n\treturn obj && typeof obj.batchNum === \"number\" && typeof obj.type === \"string\";\n};\n\n// could we make this an observation first ... and have a getter for the compute?\n\n// This is a fast-path enabled Observation wrapper use many places in can-stache.\n// The goal of this is to:\n//\n// 1.  Make something that can be passed to can-view-live directly, hopefully\n//     avoiding creating expensive computes.  Instead we will only be creating\n//     `ScopeKeyData` which are thin wrappers.\nvar ScopeKeyData = function(scope, key, options){\n\n\tthis.startingScope = scope;\n\tthis.key = key;\n\tthis.read = this.read.bind(this);\n\tthis.dispatch = this.dispatch.bind(this);\n\n\t// special case debugger helper so that it is called with helperOtions\n\t// when you do {{debugger}} as it already is with {{debugger()}}\n\tif (key === \"debugger\") {\n\t\t// prevent \"Unable to find key\" warning\n\t\tthis.startingScope = { _context: stacheHelpers };\n\n\t\tthis.read = function() {\n\t\t\tvar helperOptions = { scope: scope };\n\t\t\tvar debuggerHelper = stacheHelpers[\"debugger\"];\n\t\t\treturn debuggerHelper(helperOptions);\n\t\t};\n\t}\n\n\t//!steal-remove-start\n\tif (true) {\n\t\tObject.defineProperty(this.read, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".read\",\n\t\t});\n\t\tObject.defineProperty(this.dispatch, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".dispatch\",\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tvar observation = this.observation = new Observation(this.read, this);\n\tthis.options = assign({ observation: this.observation }, options);\n\n\t// things added later\n\tthis.fastPath = undefined;\n\tthis.root = undefined;\n\tthis.initialValue = undefined;\n\tthis.reads = undefined;\n\tthis.setRoot = undefined;\n\tthis.thisArg = undefined;\n\tthis.parentHasKey = undefined;\n\tvar valueDependencies = new Set();\n\tvalueDependencies.add(observation);\n\tthis.dependencies = {valueDependencies: valueDependencies};\n};\n\nvalueEventBindings(ScopeKeyData.prototype);\n\nfunction fastOnBoundSet_Value() {\n\tthis._value = this.newVal;\n}\n\nfunction fastOnBoundSetValue() {\n\tthis.value = this.newVal;\n}\n\nObject.assign(ScopeKeyData.prototype, {\n\tconstructor: ScopeKeyData,\n\tdispatch: function dispatch(newVal){\n\t\tvar old = this.value;\n\t\tthis.value = newVal;\n\t\t// call the base implementation in can-event-queue\n\t\tthis[dispatchSymbol].call(this, this.value, old);\n\t},\n\tonBound: function onBound(){\n\t\tthis.bound = true;\n\t\tcanReflect.onValue(this.observation, this.dispatch, \"notify\");\n\t\t// TODO: we should check this sometime in the background.\n\t\tvar fastPathRoot = getFastPathRoot(this);\n\t\tif( fastPathRoot ) {\n\t\t\t// rewrite the observation to call its event handlers\n\t\t\tthis.toFastPath(fastPathRoot);\n\t\t}\n\t\tthis.value = peekValue(this.observation);\n\t},\n\tonUnbound: function onUnbound() {\n\t\tthis.bound = false;\n\t\tcanReflect.offValue(this.observation, this.dispatch, \"notify\");\n\t\tthis.toSlowPath();\n\t},\n\tset: function(newVal){\n\t\tvar root = this.root || this.setRoot;\n\t\tif(root) {\n\t\t\tobserveReader.write(root, this.reads, newVal, this.options);\n\t\t} else {\n\t\t\tthis.startingScope.set(this.key, newVal, this.options);\n\t\t}\n\t},\n\tget: function() {\n\t\tif (ObservationRecorder.isRecording()) {\n\t\t\tObservationRecorder.add(this);\n\t\t\tif (!this.bound) {\n\t\t\t\tObservation.temporarilyBind(this);\n\t\t\t}\n\t\t}\n\n\t\tif (this.bound === true ) {\n\t\t\treturn this.value;\n\t\t} else {\n\t\t\treturn this.observation.get();\n\t\t}\n\t},\n\ttoFastPath: function(fastPathRoot){\n\t\tvar self = this,\n\t\t\tobservation = this.observation;\n\n\t\tthis.fastPath = true;\n\n\t\t// there won't be an event in the future ...\n\t\tobservation.dependencyChange = function(target, newVal){\n\t\t\tif(isEventObject(newVal)) {\n\t\t\t\tthrow \"no event objects!\";\n\t\t\t}\n\t\t\t// but I think we will be able to get at it b/c there should only be one\n\t\t\t// dependency we are binding to ...\n\t\t\tif(target === fastPathRoot && typeof newVal !== \"function\") {\n\t\t\t\tthis.newVal = newVal;\n\t\t\t} else {\n\t\t\t\t// restore\n\t\t\t\tself.toSlowPath();\n\t\t\t}\n\n\t\t\treturn Observation.prototype.dependencyChange.apply(this, arguments);\n\t\t};\n\n\t\tif (observation.hasOwnProperty(\"_value\")) {// can-observation 4.1+\n\t\t\tobservation.onBound = fastOnBoundSet_Value;\n\t\t} else {// can-observation < 4.1\n\t\t\tobservation.onBound = fastOnBoundSetValue;\n\t\t}\n\t},\n\ttoSlowPath: function(){\n\t\tthis.observation.dependencyChange = Observation.prototype.dependencyChange;\n\t\tthis.observation.onBound = Observation.prototype.onBound;\n\t\tthis.fastPath = false;\n\t},\n\tread: function(){\n\t\tvar data;\n\n\t\tif (this.root) {\n\t\t\t// if we've figured out a root observable, start reading from there\n\t\t\tdata = observeReader.read(this.root, this.reads, this.options);\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t// remove old dependency\n\t\t\t\tcanReflectDeps.deleteMutatedBy(\n\t\t\t\t\t// for properties like foo.bar add the dependency to foo\n\t\t\t\t\tthis.thisArg || this.root,\n\t\t\t\t\tthis.reads[ this.reads.length - 1 ].key,\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\t// update thisArg and add new dependency\n\t\t\tthis.thisArg = data.parent;\n\n\t\t\t//!steal-remove-start\n\t\t\tif (true) {\n\t\t\t\tcanReflectDeps.addMutatedBy(\n\t\t\t\t\t// for properties like foo.bar add the dependency to foo\n\t\t\t\t\tthis.thisArg || this.root,\n\t\t\t\t\tthis.reads[ this.reads.length - 1 ].key,\n\t\t\t\t\t{\n\t\t\t\t\t\tvalueDependencies: new Set([ this ])\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn data.value;\n\t\t}\n\t\t// If the key has not already been located in a observable then we need to search the scope for the\n\t\t// key.  Once we find the key then we need to return it's value and if it is found in an observable\n\t\t// then we need to store the observable so the next time this compute is called it can grab the value\n\t\t// directly from the observable.\n\t\tdata = this.startingScope.read(this.key, this.options);\n\n\t\t//!steal-remove-start\n\t\tif (true) {\n\t\t\tif (data.rootObserve) {\n\t\t\t\tcanReflectDeps.addMutatedBy(\n\t\t\t\t\t// for properties like foo.bar add the dependency to foo\n\t\t\t\t\tdata.thisArg || data.rootObserve,\n\t\t\t\t\tdata.reads[ data.reads.length - 1 ].key,\n\t\t\t\t\t{\n\t\t\t\t\t\tvalueDependencies: new Set([ this ])\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tthis.scope = data.scope;\n\t\tthis.reads = data.reads;\n\t\tthis.root = data.rootObserve;\n\t\tthis.setRoot = data.setRoot;\n\t\tthis.thisArg = data.thisArg;\n\t\tthis.parentHasKey = data.parentHasKey;\n\t\treturn this.initialValue = data.value;\n\t},\n\thasDependencies: function(){\n\t\treturn canReflect.valueHasDependencies( this.observation );\n\t}\n});\n\nvar scopeKeyDataPrototype = {\n\t\"can.getValue\": ScopeKeyData.prototype.get,\n\t\"can.setValue\": ScopeKeyData.prototype.set,\n\t\"can.valueHasDependencies\": ScopeKeyData.prototype.hasDependencies,\n\t\"can.getValueDependencies\": function() {\n\t\treturn this.dependencies;\n\t},\n\t\"can.getPriority\": function(){\n\t\treturn canReflect.getPriority( this.observation );\n\t},\n\t\"can.setPriority\": function(newPriority){\n\t\tcanReflect.setPriority( this.observation, newPriority );\n\t}\n};\n\n//!steal-remove-start\nif (true) {\n\tscopeKeyDataPrototype[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"{{\" + this.key + \"}}\";\n\t};\n}\n//!steal-remove-end\ncanReflect.assignSymbols(ScopeKeyData.prototype, scopeKeyDataPrototype);\n\n// Creates a compute-like for legacy reasons ...\nObject.defineProperty(ScopeKeyData.prototype, \"compute\", {\n\tget: function(){\n\t\tvar compute = makeComputeLike(this);\n\n\t\tObject.defineProperty(this, \"compute\", {\n\t\t\tvalue: compute,\n\t\t\twritable: false,\n\t\t\tconfigurable: false\n\t\t});\n\t\treturn compute;\n\t},\n\tconfigurable: true\n});\n\nmodule.exports = ScopeKeyData;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-scope/scope-key-data.js?");

/***/ }),

/***/ "../../node_modules/can-view-scope/template-context.js":
/*!****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-scope/template-context.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar SimpleMap = __webpack_require__(/*! can-simple-map */ \"../../node_modules/can-simple-map/can-simple-map.js\");\n\nvar TemplateContext = function() {\n\tthis.vars = new SimpleMap({});\n\tthis.helpers = new SimpleMap({});\n\tthis.partials = new SimpleMap({});\n\tthis.tags = new SimpleMap({});\n};\n\nmodule.exports = TemplateContext;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-scope/template-context.js?");

/***/ }),

/***/ "../../node_modules/can-view-target/can-view-target.js":
/*!****************************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/can-view-target/can-view-target.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* jshint maxdepth:7 */\n/* jshint latedef:false */\nvar getDocument = __webpack_require__(/*! can-globals/document/document */ \"../../node_modules/can-globals/document/document.js\");\nvar domMutate = __webpack_require__(/*! can-dom-mutate/node */ \"../../node_modules/can-dom-mutate/node.js\");\nvar namespace = __webpack_require__(/*! can-namespace */ \"../../node_modules/can-namespace/can-namespace.js\");\nvar MUTATION_OBSERVER = __webpack_require__(/*! can-globals/mutation-observer/mutation-observer */ \"../../node_modules/can-globals/mutation-observer/mutation-observer.js\");\n\n// if an object or a function\n// convert into what it should look like\n// then the modification can happen in place\n// but it has to have more than the current node\n// blah!\nvar processNodes = function(nodes, paths, location, document){\n\tvar frag = document.createDocumentFragment();\n\n\tfor(var i = 0, len = nodes.length; i < len; i++) {\n\t\tvar node = nodes[i];\n\t\tfrag.appendChild( processNode(node,paths,location.concat(i), document) );\n\t}\n\treturn frag;\n},\n\tkeepsTextNodes =  typeof document !== \"undefined\" && (function(){\n\t\tvar testFrag = document.createDocumentFragment();\n\t\tvar div = document.createElement(\"div\");\n\n\t\tdiv.appendChild(document.createTextNode(\"\"));\n\t\tdiv.appendChild(document.createTextNode(\"\"));\n\t\ttestFrag.appendChild(div);\n\n\t\tvar cloned  = testFrag.cloneNode(true);\n\n\t\treturn cloned.firstChild.childNodes.length === 2;\n\t})(),\n\tclonesWork = typeof document !== \"undefined\" && (function(){\n\t\t// Since html5shiv is required to support custom elements, assume cloning\n\t\t// works in any browser that doesn't have html5shiv\n\n\t\t// Clone an element containing a custom tag to see if the innerHTML is what we\n\t\t// expect it to be, or if not it probably was created outside of the document's\n\t\t// namespace.\n\t\tvar el = document.createElement('a');\n\t\tel.innerHTML = \"<xyz></xyz>\";\n\t\tvar clone = el.cloneNode(true);\n\t\tvar works = clone.innerHTML === \"<xyz></xyz>\";\n\t\tvar MO, observer;\n\n\t\tif(works) {\n\t\t\t// Cloning text nodes with dashes seems to create multiple nodes in IE11 when\n\t\t\t// MutationObservers of subtree modifications are used on the documentElement.\n\t\t\t// Since this is not what we expect we have to include detecting it here as well.\n\t\t\tel = document.createDocumentFragment();\n\t\t\tel.appendChild(document.createTextNode('foo-bar'));\n\n\t\t\tMO = MUTATION_OBSERVER();\n\n\t\t\tif (MO) {\n\t\t\t\tobserver = new MO(function() {});\n\t\t\t\tobserver.observe(document.documentElement, { childList: true, subtree: true });\n\n\t\t\t\tclone = el.cloneNode(true);\n\n\t\t\t\tobserver.disconnect();\n\t\t\t} else {\n\t\t\t\tclone = el.cloneNode(true);\n\t\t\t}\n\n\t\t\treturn clone.childNodes.length === 1;\n\t\t}\n\n\t\treturn works;\n\t})(),\n\tnamespacesWork = typeof document !== \"undefined\" && !!document.createElementNS;\n\n/**\n * @function cloneNode\n * @hide\n *\n * A custom cloneNode function to be used in browsers that properly support cloning\n * of custom tags (IE8 for example). Fixes it by doing some manual cloning that\n * uses innerHTML instead, which has been shimmed.\n *\n * @param {DocumentFragment} frag A document fragment to clone\n * @return {DocumentFragment} a new fragment that is a clone of the provided argument\n */\nvar cloneNode = clonesWork ?\n\tfunction(el){\n\t\treturn el.cloneNode(true);\n\t} :\n\tfunction(node){\n\t\tvar document = node.ownerDocument;\n\t\tvar copy;\n\n\t\tif(node.nodeType === 1) {\n\t\t\tif(node.namespaceURI !== 'http://www.w3.org/1999/xhtml' && namespacesWork && document.createElementNS) {\n\t\t\t\tcopy = document.createElementNS(node.namespaceURI, node.nodeName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcopy = document.createElement(node.nodeName);\n\t\t\t}\n\t\t} else if(node.nodeType === 3){\n\t\t\tcopy = document.createTextNode(node.nodeValue);\n\t\t} else if(node.nodeType === 8) {\n\t\t\tcopy = document.createComment(node.nodeValue);\n\t\t} else if(node.nodeType === 11) {\n\t\t\tcopy = document.createDocumentFragment();\n\t\t}\n\n\t\tif(node.attributes) {\n\t\t\tvar attributes = node.attributes;\n\t\t\tfor (var i = 0; i < attributes.length; i++) {\n\t\t\t\tvar attribute = attributes[i];\n\t\t\t\tif (attribute && attribute.specified) {\n\t\t\t\t\tdomMutate.setAttribute.call(copy, attribute.nodeName || attribute.name, attribute.nodeValue || attribute.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(node && node.firstChild) {\n\t\t\tvar child = node.firstChild;\n\n\t\t\twhile(child) {\n\t\t\t\tcopy.appendChild( cloneNode(child) );\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\t\t}\n\n\t\treturn copy;\n\t};\n\nfunction processNode(node, paths, location, document){\n\tvar callback,\n\t\tloc = location,\n\t\tnodeType = typeof node,\n\t\tel,\n\t\tp,\n\t\ti , len;\n\tvar getCallback = function(){\n\t\tif(!callback) {\n\t\t\tcallback  = {\n\t\t\t\tpath: location,\n\t\t\t\tcallbacks: []\n\t\t\t};\n\t\t\tpaths.push(callback);\n\t\t\tloc = [];\n\t\t}\n\t\treturn callback;\n\t};\n\n\tif(nodeType === \"object\") {\n\t\tif( node.tag ) {\n\t\t\tif(namespacesWork && node.namespace) {\n\t\t\t\tel = document.createElementNS(node.namespace, node.tag);\n\t\t\t} else {\n\t\t\t\tel = document.createElement(node.tag);\n\t\t\t}\n\n\t\t\tif(node.attrs) {\n\t\t\t\tfor(var attrName in node.attrs) {\n\t\t\t\t\tvar value = node.attrs[attrName];\n\t\t\t\t\tif(typeof value === \"function\"){\n\t\t\t\t\t\tgetCallback().callbacks.push({\n\t\t\t\t\t\t\tcallback:  value\n\t\t\t\t\t\t});\n\t\t\t\t\t} else  {\n\t\t\t\t\t\tdomMutate.setAttribute.call(el, attrName, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(node.attributes) {\n\t\t\t\tfor(i = 0, len = node.attributes.length; i < len; i++ ) {\n\t\t\t\t\tgetCallback().callbacks.push({callback: node.attributes[i]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(node.children && node.children.length) {\n\t\t\t\t// add paths\n\t\t\t\tif(callback) {\n\t\t\t\t\tp = callback.paths = [];\n\t\t\t\t} else {\n\t\t\t\t\tp = paths;\n\t\t\t\t}\n\n\t\t\t\tel.appendChild( processNodes(node.children, p, loc, document) );\n\t\t\t}\n\t\t} else if(node.comment) {\n\t\t\tel = document.createComment(node.comment);\n\n\t\t\tif(node.callbacks) {\n\t\t\t\tfor(i = 0, len = node.attributes.length; i < len; i++ ) {\n\t\t\t\t\tgetCallback().callbacks.push({callback: node.callbacks[i]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t} else if(nodeType === \"string\"){\n\n\t\tel = document.createTextNode(node);\n\n\t} else if(nodeType === \"function\") {\n\n\t\tif(keepsTextNodes) {\n\t\t\tel = document.createTextNode(\"\");\n\t\t\tgetCallback().callbacks.push({\n\t\t\t\tcallback: node\n\t\t\t});\n\t\t} else {\n\t\t\tel = document.createComment(\"~\");\n\t\t\tgetCallback().callbacks.push({\n\t\t\t\tcallback: function(){\n\t\t\t\t\tvar el = document.createTextNode(\"\");\n\t\t\t\t\tdomMutate.replaceChild.call(this.parentNode, el, this);\n\t\t\t\t\treturn node.apply(el,arguments );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t}\n\treturn el;\n}\n\nfunction getCallbacks(el, pathData, elementCallbacks){\n\tvar path = pathData.path,\n\t\tcallbacks = pathData.callbacks,\n\t\tpaths = pathData.paths,\n\t\tchild = el,\n\t\tpathLength = path ? path.length : 0,\n\t\tpathsLength = paths ? paths.length : 0;\n\n\tfor(var i = 0; i < pathLength; i++) {\n\t\tchild = child.childNodes.item(path[i]);\n\t}\n\n\tfor( i= 0 ; i < pathsLength; i++) {\n\t\tgetCallbacks(child, paths[i], elementCallbacks);\n\t}\n\n\telementCallbacks.push({element: child, callbacks: callbacks});\n}\n\nfunction hydrateCallbacks(callbacks, args) {\n\tvar len = callbacks.length,\n\t\tcallbacksLength,\n\t\tcallbackElement,\n\t\tcallbackData;\n\n\tfor(var i = 0; i < len; i++) {\n\t\tcallbackData = callbacks[i];\n\t\tcallbacksLength = callbackData.callbacks.length;\n\t\tcallbackElement = callbackData.element;\n\t\tfor(var c = 0; c < callbacksLength; c++) {\n\t\t\tcallbackData.callbacks[c].callback.apply(callbackElement, args);\n\t\t}\n\t}\n}\n\nfunction makeTarget(nodes, doc){\n\tvar paths = [];\n\tvar frag = processNodes(nodes, paths, [], doc || getDocument());\n\treturn {\n\t\tpaths: paths,\n\t\tclone: frag,\n\t\thydrate: function(){\n\t\t\tvar cloned = cloneNode(this.clone);\n\t\t\tvar args = [];\n\t\t\tfor (var a = 0, ref = args.length = arguments.length; a < ref; a++) {\n\t\t\t\targs[a] = arguments[a];\n\t\t\t} // see https://jsperf.com/nodelist-to-array\n\n\t\t\tvar callbacks = [];\n\t\t\tfor(var i = 0; i < paths.length; i++) {\n\t\t\t\tgetCallbacks(cloned, paths[i], callbacks);\n\t\t\t}\n\t\t\thydrateCallbacks(callbacks, args);\n\n\t\t\treturn cloned;\n\t\t}\n\t};\n}\nmakeTarget.keepsTextNodes = keepsTextNodes;\nmakeTarget.cloneNode = cloneNode;\n\nnamespace.view = namespace.view || {};\nmodule.exports = namespace.view.target = makeTarget;\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/can-view-target/can-view-target.js?");

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!************************************************************************************!*\
  !*** /home/cherif/server/donejs/can-stache-loader/node_modules/process/browser.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:////home/cherif/server/donejs/can-stache-loader/node_modules/process/browser.js?");

/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "../../node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "../../node_modules/webpack/buildin/system.js":
/*!***********************************!*\
  !*** (webpack)/buildin/system.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Provide a \"System\" global.\r\nmodule.exports = {\r\n\t// Make sure import is only used as \"System.import\"\r\n\timport: function() {\r\n\t\tthrow new Error(\"System.import cannot be used indirectly\");\r\n\t}\r\n};\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/system.js?");

/***/ }),

/***/ "./app.js":
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var renderer = __webpack_require__(/*! ./app.stache */ \"./app.stache\");\nvar partial = __webpack_require__(/*! ./partial.stache */ \"./partial.stache\");\nvar stache = __webpack_require__(/*! can-stache */ \"../../node_modules/can-stache/can-stache.js\");\n\nstache.registerPartial( \"partial.stache\", partial );\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n    var frag = renderer({\n\t\tmessage: 'Hello loaders',\n\t\tinlineMessage: 'Hello from inline partial'\n    })\n    document.body.appendChild(frag);\n});\n\n\n//# sourceURL=webpack:///./app.js?");

/***/ }),

/***/ "./app.stache":
/*!********************!*\
  !*** ./app.stache ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {\n\t\tvar stache = __webpack_require__(/*! can-stache */ \"../../node_modules/can-stache/can-stache.js\");\n\t\tvar mustacheCore = __webpack_require__( /*! can-stache/src/mustache_core */ \"../../node_modules/can-stache/src/mustache_core.js\" );\n\t\tvar parse = __webpack_require__(/*! can-stache-ast */ \"../../node_modules/can-stache-ast/can-stache-ast.js\").parse;\n\t\t//common deps\n\t\t__webpack_require__(/*! can-view-import */ \"../../node_modules/can-view-import/can-view-import.js\");\n\t\t__webpack_require__(/*! can-stache-bindings */ \"../../node_modules/can-stache-bindings/can-stache-bindings.js\");\n\t\n\t\t__webpack_require__(/*! ./imported */ \"./imported.js\");\n\t\t\n\t\tvar renderer = stache(\"/home/cherif/server/donejs/can-stache-loader/examples/import/app.stache\", [{\"tokenType\":\"start\",\"args\":[\"div\",false,1]},{\"tokenType\":\"end\",\"args\":[\"div\",false,1]},{\"tokenType\":\"chars\",\"args\":[\"\\t\",1]},{\"tokenType\":\"special\",\"args\":[\"message\",1]},{\"tokenType\":\"chars\",\"args\":[\"\\n\",1]},{\"tokenType\":\"close\",\"args\":[\"div\",2]},{\"tokenType\":\"chars\",\"args\":[\"\\n\\n\",2]},{\"tokenType\":\"start\",\"args\":[\"can-dynamic-import\",true,4]},{\"tokenType\":\"attrStart\",\"args\":[\"from\",4]},{\"tokenType\":\"attrValue\",\"args\":[\"./imported\",4]},{\"tokenType\":\"attrEnd\",\"args\":[\"from\",4]},{\"tokenType\":\"end\",\"args\":[\"can-dynamic-import\",true,4]},{\"tokenType\":\"chars\",\"args\":[\"\\n\\n\",4]},{\"tokenType\":\"special\",\"args\":[\"<inlinePartial\",6]},{\"tokenType\":\"chars\",\"args\":[\"\\n    \",6]},{\"tokenType\":\"start\",\"args\":[\"div\",false,7]},{\"tokenType\":\"end\",\"args\":[\"div\",false,7]},{\"tokenType\":\"special\",\"args\":[\"inlineMessage\",7]},{\"tokenType\":\"close\",\"args\":[\"div\",7]},{\"tokenType\":\"chars\",\"args\":[\"\\n\",7]},{\"tokenType\":\"special\",\"args\":[\"/inlinePartial\",8]},{\"tokenType\":\"chars\",\"args\":[\"\\n\\n\",8]},{\"tokenType\":\"special\",\"args\":[\"> partial.stache\",10]},{\"tokenType\":\"chars\",\"args\":[\"\\n\\n\",10]},{\"tokenType\":\"special\",\"args\":[\">inlinePartial\",12]},{\"tokenType\":\"chars\",\"args\":[\"\\n\\n\\n\",12]},{\"tokenType\":\"start\",\"args\":[\"div\",false,15]},{\"tokenType\":\"end\",\"args\":[\"div\",false,15]},{\"tokenType\":\"chars\",\"args\":[\"\\n\\t\",15]},{\"tokenType\":\"start\",\"args\":[\"x-comp\",true,16]},{\"tokenType\":\"attrStart\",\"args\":[\"message:raw\",16]},{\"tokenType\":\"attrValue\",\"args\":[\"Hello stache loader\",16]},{\"tokenType\":\"attrEnd\",\"args\":[\"message:raw\",16]},{\"tokenType\":\"end\",\"args\":[\"x-comp\",true,16]},{\"tokenType\":\"chars\",\"args\":[\"\\n\",16]},{\"tokenType\":\"close\",\"args\":[\"div\",17]},{\"tokenType\":\"chars\",\"args\":[\"\\n\\n\",17]},{\"tokenType\":\"done\",\"args\":[19]}])\n\n        module.exports = function(scope, options, nodeList) {\n\t\t\tvar moduleOptions = Object.assign({}, options);\n\t\t\t\n            if(moduleOptions.helpers) {\n                moduleOptions.helpers = Object.assign({ module: module }, moduleOptions.helpers);\n            } else {\n                moduleOptions.module = module;\n\t\t\t}\n            return renderer( scope, moduleOptions, nodeList );\n        };\n    \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ \"../../node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./app.stache?");

/***/ }),

/***/ "./imported.js":
/*!*********************!*\
  !*** ./imported.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Component = __webpack_require__(/*! can-component */ \"../../node_modules/can-component/can-component.js\");\nvar tpl = __webpack_require__(/*! ./tpl.stache */ \"./tpl.stache\");\n\nComponent.extend({\n\ttag: 'x-comp',\n\tview: tpl,\n\tViewModel: {\n\t\tmessage: {\n\t\t\ttype:'string',\n\t\t\tdefault: 'Hello Imported'\n\t\t}\n\t}\n});\n\n\n//# sourceURL=webpack:///./imported.js?");

/***/ }),

/***/ "./partial.stache":
/*!************************!*\
  !*** ./partial.stache ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {\n\t\tvar stache = __webpack_require__(/*! can-stache */ \"../../node_modules/can-stache/can-stache.js\");\n\t\tvar mustacheCore = __webpack_require__( /*! can-stache/src/mustache_core */ \"../../node_modules/can-stache/src/mustache_core.js\" );\n\t\tvar parse = __webpack_require__(/*! can-stache-ast */ \"../../node_modules/can-stache-ast/can-stache-ast.js\").parse;\n\t\t//common deps\n\t\t__webpack_require__(/*! can-view-import */ \"../../node_modules/can-view-import/can-view-import.js\");\n\t\t__webpack_require__(/*! can-stache-bindings */ \"../../node_modules/can-stache-bindings/can-stache-bindings.js\");\n\t\n\t\t\n\t\t\n\t\tvar renderer = stache(\"/home/cherif/server/donejs/can-stache-loader/examples/import/partial.stache\", [{\"tokenType\":\"chars\",\"args\":[\"I'm partial\\n\",1]},{\"tokenType\":\"done\",\"args\":[2]}])\n\n        module.exports = function(scope, options, nodeList) {\n\t\t\tvar moduleOptions = Object.assign({}, options);\n\t\t\t\n            if(moduleOptions.helpers) {\n                moduleOptions.helpers = Object.assign({ module: module }, moduleOptions.helpers);\n            } else {\n                moduleOptions.module = module;\n\t\t\t}\n            return renderer( scope, moduleOptions, nodeList );\n        };\n    \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ \"../../node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./partial.stache?");

/***/ }),

/***/ "./tpl.stache":
/*!********************!*\
  !*** ./tpl.stache ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {\n\t\tvar stache = __webpack_require__(/*! can-stache */ \"../../node_modules/can-stache/can-stache.js\");\n\t\tvar mustacheCore = __webpack_require__( /*! can-stache/src/mustache_core */ \"../../node_modules/can-stache/src/mustache_core.js\" );\n\t\tvar parse = __webpack_require__(/*! can-stache-ast */ \"../../node_modules/can-stache-ast/can-stache-ast.js\").parse;\n\t\t//common deps\n\t\t__webpack_require__(/*! can-view-import */ \"../../node_modules/can-view-import/can-view-import.js\");\n\t\t__webpack_require__(/*! can-stache-bindings */ \"../../node_modules/can-stache-bindings/can-stache-bindings.js\");\n\t\n\t\t\n\t\t\n\t\tvar renderer = stache(\"/home/cherif/server/donejs/can-stache-loader/examples/import/tpl.stache\", [{\"tokenType\":\"special\",\"args\":[\"message\",1]},{\"tokenType\":\"done\",\"args\":[1]}])\n\n        module.exports = function(scope, options, nodeList) {\n\t\t\tvar moduleOptions = Object.assign({}, options);\n\t\t\t\n            if(moduleOptions.helpers) {\n                moduleOptions.helpers = Object.assign({ module: module }, moduleOptions.helpers);\n            } else {\n                moduleOptions.module = module;\n\t\t\t}\n            return renderer( scope, moduleOptions, nodeList );\n        };\n    \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ \"../../node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./tpl.stache?");

/***/ })

/******/ });